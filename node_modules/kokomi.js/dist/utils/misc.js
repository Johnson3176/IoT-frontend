import * as THREE from "three";
import { mergeVertices, MeshSurfaceSampler } from "three-stdlib";
import { makeBuffer } from "./gl";
// 优化模型渲染
const optimizeModelRender = (renderer) => {
    renderer.outputEncoding = THREE.sRGBEncoding;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
};
// 开启真实渲染
const enableRealisticRender = (renderer) => {
    renderer.outputEncoding = THREE.sRGBEncoding;
    renderer.toneMapping = THREE.ReinhardToneMapping;
    renderer.toneMappingExposure = 3;
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.physicallyCorrectLights = true;
};
// 美化渲染
const beautifyRender = (renderer) => {
    optimizeModelRender(renderer);
};
// 开启阴影
const enableShadow = (renderer) => {
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
};
// 从hdr贴图中提取envmap
const getEnvmapFromHDRTexture = (renderer, texture) => {
    const pmremGenerator = new THREE.PMREMGenerator(renderer);
    pmremGenerator.compileEquirectangularShader();
    const envmap = pmremGenerator.fromEquirectangular(texture).texture;
    pmremGenerator.dispose();
    return envmap;
};
// 从场景中提取envmap
const getEnvmapFromScene = (renderer, scene) => {
    const pmremGenerator = new THREE.PMREMGenerator(renderer);
    const envmap = pmremGenerator.fromScene(scene).texture;
    return envmap;
};
// 获取重心坐标系
const getBaryCoord = (bufferGeometry) => {
    // https://gist.github.com/mattdesl/e399418558b2b52b58f5edeafea3c16c
    // @ts-ignore
    const length = bufferGeometry.attributes.position.array.length;
    const count = length / 3;
    const bary = [];
    for (let i = 0; i < count; i++) {
        bary.push(0, 0, 1, 0, 1, 0, 1, 0, 0);
    }
    const aCenter = new Float32Array(bary);
    bufferGeometry.setAttribute("aCenter", new THREE.BufferAttribute(aCenter, 3));
};
// 从mesh上取样微粒位置信息
const sampleParticlesPositionFromMesh = (geometry, count = 10000) => {
    const material = new THREE.MeshBasicMaterial();
    const mesh = new THREE.Mesh(geometry, material);
    const sampler = new MeshSurfaceSampler(mesh).build();
    const particlesPosition = new Float32Array(count * 3);
    for (let i = 0; i < count; i++) {
        const position = new THREE.Vector3();
        sampler.sample(position);
        particlesPosition.set([position.x, position.y, position.z], i * 3);
    }
    return particlesPosition;
};
// 遍历模型，使其扁平化
const flatModel = (model) => {
    const modelPartsArray = [];
    model.traverse((obj) => {
        modelPartsArray.push(obj);
    });
    return modelPartsArray;
};
// 打印扁平模型的所有部分
const printModel = (modelParts, modelName = "modelParts") => {
    const strArray = modelParts.map((obj, i) => {
        const row = `const ${obj.name} = ${modelName}[${i}];`;
        return row;
    });
    const str = strArray.join("\n");
    console.log(str);
    return str;
};
// 获取viewport
const getViewport = (camera) => {
    const position = new THREE.Vector3();
    const target = new THREE.Vector3();
    const distance = camera.getWorldPosition(position).distanceTo(target);
    const fov = (camera.fov * Math.PI) / 180; // convert vertical fov to radians
    const h = 2 * Math.tan(fov / 2) * distance; // visible height
    const w = h * (window.innerWidth / window.innerHeight);
    const viewport = { width: w, height: h };
    return viewport;
};
// 获取position中每个三角形的中心
const getPositionCentroids = (geometry, attrName = "position", centroidName = "aCenter") => {
    const position = geometry.attributes[attrName];
    const posCount = position.count;
    // @ts-ignore
    const posBuffer = position.array;
    const centroidBuffer = makeBuffer(posCount, (val) => val);
    for (let i = 0; i < posCount; i += 3) {
        // three vertices of triangle
        let x = posBuffer[i * 3];
        let y = posBuffer[i * 3 + 1];
        let z = posBuffer[i * 3 + 2];
        let x1 = posBuffer[i * 3 + 3];
        let y1 = posBuffer[i * 3 + 4];
        let z1 = posBuffer[i * 3 + 5];
        let x2 = posBuffer[i * 3 + 6];
        let y2 = posBuffer[i * 3 + 7];
        let z2 = posBuffer[i * 3 + 8];
        const centroid = new THREE.Vector3()
            .add(new THREE.Vector3(x, y, z))
            .add(new THREE.Vector3(x1, y1, z1))
            .add(new THREE.Vector3(x2, y2, z2))
            .divideScalar(3);
        centroidBuffer.set([centroid.x, centroid.y, centroid.z], i * 3);
        centroidBuffer.set([centroid.x, centroid.y, centroid.z], (i + 1) * 3);
        centroidBuffer.set([centroid.x, centroid.y, centroid.z], (i + 2) * 3);
    }
    geometry.setAttribute(centroidName, new THREE.BufferAttribute(centroidBuffer, 3));
    return centroidBuffer;
};
// 创建多边形形状
const createPolygonShape = (points, config = {}) => {
    const shape = new THREE.Shape();
    const { scale = 1 } = config;
    const firstPoint = points[0];
    for (let i = 0; i < points.length; i++) {
        const point = points[i];
        const x = (point.x - firstPoint.x) * scale;
        const y = (point.y - firstPoint.y) * -1 * scale;
        if (i === 0) {
            shape.moveTo(x, y);
        }
        else {
            shape.lineTo(x, y);
        }
    }
    return shape;
};
// 计算透视相机全屏大小
const calcPerspectiveScreenSize = (targetZ = 0, camera, aspect) => {
    let screenWidth = 1;
    let screenHeight = 1;
    const fovRadian = THREE.MathUtils.degToRad(camera.fov / 2);
    screenHeight = (camera.position.z - targetZ) * Math.tan(fovRadian) * 2;
    screenWidth = screenHeight * aspect;
    return { width: screenWidth, height: screenHeight };
};
// 下载文件
const downloadBlob = (blob, name) => {
    const a = document.createElement("a");
    document.body.appendChild(a);
    a.style.display = "none";
    const url = window.URL.createObjectURL(blob);
    a.href = url;
    a.download = name;
    a.click();
};
// 获取边界
const getBound = (object, precise = true) => {
    const box3 = new THREE.Box3().setFromObject(object, precise);
    const center = new THREE.Vector3();
    const sphere = new THREE.Sphere();
    box3.getCenter(center);
    box3.getBoundingSphere(sphere);
    const width = box3.max.x - box3.min.x;
    const height = box3.max.y - box3.min.y;
    const depth = box3.max.z - box3.min.z;
    return {
        boundingBox: box3,
        center,
        boundingSphere: sphere,
        width,
        height,
        depth,
    };
};
// 平滑法线
const smoothNormal = (mesh) => {
    mesh.geometry = mergeVertices(mesh.geometry);
    mesh.geometry.computeVertexNormals();
};
export { optimizeModelRender, enableRealisticRender, beautifyRender, enableShadow, getEnvmapFromHDRTexture, getEnvmapFromScene, getBaryCoord, sampleParticlesPositionFromMesh, flatModel, printModel, getViewport, getPositionCentroids, createPolygonShape, calcPerspectiveScreenSize, downloadBlob, getBound, smoothNormal, };
