import {
  require_stats_min
} from "./chunk-SFTPRNIL.js";
import {
  ParametricGeometry
} from "./chunk-AEKISQGY.js";
import {
  ACESFilmicToneMapping,
  AddEquation,
  AdditiveBlending,
  AmbientLight,
  AnimationClip,
  AnimationMixer,
  AudioLoader,
  BackSide,
  Bone,
  Box2,
  Box3,
  BoxGeometry,
  BufferAttribute,
  BufferGeometry,
  Camera,
  ClampToEdgeWrapping,
  Clock,
  Color,
  CompressedTexture,
  CubeTextureLoader,
  Curve,
  CustomBlending,
  DataTexture,
  DataTextureLoader,
  DataUtils,
  DepthFormat,
  DepthStencilFormat,
  DepthTexture,
  DirectionalLight,
  DoubleSide,
  DstAlphaFactor,
  DstColorFactor,
  DynamicDrawUsage,
  EquirectangularReflectionMapping,
  Euler,
  EventDispatcher,
  ExtrudeGeometry,
  FileLoader,
  Float32BufferAttribute,
  FloatType,
  FrontSide,
  Frustum,
  Group,
  HalfFloatType,
  ImageBitmapLoader,
  InstancedBufferAttribute,
  InstancedBufferGeometry,
  InstancedMesh,
  InterleavedBuffer,
  InterleavedBufferAttribute,
  Interpolant,
  InterpolateDiscrete,
  InterpolateLinear,
  Line,
  Line3,
  LineBasicMaterial,
  LineLoop,
  LineSegments,
  LinearEncoding,
  LinearFilter,
  LinearMipMapLinearFilter,
  LinearMipmapLinearFilter,
  LinearMipmapNearestFilter,
  Loader,
  LoaderUtils,
  LuminanceFormat,
  MOUSE,
  Material,
  MathUtils,
  Matrix3,
  Matrix4,
  Mesh,
  MeshBasicMaterial,
  MeshDepthMaterial,
  MeshDistanceMaterial,
  MeshLambertMaterial,
  MeshNormalMaterial,
  MeshPhongMaterial,
  MeshPhysicalMaterial,
  MeshStandardMaterial,
  MirroredRepeatWrapping,
  NearestFilter,
  NearestMipmapLinearFilter,
  NearestMipmapNearestFilter,
  NoBlending,
  NoToneMapping,
  NormalBlending,
  NumberKeyframeTrack,
  Object3D,
  OneMinusSrcAlphaFactor,
  OrthographicCamera,
  PCFSoftShadowMap,
  PMREMGenerator,
  Path,
  PerspectiveCamera,
  Plane,
  PlaneGeometry,
  PointLight,
  Points,
  PointsMaterial,
  PropertyBinding,
  Quaternion,
  QuaternionKeyframeTrack,
  REVISION,
  RGBADepthPacking,
  RGBAFormat,
  RGBA_ASTC_4x4_Format,
  RGBA_BPTC_Format,
  RGBA_ETC2_EAC_Format,
  RGBA_PVRTC_4BPPV1_Format,
  RGBA_S3TC_DXT5_Format,
  RGB_ETC1_Format,
  RGB_ETC2_Format,
  RGB_PVRTC_4BPPV1_Format,
  RGB_S3TC_DXT1_Format,
  RGFormat,
  RawShaderMaterial,
  Ray,
  Raycaster,
  RedFormat,
  ReinhardToneMapping,
  RepeatWrapping,
  Scene,
  ShaderChunk,
  ShaderMaterial,
  Shape,
  ShapePath,
  ShapeUtils,
  Skeleton,
  SkinnedMesh,
  Sphere,
  SphereGeometry,
  Spherical,
  SpotLight,
  SrcAlphaFactor,
  TOUCH,
  Texture,
  TextureLoader,
  Triangle,
  TriangleFanDrawMode,
  TriangleStripDrawMode,
  TrianglesDrawMode,
  UVMapping,
  Uint16BufferAttribute,
  Uint32BufferAttribute,
  Uniform,
  UniformsLib,
  UniformsUtils,
  UnsignedByteType,
  UnsignedInt248Type,
  UnsignedShortType,
  Vector2,
  Vector3,
  Vector4,
  VectorKeyframeTrack,
  VideoTexture,
  WebGLRenderTarget,
  WebGLRenderer,
  ZeroFactor,
  sRGBEncoding,
  three_module_exports
} from "./chunk-G437BGAC.js";
import {
  __commonJS,
  __publicField,
  __toESM
} from "./chunk-Y4AOG3KG.js";

// node_modules/chevrotain/lib/src/version.js
var require_version = __commonJS({
  "node_modules/chevrotain/lib/src/version.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.VERSION = void 0;
    exports2.VERSION = "10.5.0";
  }
});

// node_modules/lodash/_isPrototype.js
var require_isPrototype = __commonJS({
  "node_modules/lodash/_isPrototype.js"(exports2, module2) {
    var objectProto = Object.prototype;
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    module2.exports = isPrototype;
  }
});

// node_modules/lodash/_overArg.js
var require_overArg = __commonJS({
  "node_modules/lodash/_overArg.js"(exports2, module2) {
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    module2.exports = overArg;
  }
});

// node_modules/lodash/_nativeKeys.js
var require_nativeKeys = __commonJS({
  "node_modules/lodash/_nativeKeys.js"(exports2, module2) {
    var overArg = require_overArg();
    var nativeKeys = overArg(Object.keys, Object);
    module2.exports = nativeKeys;
  }
});

// node_modules/lodash/_baseKeys.js
var require_baseKeys = __commonJS({
  "node_modules/lodash/_baseKeys.js"(exports2, module2) {
    var isPrototype = require_isPrototype();
    var nativeKeys = require_nativeKeys();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    module2.exports = baseKeys;
  }
});

// node_modules/lodash/_freeGlobal.js
var require_freeGlobal = __commonJS({
  "node_modules/lodash/_freeGlobal.js"(exports2, module2) {
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    module2.exports = freeGlobal;
  }
});

// node_modules/lodash/_root.js
var require_root = __commonJS({
  "node_modules/lodash/_root.js"(exports2, module2) {
    var freeGlobal = require_freeGlobal();
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    module2.exports = root;
  }
});

// node_modules/lodash/_Symbol.js
var require_Symbol = __commonJS({
  "node_modules/lodash/_Symbol.js"(exports2, module2) {
    var root = require_root();
    var Symbol2 = root.Symbol;
    module2.exports = Symbol2;
  }
});

// node_modules/lodash/_getRawTag.js
var require_getRawTag = __commonJS({
  "node_modules/lodash/_getRawTag.js"(exports2, module2) {
    var Symbol2 = require_Symbol();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var nativeObjectToString = objectProto.toString;
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    function getRawTag(value) {
      var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
      try {
        value[symToStringTag] = void 0;
        var unmasked = true;
      } catch (e) {
      }
      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }
    module2.exports = getRawTag;
  }
});

// node_modules/lodash/_objectToString.js
var require_objectToString = __commonJS({
  "node_modules/lodash/_objectToString.js"(exports2, module2) {
    var objectProto = Object.prototype;
    var nativeObjectToString = objectProto.toString;
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
    module2.exports = objectToString;
  }
});

// node_modules/lodash/_baseGetTag.js
var require_baseGetTag = __commonJS({
  "node_modules/lodash/_baseGetTag.js"(exports2, module2) {
    var Symbol2 = require_Symbol();
    var getRawTag = require_getRawTag();
    var objectToString = require_objectToString();
    var nullTag = "[object Null]";
    var undefinedTag = "[object Undefined]";
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    module2.exports = baseGetTag;
  }
});

// node_modules/lodash/isObject.js
var require_isObject = __commonJS({
  "node_modules/lodash/isObject.js"(exports2, module2) {
    function isObject(value) {
      var type = typeof value;
      return value != null && (type == "object" || type == "function");
    }
    module2.exports = isObject;
  }
});

// node_modules/lodash/isFunction.js
var require_isFunction = __commonJS({
  "node_modules/lodash/isFunction.js"(exports2, module2) {
    var baseGetTag = require_baseGetTag();
    var isObject = require_isObject();
    var asyncTag = "[object AsyncFunction]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var proxyTag = "[object Proxy]";
    function isFunction(value) {
      if (!isObject(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }
    module2.exports = isFunction;
  }
});

// node_modules/lodash/_coreJsData.js
var require_coreJsData = __commonJS({
  "node_modules/lodash/_coreJsData.js"(exports2, module2) {
    var root = require_root();
    var coreJsData = root["__core-js_shared__"];
    module2.exports = coreJsData;
  }
});

// node_modules/lodash/_isMasked.js
var require_isMasked = __commonJS({
  "node_modules/lodash/_isMasked.js"(exports2, module2) {
    var coreJsData = require_coreJsData();
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    module2.exports = isMasked;
  }
});

// node_modules/lodash/_toSource.js
var require_toSource = __commonJS({
  "node_modules/lodash/_toSource.js"(exports2, module2) {
    var funcProto = Function.prototype;
    var funcToString = funcProto.toString;
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    module2.exports = toSource;
  }
});

// node_modules/lodash/_baseIsNative.js
var require_baseIsNative = __commonJS({
  "node_modules/lodash/_baseIsNative.js"(exports2, module2) {
    var isFunction = require_isFunction();
    var isMasked = require_isMasked();
    var isObject = require_isObject();
    var toSource = require_toSource();
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    module2.exports = baseIsNative;
  }
});

// node_modules/lodash/_getValue.js
var require_getValue = __commonJS({
  "node_modules/lodash/_getValue.js"(exports2, module2) {
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    module2.exports = getValue;
  }
});

// node_modules/lodash/_getNative.js
var require_getNative = __commonJS({
  "node_modules/lodash/_getNative.js"(exports2, module2) {
    var baseIsNative = require_baseIsNative();
    var getValue = require_getValue();
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    module2.exports = getNative;
  }
});

// node_modules/lodash/_DataView.js
var require_DataView = __commonJS({
  "node_modules/lodash/_DataView.js"(exports2, module2) {
    var getNative = require_getNative();
    var root = require_root();
    var DataView2 = getNative(root, "DataView");
    module2.exports = DataView2;
  }
});

// node_modules/lodash/_Map.js
var require_Map = __commonJS({
  "node_modules/lodash/_Map.js"(exports2, module2) {
    var getNative = require_getNative();
    var root = require_root();
    var Map2 = getNative(root, "Map");
    module2.exports = Map2;
  }
});

// node_modules/lodash/_Promise.js
var require_Promise = __commonJS({
  "node_modules/lodash/_Promise.js"(exports2, module2) {
    var getNative = require_getNative();
    var root = require_root();
    var Promise2 = getNative(root, "Promise");
    module2.exports = Promise2;
  }
});

// node_modules/lodash/_Set.js
var require_Set = __commonJS({
  "node_modules/lodash/_Set.js"(exports2, module2) {
    var getNative = require_getNative();
    var root = require_root();
    var Set2 = getNative(root, "Set");
    module2.exports = Set2;
  }
});

// node_modules/lodash/_WeakMap.js
var require_WeakMap = __commonJS({
  "node_modules/lodash/_WeakMap.js"(exports2, module2) {
    var getNative = require_getNative();
    var root = require_root();
    var WeakMap2 = getNative(root, "WeakMap");
    module2.exports = WeakMap2;
  }
});

// node_modules/lodash/_getTag.js
var require_getTag = __commonJS({
  "node_modules/lodash/_getTag.js"(exports2, module2) {
    var DataView2 = require_DataView();
    var Map2 = require_Map();
    var Promise2 = require_Promise();
    var Set2 = require_Set();
    var WeakMap2 = require_WeakMap();
    var baseGetTag = require_baseGetTag();
    var toSource = require_toSource();
    var mapTag = "[object Map]";
    var objectTag = "[object Object]";
    var promiseTag = "[object Promise]";
    var setTag = "[object Set]";
    var weakMapTag = "[object WeakMap]";
    var dataViewTag = "[object DataView]";
    var dataViewCtorString = toSource(DataView2);
    var mapCtorString = toSource(Map2);
    var promiseCtorString = toSource(Promise2);
    var setCtorString = toSource(Set2);
    var weakMapCtorString = toSource(WeakMap2);
    var getTag2 = baseGetTag;
    if (DataView2 && getTag2(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag2(new Map2()) != mapTag || Promise2 && getTag2(Promise2.resolve()) != promiseTag || Set2 && getTag2(new Set2()) != setTag || WeakMap2 && getTag2(new WeakMap2()) != weakMapTag) {
      getTag2 = function(value) {
        var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag;
            case mapCtorString:
              return mapTag;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag;
            case weakMapCtorString:
              return weakMapTag;
          }
        }
        return result;
      };
    }
    module2.exports = getTag2;
  }
});

// node_modules/lodash/isObjectLike.js
var require_isObjectLike = __commonJS({
  "node_modules/lodash/isObjectLike.js"(exports2, module2) {
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    module2.exports = isObjectLike;
  }
});

// node_modules/lodash/_baseIsArguments.js
var require_baseIsArguments = __commonJS({
  "node_modules/lodash/_baseIsArguments.js"(exports2, module2) {
    var baseGetTag = require_baseGetTag();
    var isObjectLike = require_isObjectLike();
    var argsTag = "[object Arguments]";
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag;
    }
    module2.exports = baseIsArguments;
  }
});

// node_modules/lodash/isArguments.js
var require_isArguments = __commonJS({
  "node_modules/lodash/isArguments.js"(exports2, module2) {
    var baseIsArguments = require_baseIsArguments();
    var isObjectLike = require_isObjectLike();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var isArguments = baseIsArguments(function() {
      return arguments;
    }()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
    };
    module2.exports = isArguments;
  }
});

// node_modules/lodash/isArray.js
var require_isArray = __commonJS({
  "node_modules/lodash/isArray.js"(exports2, module2) {
    var isArray = Array.isArray;
    module2.exports = isArray;
  }
});

// node_modules/lodash/isLength.js
var require_isLength = __commonJS({
  "node_modules/lodash/isLength.js"(exports2, module2) {
    var MAX_SAFE_INTEGER = 9007199254740991;
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    module2.exports = isLength;
  }
});

// node_modules/lodash/isArrayLike.js
var require_isArrayLike = __commonJS({
  "node_modules/lodash/isArrayLike.js"(exports2, module2) {
    var isFunction = require_isFunction();
    var isLength = require_isLength();
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    module2.exports = isArrayLike;
  }
});

// node_modules/lodash/stubFalse.js
var require_stubFalse = __commonJS({
  "node_modules/lodash/stubFalse.js"(exports2, module2) {
    function stubFalse() {
      return false;
    }
    module2.exports = stubFalse;
  }
});

// node_modules/lodash/isBuffer.js
var require_isBuffer = __commonJS({
  "node_modules/lodash/isBuffer.js"(exports2, module2) {
    var root = require_root();
    var stubFalse = require_stubFalse();
    var freeExports = typeof exports2 == "object" && exports2 && !exports2.nodeType && exports2;
    var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var Buffer2 = moduleExports ? root.Buffer : void 0;
    var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
    var isBuffer = nativeIsBuffer || stubFalse;
    module2.exports = isBuffer;
  }
});

// node_modules/lodash/_baseIsTypedArray.js
var require_baseIsTypedArray = __commonJS({
  "node_modules/lodash/_baseIsTypedArray.js"(exports2, module2) {
    var baseGetTag = require_baseGetTag();
    var isLength = require_isLength();
    var isObjectLike = require_isObjectLike();
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var objectTag = "[object Object]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }
    module2.exports = baseIsTypedArray;
  }
});

// node_modules/lodash/_baseUnary.js
var require_baseUnary = __commonJS({
  "node_modules/lodash/_baseUnary.js"(exports2, module2) {
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    module2.exports = baseUnary;
  }
});

// node_modules/lodash/_nodeUtil.js
var require_nodeUtil = __commonJS({
  "node_modules/lodash/_nodeUtil.js"(exports2, module2) {
    var freeGlobal = require_freeGlobal();
    var freeExports = typeof exports2 == "object" && exports2 && !exports2.nodeType && exports2;
    var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        var types = freeModule && freeModule.require && freeModule.require("util").types;
        if (types) {
          return types;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e) {
      }
    }();
    module2.exports = nodeUtil;
  }
});

// node_modules/lodash/isTypedArray.js
var require_isTypedArray = __commonJS({
  "node_modules/lodash/isTypedArray.js"(exports2, module2) {
    var baseIsTypedArray = require_baseIsTypedArray();
    var baseUnary = require_baseUnary();
    var nodeUtil = require_nodeUtil();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    module2.exports = isTypedArray;
  }
});

// node_modules/lodash/isEmpty.js
var require_isEmpty = __commonJS({
  "node_modules/lodash/isEmpty.js"(exports2, module2) {
    var baseKeys = require_baseKeys();
    var getTag2 = require_getTag();
    var isArguments = require_isArguments();
    var isArray = require_isArray();
    var isArrayLike = require_isArrayLike();
    var isBuffer = require_isBuffer();
    var isPrototype = require_isPrototype();
    var isTypedArray = require_isTypedArray();
    var mapTag = "[object Map]";
    var setTag = "[object Set]";
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function isEmpty(value) {
      if (value == null) {
        return true;
      }
      if (isArrayLike(value) && (isArray(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isTypedArray(value) || isArguments(value))) {
        return !value.length;
      }
      var tag = getTag2(value);
      if (tag == mapTag || tag == setTag) {
        return !value.size;
      }
      if (isPrototype(value)) {
        return !baseKeys(value).length;
      }
      for (var key in value) {
        if (hasOwnProperty.call(value, key)) {
          return false;
        }
      }
      return true;
    }
    module2.exports = isEmpty;
  }
});

// node_modules/lodash/_arrayMap.js
var require_arrayMap = __commonJS({
  "node_modules/lodash/_arrayMap.js"(exports2, module2) {
    function arrayMap(array, iteratee) {
      var index = -1, length = array == null ? 0 : array.length, result = Array(length);
      while (++index < length) {
        result[index] = iteratee(array[index], index, array);
      }
      return result;
    }
    module2.exports = arrayMap;
  }
});

// node_modules/lodash/_listCacheClear.js
var require_listCacheClear = __commonJS({
  "node_modules/lodash/_listCacheClear.js"(exports2, module2) {
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }
    module2.exports = listCacheClear;
  }
});

// node_modules/lodash/eq.js
var require_eq = __commonJS({
  "node_modules/lodash/eq.js"(exports2, module2) {
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    module2.exports = eq;
  }
});

// node_modules/lodash/_assocIndexOf.js
var require_assocIndexOf = __commonJS({
  "node_modules/lodash/_assocIndexOf.js"(exports2, module2) {
    var eq = require_eq();
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    module2.exports = assocIndexOf;
  }
});

// node_modules/lodash/_listCacheDelete.js
var require_listCacheDelete = __commonJS({
  "node_modules/lodash/_listCacheDelete.js"(exports2, module2) {
    var assocIndexOf = require_assocIndexOf();
    var arrayProto = Array.prototype;
    var splice = arrayProto.splice;
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      --this.size;
      return true;
    }
    module2.exports = listCacheDelete;
  }
});

// node_modules/lodash/_listCacheGet.js
var require_listCacheGet = __commonJS({
  "node_modules/lodash/_listCacheGet.js"(exports2, module2) {
    var assocIndexOf = require_assocIndexOf();
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    module2.exports = listCacheGet;
  }
});

// node_modules/lodash/_listCacheHas.js
var require_listCacheHas = __commonJS({
  "node_modules/lodash/_listCacheHas.js"(exports2, module2) {
    var assocIndexOf = require_assocIndexOf();
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    module2.exports = listCacheHas;
  }
});

// node_modules/lodash/_listCacheSet.js
var require_listCacheSet = __commonJS({
  "node_modules/lodash/_listCacheSet.js"(exports2, module2) {
    var assocIndexOf = require_assocIndexOf();
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        ++this.size;
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    module2.exports = listCacheSet;
  }
});

// node_modules/lodash/_ListCache.js
var require_ListCache = __commonJS({
  "node_modules/lodash/_ListCache.js"(exports2, module2) {
    var listCacheClear = require_listCacheClear();
    var listCacheDelete = require_listCacheDelete();
    var listCacheGet = require_listCacheGet();
    var listCacheHas = require_listCacheHas();
    var listCacheSet = require_listCacheSet();
    function ListCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    module2.exports = ListCache;
  }
});

// node_modules/lodash/_stackClear.js
var require_stackClear = __commonJS({
  "node_modules/lodash/_stackClear.js"(exports2, module2) {
    var ListCache = require_ListCache();
    function stackClear() {
      this.__data__ = new ListCache();
      this.size = 0;
    }
    module2.exports = stackClear;
  }
});

// node_modules/lodash/_stackDelete.js
var require_stackDelete = __commonJS({
  "node_modules/lodash/_stackDelete.js"(exports2, module2) {
    function stackDelete(key) {
      var data = this.__data__, result = data["delete"](key);
      this.size = data.size;
      return result;
    }
    module2.exports = stackDelete;
  }
});

// node_modules/lodash/_stackGet.js
var require_stackGet = __commonJS({
  "node_modules/lodash/_stackGet.js"(exports2, module2) {
    function stackGet(key) {
      return this.__data__.get(key);
    }
    module2.exports = stackGet;
  }
});

// node_modules/lodash/_stackHas.js
var require_stackHas = __commonJS({
  "node_modules/lodash/_stackHas.js"(exports2, module2) {
    function stackHas(key) {
      return this.__data__.has(key);
    }
    module2.exports = stackHas;
  }
});

// node_modules/lodash/_nativeCreate.js
var require_nativeCreate = __commonJS({
  "node_modules/lodash/_nativeCreate.js"(exports2, module2) {
    var getNative = require_getNative();
    var nativeCreate = getNative(Object, "create");
    module2.exports = nativeCreate;
  }
});

// node_modules/lodash/_hashClear.js
var require_hashClear = __commonJS({
  "node_modules/lodash/_hashClear.js"(exports2, module2) {
    var nativeCreate = require_nativeCreate();
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }
    module2.exports = hashClear;
  }
});

// node_modules/lodash/_hashDelete.js
var require_hashDelete = __commonJS({
  "node_modules/lodash/_hashDelete.js"(exports2, module2) {
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }
    module2.exports = hashDelete;
  }
});

// node_modules/lodash/_hashGet.js
var require_hashGet = __commonJS({
  "node_modules/lodash/_hashGet.js"(exports2, module2) {
    var nativeCreate = require_nativeCreate();
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : void 0;
    }
    module2.exports = hashGet;
  }
});

// node_modules/lodash/_hashHas.js
var require_hashHas = __commonJS({
  "node_modules/lodash/_hashHas.js"(exports2, module2) {
    var nativeCreate = require_nativeCreate();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
    }
    module2.exports = hashHas;
  }
});

// node_modules/lodash/_hashSet.js
var require_hashSet = __commonJS({
  "node_modules/lodash/_hashSet.js"(exports2, module2) {
    var nativeCreate = require_nativeCreate();
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    function hashSet(key, value) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    module2.exports = hashSet;
  }
});

// node_modules/lodash/_Hash.js
var require_Hash = __commonJS({
  "node_modules/lodash/_Hash.js"(exports2, module2) {
    var hashClear = require_hashClear();
    var hashDelete = require_hashDelete();
    var hashGet = require_hashGet();
    var hashHas = require_hashHas();
    var hashSet = require_hashSet();
    function Hash(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    module2.exports = Hash;
  }
});

// node_modules/lodash/_mapCacheClear.js
var require_mapCacheClear = __commonJS({
  "node_modules/lodash/_mapCacheClear.js"(exports2, module2) {
    var Hash = require_Hash();
    var ListCache = require_ListCache();
    var Map2 = require_Map();
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash()
      };
    }
    module2.exports = mapCacheClear;
  }
});

// node_modules/lodash/_isKeyable.js
var require_isKeyable = __commonJS({
  "node_modules/lodash/_isKeyable.js"(exports2, module2) {
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    module2.exports = isKeyable;
  }
});

// node_modules/lodash/_getMapData.js
var require_getMapData = __commonJS({
  "node_modules/lodash/_getMapData.js"(exports2, module2) {
    var isKeyable = require_isKeyable();
    function getMapData(map2, key) {
      var data = map2.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    module2.exports = getMapData;
  }
});

// node_modules/lodash/_mapCacheDelete.js
var require_mapCacheDelete = __commonJS({
  "node_modules/lodash/_mapCacheDelete.js"(exports2, module2) {
    var getMapData = require_getMapData();
    function mapCacheDelete(key) {
      var result = getMapData(this, key)["delete"](key);
      this.size -= result ? 1 : 0;
      return result;
    }
    module2.exports = mapCacheDelete;
  }
});

// node_modules/lodash/_mapCacheGet.js
var require_mapCacheGet = __commonJS({
  "node_modules/lodash/_mapCacheGet.js"(exports2, module2) {
    var getMapData = require_getMapData();
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    module2.exports = mapCacheGet;
  }
});

// node_modules/lodash/_mapCacheHas.js
var require_mapCacheHas = __commonJS({
  "node_modules/lodash/_mapCacheHas.js"(exports2, module2) {
    var getMapData = require_getMapData();
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    module2.exports = mapCacheHas;
  }
});

// node_modules/lodash/_mapCacheSet.js
var require_mapCacheSet = __commonJS({
  "node_modules/lodash/_mapCacheSet.js"(exports2, module2) {
    var getMapData = require_getMapData();
    function mapCacheSet(key, value) {
      var data = getMapData(this, key), size2 = data.size;
      data.set(key, value);
      this.size += data.size == size2 ? 0 : 1;
      return this;
    }
    module2.exports = mapCacheSet;
  }
});

// node_modules/lodash/_MapCache.js
var require_MapCache = __commonJS({
  "node_modules/lodash/_MapCache.js"(exports2, module2) {
    var mapCacheClear = require_mapCacheClear();
    var mapCacheDelete = require_mapCacheDelete();
    var mapCacheGet = require_mapCacheGet();
    var mapCacheHas = require_mapCacheHas();
    var mapCacheSet = require_mapCacheSet();
    function MapCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    module2.exports = MapCache;
  }
});

// node_modules/lodash/_stackSet.js
var require_stackSet = __commonJS({
  "node_modules/lodash/_stackSet.js"(exports2, module2) {
    var ListCache = require_ListCache();
    var Map2 = require_Map();
    var MapCache = require_MapCache();
    var LARGE_ARRAY_SIZE = 200;
    function stackSet(key, value) {
      var data = this.__data__;
      if (data instanceof ListCache) {
        var pairs = data.__data__;
        if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          this.size = ++data.size;
          return this;
        }
        data = this.__data__ = new MapCache(pairs);
      }
      data.set(key, value);
      this.size = data.size;
      return this;
    }
    module2.exports = stackSet;
  }
});

// node_modules/lodash/_Stack.js
var require_Stack = __commonJS({
  "node_modules/lodash/_Stack.js"(exports2, module2) {
    var ListCache = require_ListCache();
    var stackClear = require_stackClear();
    var stackDelete = require_stackDelete();
    var stackGet = require_stackGet();
    var stackHas = require_stackHas();
    var stackSet = require_stackSet();
    function Stack(entries) {
      var data = this.__data__ = new ListCache(entries);
      this.size = data.size;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    module2.exports = Stack;
  }
});

// node_modules/lodash/_setCacheAdd.js
var require_setCacheAdd = __commonJS({
  "node_modules/lodash/_setCacheAdd.js"(exports2, module2) {
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }
    module2.exports = setCacheAdd;
  }
});

// node_modules/lodash/_setCacheHas.js
var require_setCacheHas = __commonJS({
  "node_modules/lodash/_setCacheHas.js"(exports2, module2) {
    function setCacheHas(value) {
      return this.__data__.has(value);
    }
    module2.exports = setCacheHas;
  }
});

// node_modules/lodash/_SetCache.js
var require_SetCache = __commonJS({
  "node_modules/lodash/_SetCache.js"(exports2, module2) {
    var MapCache = require_MapCache();
    var setCacheAdd = require_setCacheAdd();
    var setCacheHas = require_setCacheHas();
    function SetCache(values) {
      var index = -1, length = values == null ? 0 : values.length;
      this.__data__ = new MapCache();
      while (++index < length) {
        this.add(values[index]);
      }
    }
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;
    module2.exports = SetCache;
  }
});

// node_modules/lodash/_arraySome.js
var require_arraySome = __commonJS({
  "node_modules/lodash/_arraySome.js"(exports2, module2) {
    function arraySome(array, predicate) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (predicate(array[index], index, array)) {
          return true;
        }
      }
      return false;
    }
    module2.exports = arraySome;
  }
});

// node_modules/lodash/_cacheHas.js
var require_cacheHas = __commonJS({
  "node_modules/lodash/_cacheHas.js"(exports2, module2) {
    function cacheHas(cache, key) {
      return cache.has(key);
    }
    module2.exports = cacheHas;
  }
});

// node_modules/lodash/_equalArrays.js
var require_equalArrays = __commonJS({
  "node_modules/lodash/_equalArrays.js"(exports2, module2) {
    var SetCache = require_SetCache();
    var arraySome = require_arraySome();
    var cacheHas = require_cacheHas();
    var COMPARE_PARTIAL_FLAG = 1;
    var COMPARE_UNORDERED_FLAG = 2;
    function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      var arrStacked = stack.get(array);
      var othStacked = stack.get(other);
      if (arrStacked && othStacked) {
        return arrStacked == other && othStacked == array;
      }
      var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : void 0;
      stack.set(array, other);
      stack.set(other, array);
      while (++index < arrLength) {
        var arrValue = array[index], othValue = other[index];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
        }
        if (compared !== void 0) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        if (seen) {
          if (!arraySome(other, function(othValue2, othIndex) {
            if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
              return seen.push(othIndex);
            }
          })) {
            result = false;
            break;
          }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
          result = false;
          break;
        }
      }
      stack["delete"](array);
      stack["delete"](other);
      return result;
    }
    module2.exports = equalArrays;
  }
});

// node_modules/lodash/_Uint8Array.js
var require_Uint8Array = __commonJS({
  "node_modules/lodash/_Uint8Array.js"(exports2, module2) {
    var root = require_root();
    var Uint8Array2 = root.Uint8Array;
    module2.exports = Uint8Array2;
  }
});

// node_modules/lodash/_mapToArray.js
var require_mapToArray = __commonJS({
  "node_modules/lodash/_mapToArray.js"(exports2, module2) {
    function mapToArray(map2) {
      var index = -1, result = Array(map2.size);
      map2.forEach(function(value, key) {
        result[++index] = [key, value];
      });
      return result;
    }
    module2.exports = mapToArray;
  }
});

// node_modules/lodash/_setToArray.js
var require_setToArray = __commonJS({
  "node_modules/lodash/_setToArray.js"(exports2, module2) {
    function setToArray(set) {
      var index = -1, result = Array(set.size);
      set.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }
    module2.exports = setToArray;
  }
});

// node_modules/lodash/_equalByTag.js
var require_equalByTag = __commonJS({
  "node_modules/lodash/_equalByTag.js"(exports2, module2) {
    var Symbol2 = require_Symbol();
    var Uint8Array2 = require_Uint8Array();
    var eq = require_eq();
    var equalArrays = require_equalArrays();
    var mapToArray = require_mapToArray();
    var setToArray = require_setToArray();
    var COMPARE_PARTIAL_FLAG = 1;
    var COMPARE_UNORDERED_FLAG = 2;
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
      switch (tag) {
        case dataViewTag:
          if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
            return false;
          }
          object = object.buffer;
          other = other.buffer;
        case arrayBufferTag:
          if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
            return false;
          }
          return true;
        case boolTag:
        case dateTag:
        case numberTag:
          return eq(+object, +other);
        case errorTag:
          return object.name == other.name && object.message == other.message;
        case regexpTag:
        case stringTag:
          return object == other + "";
        case mapTag:
          var convert = mapToArray;
        case setTag:
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
          convert || (convert = setToArray);
          if (object.size != other.size && !isPartial) {
            return false;
          }
          var stacked = stack.get(object);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= COMPARE_UNORDERED_FLAG;
          stack.set(object, other);
          var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
          stack["delete"](object);
          return result;
        case symbolTag:
          if (symbolValueOf) {
            return symbolValueOf.call(object) == symbolValueOf.call(other);
          }
      }
      return false;
    }
    module2.exports = equalByTag;
  }
});

// node_modules/lodash/_arrayPush.js
var require_arrayPush = __commonJS({
  "node_modules/lodash/_arrayPush.js"(exports2, module2) {
    function arrayPush(array, values) {
      var index = -1, length = values.length, offset = array.length;
      while (++index < length) {
        array[offset + index] = values[index];
      }
      return array;
    }
    module2.exports = arrayPush;
  }
});

// node_modules/lodash/_baseGetAllKeys.js
var require_baseGetAllKeys = __commonJS({
  "node_modules/lodash/_baseGetAllKeys.js"(exports2, module2) {
    var arrayPush = require_arrayPush();
    var isArray = require_isArray();
    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
      var result = keysFunc(object);
      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
    }
    module2.exports = baseGetAllKeys;
  }
});

// node_modules/lodash/_arrayFilter.js
var require_arrayFilter = __commonJS({
  "node_modules/lodash/_arrayFilter.js"(exports2, module2) {
    function arrayFilter(array, predicate) {
      var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result[resIndex++] = value;
        }
      }
      return result;
    }
    module2.exports = arrayFilter;
  }
});

// node_modules/lodash/stubArray.js
var require_stubArray = __commonJS({
  "node_modules/lodash/stubArray.js"(exports2, module2) {
    function stubArray() {
      return [];
    }
    module2.exports = stubArray;
  }
});

// node_modules/lodash/_getSymbols.js
var require_getSymbols = __commonJS({
  "node_modules/lodash/_getSymbols.js"(exports2, module2) {
    var arrayFilter = require_arrayFilter();
    var stubArray = require_stubArray();
    var objectProto = Object.prototype;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var nativeGetSymbols = Object.getOwnPropertySymbols;
    var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
      if (object == null) {
        return [];
      }
      object = Object(object);
      return arrayFilter(nativeGetSymbols(object), function(symbol) {
        return propertyIsEnumerable.call(object, symbol);
      });
    };
    module2.exports = getSymbols;
  }
});

// node_modules/lodash/_baseTimes.js
var require_baseTimes = __commonJS({
  "node_modules/lodash/_baseTimes.js"(exports2, module2) {
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    module2.exports = baseTimes;
  }
});

// node_modules/lodash/_isIndex.js
var require_isIndex = __commonJS({
  "node_modules/lodash/_isIndex.js"(exports2, module2) {
    var MAX_SAFE_INTEGER = 9007199254740991;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    function isIndex(value, length) {
      var type = typeof value;
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    module2.exports = isIndex;
  }
});

// node_modules/lodash/_arrayLikeKeys.js
var require_arrayLikeKeys = __commonJS({
  "node_modules/lodash/_arrayLikeKeys.js"(exports2, module2) {
    var baseTimes = require_baseTimes();
    var isArguments = require_isArguments();
    var isArray = require_isArray();
    var isBuffer = require_isBuffer();
    var isIndex = require_isIndex();
    var isTypedArray = require_isTypedArray();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
        (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
        isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
        isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
        isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    module2.exports = arrayLikeKeys;
  }
});

// node_modules/lodash/keys.js
var require_keys = __commonJS({
  "node_modules/lodash/keys.js"(exports2, module2) {
    var arrayLikeKeys = require_arrayLikeKeys();
    var baseKeys = require_baseKeys();
    var isArrayLike = require_isArrayLike();
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    module2.exports = keys;
  }
});

// node_modules/lodash/_getAllKeys.js
var require_getAllKeys = __commonJS({
  "node_modules/lodash/_getAllKeys.js"(exports2, module2) {
    var baseGetAllKeys = require_baseGetAllKeys();
    var getSymbols = require_getSymbols();
    var keys = require_keys();
    function getAllKeys(object) {
      return baseGetAllKeys(object, keys, getSymbols);
    }
    module2.exports = getAllKeys;
  }
});

// node_modules/lodash/_equalObjects.js
var require_equalObjects = __commonJS({
  "node_modules/lodash/_equalObjects.js"(exports2, module2) {
    var getAllKeys = require_getAllKeys();
    var COMPARE_PARTIAL_FLAG = 1;
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index = objLength;
      while (index--) {
        var key = objProps[index];
        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
          return false;
        }
      }
      var objStacked = stack.get(object);
      var othStacked = stack.get(other);
      if (objStacked && othStacked) {
        return objStacked == other && othStacked == object;
      }
      var result = true;
      stack.set(object, other);
      stack.set(other, object);
      var skipCtor = isPartial;
      while (++index < objLength) {
        key = objProps[index];
        var objValue = object[key], othValue = other[key];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
        }
        if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key == "constructor");
      }
      if (result && !skipCtor) {
        var objCtor = object.constructor, othCtor = other.constructor;
        if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack["delete"](object);
      stack["delete"](other);
      return result;
    }
    module2.exports = equalObjects;
  }
});

// node_modules/lodash/_baseIsEqualDeep.js
var require_baseIsEqualDeep = __commonJS({
  "node_modules/lodash/_baseIsEqualDeep.js"(exports2, module2) {
    var Stack = require_Stack();
    var equalArrays = require_equalArrays();
    var equalByTag = require_equalByTag();
    var equalObjects = require_equalObjects();
    var getTag2 = require_getTag();
    var isArray = require_isArray();
    var isBuffer = require_isBuffer();
    var isTypedArray = require_isTypedArray();
    var COMPARE_PARTIAL_FLAG = 1;
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var objectTag = "[object Object]";
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
      var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag2(object), othTag = othIsArr ? arrayTag : getTag2(other);
      objTag = objTag == argsTag ? objectTag : objTag;
      othTag = othTag == argsTag ? objectTag : othTag;
      var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
      if (isSameTag && isBuffer(object)) {
        if (!isBuffer(other)) {
          return false;
        }
        objIsArr = true;
        objIsObj = false;
      }
      if (isSameTag && !objIsObj) {
        stack || (stack = new Stack());
        return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
      }
      if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
          stack || (stack = new Stack());
          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack || (stack = new Stack());
      return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
    }
    module2.exports = baseIsEqualDeep;
  }
});

// node_modules/lodash/_baseIsEqual.js
var require_baseIsEqual = __commonJS({
  "node_modules/lodash/_baseIsEqual.js"(exports2, module2) {
    var baseIsEqualDeep = require_baseIsEqualDeep();
    var isObjectLike = require_isObjectLike();
    function baseIsEqual(value, other, bitmask, customizer, stack) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
    }
    module2.exports = baseIsEqual;
  }
});

// node_modules/lodash/_baseIsMatch.js
var require_baseIsMatch = __commonJS({
  "node_modules/lodash/_baseIsMatch.js"(exports2, module2) {
    var Stack = require_Stack();
    var baseIsEqual = require_baseIsEqual();
    var COMPARE_PARTIAL_FLAG = 1;
    var COMPARE_UNORDERED_FLAG = 2;
    function baseIsMatch(object, source, matchData, customizer) {
      var index = matchData.length, length = index, noCustomizer = !customizer;
      if (object == null) {
        return !length;
      }
      object = Object(object);
      while (index--) {
        var data = matchData[index];
        if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
          return false;
        }
      }
      while (++index < length) {
        data = matchData[index];
        var key = data[0], objValue = object[key], srcValue = data[1];
        if (noCustomizer && data[2]) {
          if (objValue === void 0 && !(key in object)) {
            return false;
          }
        } else {
          var stack = new Stack();
          if (customizer) {
            var result = customizer(objValue, srcValue, key, object, source, stack);
          }
          if (!(result === void 0 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result)) {
            return false;
          }
        }
      }
      return true;
    }
    module2.exports = baseIsMatch;
  }
});

// node_modules/lodash/_isStrictComparable.js
var require_isStrictComparable = __commonJS({
  "node_modules/lodash/_isStrictComparable.js"(exports2, module2) {
    var isObject = require_isObject();
    function isStrictComparable(value) {
      return value === value && !isObject(value);
    }
    module2.exports = isStrictComparable;
  }
});

// node_modules/lodash/_getMatchData.js
var require_getMatchData = __commonJS({
  "node_modules/lodash/_getMatchData.js"(exports2, module2) {
    var isStrictComparable = require_isStrictComparable();
    var keys = require_keys();
    function getMatchData(object) {
      var result = keys(object), length = result.length;
      while (length--) {
        var key = result[length], value = object[key];
        result[length] = [key, value, isStrictComparable(value)];
      }
      return result;
    }
    module2.exports = getMatchData;
  }
});

// node_modules/lodash/_matchesStrictComparable.js
var require_matchesStrictComparable = __commonJS({
  "node_modules/lodash/_matchesStrictComparable.js"(exports2, module2) {
    function matchesStrictComparable(key, srcValue) {
      return function(object) {
        if (object == null) {
          return false;
        }
        return object[key] === srcValue && (srcValue !== void 0 || key in Object(object));
      };
    }
    module2.exports = matchesStrictComparable;
  }
});

// node_modules/lodash/_baseMatches.js
var require_baseMatches = __commonJS({
  "node_modules/lodash/_baseMatches.js"(exports2, module2) {
    var baseIsMatch = require_baseIsMatch();
    var getMatchData = require_getMatchData();
    var matchesStrictComparable = require_matchesStrictComparable();
    function baseMatches(source) {
      var matchData = getMatchData(source);
      if (matchData.length == 1 && matchData[0][2]) {
        return matchesStrictComparable(matchData[0][0], matchData[0][1]);
      }
      return function(object) {
        return object === source || baseIsMatch(object, source, matchData);
      };
    }
    module2.exports = baseMatches;
  }
});

// node_modules/lodash/isSymbol.js
var require_isSymbol = __commonJS({
  "node_modules/lodash/isSymbol.js"(exports2, module2) {
    var baseGetTag = require_baseGetTag();
    var isObjectLike = require_isObjectLike();
    var symbolTag = "[object Symbol]";
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
    }
    module2.exports = isSymbol;
  }
});

// node_modules/lodash/_isKey.js
var require_isKey = __commonJS({
  "node_modules/lodash/_isKey.js"(exports2, module2) {
    var isArray = require_isArray();
    var isSymbol = require_isSymbol();
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
    var reIsPlainProp = /^\w*$/;
    function isKey(value, object) {
      if (isArray(value)) {
        return false;
      }
      var type = typeof value;
      if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
        return true;
      }
      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
    }
    module2.exports = isKey;
  }
});

// node_modules/lodash/memoize.js
var require_memoize = __commonJS({
  "node_modules/lodash/memoize.js"(exports2, module2) {
    var MapCache = require_MapCache();
    var FUNC_ERROR_TEXT = "Expected a function";
    function memoize(func, resolver) {
      if (typeof func != "function" || resolver != null && typeof resolver != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = function() {
        var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
        if (cache.has(key)) {
          return cache.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result) || cache;
        return result;
      };
      memoized.cache = new (memoize.Cache || MapCache)();
      return memoized;
    }
    memoize.Cache = MapCache;
    module2.exports = memoize;
  }
});

// node_modules/lodash/_memoizeCapped.js
var require_memoizeCapped = __commonJS({
  "node_modules/lodash/_memoizeCapped.js"(exports2, module2) {
    var memoize = require_memoize();
    var MAX_MEMOIZE_SIZE = 500;
    function memoizeCapped(func) {
      var result = memoize(func, function(key) {
        if (cache.size === MAX_MEMOIZE_SIZE) {
          cache.clear();
        }
        return key;
      });
      var cache = result.cache;
      return result;
    }
    module2.exports = memoizeCapped;
  }
});

// node_modules/lodash/_stringToPath.js
var require_stringToPath = __commonJS({
  "node_modules/lodash/_stringToPath.js"(exports2, module2) {
    var memoizeCapped = require_memoizeCapped();
    var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = memoizeCapped(function(string) {
      var result = [];
      if (string.charCodeAt(0) === 46) {
        result.push("");
      }
      string.replace(rePropName, function(match, number, quote, subString) {
        result.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
      });
      return result;
    });
    module2.exports = stringToPath;
  }
});

// node_modules/lodash/_baseToString.js
var require_baseToString = __commonJS({
  "node_modules/lodash/_baseToString.js"(exports2, module2) {
    var Symbol2 = require_Symbol();
    var arrayMap = require_arrayMap();
    var isArray = require_isArray();
    var isSymbol = require_isSymbol();
    var INFINITY = 1 / 0;
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolToString = symbolProto ? symbolProto.toString : void 0;
    function baseToString(value) {
      if (typeof value == "string") {
        return value;
      }
      if (isArray(value)) {
        return arrayMap(value, baseToString) + "";
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : "";
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    module2.exports = baseToString;
  }
});

// node_modules/lodash/toString.js
var require_toString = __commonJS({
  "node_modules/lodash/toString.js"(exports2, module2) {
    var baseToString = require_baseToString();
    function toString(value) {
      return value == null ? "" : baseToString(value);
    }
    module2.exports = toString;
  }
});

// node_modules/lodash/_castPath.js
var require_castPath = __commonJS({
  "node_modules/lodash/_castPath.js"(exports2, module2) {
    var isArray = require_isArray();
    var isKey = require_isKey();
    var stringToPath = require_stringToPath();
    var toString = require_toString();
    function castPath(value, object) {
      if (isArray(value)) {
        return value;
      }
      return isKey(value, object) ? [value] : stringToPath(toString(value));
    }
    module2.exports = castPath;
  }
});

// node_modules/lodash/_toKey.js
var require_toKey = __commonJS({
  "node_modules/lodash/_toKey.js"(exports2, module2) {
    var isSymbol = require_isSymbol();
    var INFINITY = 1 / 0;
    function toKey(value) {
      if (typeof value == "string" || isSymbol(value)) {
        return value;
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    module2.exports = toKey;
  }
});

// node_modules/lodash/_baseGet.js
var require_baseGet = __commonJS({
  "node_modules/lodash/_baseGet.js"(exports2, module2) {
    var castPath = require_castPath();
    var toKey = require_toKey();
    function baseGet(object, path) {
      path = castPath(path, object);
      var index = 0, length = path.length;
      while (object != null && index < length) {
        object = object[toKey(path[index++])];
      }
      return index && index == length ? object : void 0;
    }
    module2.exports = baseGet;
  }
});

// node_modules/lodash/get.js
var require_get = __commonJS({
  "node_modules/lodash/get.js"(exports2, module2) {
    var baseGet = require_baseGet();
    function get(object, path, defaultValue) {
      var result = object == null ? void 0 : baseGet(object, path);
      return result === void 0 ? defaultValue : result;
    }
    module2.exports = get;
  }
});

// node_modules/lodash/_baseHasIn.js
var require_baseHasIn = __commonJS({
  "node_modules/lodash/_baseHasIn.js"(exports2, module2) {
    function baseHasIn(object, key) {
      return object != null && key in Object(object);
    }
    module2.exports = baseHasIn;
  }
});

// node_modules/lodash/_hasPath.js
var require_hasPath = __commonJS({
  "node_modules/lodash/_hasPath.js"(exports2, module2) {
    var castPath = require_castPath();
    var isArguments = require_isArguments();
    var isArray = require_isArray();
    var isIndex = require_isIndex();
    var isLength = require_isLength();
    var toKey = require_toKey();
    function hasPath(object, path, hasFunc) {
      path = castPath(path, object);
      var index = -1, length = path.length, result = false;
      while (++index < length) {
        var key = toKey(path[index]);
        if (!(result = object != null && hasFunc(object, key))) {
          break;
        }
        object = object[key];
      }
      if (result || ++index != length) {
        return result;
      }
      length = object == null ? 0 : object.length;
      return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
    }
    module2.exports = hasPath;
  }
});

// node_modules/lodash/hasIn.js
var require_hasIn = __commonJS({
  "node_modules/lodash/hasIn.js"(exports2, module2) {
    var baseHasIn = require_baseHasIn();
    var hasPath = require_hasPath();
    function hasIn(object, path) {
      return object != null && hasPath(object, path, baseHasIn);
    }
    module2.exports = hasIn;
  }
});

// node_modules/lodash/_baseMatchesProperty.js
var require_baseMatchesProperty = __commonJS({
  "node_modules/lodash/_baseMatchesProperty.js"(exports2, module2) {
    var baseIsEqual = require_baseIsEqual();
    var get = require_get();
    var hasIn = require_hasIn();
    var isKey = require_isKey();
    var isStrictComparable = require_isStrictComparable();
    var matchesStrictComparable = require_matchesStrictComparable();
    var toKey = require_toKey();
    var COMPARE_PARTIAL_FLAG = 1;
    var COMPARE_UNORDERED_FLAG = 2;
    function baseMatchesProperty(path, srcValue) {
      if (isKey(path) && isStrictComparable(srcValue)) {
        return matchesStrictComparable(toKey(path), srcValue);
      }
      return function(object) {
        var objValue = get(object, path);
        return objValue === void 0 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
      };
    }
    module2.exports = baseMatchesProperty;
  }
});

// node_modules/lodash/identity.js
var require_identity = __commonJS({
  "node_modules/lodash/identity.js"(exports2, module2) {
    function identity(value) {
      return value;
    }
    module2.exports = identity;
  }
});

// node_modules/lodash/_baseProperty.js
var require_baseProperty = __commonJS({
  "node_modules/lodash/_baseProperty.js"(exports2, module2) {
    function baseProperty(key) {
      return function(object) {
        return object == null ? void 0 : object[key];
      };
    }
    module2.exports = baseProperty;
  }
});

// node_modules/lodash/_basePropertyDeep.js
var require_basePropertyDeep = __commonJS({
  "node_modules/lodash/_basePropertyDeep.js"(exports2, module2) {
    var baseGet = require_baseGet();
    function basePropertyDeep(path) {
      return function(object) {
        return baseGet(object, path);
      };
    }
    module2.exports = basePropertyDeep;
  }
});

// node_modules/lodash/property.js
var require_property = __commonJS({
  "node_modules/lodash/property.js"(exports2, module2) {
    var baseProperty = require_baseProperty();
    var basePropertyDeep = require_basePropertyDeep();
    var isKey = require_isKey();
    var toKey = require_toKey();
    function property(path) {
      return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
    }
    module2.exports = property;
  }
});

// node_modules/lodash/_baseIteratee.js
var require_baseIteratee = __commonJS({
  "node_modules/lodash/_baseIteratee.js"(exports2, module2) {
    var baseMatches = require_baseMatches();
    var baseMatchesProperty = require_baseMatchesProperty();
    var identity = require_identity();
    var isArray = require_isArray();
    var property = require_property();
    function baseIteratee(value) {
      if (typeof value == "function") {
        return value;
      }
      if (value == null) {
        return identity;
      }
      if (typeof value == "object") {
        return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
      }
      return property(value);
    }
    module2.exports = baseIteratee;
  }
});

// node_modules/lodash/_createBaseFor.js
var require_createBaseFor = __commonJS({
  "node_modules/lodash/_createBaseFor.js"(exports2, module2) {
    function createBaseFor(fromRight) {
      return function(object, iteratee, keysFunc) {
        var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
        while (length--) {
          var key = props[fromRight ? length : ++index];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object;
      };
    }
    module2.exports = createBaseFor;
  }
});

// node_modules/lodash/_baseFor.js
var require_baseFor = __commonJS({
  "node_modules/lodash/_baseFor.js"(exports2, module2) {
    var createBaseFor = require_createBaseFor();
    var baseFor = createBaseFor();
    module2.exports = baseFor;
  }
});

// node_modules/lodash/_baseForOwn.js
var require_baseForOwn = __commonJS({
  "node_modules/lodash/_baseForOwn.js"(exports2, module2) {
    var baseFor = require_baseFor();
    var keys = require_keys();
    function baseForOwn(object, iteratee) {
      return object && baseFor(object, iteratee, keys);
    }
    module2.exports = baseForOwn;
  }
});

// node_modules/lodash/_createBaseEach.js
var require_createBaseEach = __commonJS({
  "node_modules/lodash/_createBaseEach.js"(exports2, module2) {
    var isArrayLike = require_isArrayLike();
    function createBaseEach(eachFunc, fromRight) {
      return function(collection, iteratee) {
        if (collection == null) {
          return collection;
        }
        if (!isArrayLike(collection)) {
          return eachFunc(collection, iteratee);
        }
        var length = collection.length, index = fromRight ? length : -1, iterable = Object(collection);
        while (fromRight ? index-- : ++index < length) {
          if (iteratee(iterable[index], index, iterable) === false) {
            break;
          }
        }
        return collection;
      };
    }
    module2.exports = createBaseEach;
  }
});

// node_modules/lodash/_baseEach.js
var require_baseEach = __commonJS({
  "node_modules/lodash/_baseEach.js"(exports2, module2) {
    var baseForOwn = require_baseForOwn();
    var createBaseEach = require_createBaseEach();
    var baseEach = createBaseEach(baseForOwn);
    module2.exports = baseEach;
  }
});

// node_modules/lodash/_baseMap.js
var require_baseMap = __commonJS({
  "node_modules/lodash/_baseMap.js"(exports2, module2) {
    var baseEach = require_baseEach();
    var isArrayLike = require_isArrayLike();
    function baseMap(collection, iteratee) {
      var index = -1, result = isArrayLike(collection) ? Array(collection.length) : [];
      baseEach(collection, function(value, key, collection2) {
        result[++index] = iteratee(value, key, collection2);
      });
      return result;
    }
    module2.exports = baseMap;
  }
});

// node_modules/lodash/map.js
var require_map = __commonJS({
  "node_modules/lodash/map.js"(exports2, module2) {
    var arrayMap = require_arrayMap();
    var baseIteratee = require_baseIteratee();
    var baseMap = require_baseMap();
    var isArray = require_isArray();
    function map2(collection, iteratee) {
      var func = isArray(collection) ? arrayMap : baseMap;
      return func(collection, baseIteratee(iteratee, 3));
    }
    module2.exports = map2;
  }
});

// node_modules/lodash/_arrayEach.js
var require_arrayEach = __commonJS({
  "node_modules/lodash/_arrayEach.js"(exports2, module2) {
    function arrayEach(array, iteratee) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (iteratee(array[index], index, array) === false) {
          break;
        }
      }
      return array;
    }
    module2.exports = arrayEach;
  }
});

// node_modules/lodash/_castFunction.js
var require_castFunction = __commonJS({
  "node_modules/lodash/_castFunction.js"(exports2, module2) {
    var identity = require_identity();
    function castFunction(value) {
      return typeof value == "function" ? value : identity;
    }
    module2.exports = castFunction;
  }
});

// node_modules/lodash/forEach.js
var require_forEach = __commonJS({
  "node_modules/lodash/forEach.js"(exports2, module2) {
    var arrayEach = require_arrayEach();
    var baseEach = require_baseEach();
    var castFunction = require_castFunction();
    var isArray = require_isArray();
    function forEach(collection, iteratee) {
      var func = isArray(collection) ? arrayEach : baseEach;
      return func(collection, castFunction(iteratee));
    }
    module2.exports = forEach;
  }
});

// node_modules/lodash/_baseValues.js
var require_baseValues = __commonJS({
  "node_modules/lodash/_baseValues.js"(exports2, module2) {
    var arrayMap = require_arrayMap();
    function baseValues(object, props) {
      return arrayMap(props, function(key) {
        return object[key];
      });
    }
    module2.exports = baseValues;
  }
});

// node_modules/lodash/values.js
var require_values = __commonJS({
  "node_modules/lodash/values.js"(exports2, module2) {
    var baseValues = require_baseValues();
    var keys = require_keys();
    function values(object) {
      return object == null ? [] : baseValues(object, keys(object));
    }
    module2.exports = values;
  }
});

// node_modules/lodash/_baseHas.js
var require_baseHas = __commonJS({
  "node_modules/lodash/_baseHas.js"(exports2, module2) {
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function baseHas(object, key) {
      return object != null && hasOwnProperty.call(object, key);
    }
    module2.exports = baseHas;
  }
});

// node_modules/lodash/has.js
var require_has = __commonJS({
  "node_modules/lodash/has.js"(exports2, module2) {
    var baseHas = require_baseHas();
    var hasPath = require_hasPath();
    function has(object, path) {
      return object != null && hasPath(object, path, baseHas);
    }
    module2.exports = has;
  }
});

// node_modules/lodash/_defineProperty.js
var require_defineProperty = __commonJS({
  "node_modules/lodash/_defineProperty.js"(exports2, module2) {
    var getNative = require_getNative();
    var defineProperty = function() {
      try {
        var func = getNative(Object, "defineProperty");
        func({}, "", {});
        return func;
      } catch (e) {
      }
    }();
    module2.exports = defineProperty;
  }
});

// node_modules/lodash/_baseAssignValue.js
var require_baseAssignValue = __commonJS({
  "node_modules/lodash/_baseAssignValue.js"(exports2, module2) {
    var defineProperty = require_defineProperty();
    function baseAssignValue(object, key, value) {
      if (key == "__proto__" && defineProperty) {
        defineProperty(object, key, {
          "configurable": true,
          "enumerable": true,
          "value": value,
          "writable": true
        });
      } else {
        object[key] = value;
      }
    }
    module2.exports = baseAssignValue;
  }
});

// node_modules/lodash/_assignValue.js
var require_assignValue = __commonJS({
  "node_modules/lodash/_assignValue.js"(exports2, module2) {
    var baseAssignValue = require_baseAssignValue();
    var eq = require_eq();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function assignValue(object, key, value) {
      var objValue = object[key];
      if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
        baseAssignValue(object, key, value);
      }
    }
    module2.exports = assignValue;
  }
});

// node_modules/lodash/_copyObject.js
var require_copyObject = __commonJS({
  "node_modules/lodash/_copyObject.js"(exports2, module2) {
    var assignValue = require_assignValue();
    var baseAssignValue = require_baseAssignValue();
    function copyObject(source, props, object, customizer) {
      var isNew = !object;
      object || (object = {});
      var index = -1, length = props.length;
      while (++index < length) {
        var key = props[index];
        var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
        if (newValue === void 0) {
          newValue = source[key];
        }
        if (isNew) {
          baseAssignValue(object, key, newValue);
        } else {
          assignValue(object, key, newValue);
        }
      }
      return object;
    }
    module2.exports = copyObject;
  }
});

// node_modules/lodash/_baseAssign.js
var require_baseAssign = __commonJS({
  "node_modules/lodash/_baseAssign.js"(exports2, module2) {
    var copyObject = require_copyObject();
    var keys = require_keys();
    function baseAssign(object, source) {
      return object && copyObject(source, keys(source), object);
    }
    module2.exports = baseAssign;
  }
});

// node_modules/lodash/_nativeKeysIn.js
var require_nativeKeysIn = __commonJS({
  "node_modules/lodash/_nativeKeysIn.js"(exports2, module2) {
    function nativeKeysIn(object) {
      var result = [];
      if (object != null) {
        for (var key in Object(object)) {
          result.push(key);
        }
      }
      return result;
    }
    module2.exports = nativeKeysIn;
  }
});

// node_modules/lodash/_baseKeysIn.js
var require_baseKeysIn = __commonJS({
  "node_modules/lodash/_baseKeysIn.js"(exports2, module2) {
    var isObject = require_isObject();
    var isPrototype = require_isPrototype();
    var nativeKeysIn = require_nativeKeysIn();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function baseKeysIn(object) {
      if (!isObject(object)) {
        return nativeKeysIn(object);
      }
      var isProto = isPrototype(object), result = [];
      for (var key in object) {
        if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
          result.push(key);
        }
      }
      return result;
    }
    module2.exports = baseKeysIn;
  }
});

// node_modules/lodash/keysIn.js
var require_keysIn = __commonJS({
  "node_modules/lodash/keysIn.js"(exports2, module2) {
    var arrayLikeKeys = require_arrayLikeKeys();
    var baseKeysIn = require_baseKeysIn();
    var isArrayLike = require_isArrayLike();
    function keysIn(object) {
      return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
    }
    module2.exports = keysIn;
  }
});

// node_modules/lodash/_baseAssignIn.js
var require_baseAssignIn = __commonJS({
  "node_modules/lodash/_baseAssignIn.js"(exports2, module2) {
    var copyObject = require_copyObject();
    var keysIn = require_keysIn();
    function baseAssignIn(object, source) {
      return object && copyObject(source, keysIn(source), object);
    }
    module2.exports = baseAssignIn;
  }
});

// node_modules/lodash/_cloneBuffer.js
var require_cloneBuffer = __commonJS({
  "node_modules/lodash/_cloneBuffer.js"(exports2, module2) {
    var root = require_root();
    var freeExports = typeof exports2 == "object" && exports2 && !exports2.nodeType && exports2;
    var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var Buffer2 = moduleExports ? root.Buffer : void 0;
    var allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : void 0;
    function cloneBuffer(buffer, isDeep) {
      if (isDeep) {
        return buffer.slice();
      }
      var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
      buffer.copy(result);
      return result;
    }
    module2.exports = cloneBuffer;
  }
});

// node_modules/lodash/_copyArray.js
var require_copyArray = __commonJS({
  "node_modules/lodash/_copyArray.js"(exports2, module2) {
    function copyArray(source, array) {
      var index = -1, length = source.length;
      array || (array = Array(length));
      while (++index < length) {
        array[index] = source[index];
      }
      return array;
    }
    module2.exports = copyArray;
  }
});

// node_modules/lodash/_copySymbols.js
var require_copySymbols = __commonJS({
  "node_modules/lodash/_copySymbols.js"(exports2, module2) {
    var copyObject = require_copyObject();
    var getSymbols = require_getSymbols();
    function copySymbols(source, object) {
      return copyObject(source, getSymbols(source), object);
    }
    module2.exports = copySymbols;
  }
});

// node_modules/lodash/_getPrototype.js
var require_getPrototype = __commonJS({
  "node_modules/lodash/_getPrototype.js"(exports2, module2) {
    var overArg = require_overArg();
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    module2.exports = getPrototype;
  }
});

// node_modules/lodash/_getSymbolsIn.js
var require_getSymbolsIn = __commonJS({
  "node_modules/lodash/_getSymbolsIn.js"(exports2, module2) {
    var arrayPush = require_arrayPush();
    var getPrototype = require_getPrototype();
    var getSymbols = require_getSymbols();
    var stubArray = require_stubArray();
    var nativeGetSymbols = Object.getOwnPropertySymbols;
    var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
      var result = [];
      while (object) {
        arrayPush(result, getSymbols(object));
        object = getPrototype(object);
      }
      return result;
    };
    module2.exports = getSymbolsIn;
  }
});

// node_modules/lodash/_copySymbolsIn.js
var require_copySymbolsIn = __commonJS({
  "node_modules/lodash/_copySymbolsIn.js"(exports2, module2) {
    var copyObject = require_copyObject();
    var getSymbolsIn = require_getSymbolsIn();
    function copySymbolsIn(source, object) {
      return copyObject(source, getSymbolsIn(source), object);
    }
    module2.exports = copySymbolsIn;
  }
});

// node_modules/lodash/_getAllKeysIn.js
var require_getAllKeysIn = __commonJS({
  "node_modules/lodash/_getAllKeysIn.js"(exports2, module2) {
    var baseGetAllKeys = require_baseGetAllKeys();
    var getSymbolsIn = require_getSymbolsIn();
    var keysIn = require_keysIn();
    function getAllKeysIn(object) {
      return baseGetAllKeys(object, keysIn, getSymbolsIn);
    }
    module2.exports = getAllKeysIn;
  }
});

// node_modules/lodash/_initCloneArray.js
var require_initCloneArray = __commonJS({
  "node_modules/lodash/_initCloneArray.js"(exports2, module2) {
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function initCloneArray(array) {
      var length = array.length, result = new array.constructor(length);
      if (length && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
        result.index = array.index;
        result.input = array.input;
      }
      return result;
    }
    module2.exports = initCloneArray;
  }
});

// node_modules/lodash/_cloneArrayBuffer.js
var require_cloneArrayBuffer = __commonJS({
  "node_modules/lodash/_cloneArrayBuffer.js"(exports2, module2) {
    var Uint8Array2 = require_Uint8Array();
    function cloneArrayBuffer(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array2(result).set(new Uint8Array2(arrayBuffer));
      return result;
    }
    module2.exports = cloneArrayBuffer;
  }
});

// node_modules/lodash/_cloneDataView.js
var require_cloneDataView = __commonJS({
  "node_modules/lodash/_cloneDataView.js"(exports2, module2) {
    var cloneArrayBuffer = require_cloneArrayBuffer();
    function cloneDataView(dataView, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
    }
    module2.exports = cloneDataView;
  }
});

// node_modules/lodash/_cloneRegExp.js
var require_cloneRegExp = __commonJS({
  "node_modules/lodash/_cloneRegExp.js"(exports2, module2) {
    var reFlags = /\w*$/;
    function cloneRegExp(regexp) {
      var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
      result.lastIndex = regexp.lastIndex;
      return result;
    }
    module2.exports = cloneRegExp;
  }
});

// node_modules/lodash/_cloneSymbol.js
var require_cloneSymbol = __commonJS({
  "node_modules/lodash/_cloneSymbol.js"(exports2, module2) {
    var Symbol2 = require_Symbol();
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    function cloneSymbol(symbol) {
      return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
    }
    module2.exports = cloneSymbol;
  }
});

// node_modules/lodash/_cloneTypedArray.js
var require_cloneTypedArray = __commonJS({
  "node_modules/lodash/_cloneTypedArray.js"(exports2, module2) {
    var cloneArrayBuffer = require_cloneArrayBuffer();
    function cloneTypedArray(typedArray, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
    }
    module2.exports = cloneTypedArray;
  }
});

// node_modules/lodash/_initCloneByTag.js
var require_initCloneByTag = __commonJS({
  "node_modules/lodash/_initCloneByTag.js"(exports2, module2) {
    var cloneArrayBuffer = require_cloneArrayBuffer();
    var cloneDataView = require_cloneDataView();
    var cloneRegExp = require_cloneRegExp();
    var cloneSymbol = require_cloneSymbol();
    var cloneTypedArray = require_cloneTypedArray();
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    function initCloneByTag(object, tag, isDeep) {
      var Ctor = object.constructor;
      switch (tag) {
        case arrayBufferTag:
          return cloneArrayBuffer(object);
        case boolTag:
        case dateTag:
          return new Ctor(+object);
        case dataViewTag:
          return cloneDataView(object, isDeep);
        case float32Tag:
        case float64Tag:
        case int8Tag:
        case int16Tag:
        case int32Tag:
        case uint8Tag:
        case uint8ClampedTag:
        case uint16Tag:
        case uint32Tag:
          return cloneTypedArray(object, isDeep);
        case mapTag:
          return new Ctor();
        case numberTag:
        case stringTag:
          return new Ctor(object);
        case regexpTag:
          return cloneRegExp(object);
        case setTag:
          return new Ctor();
        case symbolTag:
          return cloneSymbol(object);
      }
    }
    module2.exports = initCloneByTag;
  }
});

// node_modules/lodash/_baseCreate.js
var require_baseCreate = __commonJS({
  "node_modules/lodash/_baseCreate.js"(exports2, module2) {
    var isObject = require_isObject();
    var objectCreate = Object.create;
    var baseCreate = function() {
      function object() {
      }
      return function(proto) {
        if (!isObject(proto)) {
          return {};
        }
        if (objectCreate) {
          return objectCreate(proto);
        }
        object.prototype = proto;
        var result = new object();
        object.prototype = void 0;
        return result;
      };
    }();
    module2.exports = baseCreate;
  }
});

// node_modules/lodash/_initCloneObject.js
var require_initCloneObject = __commonJS({
  "node_modules/lodash/_initCloneObject.js"(exports2, module2) {
    var baseCreate = require_baseCreate();
    var getPrototype = require_getPrototype();
    var isPrototype = require_isPrototype();
    function initCloneObject(object) {
      return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
    }
    module2.exports = initCloneObject;
  }
});

// node_modules/lodash/_baseIsMap.js
var require_baseIsMap = __commonJS({
  "node_modules/lodash/_baseIsMap.js"(exports2, module2) {
    var getTag2 = require_getTag();
    var isObjectLike = require_isObjectLike();
    var mapTag = "[object Map]";
    function baseIsMap(value) {
      return isObjectLike(value) && getTag2(value) == mapTag;
    }
    module2.exports = baseIsMap;
  }
});

// node_modules/lodash/isMap.js
var require_isMap = __commonJS({
  "node_modules/lodash/isMap.js"(exports2, module2) {
    var baseIsMap = require_baseIsMap();
    var baseUnary = require_baseUnary();
    var nodeUtil = require_nodeUtil();
    var nodeIsMap = nodeUtil && nodeUtil.isMap;
    var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
    module2.exports = isMap;
  }
});

// node_modules/lodash/_baseIsSet.js
var require_baseIsSet = __commonJS({
  "node_modules/lodash/_baseIsSet.js"(exports2, module2) {
    var getTag2 = require_getTag();
    var isObjectLike = require_isObjectLike();
    var setTag = "[object Set]";
    function baseIsSet(value) {
      return isObjectLike(value) && getTag2(value) == setTag;
    }
    module2.exports = baseIsSet;
  }
});

// node_modules/lodash/isSet.js
var require_isSet = __commonJS({
  "node_modules/lodash/isSet.js"(exports2, module2) {
    var baseIsSet = require_baseIsSet();
    var baseUnary = require_baseUnary();
    var nodeUtil = require_nodeUtil();
    var nodeIsSet = nodeUtil && nodeUtil.isSet;
    var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
    module2.exports = isSet;
  }
});

// node_modules/lodash/_baseClone.js
var require_baseClone = __commonJS({
  "node_modules/lodash/_baseClone.js"(exports2, module2) {
    var Stack = require_Stack();
    var arrayEach = require_arrayEach();
    var assignValue = require_assignValue();
    var baseAssign = require_baseAssign();
    var baseAssignIn = require_baseAssignIn();
    var cloneBuffer = require_cloneBuffer();
    var copyArray = require_copyArray();
    var copySymbols = require_copySymbols();
    var copySymbolsIn = require_copySymbolsIn();
    var getAllKeys = require_getAllKeys();
    var getAllKeysIn = require_getAllKeysIn();
    var getTag2 = require_getTag();
    var initCloneArray = require_initCloneArray();
    var initCloneByTag = require_initCloneByTag();
    var initCloneObject = require_initCloneObject();
    var isArray = require_isArray();
    var isBuffer = require_isBuffer();
    var isMap = require_isMap();
    var isObject = require_isObject();
    var isSet = require_isSet();
    var keys = require_keys();
    var keysIn = require_keysIn();
    var CLONE_DEEP_FLAG = 1;
    var CLONE_FLAT_FLAG = 2;
    var CLONE_SYMBOLS_FLAG = 4;
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var objectTag = "[object Object]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var cloneableTags = {};
    cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
    cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
    function baseClone(value, bitmask, customizer, key, object, stack) {
      var result, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
      if (customizer) {
        result = object ? customizer(value, key, object, stack) : customizer(value);
      }
      if (result !== void 0) {
        return result;
      }
      if (!isObject(value)) {
        return value;
      }
      var isArr = isArray(value);
      if (isArr) {
        result = initCloneArray(value);
        if (!isDeep) {
          return copyArray(value, result);
        }
      } else {
        var tag = getTag2(value), isFunc = tag == funcTag || tag == genTag;
        if (isBuffer(value)) {
          return cloneBuffer(value, isDeep);
        }
        if (tag == objectTag || tag == argsTag || isFunc && !object) {
          result = isFlat || isFunc ? {} : initCloneObject(value);
          if (!isDeep) {
            return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
          }
        } else {
          if (!cloneableTags[tag]) {
            return object ? value : {};
          }
          result = initCloneByTag(value, tag, isDeep);
        }
      }
      stack || (stack = new Stack());
      var stacked = stack.get(value);
      if (stacked) {
        return stacked;
      }
      stack.set(value, result);
      if (isSet(value)) {
        value.forEach(function(subValue) {
          result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
        });
      } else if (isMap(value)) {
        value.forEach(function(subValue, key2) {
          result.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
        });
      }
      var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
      var props = isArr ? void 0 : keysFunc(value);
      arrayEach(props || value, function(subValue, key2) {
        if (props) {
          key2 = subValue;
          subValue = value[key2];
        }
        assignValue(result, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
      });
      return result;
    }
    module2.exports = baseClone;
  }
});

// node_modules/lodash/clone.js
var require_clone = __commonJS({
  "node_modules/lodash/clone.js"(exports2, module2) {
    var baseClone = require_baseClone();
    var CLONE_SYMBOLS_FLAG = 4;
    function clone2(value) {
      return baseClone(value, CLONE_SYMBOLS_FLAG);
    }
    module2.exports = clone2;
  }
});

// node_modules/@chevrotain/utils/lib/src/print.js
var require_print = __commonJS({
  "node_modules/@chevrotain/utils/lib/src/print.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PRINT_WARNING = exports2.PRINT_ERROR = void 0;
    function PRINT_ERROR(msg) {
      if (console && console.error) {
        console.error("Error: ".concat(msg));
      }
    }
    exports2.PRINT_ERROR = PRINT_ERROR;
    function PRINT_WARNING(msg) {
      if (console && console.warn) {
        console.warn("Warning: ".concat(msg));
      }
    }
    exports2.PRINT_WARNING = PRINT_WARNING;
  }
});

// node_modules/@chevrotain/utils/lib/src/timer.js
var require_timer = __commonJS({
  "node_modules/@chevrotain/utils/lib/src/timer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.timer = void 0;
    function timer2(func) {
      var start = (/* @__PURE__ */ new Date()).getTime();
      var val = func();
      var end = (/* @__PURE__ */ new Date()).getTime();
      var total = end - start;
      return { time: total, value: val };
    }
    exports2.timer = timer2;
  }
});

// node_modules/@chevrotain/utils/lib/src/to-fast-properties.js
var require_to_fast_properties = __commonJS({
  "node_modules/@chevrotain/utils/lib/src/to-fast-properties.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toFastProperties = void 0;
    function toFastProperties(toBecomeFast) {
      function FakeConstructor() {
      }
      FakeConstructor.prototype = toBecomeFast;
      var fakeInstance = new FakeConstructor();
      function fakeAccess() {
        return typeof fakeInstance.bar;
      }
      fakeAccess();
      fakeAccess();
      if (1)
        return toBecomeFast;
      eval(toBecomeFast);
    }
    exports.toFastProperties = toFastProperties;
  }
});

// node_modules/@chevrotain/utils/lib/src/api.js
var require_api = __commonJS({
  "node_modules/@chevrotain/utils/lib/src/api.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.toFastProperties = exports2.timer = exports2.PRINT_ERROR = exports2.PRINT_WARNING = void 0;
    var print_1 = require_print();
    Object.defineProperty(exports2, "PRINT_WARNING", { enumerable: true, get: function() {
      return print_1.PRINT_WARNING;
    } });
    Object.defineProperty(exports2, "PRINT_ERROR", { enumerable: true, get: function() {
      return print_1.PRINT_ERROR;
    } });
    var timer_1 = require_timer();
    Object.defineProperty(exports2, "timer", { enumerable: true, get: function() {
      return timer_1.timer;
    } });
    var to_fast_properties_1 = require_to_fast_properties();
    Object.defineProperty(exports2, "toFastProperties", { enumerable: true, get: function() {
      return to_fast_properties_1.toFastProperties;
    } });
  }
});

// node_modules/lodash/_baseSlice.js
var require_baseSlice = __commonJS({
  "node_modules/lodash/_baseSlice.js"(exports2, module2) {
    function baseSlice(array, start, end) {
      var index = -1, length = array.length;
      if (start < 0) {
        start = -start > length ? 0 : length + start;
      }
      end = end > length ? length : end;
      if (end < 0) {
        end += length;
      }
      length = start > end ? 0 : end - start >>> 0;
      start >>>= 0;
      var result = Array(length);
      while (++index < length) {
        result[index] = array[index + start];
      }
      return result;
    }
    module2.exports = baseSlice;
  }
});

// node_modules/lodash/_trimmedEndIndex.js
var require_trimmedEndIndex = __commonJS({
  "node_modules/lodash/_trimmedEndIndex.js"(exports2, module2) {
    var reWhitespace = /\s/;
    function trimmedEndIndex(string) {
      var index = string.length;
      while (index-- && reWhitespace.test(string.charAt(index))) {
      }
      return index;
    }
    module2.exports = trimmedEndIndex;
  }
});

// node_modules/lodash/_baseTrim.js
var require_baseTrim = __commonJS({
  "node_modules/lodash/_baseTrim.js"(exports2, module2) {
    var trimmedEndIndex = require_trimmedEndIndex();
    var reTrimStart = /^\s+/;
    function baseTrim(string) {
      return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
    }
    module2.exports = baseTrim;
  }
});

// node_modules/lodash/toNumber.js
var require_toNumber = __commonJS({
  "node_modules/lodash/toNumber.js"(exports2, module2) {
    var baseTrim = require_baseTrim();
    var isObject = require_isObject();
    var isSymbol = require_isSymbol();
    var NAN = 0 / 0;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var freeParseInt = parseInt;
    function toNumber(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = baseTrim(value);
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    module2.exports = toNumber;
  }
});

// node_modules/lodash/toFinite.js
var require_toFinite = __commonJS({
  "node_modules/lodash/toFinite.js"(exports2, module2) {
    var toNumber = require_toNumber();
    var INFINITY = 1 / 0;
    var MAX_INTEGER = 17976931348623157e292;
    function toFinite(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber(value);
      if (value === INFINITY || value === -INFINITY) {
        var sign = value < 0 ? -1 : 1;
        return sign * MAX_INTEGER;
      }
      return value === value ? value : 0;
    }
    module2.exports = toFinite;
  }
});

// node_modules/lodash/toInteger.js
var require_toInteger = __commonJS({
  "node_modules/lodash/toInteger.js"(exports2, module2) {
    var toFinite = require_toFinite();
    function toInteger(value) {
      var result = toFinite(value), remainder = result % 1;
      return result === result ? remainder ? result - remainder : result : 0;
    }
    module2.exports = toInteger;
  }
});

// node_modules/lodash/drop.js
var require_drop = __commonJS({
  "node_modules/lodash/drop.js"(exports2, module2) {
    var baseSlice = require_baseSlice();
    var toInteger = require_toInteger();
    function drop(array, n, guard) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      n = guard || n === void 0 ? 1 : toInteger(n);
      return baseSlice(array, n < 0 ? 0 : n, length);
    }
    module2.exports = drop;
  }
});

// node_modules/lodash/isString.js
var require_isString = __commonJS({
  "node_modules/lodash/isString.js"(exports2, module2) {
    var baseGetTag = require_baseGetTag();
    var isArray = require_isArray();
    var isObjectLike = require_isObjectLike();
    var stringTag = "[object String]";
    function isString(value) {
      return typeof value == "string" || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
    }
    module2.exports = isString;
  }
});

// node_modules/lodash/_baseIsRegExp.js
var require_baseIsRegExp = __commonJS({
  "node_modules/lodash/_baseIsRegExp.js"(exports2, module2) {
    var baseGetTag = require_baseGetTag();
    var isObjectLike = require_isObjectLike();
    var regexpTag = "[object RegExp]";
    function baseIsRegExp(value) {
      return isObjectLike(value) && baseGetTag(value) == regexpTag;
    }
    module2.exports = baseIsRegExp;
  }
});

// node_modules/lodash/isRegExp.js
var require_isRegExp = __commonJS({
  "node_modules/lodash/isRegExp.js"(exports2, module2) {
    var baseIsRegExp = require_baseIsRegExp();
    var baseUnary = require_baseUnary();
    var nodeUtil = require_nodeUtil();
    var nodeIsRegExp = nodeUtil && nodeUtil.isRegExp;
    var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
    module2.exports = isRegExp;
  }
});

// node_modules/lodash/_baseSet.js
var require_baseSet = __commonJS({
  "node_modules/lodash/_baseSet.js"(exports2, module2) {
    var assignValue = require_assignValue();
    var castPath = require_castPath();
    var isIndex = require_isIndex();
    var isObject = require_isObject();
    var toKey = require_toKey();
    function baseSet(object, path, value, customizer) {
      if (!isObject(object)) {
        return object;
      }
      path = castPath(path, object);
      var index = -1, length = path.length, lastIndex = length - 1, nested = object;
      while (nested != null && ++index < length) {
        var key = toKey(path[index]), newValue = value;
        if (key === "__proto__" || key === "constructor" || key === "prototype") {
          return object;
        }
        if (index != lastIndex) {
          var objValue = nested[key];
          newValue = customizer ? customizer(objValue, key, nested) : void 0;
          if (newValue === void 0) {
            newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
          }
        }
        assignValue(nested, key, newValue);
        nested = nested[key];
      }
      return object;
    }
    module2.exports = baseSet;
  }
});

// node_modules/lodash/_basePickBy.js
var require_basePickBy = __commonJS({
  "node_modules/lodash/_basePickBy.js"(exports2, module2) {
    var baseGet = require_baseGet();
    var baseSet = require_baseSet();
    var castPath = require_castPath();
    function basePickBy(object, paths, predicate) {
      var index = -1, length = paths.length, result = {};
      while (++index < length) {
        var path = paths[index], value = baseGet(object, path);
        if (predicate(value, path)) {
          baseSet(result, castPath(path, object), value);
        }
      }
      return result;
    }
    module2.exports = basePickBy;
  }
});

// node_modules/lodash/pickBy.js
var require_pickBy = __commonJS({
  "node_modules/lodash/pickBy.js"(exports2, module2) {
    var arrayMap = require_arrayMap();
    var baseIteratee = require_baseIteratee();
    var basePickBy = require_basePickBy();
    var getAllKeysIn = require_getAllKeysIn();
    function pickBy(object, predicate) {
      if (object == null) {
        return {};
      }
      var props = arrayMap(getAllKeysIn(object), function(prop) {
        return [prop];
      });
      predicate = baseIteratee(predicate);
      return basePickBy(object, props, function(value, path) {
        return predicate(value, path[0]);
      });
    }
    module2.exports = pickBy;
  }
});

// node_modules/lodash/_apply.js
var require_apply = __commonJS({
  "node_modules/lodash/_apply.js"(exports2, module2) {
    function apply(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    module2.exports = apply;
  }
});

// node_modules/lodash/_overRest.js
var require_overRest = __commonJS({
  "node_modules/lodash/_overRest.js"(exports2, module2) {
    var apply = require_apply();
    var nativeMax = Math.max;
    function overRest(func, start, transform) {
      start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
      return function() {
        var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
        while (++index < length) {
          array[index] = args[start + index];
        }
        index = -1;
        var otherArgs = Array(start + 1);
        while (++index < start) {
          otherArgs[index] = args[index];
        }
        otherArgs[start] = transform(array);
        return apply(func, this, otherArgs);
      };
    }
    module2.exports = overRest;
  }
});

// node_modules/lodash/constant.js
var require_constant = __commonJS({
  "node_modules/lodash/constant.js"(exports2, module2) {
    function constant2(value) {
      return function() {
        return value;
      };
    }
    module2.exports = constant2;
  }
});

// node_modules/lodash/_baseSetToString.js
var require_baseSetToString = __commonJS({
  "node_modules/lodash/_baseSetToString.js"(exports2, module2) {
    var constant2 = require_constant();
    var defineProperty = require_defineProperty();
    var identity = require_identity();
    var baseSetToString = !defineProperty ? identity : function(func, string) {
      return defineProperty(func, "toString", {
        "configurable": true,
        "enumerable": false,
        "value": constant2(string),
        "writable": true
      });
    };
    module2.exports = baseSetToString;
  }
});

// node_modules/lodash/_shortOut.js
var require_shortOut = __commonJS({
  "node_modules/lodash/_shortOut.js"(exports2, module2) {
    var HOT_COUNT = 800;
    var HOT_SPAN = 16;
    var nativeNow = Date.now;
    function shortOut(func) {
      var count = 0, lastCalled = 0;
      return function() {
        var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
        lastCalled = stamp;
        if (remaining > 0) {
          if (++count >= HOT_COUNT) {
            return arguments[0];
          }
        } else {
          count = 0;
        }
        return func.apply(void 0, arguments);
      };
    }
    module2.exports = shortOut;
  }
});

// node_modules/lodash/_setToString.js
var require_setToString = __commonJS({
  "node_modules/lodash/_setToString.js"(exports2, module2) {
    var baseSetToString = require_baseSetToString();
    var shortOut = require_shortOut();
    var setToString = shortOut(baseSetToString);
    module2.exports = setToString;
  }
});

// node_modules/lodash/_baseRest.js
var require_baseRest = __commonJS({
  "node_modules/lodash/_baseRest.js"(exports2, module2) {
    var identity = require_identity();
    var overRest = require_overRest();
    var setToString = require_setToString();
    function baseRest(func, start) {
      return setToString(overRest(func, start, identity), func + "");
    }
    module2.exports = baseRest;
  }
});

// node_modules/lodash/_isIterateeCall.js
var require_isIterateeCall = __commonJS({
  "node_modules/lodash/_isIterateeCall.js"(exports2, module2) {
    var eq = require_eq();
    var isArrayLike = require_isArrayLike();
    var isIndex = require_isIndex();
    var isObject = require_isObject();
    function isIterateeCall(value, index, object) {
      if (!isObject(object)) {
        return false;
      }
      var type = typeof index;
      if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
        return eq(object[index], value);
      }
      return false;
    }
    module2.exports = isIterateeCall;
  }
});

// node_modules/lodash/_createAssigner.js
var require_createAssigner = __commonJS({
  "node_modules/lodash/_createAssigner.js"(exports2, module2) {
    var baseRest = require_baseRest();
    var isIterateeCall = require_isIterateeCall();
    function createAssigner(assigner) {
      return baseRest(function(object, sources) {
        var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
        customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          customizer = length < 3 ? void 0 : customizer;
          length = 1;
        }
        object = Object(object);
        while (++index < length) {
          var source = sources[index];
          if (source) {
            assigner(object, source, index, customizer);
          }
        }
        return object;
      });
    }
    module2.exports = createAssigner;
  }
});

// node_modules/lodash/assign.js
var require_assign = __commonJS({
  "node_modules/lodash/assign.js"(exports2, module2) {
    var assignValue = require_assignValue();
    var copyObject = require_copyObject();
    var createAssigner = require_createAssigner();
    var isArrayLike = require_isArrayLike();
    var isPrototype = require_isPrototype();
    var keys = require_keys();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var assign3 = createAssigner(function(object, source) {
      if (isPrototype(source) || isArrayLike(source)) {
        copyObject(source, keys(source), object);
        return;
      }
      for (var key in source) {
        if (hasOwnProperty.call(source, key)) {
          assignValue(object, key, source[key]);
        }
      }
    });
    module2.exports = assign3;
  }
});

// node_modules/@chevrotain/gast/lib/src/model.js
var require_model = __commonJS({
  "node_modules/@chevrotain/gast/lib/src/model.js"(exports2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || function() {
      var extendStatics = function(d, b5) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b6) {
          d2.__proto__ = b6;
        } || function(d2, b6) {
          for (var p in b6)
            if (Object.prototype.hasOwnProperty.call(b6, p))
              d2[p] = b6[p];
        };
        return extendStatics(d, b5);
      };
      return function(d, b5) {
        if (typeof b5 !== "function" && b5 !== null)
          throw new TypeError("Class extends value " + String(b5) + " is not a constructor or null");
        extendStatics(d, b5);
        function __() {
          this.constructor = d;
        }
        d.prototype = b5 === null ? Object.create(b5) : (__.prototype = b5.prototype, new __());
      };
    }();
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.serializeProduction = exports2.serializeGrammar = exports2.Terminal = exports2.Alternation = exports2.RepetitionWithSeparator = exports2.Repetition = exports2.RepetitionMandatoryWithSeparator = exports2.RepetitionMandatory = exports2.Option = exports2.Alternative = exports2.Rule = exports2.NonTerminal = exports2.AbstractProduction = void 0;
    var map_1 = __importDefault(require_map());
    var forEach_1 = __importDefault(require_forEach());
    var isString_1 = __importDefault(require_isString());
    var isRegExp_1 = __importDefault(require_isRegExp());
    var pickBy_1 = __importDefault(require_pickBy());
    var assign_1 = __importDefault(require_assign());
    function tokenLabel2(tokType) {
      if (hasTokenLabel(tokType)) {
        return tokType.LABEL;
      } else {
        return tokType.name;
      }
    }
    function hasTokenLabel(obj) {
      return (0, isString_1.default)(obj.LABEL) && obj.LABEL !== "";
    }
    var AbstractProduction = (
      /** @class */
      function() {
        function AbstractProduction2(_definition) {
          this._definition = _definition;
        }
        Object.defineProperty(AbstractProduction2.prototype, "definition", {
          get: function() {
            return this._definition;
          },
          set: function(value) {
            this._definition = value;
          },
          enumerable: false,
          configurable: true
        });
        AbstractProduction2.prototype.accept = function(visitor) {
          visitor.visit(this);
          (0, forEach_1.default)(this.definition, function(prod) {
            prod.accept(visitor);
          });
        };
        return AbstractProduction2;
      }()
    );
    exports2.AbstractProduction = AbstractProduction;
    var NonTerminal2 = (
      /** @class */
      function(_super) {
        __extends(NonTerminal3, _super);
        function NonTerminal3(options) {
          var _this = _super.call(this, []) || this;
          _this.idx = 1;
          (0, assign_1.default)(_this, (0, pickBy_1.default)(options, function(v) {
            return v !== void 0;
          }));
          return _this;
        }
        Object.defineProperty(NonTerminal3.prototype, "definition", {
          get: function() {
            if (this.referencedRule !== void 0) {
              return this.referencedRule.definition;
            }
            return [];
          },
          set: function(definition) {
          },
          enumerable: false,
          configurable: true
        });
        NonTerminal3.prototype.accept = function(visitor) {
          visitor.visit(this);
        };
        return NonTerminal3;
      }(AbstractProduction)
    );
    exports2.NonTerminal = NonTerminal2;
    var Rule2 = (
      /** @class */
      function(_super) {
        __extends(Rule3, _super);
        function Rule3(options) {
          var _this = _super.call(this, options.definition) || this;
          _this.orgText = "";
          (0, assign_1.default)(_this, (0, pickBy_1.default)(options, function(v) {
            return v !== void 0;
          }));
          return _this;
        }
        return Rule3;
      }(AbstractProduction)
    );
    exports2.Rule = Rule2;
    var Alternative2 = (
      /** @class */
      function(_super) {
        __extends(Alternative3, _super);
        function Alternative3(options) {
          var _this = _super.call(this, options.definition) || this;
          _this.ignoreAmbiguities = false;
          (0, assign_1.default)(_this, (0, pickBy_1.default)(options, function(v) {
            return v !== void 0;
          }));
          return _this;
        }
        return Alternative3;
      }(AbstractProduction)
    );
    exports2.Alternative = Alternative2;
    var Option2 = (
      /** @class */
      function(_super) {
        __extends(Option3, _super);
        function Option3(options) {
          var _this = _super.call(this, options.definition) || this;
          _this.idx = 1;
          (0, assign_1.default)(_this, (0, pickBy_1.default)(options, function(v) {
            return v !== void 0;
          }));
          return _this;
        }
        return Option3;
      }(AbstractProduction)
    );
    exports2.Option = Option2;
    var RepetitionMandatory2 = (
      /** @class */
      function(_super) {
        __extends(RepetitionMandatory3, _super);
        function RepetitionMandatory3(options) {
          var _this = _super.call(this, options.definition) || this;
          _this.idx = 1;
          (0, assign_1.default)(_this, (0, pickBy_1.default)(options, function(v) {
            return v !== void 0;
          }));
          return _this;
        }
        return RepetitionMandatory3;
      }(AbstractProduction)
    );
    exports2.RepetitionMandatory = RepetitionMandatory2;
    var RepetitionMandatoryWithSeparator2 = (
      /** @class */
      function(_super) {
        __extends(RepetitionMandatoryWithSeparator3, _super);
        function RepetitionMandatoryWithSeparator3(options) {
          var _this = _super.call(this, options.definition) || this;
          _this.idx = 1;
          (0, assign_1.default)(_this, (0, pickBy_1.default)(options, function(v) {
            return v !== void 0;
          }));
          return _this;
        }
        return RepetitionMandatoryWithSeparator3;
      }(AbstractProduction)
    );
    exports2.RepetitionMandatoryWithSeparator = RepetitionMandatoryWithSeparator2;
    var Repetition2 = (
      /** @class */
      function(_super) {
        __extends(Repetition3, _super);
        function Repetition3(options) {
          var _this = _super.call(this, options.definition) || this;
          _this.idx = 1;
          (0, assign_1.default)(_this, (0, pickBy_1.default)(options, function(v) {
            return v !== void 0;
          }));
          return _this;
        }
        return Repetition3;
      }(AbstractProduction)
    );
    exports2.Repetition = Repetition2;
    var RepetitionWithSeparator2 = (
      /** @class */
      function(_super) {
        __extends(RepetitionWithSeparator3, _super);
        function RepetitionWithSeparator3(options) {
          var _this = _super.call(this, options.definition) || this;
          _this.idx = 1;
          (0, assign_1.default)(_this, (0, pickBy_1.default)(options, function(v) {
            return v !== void 0;
          }));
          return _this;
        }
        return RepetitionWithSeparator3;
      }(AbstractProduction)
    );
    exports2.RepetitionWithSeparator = RepetitionWithSeparator2;
    var Alternation2 = (
      /** @class */
      function(_super) {
        __extends(Alternation3, _super);
        function Alternation3(options) {
          var _this = _super.call(this, options.definition) || this;
          _this.idx = 1;
          _this.ignoreAmbiguities = false;
          _this.hasPredicates = false;
          (0, assign_1.default)(_this, (0, pickBy_1.default)(options, function(v) {
            return v !== void 0;
          }));
          return _this;
        }
        Object.defineProperty(Alternation3.prototype, "definition", {
          get: function() {
            return this._definition;
          },
          set: function(value) {
            this._definition = value;
          },
          enumerable: false,
          configurable: true
        });
        return Alternation3;
      }(AbstractProduction)
    );
    exports2.Alternation = Alternation2;
    var Terminal2 = (
      /** @class */
      function() {
        function Terminal3(options) {
          this.idx = 1;
          (0, assign_1.default)(this, (0, pickBy_1.default)(options, function(v) {
            return v !== void 0;
          }));
        }
        Terminal3.prototype.accept = function(visitor) {
          visitor.visit(this);
        };
        return Terminal3;
      }()
    );
    exports2.Terminal = Terminal2;
    function serializeGrammar2(topRules) {
      return (0, map_1.default)(topRules, serializeProduction2);
    }
    exports2.serializeGrammar = serializeGrammar2;
    function serializeProduction2(node) {
      function convertDefinition(definition) {
        return (0, map_1.default)(definition, serializeProduction2);
      }
      if (node instanceof NonTerminal2) {
        var serializedNonTerminal = {
          type: "NonTerminal",
          name: node.nonTerminalName,
          idx: node.idx
        };
        if ((0, isString_1.default)(node.label)) {
          serializedNonTerminal.label = node.label;
        }
        return serializedNonTerminal;
      } else if (node instanceof Alternative2) {
        return {
          type: "Alternative",
          definition: convertDefinition(node.definition)
        };
      } else if (node instanceof Option2) {
        return {
          type: "Option",
          idx: node.idx,
          definition: convertDefinition(node.definition)
        };
      } else if (node instanceof RepetitionMandatory2) {
        return {
          type: "RepetitionMandatory",
          idx: node.idx,
          definition: convertDefinition(node.definition)
        };
      } else if (node instanceof RepetitionMandatoryWithSeparator2) {
        return {
          type: "RepetitionMandatoryWithSeparator",
          idx: node.idx,
          separator: serializeProduction2(new Terminal2({ terminalType: node.separator })),
          definition: convertDefinition(node.definition)
        };
      } else if (node instanceof RepetitionWithSeparator2) {
        return {
          type: "RepetitionWithSeparator",
          idx: node.idx,
          separator: serializeProduction2(new Terminal2({ terminalType: node.separator })),
          definition: convertDefinition(node.definition)
        };
      } else if (node instanceof Repetition2) {
        return {
          type: "Repetition",
          idx: node.idx,
          definition: convertDefinition(node.definition)
        };
      } else if (node instanceof Alternation2) {
        return {
          type: "Alternation",
          idx: node.idx,
          definition: convertDefinition(node.definition)
        };
      } else if (node instanceof Terminal2) {
        var serializedTerminal = {
          type: "Terminal",
          name: node.terminalType.name,
          label: tokenLabel2(node.terminalType),
          idx: node.idx
        };
        if ((0, isString_1.default)(node.label)) {
          serializedTerminal.terminalLabel = node.label;
        }
        var pattern = node.terminalType.PATTERN;
        if (node.terminalType.PATTERN) {
          serializedTerminal.pattern = (0, isRegExp_1.default)(pattern) ? pattern.source : pattern;
        }
        return serializedTerminal;
      } else if (node instanceof Rule2) {
        return {
          type: "Rule",
          name: node.name,
          orgText: node.orgText,
          definition: convertDefinition(node.definition)
        };
      } else {
        throw Error("non exhaustive match");
      }
    }
    exports2.serializeProduction = serializeProduction2;
  }
});

// node_modules/@chevrotain/gast/lib/src/visitor.js
var require_visitor = __commonJS({
  "node_modules/@chevrotain/gast/lib/src/visitor.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.GAstVisitor = void 0;
    var model_1 = require_model();
    var GAstVisitor2 = (
      /** @class */
      function() {
        function GAstVisitor3() {
        }
        GAstVisitor3.prototype.visit = function(node) {
          var nodeAny = node;
          switch (nodeAny.constructor) {
            case model_1.NonTerminal:
              return this.visitNonTerminal(nodeAny);
            case model_1.Alternative:
              return this.visitAlternative(nodeAny);
            case model_1.Option:
              return this.visitOption(nodeAny);
            case model_1.RepetitionMandatory:
              return this.visitRepetitionMandatory(nodeAny);
            case model_1.RepetitionMandatoryWithSeparator:
              return this.visitRepetitionMandatoryWithSeparator(nodeAny);
            case model_1.RepetitionWithSeparator:
              return this.visitRepetitionWithSeparator(nodeAny);
            case model_1.Repetition:
              return this.visitRepetition(nodeAny);
            case model_1.Alternation:
              return this.visitAlternation(nodeAny);
            case model_1.Terminal:
              return this.visitTerminal(nodeAny);
            case model_1.Rule:
              return this.visitRule(nodeAny);
            default:
              throw Error("non exhaustive match");
          }
        };
        GAstVisitor3.prototype.visitNonTerminal = function(node) {
        };
        GAstVisitor3.prototype.visitAlternative = function(node) {
        };
        GAstVisitor3.prototype.visitOption = function(node) {
        };
        GAstVisitor3.prototype.visitRepetition = function(node) {
        };
        GAstVisitor3.prototype.visitRepetitionMandatory = function(node) {
        };
        GAstVisitor3.prototype.visitRepetitionMandatoryWithSeparator = function(node) {
        };
        GAstVisitor3.prototype.visitRepetitionWithSeparator = function(node) {
        };
        GAstVisitor3.prototype.visitAlternation = function(node) {
        };
        GAstVisitor3.prototype.visitTerminal = function(node) {
        };
        GAstVisitor3.prototype.visitRule = function(node) {
        };
        return GAstVisitor3;
      }()
    );
    exports2.GAstVisitor = GAstVisitor2;
  }
});

// node_modules/lodash/_baseSome.js
var require_baseSome = __commonJS({
  "node_modules/lodash/_baseSome.js"(exports2, module2) {
    var baseEach = require_baseEach();
    function baseSome(collection, predicate) {
      var result;
      baseEach(collection, function(value, index, collection2) {
        result = predicate(value, index, collection2);
        return !result;
      });
      return !!result;
    }
    module2.exports = baseSome;
  }
});

// node_modules/lodash/some.js
var require_some = __commonJS({
  "node_modules/lodash/some.js"(exports2, module2) {
    var arraySome = require_arraySome();
    var baseIteratee = require_baseIteratee();
    var baseSome = require_baseSome();
    var isArray = require_isArray();
    var isIterateeCall = require_isIterateeCall();
    function some(collection, predicate, guard) {
      var func = isArray(collection) ? arraySome : baseSome;
      if (guard && isIterateeCall(collection, predicate, guard)) {
        predicate = void 0;
      }
      return func(collection, baseIteratee(predicate, 3));
    }
    module2.exports = some;
  }
});

// node_modules/lodash/_arrayEvery.js
var require_arrayEvery = __commonJS({
  "node_modules/lodash/_arrayEvery.js"(exports2, module2) {
    function arrayEvery(array, predicate) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (!predicate(array[index], index, array)) {
          return false;
        }
      }
      return true;
    }
    module2.exports = arrayEvery;
  }
});

// node_modules/lodash/_baseEvery.js
var require_baseEvery = __commonJS({
  "node_modules/lodash/_baseEvery.js"(exports2, module2) {
    var baseEach = require_baseEach();
    function baseEvery(collection, predicate) {
      var result = true;
      baseEach(collection, function(value, index, collection2) {
        result = !!predicate(value, index, collection2);
        return result;
      });
      return result;
    }
    module2.exports = baseEvery;
  }
});

// node_modules/lodash/every.js
var require_every = __commonJS({
  "node_modules/lodash/every.js"(exports2, module2) {
    var arrayEvery = require_arrayEvery();
    var baseEvery = require_baseEvery();
    var baseIteratee = require_baseIteratee();
    var isArray = require_isArray();
    var isIterateeCall = require_isIterateeCall();
    function every(collection, predicate, guard) {
      var func = isArray(collection) ? arrayEvery : baseEvery;
      if (guard && isIterateeCall(collection, predicate, guard)) {
        predicate = void 0;
      }
      return func(collection, baseIteratee(predicate, 3));
    }
    module2.exports = every;
  }
});

// node_modules/lodash/_baseFindIndex.js
var require_baseFindIndex = __commonJS({
  "node_modules/lodash/_baseFindIndex.js"(exports2, module2) {
    function baseFindIndex(array, predicate, fromIndex, fromRight) {
      var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
      while (fromRight ? index-- : ++index < length) {
        if (predicate(array[index], index, array)) {
          return index;
        }
      }
      return -1;
    }
    module2.exports = baseFindIndex;
  }
});

// node_modules/lodash/_baseIsNaN.js
var require_baseIsNaN = __commonJS({
  "node_modules/lodash/_baseIsNaN.js"(exports2, module2) {
    function baseIsNaN(value) {
      return value !== value;
    }
    module2.exports = baseIsNaN;
  }
});

// node_modules/lodash/_strictIndexOf.js
var require_strictIndexOf = __commonJS({
  "node_modules/lodash/_strictIndexOf.js"(exports2, module2) {
    function strictIndexOf(array, value, fromIndex) {
      var index = fromIndex - 1, length = array.length;
      while (++index < length) {
        if (array[index] === value) {
          return index;
        }
      }
      return -1;
    }
    module2.exports = strictIndexOf;
  }
});

// node_modules/lodash/_baseIndexOf.js
var require_baseIndexOf = __commonJS({
  "node_modules/lodash/_baseIndexOf.js"(exports2, module2) {
    var baseFindIndex = require_baseFindIndex();
    var baseIsNaN = require_baseIsNaN();
    var strictIndexOf = require_strictIndexOf();
    function baseIndexOf(array, value, fromIndex) {
      return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
    }
    module2.exports = baseIndexOf;
  }
});

// node_modules/lodash/includes.js
var require_includes = __commonJS({
  "node_modules/lodash/includes.js"(exports2, module2) {
    var baseIndexOf = require_baseIndexOf();
    var isArrayLike = require_isArrayLike();
    var isString = require_isString();
    var toInteger = require_toInteger();
    var values = require_values();
    var nativeMax = Math.max;
    function includes(collection, value, fromIndex, guard) {
      collection = isArrayLike(collection) ? collection : values(collection);
      fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
      var length = collection.length;
      if (fromIndex < 0) {
        fromIndex = nativeMax(length + fromIndex, 0);
      }
      return isString(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
    }
    module2.exports = includes;
  }
});

// node_modules/@chevrotain/gast/lib/src/helpers.js
var require_helpers = __commonJS({
  "node_modules/@chevrotain/gast/lib/src/helpers.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getProductionDslName = exports2.isBranchingProd = exports2.isOptionalProd = exports2.isSequenceProd = void 0;
    var some_1 = __importDefault(require_some());
    var every_1 = __importDefault(require_every());
    var includes_1 = __importDefault(require_includes());
    var model_1 = require_model();
    function isSequenceProd(prod) {
      return prod instanceof model_1.Alternative || prod instanceof model_1.Option || prod instanceof model_1.Repetition || prod instanceof model_1.RepetitionMandatory || prod instanceof model_1.RepetitionMandatoryWithSeparator || prod instanceof model_1.RepetitionWithSeparator || prod instanceof model_1.Terminal || prod instanceof model_1.Rule;
    }
    exports2.isSequenceProd = isSequenceProd;
    function isOptionalProd(prod, alreadyVisited) {
      if (alreadyVisited === void 0) {
        alreadyVisited = [];
      }
      var isDirectlyOptional = prod instanceof model_1.Option || prod instanceof model_1.Repetition || prod instanceof model_1.RepetitionWithSeparator;
      if (isDirectlyOptional) {
        return true;
      }
      if (prod instanceof model_1.Alternation) {
        return (0, some_1.default)(prod.definition, function(subProd) {
          return isOptionalProd(subProd, alreadyVisited);
        });
      } else if (prod instanceof model_1.NonTerminal && (0, includes_1.default)(alreadyVisited, prod)) {
        return false;
      } else if (prod instanceof model_1.AbstractProduction) {
        if (prod instanceof model_1.NonTerminal) {
          alreadyVisited.push(prod);
        }
        return (0, every_1.default)(prod.definition, function(subProd) {
          return isOptionalProd(subProd, alreadyVisited);
        });
      } else {
        return false;
      }
    }
    exports2.isOptionalProd = isOptionalProd;
    function isBranchingProd(prod) {
      return prod instanceof model_1.Alternation;
    }
    exports2.isBranchingProd = isBranchingProd;
    function getProductionDslName(prod) {
      if (prod instanceof model_1.NonTerminal) {
        return "SUBRULE";
      } else if (prod instanceof model_1.Option) {
        return "OPTION";
      } else if (prod instanceof model_1.Alternation) {
        return "OR";
      } else if (prod instanceof model_1.RepetitionMandatory) {
        return "AT_LEAST_ONE";
      } else if (prod instanceof model_1.RepetitionMandatoryWithSeparator) {
        return "AT_LEAST_ONE_SEP";
      } else if (prod instanceof model_1.RepetitionWithSeparator) {
        return "MANY_SEP";
      } else if (prod instanceof model_1.Repetition) {
        return "MANY";
      } else if (prod instanceof model_1.Terminal) {
        return "CONSUME";
      } else {
        throw Error("non exhaustive match");
      }
    }
    exports2.getProductionDslName = getProductionDslName;
  }
});

// node_modules/@chevrotain/gast/lib/src/api.js
var require_api2 = __commonJS({
  "node_modules/@chevrotain/gast/lib/src/api.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isSequenceProd = exports2.isBranchingProd = exports2.isOptionalProd = exports2.getProductionDslName = exports2.GAstVisitor = exports2.serializeProduction = exports2.serializeGrammar = exports2.Alternative = exports2.Alternation = exports2.RepetitionWithSeparator = exports2.RepetitionMandatoryWithSeparator = exports2.RepetitionMandatory = exports2.Repetition = exports2.Option = exports2.NonTerminal = exports2.Terminal = exports2.Rule = void 0;
    var model_1 = require_model();
    Object.defineProperty(exports2, "Rule", { enumerable: true, get: function() {
      return model_1.Rule;
    } });
    Object.defineProperty(exports2, "Terminal", { enumerable: true, get: function() {
      return model_1.Terminal;
    } });
    Object.defineProperty(exports2, "NonTerminal", { enumerable: true, get: function() {
      return model_1.NonTerminal;
    } });
    Object.defineProperty(exports2, "Option", { enumerable: true, get: function() {
      return model_1.Option;
    } });
    Object.defineProperty(exports2, "Repetition", { enumerable: true, get: function() {
      return model_1.Repetition;
    } });
    Object.defineProperty(exports2, "RepetitionMandatory", { enumerable: true, get: function() {
      return model_1.RepetitionMandatory;
    } });
    Object.defineProperty(exports2, "RepetitionMandatoryWithSeparator", { enumerable: true, get: function() {
      return model_1.RepetitionMandatoryWithSeparator;
    } });
    Object.defineProperty(exports2, "RepetitionWithSeparator", { enumerable: true, get: function() {
      return model_1.RepetitionWithSeparator;
    } });
    Object.defineProperty(exports2, "Alternation", { enumerable: true, get: function() {
      return model_1.Alternation;
    } });
    Object.defineProperty(exports2, "Alternative", { enumerable: true, get: function() {
      return model_1.Alternative;
    } });
    Object.defineProperty(exports2, "serializeGrammar", { enumerable: true, get: function() {
      return model_1.serializeGrammar;
    } });
    Object.defineProperty(exports2, "serializeProduction", { enumerable: true, get: function() {
      return model_1.serializeProduction;
    } });
    var visitor_1 = require_visitor();
    Object.defineProperty(exports2, "GAstVisitor", { enumerable: true, get: function() {
      return visitor_1.GAstVisitor;
    } });
    var helpers_1 = require_helpers();
    Object.defineProperty(exports2, "getProductionDslName", { enumerable: true, get: function() {
      return helpers_1.getProductionDslName;
    } });
    Object.defineProperty(exports2, "isOptionalProd", { enumerable: true, get: function() {
      return helpers_1.isOptionalProd;
    } });
    Object.defineProperty(exports2, "isBranchingProd", { enumerable: true, get: function() {
      return helpers_1.isBranchingProd;
    } });
    Object.defineProperty(exports2, "isSequenceProd", { enumerable: true, get: function() {
      return helpers_1.isSequenceProd;
    } });
  }
});

// node_modules/chevrotain/lib/src/parse/grammar/rest.js
var require_rest = __commonJS({
  "node_modules/chevrotain/lib/src/parse/grammar/rest.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RestWalker = void 0;
    var drop_1 = __importDefault(require_drop());
    var forEach_1 = __importDefault(require_forEach());
    var gast_1 = require_api2();
    var RestWalker = (
      /** @class */
      function() {
        function RestWalker2() {
        }
        RestWalker2.prototype.walk = function(prod, prevRest) {
          var _this = this;
          if (prevRest === void 0) {
            prevRest = [];
          }
          (0, forEach_1.default)(prod.definition, function(subProd, index) {
            var currRest = (0, drop_1.default)(prod.definition, index + 1);
            if (subProd instanceof gast_1.NonTerminal) {
              _this.walkProdRef(subProd, currRest, prevRest);
            } else if (subProd instanceof gast_1.Terminal) {
              _this.walkTerminal(subProd, currRest, prevRest);
            } else if (subProd instanceof gast_1.Alternative) {
              _this.walkFlat(subProd, currRest, prevRest);
            } else if (subProd instanceof gast_1.Option) {
              _this.walkOption(subProd, currRest, prevRest);
            } else if (subProd instanceof gast_1.RepetitionMandatory) {
              _this.walkAtLeastOne(subProd, currRest, prevRest);
            } else if (subProd instanceof gast_1.RepetitionMandatoryWithSeparator) {
              _this.walkAtLeastOneSep(subProd, currRest, prevRest);
            } else if (subProd instanceof gast_1.RepetitionWithSeparator) {
              _this.walkManySep(subProd, currRest, prevRest);
            } else if (subProd instanceof gast_1.Repetition) {
              _this.walkMany(subProd, currRest, prevRest);
            } else if (subProd instanceof gast_1.Alternation) {
              _this.walkOr(subProd, currRest, prevRest);
            } else {
              throw Error("non exhaustive match");
            }
          });
        };
        RestWalker2.prototype.walkTerminal = function(terminal, currRest, prevRest) {
        };
        RestWalker2.prototype.walkProdRef = function(refProd, currRest, prevRest) {
        };
        RestWalker2.prototype.walkFlat = function(flatProd, currRest, prevRest) {
          var fullOrRest = currRest.concat(prevRest);
          this.walk(flatProd, fullOrRest);
        };
        RestWalker2.prototype.walkOption = function(optionProd, currRest, prevRest) {
          var fullOrRest = currRest.concat(prevRest);
          this.walk(optionProd, fullOrRest);
        };
        RestWalker2.prototype.walkAtLeastOne = function(atLeastOneProd, currRest, prevRest) {
          var fullAtLeastOneRest = [
            new gast_1.Option({ definition: atLeastOneProd.definition })
          ].concat(currRest, prevRest);
          this.walk(atLeastOneProd, fullAtLeastOneRest);
        };
        RestWalker2.prototype.walkAtLeastOneSep = function(atLeastOneSepProd, currRest, prevRest) {
          var fullAtLeastOneSepRest = restForRepetitionWithSeparator(atLeastOneSepProd, currRest, prevRest);
          this.walk(atLeastOneSepProd, fullAtLeastOneSepRest);
        };
        RestWalker2.prototype.walkMany = function(manyProd, currRest, prevRest) {
          var fullManyRest = [
            new gast_1.Option({ definition: manyProd.definition })
          ].concat(currRest, prevRest);
          this.walk(manyProd, fullManyRest);
        };
        RestWalker2.prototype.walkManySep = function(manySepProd, currRest, prevRest) {
          var fullManySepRest = restForRepetitionWithSeparator(manySepProd, currRest, prevRest);
          this.walk(manySepProd, fullManySepRest);
        };
        RestWalker2.prototype.walkOr = function(orProd, currRest, prevRest) {
          var _this = this;
          var fullOrRest = currRest.concat(prevRest);
          (0, forEach_1.default)(orProd.definition, function(alt) {
            var prodWrapper = new gast_1.Alternative({ definition: [alt] });
            _this.walk(prodWrapper, fullOrRest);
          });
        };
        return RestWalker2;
      }()
    );
    exports2.RestWalker = RestWalker;
    function restForRepetitionWithSeparator(repSepProd, currRest, prevRest) {
      var repSepRest = [
        new gast_1.Option({
          definition: [
            new gast_1.Terminal({ terminalType: repSepProd.separator })
          ].concat(repSepProd.definition)
        })
      ];
      var fullRepSepRest = repSepRest.concat(currRest, prevRest);
      return fullRepSepRest;
    }
  }
});

// node_modules/lodash/_isFlattenable.js
var require_isFlattenable = __commonJS({
  "node_modules/lodash/_isFlattenable.js"(exports2, module2) {
    var Symbol2 = require_Symbol();
    var isArguments = require_isArguments();
    var isArray = require_isArray();
    var spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : void 0;
    function isFlattenable(value) {
      return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
    }
    module2.exports = isFlattenable;
  }
});

// node_modules/lodash/_baseFlatten.js
var require_baseFlatten = __commonJS({
  "node_modules/lodash/_baseFlatten.js"(exports2, module2) {
    var arrayPush = require_arrayPush();
    var isFlattenable = require_isFlattenable();
    function baseFlatten(array, depth, predicate, isStrict, result) {
      var index = -1, length = array.length;
      predicate || (predicate = isFlattenable);
      result || (result = []);
      while (++index < length) {
        var value = array[index];
        if (depth > 0 && predicate(value)) {
          if (depth > 1) {
            baseFlatten(value, depth - 1, predicate, isStrict, result);
          } else {
            arrayPush(result, value);
          }
        } else if (!isStrict) {
          result[result.length] = value;
        }
      }
      return result;
    }
    module2.exports = baseFlatten;
  }
});

// node_modules/lodash/flatten.js
var require_flatten = __commonJS({
  "node_modules/lodash/flatten.js"(exports2, module2) {
    var baseFlatten = require_baseFlatten();
    function flatten(array) {
      var length = array == null ? 0 : array.length;
      return length ? baseFlatten(array, 1) : [];
    }
    module2.exports = flatten;
  }
});

// node_modules/lodash/_arrayIncludes.js
var require_arrayIncludes = __commonJS({
  "node_modules/lodash/_arrayIncludes.js"(exports2, module2) {
    var baseIndexOf = require_baseIndexOf();
    function arrayIncludes(array, value) {
      var length = array == null ? 0 : array.length;
      return !!length && baseIndexOf(array, value, 0) > -1;
    }
    module2.exports = arrayIncludes;
  }
});

// node_modules/lodash/_arrayIncludesWith.js
var require_arrayIncludesWith = __commonJS({
  "node_modules/lodash/_arrayIncludesWith.js"(exports2, module2) {
    function arrayIncludesWith(array, value, comparator) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (comparator(value, array[index])) {
          return true;
        }
      }
      return false;
    }
    module2.exports = arrayIncludesWith;
  }
});

// node_modules/lodash/noop.js
var require_noop = __commonJS({
  "node_modules/lodash/noop.js"(exports2, module2) {
    function noop() {
    }
    module2.exports = noop;
  }
});

// node_modules/lodash/_createSet.js
var require_createSet = __commonJS({
  "node_modules/lodash/_createSet.js"(exports2, module2) {
    var Set2 = require_Set();
    var noop = require_noop();
    var setToArray = require_setToArray();
    var INFINITY = 1 / 0;
    var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop : function(values) {
      return new Set2(values);
    };
    module2.exports = createSet;
  }
});

// node_modules/lodash/_baseUniq.js
var require_baseUniq = __commonJS({
  "node_modules/lodash/_baseUniq.js"(exports2, module2) {
    var SetCache = require_SetCache();
    var arrayIncludes = require_arrayIncludes();
    var arrayIncludesWith = require_arrayIncludesWith();
    var cacheHas = require_cacheHas();
    var createSet = require_createSet();
    var setToArray = require_setToArray();
    var LARGE_ARRAY_SIZE = 200;
    function baseUniq(array, iteratee, comparator) {
      var index = -1, includes = arrayIncludes, length = array.length, isCommon = true, result = [], seen = result;
      if (comparator) {
        isCommon = false;
        includes = arrayIncludesWith;
      } else if (length >= LARGE_ARRAY_SIZE) {
        var set = iteratee ? null : createSet(array);
        if (set) {
          return setToArray(set);
        }
        isCommon = false;
        includes = cacheHas;
        seen = new SetCache();
      } else {
        seen = iteratee ? [] : result;
      }
      outer:
        while (++index < length) {
          var value = array[index], computed = iteratee ? iteratee(value) : value;
          value = comparator || value !== 0 ? value : 0;
          if (isCommon && computed === computed) {
            var seenIndex = seen.length;
            while (seenIndex--) {
              if (seen[seenIndex] === computed) {
                continue outer;
              }
            }
            if (iteratee) {
              seen.push(computed);
            }
            result.push(value);
          } else if (!includes(seen, computed, comparator)) {
            if (seen !== result) {
              seen.push(computed);
            }
            result.push(value);
          }
        }
      return result;
    }
    module2.exports = baseUniq;
  }
});

// node_modules/lodash/uniq.js
var require_uniq = __commonJS({
  "node_modules/lodash/uniq.js"(exports2, module2) {
    var baseUniq = require_baseUniq();
    function uniq(array) {
      return array && array.length ? baseUniq(array) : [];
    }
    module2.exports = uniq;
  }
});

// node_modules/chevrotain/lib/src/parse/grammar/first.js
var require_first = __commonJS({
  "node_modules/chevrotain/lib/src/parse/grammar/first.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.firstForTerminal = exports2.firstForBranching = exports2.firstForSequence = exports2.first = void 0;
    var flatten_1 = __importDefault(require_flatten());
    var uniq_1 = __importDefault(require_uniq());
    var map_1 = __importDefault(require_map());
    var gast_1 = require_api2();
    var gast_2 = require_api2();
    function first2(prod) {
      if (prod instanceof gast_1.NonTerminal) {
        return first2(prod.referencedRule);
      } else if (prod instanceof gast_1.Terminal) {
        return firstForTerminal(prod);
      } else if ((0, gast_2.isSequenceProd)(prod)) {
        return firstForSequence(prod);
      } else if ((0, gast_2.isBranchingProd)(prod)) {
        return firstForBranching(prod);
      } else {
        throw Error("non exhaustive match");
      }
    }
    exports2.first = first2;
    function firstForSequence(prod) {
      var firstSet = [];
      var seq = prod.definition;
      var nextSubProdIdx = 0;
      var hasInnerProdsRemaining = seq.length > nextSubProdIdx;
      var currSubProd;
      var isLastInnerProdOptional = true;
      while (hasInnerProdsRemaining && isLastInnerProdOptional) {
        currSubProd = seq[nextSubProdIdx];
        isLastInnerProdOptional = (0, gast_2.isOptionalProd)(currSubProd);
        firstSet = firstSet.concat(first2(currSubProd));
        nextSubProdIdx = nextSubProdIdx + 1;
        hasInnerProdsRemaining = seq.length > nextSubProdIdx;
      }
      return (0, uniq_1.default)(firstSet);
    }
    exports2.firstForSequence = firstForSequence;
    function firstForBranching(prod) {
      var allAlternativesFirsts = (0, map_1.default)(prod.definition, function(innerProd) {
        return first2(innerProd);
      });
      return (0, uniq_1.default)((0, flatten_1.default)(allAlternativesFirsts));
    }
    exports2.firstForBranching = firstForBranching;
    function firstForTerminal(terminal) {
      return [terminal.terminalType];
    }
    exports2.firstForTerminal = firstForTerminal;
  }
});

// node_modules/chevrotain/lib/src/parse/constants.js
var require_constants = __commonJS({
  "node_modules/chevrotain/lib/src/parse/constants.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IN = void 0;
    exports2.IN = "_~IN~_";
  }
});

// node_modules/chevrotain/lib/src/parse/grammar/follow.js
var require_follow = __commonJS({
  "node_modules/chevrotain/lib/src/parse/grammar/follow.js"(exports2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || function() {
      var extendStatics = function(d, b5) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b6) {
          d2.__proto__ = b6;
        } || function(d2, b6) {
          for (var p in b6)
            if (Object.prototype.hasOwnProperty.call(b6, p))
              d2[p] = b6[p];
        };
        return extendStatics(d, b5);
      };
      return function(d, b5) {
        if (typeof b5 !== "function" && b5 !== null)
          throw new TypeError("Class extends value " + String(b5) + " is not a constructor or null");
        extendStatics(d, b5);
        function __() {
          this.constructor = d;
        }
        d.prototype = b5 === null ? Object.create(b5) : (__.prototype = b5.prototype, new __());
      };
    }();
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.buildInProdFollowPrefix = exports2.buildBetweenProdsFollowPrefix = exports2.computeAllProdsFollows = exports2.ResyncFollowsWalker = void 0;
    var rest_1 = require_rest();
    var first_1 = require_first();
    var forEach_1 = __importDefault(require_forEach());
    var assign_1 = __importDefault(require_assign());
    var constants_1 = require_constants();
    var gast_1 = require_api2();
    var ResyncFollowsWalker = (
      /** @class */
      function(_super) {
        __extends(ResyncFollowsWalker2, _super);
        function ResyncFollowsWalker2(topProd) {
          var _this = _super.call(this) || this;
          _this.topProd = topProd;
          _this.follows = {};
          return _this;
        }
        ResyncFollowsWalker2.prototype.startWalking = function() {
          this.walk(this.topProd);
          return this.follows;
        };
        ResyncFollowsWalker2.prototype.walkTerminal = function(terminal, currRest, prevRest) {
        };
        ResyncFollowsWalker2.prototype.walkProdRef = function(refProd, currRest, prevRest) {
          var followName = buildBetweenProdsFollowPrefix(refProd.referencedRule, refProd.idx) + this.topProd.name;
          var fullRest = currRest.concat(prevRest);
          var restProd = new gast_1.Alternative({ definition: fullRest });
          var t_in_topProd_follows = (0, first_1.first)(restProd);
          this.follows[followName] = t_in_topProd_follows;
        };
        return ResyncFollowsWalker2;
      }(rest_1.RestWalker)
    );
    exports2.ResyncFollowsWalker = ResyncFollowsWalker;
    function computeAllProdsFollows(topProductions) {
      var reSyncFollows = {};
      (0, forEach_1.default)(topProductions, function(topProd) {
        var currRefsFollow = new ResyncFollowsWalker(topProd).startWalking();
        (0, assign_1.default)(reSyncFollows, currRefsFollow);
      });
      return reSyncFollows;
    }
    exports2.computeAllProdsFollows = computeAllProdsFollows;
    function buildBetweenProdsFollowPrefix(inner, occurenceInParent) {
      return inner.name + occurenceInParent + constants_1.IN;
    }
    exports2.buildBetweenProdsFollowPrefix = buildBetweenProdsFollowPrefix;
    function buildInProdFollowPrefix(terminal) {
      var terminalName = terminal.terminalType.name;
      return terminalName + terminal.idx + constants_1.IN;
    }
    exports2.buildInProdFollowPrefix = buildInProdFollowPrefix;
  }
});

// node_modules/lodash/isUndefined.js
var require_isUndefined = __commonJS({
  "node_modules/lodash/isUndefined.js"(exports2, module2) {
    function isUndefined(value) {
      return value === void 0;
    }
    module2.exports = isUndefined;
  }
});

// node_modules/regexp-to-ast/lib/regexp-to-ast.js
var require_regexp_to_ast = __commonJS({
  "node_modules/regexp-to-ast/lib/regexp-to-ast.js"(exports2, module2) {
    (function(root, factory2) {
      if (typeof define === "function" && define.amd) {
        define([], factory2);
      } else if (typeof module2 === "object" && module2.exports) {
        module2.exports = factory2();
      } else {
        root.regexpToAst = factory2();
      }
    })(
      typeof self !== "undefined" ? (
        // istanbul ignore next
        self
      ) : exports2,
      function() {
        function RegExpParser() {
        }
        RegExpParser.prototype.saveState = function() {
          return {
            idx: this.idx,
            input: this.input,
            groupIdx: this.groupIdx
          };
        };
        RegExpParser.prototype.restoreState = function(newState) {
          this.idx = newState.idx;
          this.input = newState.input;
          this.groupIdx = newState.groupIdx;
        };
        RegExpParser.prototype.pattern = function(input) {
          this.idx = 0;
          this.input = input;
          this.groupIdx = 0;
          this.consumeChar("/");
          var value = this.disjunction();
          this.consumeChar("/");
          var flags = {
            type: "Flags",
            loc: { begin: this.idx, end: input.length },
            global: false,
            ignoreCase: false,
            multiLine: false,
            unicode: false,
            sticky: false
          };
          while (this.isRegExpFlag()) {
            switch (this.popChar()) {
              case "g":
                addFlag(flags, "global");
                break;
              case "i":
                addFlag(flags, "ignoreCase");
                break;
              case "m":
                addFlag(flags, "multiLine");
                break;
              case "u":
                addFlag(flags, "unicode");
                break;
              case "y":
                addFlag(flags, "sticky");
                break;
            }
          }
          if (this.idx !== this.input.length) {
            throw Error(
              "Redundant input: " + this.input.substring(this.idx)
            );
          }
          return {
            type: "Pattern",
            flags,
            value,
            loc: this.loc(0)
          };
        };
        RegExpParser.prototype.disjunction = function() {
          var alts = [];
          var begin = this.idx;
          alts.push(this.alternative());
          while (this.peekChar() === "|") {
            this.consumeChar("|");
            alts.push(this.alternative());
          }
          return { type: "Disjunction", value: alts, loc: this.loc(begin) };
        };
        RegExpParser.prototype.alternative = function() {
          var terms = [];
          var begin = this.idx;
          while (this.isTerm()) {
            terms.push(this.term());
          }
          return { type: "Alternative", value: terms, loc: this.loc(begin) };
        };
        RegExpParser.prototype.term = function() {
          if (this.isAssertion()) {
            return this.assertion();
          } else {
            return this.atom();
          }
        };
        RegExpParser.prototype.assertion = function() {
          var begin = this.idx;
          switch (this.popChar()) {
            case "^":
              return {
                type: "StartAnchor",
                loc: this.loc(begin)
              };
            case "$":
              return { type: "EndAnchor", loc: this.loc(begin) };
            case "\\":
              switch (this.popChar()) {
                case "b":
                  return {
                    type: "WordBoundary",
                    loc: this.loc(begin)
                  };
                case "B":
                  return {
                    type: "NonWordBoundary",
                    loc: this.loc(begin)
                  };
              }
              throw Error("Invalid Assertion Escape");
            case "(":
              this.consumeChar("?");
              var type;
              switch (this.popChar()) {
                case "=":
                  type = "Lookahead";
                  break;
                case "!":
                  type = "NegativeLookahead";
                  break;
              }
              ASSERT_EXISTS(type);
              var disjunction = this.disjunction();
              this.consumeChar(")");
              return {
                type,
                value: disjunction,
                loc: this.loc(begin)
              };
          }
          ASSERT_NEVER_REACH_HERE();
        };
        RegExpParser.prototype.quantifier = function(isBacktracking) {
          var range2;
          var begin = this.idx;
          switch (this.popChar()) {
            case "*":
              range2 = {
                atLeast: 0,
                atMost: Infinity
              };
              break;
            case "+":
              range2 = {
                atLeast: 1,
                atMost: Infinity
              };
              break;
            case "?":
              range2 = {
                atLeast: 0,
                atMost: 1
              };
              break;
            case "{":
              var atLeast = this.integerIncludingZero();
              switch (this.popChar()) {
                case "}":
                  range2 = {
                    atLeast,
                    atMost: atLeast
                  };
                  break;
                case ",":
                  var atMost;
                  if (this.isDigit()) {
                    atMost = this.integerIncludingZero();
                    range2 = {
                      atLeast,
                      atMost
                    };
                  } else {
                    range2 = {
                      atLeast,
                      atMost: Infinity
                    };
                  }
                  this.consumeChar("}");
                  break;
              }
              if (isBacktracking === true && range2 === void 0) {
                return void 0;
              }
              ASSERT_EXISTS(range2);
              break;
          }
          if (isBacktracking === true && range2 === void 0) {
            return void 0;
          }
          ASSERT_EXISTS(range2);
          if (this.peekChar(0) === "?") {
            this.consumeChar("?");
            range2.greedy = false;
          } else {
            range2.greedy = true;
          }
          range2.type = "Quantifier";
          range2.loc = this.loc(begin);
          return range2;
        };
        RegExpParser.prototype.atom = function() {
          var atom;
          var begin = this.idx;
          switch (this.peekChar()) {
            case ".":
              atom = this.dotAll();
              break;
            case "\\":
              atom = this.atomEscape();
              break;
            case "[":
              atom = this.characterClass();
              break;
            case "(":
              atom = this.group();
              break;
          }
          if (atom === void 0 && this.isPatternCharacter()) {
            atom = this.patternCharacter();
          }
          ASSERT_EXISTS(atom);
          atom.loc = this.loc(begin);
          if (this.isQuantifier()) {
            atom.quantifier = this.quantifier();
          }
          return atom;
        };
        RegExpParser.prototype.dotAll = function() {
          this.consumeChar(".");
          return {
            type: "Set",
            complement: true,
            value: [cc("\n"), cc("\r"), cc("\u2028"), cc("\u2029")]
          };
        };
        RegExpParser.prototype.atomEscape = function() {
          this.consumeChar("\\");
          switch (this.peekChar()) {
            case "1":
            case "2":
            case "3":
            case "4":
            case "5":
            case "6":
            case "7":
            case "8":
            case "9":
              return this.decimalEscapeAtom();
            case "d":
            case "D":
            case "s":
            case "S":
            case "w":
            case "W":
              return this.characterClassEscape();
            case "f":
            case "n":
            case "r":
            case "t":
            case "v":
              return this.controlEscapeAtom();
            case "c":
              return this.controlLetterEscapeAtom();
            case "0":
              return this.nulCharacterAtom();
            case "x":
              return this.hexEscapeSequenceAtom();
            case "u":
              return this.regExpUnicodeEscapeSequenceAtom();
            default:
              return this.identityEscapeAtom();
          }
        };
        RegExpParser.prototype.decimalEscapeAtom = function() {
          var value = this.positiveInteger();
          return { type: "GroupBackReference", value };
        };
        RegExpParser.prototype.characterClassEscape = function() {
          var set;
          var complement = false;
          switch (this.popChar()) {
            case "d":
              set = digitsCharCodes;
              break;
            case "D":
              set = digitsCharCodes;
              complement = true;
              break;
            case "s":
              set = whitespaceCodes;
              break;
            case "S":
              set = whitespaceCodes;
              complement = true;
              break;
            case "w":
              set = wordCharCodes;
              break;
            case "W":
              set = wordCharCodes;
              complement = true;
              break;
          }
          ASSERT_EXISTS(set);
          return { type: "Set", value: set, complement };
        };
        RegExpParser.prototype.controlEscapeAtom = function() {
          var escapeCode;
          switch (this.popChar()) {
            case "f":
              escapeCode = cc("\f");
              break;
            case "n":
              escapeCode = cc("\n");
              break;
            case "r":
              escapeCode = cc("\r");
              break;
            case "t":
              escapeCode = cc("	");
              break;
            case "v":
              escapeCode = cc("\v");
              break;
          }
          ASSERT_EXISTS(escapeCode);
          return { type: "Character", value: escapeCode };
        };
        RegExpParser.prototype.controlLetterEscapeAtom = function() {
          this.consumeChar("c");
          var letter = this.popChar();
          if (/[a-zA-Z]/.test(letter) === false) {
            throw Error("Invalid ");
          }
          var letterCode = letter.toUpperCase().charCodeAt(0) - 64;
          return { type: "Character", value: letterCode };
        };
        RegExpParser.prototype.nulCharacterAtom = function() {
          this.consumeChar("0");
          return { type: "Character", value: cc("\0") };
        };
        RegExpParser.prototype.hexEscapeSequenceAtom = function() {
          this.consumeChar("x");
          return this.parseHexDigits(2);
        };
        RegExpParser.prototype.regExpUnicodeEscapeSequenceAtom = function() {
          this.consumeChar("u");
          return this.parseHexDigits(4);
        };
        RegExpParser.prototype.identityEscapeAtom = function() {
          var escapedChar = this.popChar();
          return { type: "Character", value: cc(escapedChar) };
        };
        RegExpParser.prototype.classPatternCharacterAtom = function() {
          switch (this.peekChar()) {
            case "\n":
            case "\r":
            case "\u2028":
            case "\u2029":
            case "\\":
            case "]":
              throw Error("TBD");
            default:
              var nextChar = this.popChar();
              return { type: "Character", value: cc(nextChar) };
          }
        };
        RegExpParser.prototype.characterClass = function() {
          var set = [];
          var complement = false;
          this.consumeChar("[");
          if (this.peekChar(0) === "^") {
            this.consumeChar("^");
            complement = true;
          }
          while (this.isClassAtom()) {
            var from = this.classAtom();
            var isFromSingleChar = from.type === "Character";
            if (isFromSingleChar && this.isRangeDash()) {
              this.consumeChar("-");
              var to = this.classAtom();
              var isToSingleChar = to.type === "Character";
              if (isToSingleChar) {
                if (to.value < from.value) {
                  throw Error("Range out of order in character class");
                }
                set.push({ from: from.value, to: to.value });
              } else {
                insertToSet(from.value, set);
                set.push(cc("-"));
                insertToSet(to.value, set);
              }
            } else {
              insertToSet(from.value, set);
            }
          }
          this.consumeChar("]");
          return { type: "Set", complement, value: set };
        };
        RegExpParser.prototype.classAtom = function() {
          switch (this.peekChar()) {
            case "]":
            case "\n":
            case "\r":
            case "\u2028":
            case "\u2029":
              throw Error("TBD");
            case "\\":
              return this.classEscape();
            default:
              return this.classPatternCharacterAtom();
          }
        };
        RegExpParser.prototype.classEscape = function() {
          this.consumeChar("\\");
          switch (this.peekChar()) {
            case "b":
              this.consumeChar("b");
              return { type: "Character", value: cc("\b") };
            case "d":
            case "D":
            case "s":
            case "S":
            case "w":
            case "W":
              return this.characterClassEscape();
            case "f":
            case "n":
            case "r":
            case "t":
            case "v":
              return this.controlEscapeAtom();
            case "c":
              return this.controlLetterEscapeAtom();
            case "0":
              return this.nulCharacterAtom();
            case "x":
              return this.hexEscapeSequenceAtom();
            case "u":
              return this.regExpUnicodeEscapeSequenceAtom();
            default:
              return this.identityEscapeAtom();
          }
        };
        RegExpParser.prototype.group = function() {
          var capturing = true;
          this.consumeChar("(");
          switch (this.peekChar(0)) {
            case "?":
              this.consumeChar("?");
              this.consumeChar(":");
              capturing = false;
              break;
            default:
              this.groupIdx++;
              break;
          }
          var value = this.disjunction();
          this.consumeChar(")");
          var groupAst = {
            type: "Group",
            capturing,
            value
          };
          if (capturing) {
            groupAst.idx = this.groupIdx;
          }
          return groupAst;
        };
        RegExpParser.prototype.positiveInteger = function() {
          var number = this.popChar();
          if (decimalPatternNoZero.test(number) === false) {
            throw Error("Expecting a positive integer");
          }
          while (decimalPattern.test(this.peekChar(0))) {
            number += this.popChar();
          }
          return parseInt(number, 10);
        };
        RegExpParser.prototype.integerIncludingZero = function() {
          var number = this.popChar();
          if (decimalPattern.test(number) === false) {
            throw Error("Expecting an integer");
          }
          while (decimalPattern.test(this.peekChar(0))) {
            number += this.popChar();
          }
          return parseInt(number, 10);
        };
        RegExpParser.prototype.patternCharacter = function() {
          var nextChar = this.popChar();
          switch (nextChar) {
            case "\n":
            case "\r":
            case "\u2028":
            case "\u2029":
            case "^":
            case "$":
            case "\\":
            case ".":
            case "*":
            case "+":
            case "?":
            case "(":
            case ")":
            case "[":
            case "|":
              throw Error("TBD");
            default:
              return { type: "Character", value: cc(nextChar) };
          }
        };
        RegExpParser.prototype.isRegExpFlag = function() {
          switch (this.peekChar(0)) {
            case "g":
            case "i":
            case "m":
            case "u":
            case "y":
              return true;
            default:
              return false;
          }
        };
        RegExpParser.prototype.isRangeDash = function() {
          return this.peekChar() === "-" && this.isClassAtom(1);
        };
        RegExpParser.prototype.isDigit = function() {
          return decimalPattern.test(this.peekChar(0));
        };
        RegExpParser.prototype.isClassAtom = function(howMuch) {
          if (howMuch === void 0) {
            howMuch = 0;
          }
          switch (this.peekChar(howMuch)) {
            case "]":
            case "\n":
            case "\r":
            case "\u2028":
            case "\u2029":
              return false;
            default:
              return true;
          }
        };
        RegExpParser.prototype.isTerm = function() {
          return this.isAtom() || this.isAssertion();
        };
        RegExpParser.prototype.isAtom = function() {
          if (this.isPatternCharacter()) {
            return true;
          }
          switch (this.peekChar(0)) {
            case ".":
            case "\\":
            case "[":
            case "(":
              return true;
            default:
              return false;
          }
        };
        RegExpParser.prototype.isAssertion = function() {
          switch (this.peekChar(0)) {
            case "^":
            case "$":
              return true;
            case "\\":
              switch (this.peekChar(1)) {
                case "b":
                case "B":
                  return true;
                default:
                  return false;
              }
            case "(":
              return this.peekChar(1) === "?" && (this.peekChar(2) === "=" || this.peekChar(2) === "!");
            default:
              return false;
          }
        };
        RegExpParser.prototype.isQuantifier = function() {
          var prevState = this.saveState();
          try {
            return this.quantifier(true) !== void 0;
          } catch (e) {
            return false;
          } finally {
            this.restoreState(prevState);
          }
        };
        RegExpParser.prototype.isPatternCharacter = function() {
          switch (this.peekChar()) {
            case "^":
            case "$":
            case "\\":
            case ".":
            case "*":
            case "+":
            case "?":
            case "(":
            case ")":
            case "[":
            case "|":
            case "/":
            case "\n":
            case "\r":
            case "\u2028":
            case "\u2029":
              return false;
            default:
              return true;
          }
        };
        RegExpParser.prototype.parseHexDigits = function(howMany) {
          var hexString = "";
          for (var i4 = 0; i4 < howMany; i4++) {
            var hexChar = this.popChar();
            if (hexDigitPattern.test(hexChar) === false) {
              throw Error("Expecting a HexDecimal digits");
            }
            hexString += hexChar;
          }
          var charCode = parseInt(hexString, 16);
          return { type: "Character", value: charCode };
        };
        RegExpParser.prototype.peekChar = function(howMuch) {
          if (howMuch === void 0) {
            howMuch = 0;
          }
          return this.input[this.idx + howMuch];
        };
        RegExpParser.prototype.popChar = function() {
          var nextChar = this.peekChar(0);
          this.consumeChar();
          return nextChar;
        };
        RegExpParser.prototype.consumeChar = function(char) {
          if (char !== void 0 && this.input[this.idx] !== char) {
            throw Error(
              "Expected: '" + char + "' but found: '" + this.input[this.idx] + "' at offset: " + this.idx
            );
          }
          if (this.idx >= this.input.length) {
            throw Error("Unexpected end of input");
          }
          this.idx++;
        };
        RegExpParser.prototype.loc = function(begin) {
          return { begin, end: this.idx };
        };
        var hexDigitPattern = /[0-9a-fA-F]/;
        var decimalPattern = /[0-9]/;
        var decimalPatternNoZero = /[1-9]/;
        function cc(char) {
          return char.charCodeAt(0);
        }
        function insertToSet(item, set) {
          if (item.length !== void 0) {
            item.forEach(function(subItem) {
              set.push(subItem);
            });
          } else {
            set.push(item);
          }
        }
        function addFlag(flagObj, flagKey) {
          if (flagObj[flagKey] === true) {
            throw "duplicate flag " + flagKey;
          }
          flagObj[flagKey] = true;
        }
        function ASSERT_EXISTS(obj) {
          if (obj === void 0) {
            throw Error("Internal Error - Should never get here!");
          }
        }
        function ASSERT_NEVER_REACH_HERE() {
          throw Error("Internal Error - Should never get here!");
        }
        var i3;
        var digitsCharCodes = [];
        for (i3 = cc("0"); i3 <= cc("9"); i3++) {
          digitsCharCodes.push(i3);
        }
        var wordCharCodes = [cc("_")].concat(digitsCharCodes);
        for (i3 = cc("a"); i3 <= cc("z"); i3++) {
          wordCharCodes.push(i3);
        }
        for (i3 = cc("A"); i3 <= cc("Z"); i3++) {
          wordCharCodes.push(i3);
        }
        var whitespaceCodes = [
          cc(" "),
          cc("\f"),
          cc("\n"),
          cc("\r"),
          cc("	"),
          cc("\v"),
          cc("	"),
          cc(" "),
          cc(" "),
          cc(" "),
          cc(" "),
          cc(" "),
          cc(" "),
          cc(" "),
          cc(" "),
          cc(" "),
          cc(" "),
          cc(" "),
          cc(" "),
          cc(" "),
          cc("\u2028"),
          cc("\u2029"),
          cc(" "),
          cc(" "),
          cc("　"),
          cc("\uFEFF")
        ];
        function BaseRegExpVisitor() {
        }
        BaseRegExpVisitor.prototype.visitChildren = function(node) {
          for (var key in node) {
            var child = node[key];
            if (node.hasOwnProperty(key)) {
              if (child.type !== void 0) {
                this.visit(child);
              } else if (Array.isArray(child)) {
                child.forEach(function(subChild) {
                  this.visit(subChild);
                }, this);
              }
            }
          }
        };
        BaseRegExpVisitor.prototype.visit = function(node) {
          switch (node.type) {
            case "Pattern":
              this.visitPattern(node);
              break;
            case "Flags":
              this.visitFlags(node);
              break;
            case "Disjunction":
              this.visitDisjunction(node);
              break;
            case "Alternative":
              this.visitAlternative(node);
              break;
            case "StartAnchor":
              this.visitStartAnchor(node);
              break;
            case "EndAnchor":
              this.visitEndAnchor(node);
              break;
            case "WordBoundary":
              this.visitWordBoundary(node);
              break;
            case "NonWordBoundary":
              this.visitNonWordBoundary(node);
              break;
            case "Lookahead":
              this.visitLookahead(node);
              break;
            case "NegativeLookahead":
              this.visitNegativeLookahead(node);
              break;
            case "Character":
              this.visitCharacter(node);
              break;
            case "Set":
              this.visitSet(node);
              break;
            case "Group":
              this.visitGroup(node);
              break;
            case "GroupBackReference":
              this.visitGroupBackReference(node);
              break;
            case "Quantifier":
              this.visitQuantifier(node);
              break;
          }
          this.visitChildren(node);
        };
        BaseRegExpVisitor.prototype.visitPattern = function(node) {
        };
        BaseRegExpVisitor.prototype.visitFlags = function(node) {
        };
        BaseRegExpVisitor.prototype.visitDisjunction = function(node) {
        };
        BaseRegExpVisitor.prototype.visitAlternative = function(node) {
        };
        BaseRegExpVisitor.prototype.visitStartAnchor = function(node) {
        };
        BaseRegExpVisitor.prototype.visitEndAnchor = function(node) {
        };
        BaseRegExpVisitor.prototype.visitWordBoundary = function(node) {
        };
        BaseRegExpVisitor.prototype.visitNonWordBoundary = function(node) {
        };
        BaseRegExpVisitor.prototype.visitLookahead = function(node) {
        };
        BaseRegExpVisitor.prototype.visitNegativeLookahead = function(node) {
        };
        BaseRegExpVisitor.prototype.visitCharacter = function(node) {
        };
        BaseRegExpVisitor.prototype.visitSet = function(node) {
        };
        BaseRegExpVisitor.prototype.visitGroup = function(node) {
        };
        BaseRegExpVisitor.prototype.visitGroupBackReference = function(node) {
        };
        BaseRegExpVisitor.prototype.visitQuantifier = function(node) {
        };
        return {
          RegExpParser,
          BaseRegExpVisitor,
          VERSION: "0.5.0"
        };
      }
    );
  }
});

// node_modules/lodash/head.js
var require_head = __commonJS({
  "node_modules/lodash/head.js"(exports2, module2) {
    function head2(array) {
      return array && array.length ? array[0] : void 0;
    }
    module2.exports = head2;
  }
});

// node_modules/lodash/first.js
var require_first2 = __commonJS({
  "node_modules/lodash/first.js"(exports2, module2) {
    module2.exports = require_head();
  }
});

// node_modules/lodash/compact.js
var require_compact = __commonJS({
  "node_modules/lodash/compact.js"(exports2, module2) {
    function compact(array) {
      var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
      while (++index < length) {
        var value = array[index];
        if (value) {
          result[resIndex++] = value;
        }
      }
      return result;
    }
    module2.exports = compact;
  }
});

// node_modules/lodash/_baseFilter.js
var require_baseFilter = __commonJS({
  "node_modules/lodash/_baseFilter.js"(exports2, module2) {
    var baseEach = require_baseEach();
    function baseFilter(collection, predicate) {
      var result = [];
      baseEach(collection, function(value, index, collection2) {
        if (predicate(value, index, collection2)) {
          result.push(value);
        }
      });
      return result;
    }
    module2.exports = baseFilter;
  }
});

// node_modules/lodash/negate.js
var require_negate = __commonJS({
  "node_modules/lodash/negate.js"(exports2, module2) {
    var FUNC_ERROR_TEXT = "Expected a function";
    function negate(predicate) {
      if (typeof predicate != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      return function() {
        var args = arguments;
        switch (args.length) {
          case 0:
            return !predicate.call(this);
          case 1:
            return !predicate.call(this, args[0]);
          case 2:
            return !predicate.call(this, args[0], args[1]);
          case 3:
            return !predicate.call(this, args[0], args[1], args[2]);
        }
        return !predicate.apply(this, args);
      };
    }
    module2.exports = negate;
  }
});

// node_modules/lodash/reject.js
var require_reject = __commonJS({
  "node_modules/lodash/reject.js"(exports2, module2) {
    var arrayFilter = require_arrayFilter();
    var baseFilter = require_baseFilter();
    var baseIteratee = require_baseIteratee();
    var isArray = require_isArray();
    var negate = require_negate();
    function reject(collection, predicate) {
      var func = isArray(collection) ? arrayFilter : baseFilter;
      return func(collection, negate(baseIteratee(predicate, 3)));
    }
    module2.exports = reject;
  }
});

// node_modules/lodash/_baseDifference.js
var require_baseDifference = __commonJS({
  "node_modules/lodash/_baseDifference.js"(exports2, module2) {
    var SetCache = require_SetCache();
    var arrayIncludes = require_arrayIncludes();
    var arrayIncludesWith = require_arrayIncludesWith();
    var arrayMap = require_arrayMap();
    var baseUnary = require_baseUnary();
    var cacheHas = require_cacheHas();
    var LARGE_ARRAY_SIZE = 200;
    function baseDifference(array, values, iteratee, comparator) {
      var index = -1, includes = arrayIncludes, isCommon = true, length = array.length, result = [], valuesLength = values.length;
      if (!length) {
        return result;
      }
      if (iteratee) {
        values = arrayMap(values, baseUnary(iteratee));
      }
      if (comparator) {
        includes = arrayIncludesWith;
        isCommon = false;
      } else if (values.length >= LARGE_ARRAY_SIZE) {
        includes = cacheHas;
        isCommon = false;
        values = new SetCache(values);
      }
      outer:
        while (++index < length) {
          var value = array[index], computed = iteratee == null ? value : iteratee(value);
          value = comparator || value !== 0 ? value : 0;
          if (isCommon && computed === computed) {
            var valuesIndex = valuesLength;
            while (valuesIndex--) {
              if (values[valuesIndex] === computed) {
                continue outer;
              }
            }
            result.push(value);
          } else if (!includes(values, computed, comparator)) {
            result.push(value);
          }
        }
      return result;
    }
    module2.exports = baseDifference;
  }
});

// node_modules/lodash/isArrayLikeObject.js
var require_isArrayLikeObject = __commonJS({
  "node_modules/lodash/isArrayLikeObject.js"(exports2, module2) {
    var isArrayLike = require_isArrayLike();
    var isObjectLike = require_isObjectLike();
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    module2.exports = isArrayLikeObject;
  }
});

// node_modules/lodash/difference.js
var require_difference = __commonJS({
  "node_modules/lodash/difference.js"(exports2, module2) {
    var baseDifference = require_baseDifference();
    var baseFlatten = require_baseFlatten();
    var baseRest = require_baseRest();
    var isArrayLikeObject = require_isArrayLikeObject();
    var difference = baseRest(function(array, values) {
      return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true)) : [];
    });
    module2.exports = difference;
  }
});

// node_modules/lodash/indexOf.js
var require_indexOf = __commonJS({
  "node_modules/lodash/indexOf.js"(exports2, module2) {
    var baseIndexOf = require_baseIndexOf();
    var toInteger = require_toInteger();
    var nativeMax = Math.max;
    function indexOf(array, value, fromIndex) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return -1;
      }
      var index = fromIndex == null ? 0 : toInteger(fromIndex);
      if (index < 0) {
        index = nativeMax(length + index, 0);
      }
      return baseIndexOf(array, value, index);
    }
    module2.exports = indexOf;
  }
});

// node_modules/lodash/_createFind.js
var require_createFind = __commonJS({
  "node_modules/lodash/_createFind.js"(exports2, module2) {
    var baseIteratee = require_baseIteratee();
    var isArrayLike = require_isArrayLike();
    var keys = require_keys();
    function createFind(findIndexFunc) {
      return function(collection, predicate, fromIndex) {
        var iterable = Object(collection);
        if (!isArrayLike(collection)) {
          var iteratee = baseIteratee(predicate, 3);
          collection = keys(collection);
          predicate = function(key) {
            return iteratee(iterable[key], key, iterable);
          };
        }
        var index = findIndexFunc(collection, predicate, fromIndex);
        return index > -1 ? iterable[iteratee ? collection[index] : index] : void 0;
      };
    }
    module2.exports = createFind;
  }
});

// node_modules/lodash/findIndex.js
var require_findIndex = __commonJS({
  "node_modules/lodash/findIndex.js"(exports2, module2) {
    var baseFindIndex = require_baseFindIndex();
    var baseIteratee = require_baseIteratee();
    var toInteger = require_toInteger();
    var nativeMax = Math.max;
    function findIndex(array, predicate, fromIndex) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return -1;
      }
      var index = fromIndex == null ? 0 : toInteger(fromIndex);
      if (index < 0) {
        index = nativeMax(length + index, 0);
      }
      return baseFindIndex(array, baseIteratee(predicate, 3), index);
    }
    module2.exports = findIndex;
  }
});

// node_modules/lodash/find.js
var require_find = __commonJS({
  "node_modules/lodash/find.js"(exports2, module2) {
    var createFind = require_createFind();
    var findIndex = require_findIndex();
    var find = createFind(findIndex);
    module2.exports = find;
  }
});

// node_modules/lodash/filter.js
var require_filter = __commonJS({
  "node_modules/lodash/filter.js"(exports2, module2) {
    var arrayFilter = require_arrayFilter();
    var baseFilter = require_baseFilter();
    var baseIteratee = require_baseIteratee();
    var isArray = require_isArray();
    function filter(collection, predicate) {
      var func = isArray(collection) ? arrayFilter : baseFilter;
      return func(collection, baseIteratee(predicate, 3));
    }
    module2.exports = filter;
  }
});

// node_modules/lodash/defaults.js
var require_defaults = __commonJS({
  "node_modules/lodash/defaults.js"(exports2, module2) {
    var baseRest = require_baseRest();
    var eq = require_eq();
    var isIterateeCall = require_isIterateeCall();
    var keysIn = require_keysIn();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var defaults2 = baseRest(function(object, sources) {
      object = Object(object);
      var index = -1;
      var length = sources.length;
      var guard = length > 2 ? sources[2] : void 0;
      if (guard && isIterateeCall(sources[0], sources[1], guard)) {
        length = 1;
      }
      while (++index < length) {
        var source = sources[index];
        var props = keysIn(source);
        var propsIndex = -1;
        var propsLength = props.length;
        while (++propsIndex < propsLength) {
          var key = props[propsIndex];
          var value = object[key];
          if (value === void 0 || eq(value, objectProto[key]) && !hasOwnProperty.call(object, key)) {
            object[key] = source[key];
          }
        }
      }
      return object;
    });
    module2.exports = defaults2;
  }
});

// node_modules/lodash/_arrayReduce.js
var require_arrayReduce = __commonJS({
  "node_modules/lodash/_arrayReduce.js"(exports2, module2) {
    function arrayReduce(array, iteratee, accumulator, initAccum) {
      var index = -1, length = array == null ? 0 : array.length;
      if (initAccum && length) {
        accumulator = array[++index];
      }
      while (++index < length) {
        accumulator = iteratee(accumulator, array[index], index, array);
      }
      return accumulator;
    }
    module2.exports = arrayReduce;
  }
});

// node_modules/lodash/_baseReduce.js
var require_baseReduce = __commonJS({
  "node_modules/lodash/_baseReduce.js"(exports2, module2) {
    function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
      eachFunc(collection, function(value, index, collection2) {
        accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection2);
      });
      return accumulator;
    }
    module2.exports = baseReduce;
  }
});

// node_modules/lodash/reduce.js
var require_reduce = __commonJS({
  "node_modules/lodash/reduce.js"(exports2, module2) {
    var arrayReduce = require_arrayReduce();
    var baseEach = require_baseEach();
    var baseIteratee = require_baseIteratee();
    var baseReduce = require_baseReduce();
    var isArray = require_isArray();
    function reduce(collection, iteratee, accumulator) {
      var func = isArray(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
      return func(collection, baseIteratee(iteratee, 4), accumulator, initAccum, baseEach);
    }
    module2.exports = reduce;
  }
});

// node_modules/chevrotain/lib/src/scan/reg_exp_parser.js
var require_reg_exp_parser = __commonJS({
  "node_modules/chevrotain/lib/src/scan/reg_exp_parser.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.clearRegExpParserCache = exports2.getRegExpAst = void 0;
    var regexp_to_ast_1 = require_regexp_to_ast();
    var regExpAstCache = {};
    var regExpParser = new regexp_to_ast_1.RegExpParser();
    function getRegExpAst(regExp) {
      var regExpStr = regExp.toString();
      if (regExpAstCache.hasOwnProperty(regExpStr)) {
        return regExpAstCache[regExpStr];
      } else {
        var regExpAst = regExpParser.pattern(regExpStr);
        regExpAstCache[regExpStr] = regExpAst;
        return regExpAst;
      }
    }
    exports2.getRegExpAst = getRegExpAst;
    function clearRegExpParserCache() {
      regExpAstCache = {};
    }
    exports2.clearRegExpParserCache = clearRegExpParserCache;
  }
});

// node_modules/chevrotain/lib/src/scan/reg_exp.js
var require_reg_exp = __commonJS({
  "node_modules/chevrotain/lib/src/scan/reg_exp.js"(exports2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || function() {
      var extendStatics = function(d, b5) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b6) {
          d2.__proto__ = b6;
        } || function(d2, b6) {
          for (var p in b6)
            if (Object.prototype.hasOwnProperty.call(b6, p))
              d2[p] = b6[p];
        };
        return extendStatics(d, b5);
      };
      return function(d, b5) {
        if (typeof b5 !== "function" && b5 !== null)
          throw new TypeError("Class extends value " + String(b5) + " is not a constructor or null");
        extendStatics(d, b5);
        function __() {
          this.constructor = d;
        }
        d.prototype = b5 === null ? Object.create(b5) : (__.prototype = b5.prototype, new __());
      };
    }();
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.canMatchCharCode = exports2.firstCharOptimizedIndices = exports2.getOptimizedStartCodesIndices = exports2.failedOptimizationPrefixMsg = void 0;
    var regexp_to_ast_1 = require_regexp_to_ast();
    var isArray_1 = __importDefault(require_isArray());
    var every_1 = __importDefault(require_every());
    var forEach_1 = __importDefault(require_forEach());
    var find_1 = __importDefault(require_find());
    var values_1 = __importDefault(require_values());
    var includes_1 = __importDefault(require_includes());
    var utils_1 = require_api();
    var reg_exp_parser_1 = require_reg_exp_parser();
    var lexer_1 = require_lexer();
    var complementErrorMessage = "Complement Sets are not supported for first char optimization";
    exports2.failedOptimizationPrefixMsg = 'Unable to use "first char" lexer optimizations:\n';
    function getOptimizedStartCodesIndices(regExp, ensureOptimizations) {
      if (ensureOptimizations === void 0) {
        ensureOptimizations = false;
      }
      try {
        var ast = (0, reg_exp_parser_1.getRegExpAst)(regExp);
        var firstChars = firstCharOptimizedIndices(ast.value, {}, ast.flags.ignoreCase);
        return firstChars;
      } catch (e) {
        if (e.message === complementErrorMessage) {
          if (ensureOptimizations) {
            (0, utils_1.PRINT_WARNING)("".concat(exports2.failedOptimizationPrefixMsg) + "	Unable to optimize: < ".concat(regExp.toString(), " >\n") + "	Complement Sets cannot be automatically optimized.\n	This will disable the lexer's first char optimizations.\n	See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#COMPLEMENT for details.");
          }
        } else {
          var msgSuffix = "";
          if (ensureOptimizations) {
            msgSuffix = "\n	This will disable the lexer's first char optimizations.\n	See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#REGEXP_PARSING for details.";
          }
          (0, utils_1.PRINT_ERROR)("".concat(exports2.failedOptimizationPrefixMsg, "\n") + "	Failed parsing: < ".concat(regExp.toString(), " >\n") + "	Using the regexp-to-ast library version: ".concat(regexp_to_ast_1.VERSION, "\n") + "	Please open an issue at: https://github.com/bd82/regexp-to-ast/issues" + msgSuffix);
        }
      }
      return [];
    }
    exports2.getOptimizedStartCodesIndices = getOptimizedStartCodesIndices;
    function firstCharOptimizedIndices(ast, result, ignoreCase) {
      switch (ast.type) {
        case "Disjunction":
          for (var i3 = 0; i3 < ast.value.length; i3++) {
            firstCharOptimizedIndices(ast.value[i3], result, ignoreCase);
          }
          break;
        case "Alternative":
          var terms = ast.value;
          for (var i3 = 0; i3 < terms.length; i3++) {
            var term = terms[i3];
            switch (term.type) {
              case "EndAnchor":
              case "GroupBackReference":
              case "Lookahead":
              case "NegativeLookahead":
              case "StartAnchor":
              case "WordBoundary":
              case "NonWordBoundary":
                continue;
            }
            var atom = term;
            switch (atom.type) {
              case "Character":
                addOptimizedIdxToResult(atom.value, result, ignoreCase);
                break;
              case "Set":
                if (atom.complement === true) {
                  throw Error(complementErrorMessage);
                }
                (0, forEach_1.default)(atom.value, function(code) {
                  if (typeof code === "number") {
                    addOptimizedIdxToResult(code, result, ignoreCase);
                  } else {
                    var range2 = code;
                    if (ignoreCase === true) {
                      for (var rangeCode = range2.from; rangeCode <= range2.to; rangeCode++) {
                        addOptimizedIdxToResult(rangeCode, result, ignoreCase);
                      }
                    } else {
                      for (var rangeCode = range2.from; rangeCode <= range2.to && rangeCode < lexer_1.minOptimizationVal; rangeCode++) {
                        addOptimizedIdxToResult(rangeCode, result, ignoreCase);
                      }
                      if (range2.to >= lexer_1.minOptimizationVal) {
                        var minUnOptVal = range2.from >= lexer_1.minOptimizationVal ? range2.from : lexer_1.minOptimizationVal;
                        var maxUnOptVal = range2.to;
                        var minOptIdx = (0, lexer_1.charCodeToOptimizedIndex)(minUnOptVal);
                        var maxOptIdx = (0, lexer_1.charCodeToOptimizedIndex)(maxUnOptVal);
                        for (var currOptIdx = minOptIdx; currOptIdx <= maxOptIdx; currOptIdx++) {
                          result[currOptIdx] = currOptIdx;
                        }
                      }
                    }
                  }
                });
                break;
              case "Group":
                firstCharOptimizedIndices(atom.value, result, ignoreCase);
                break;
              default:
                throw Error("Non Exhaustive Match");
            }
            var isOptionalQuantifier = atom.quantifier !== void 0 && atom.quantifier.atLeast === 0;
            if (
              // A group may be optional due to empty contents /(?:)/
              // or if everything inside it is optional /((a)?)/
              atom.type === "Group" && isWholeOptional(atom) === false || // If this term is not a group it may only be optional if it has an optional quantifier
              atom.type !== "Group" && isOptionalQuantifier === false
            ) {
              break;
            }
          }
          break;
        default:
          throw Error("non exhaustive match!");
      }
      return (0, values_1.default)(result);
    }
    exports2.firstCharOptimizedIndices = firstCharOptimizedIndices;
    function addOptimizedIdxToResult(code, result, ignoreCase) {
      var optimizedCharIdx = (0, lexer_1.charCodeToOptimizedIndex)(code);
      result[optimizedCharIdx] = optimizedCharIdx;
      if (ignoreCase === true) {
        handleIgnoreCase(code, result);
      }
    }
    function handleIgnoreCase(code, result) {
      var char = String.fromCharCode(code);
      var upperChar = char.toUpperCase();
      if (upperChar !== char) {
        var optimizedCharIdx = (0, lexer_1.charCodeToOptimizedIndex)(upperChar.charCodeAt(0));
        result[optimizedCharIdx] = optimizedCharIdx;
      } else {
        var lowerChar = char.toLowerCase();
        if (lowerChar !== char) {
          var optimizedCharIdx = (0, lexer_1.charCodeToOptimizedIndex)(lowerChar.charCodeAt(0));
          result[optimizedCharIdx] = optimizedCharIdx;
        }
      }
    }
    function findCode(setNode, targetCharCodes) {
      return (0, find_1.default)(setNode.value, function(codeOrRange) {
        if (typeof codeOrRange === "number") {
          return (0, includes_1.default)(targetCharCodes, codeOrRange);
        } else {
          var range_1 = codeOrRange;
          return (0, find_1.default)(targetCharCodes, function(targetCode) {
            return range_1.from <= targetCode && targetCode <= range_1.to;
          }) !== void 0;
        }
      });
    }
    function isWholeOptional(ast) {
      var quantifier = ast.quantifier;
      if (quantifier && quantifier.atLeast === 0) {
        return true;
      }
      if (!ast.value) {
        return false;
      }
      return (0, isArray_1.default)(ast.value) ? (0, every_1.default)(ast.value, isWholeOptional) : isWholeOptional(ast.value);
    }
    var CharCodeFinder = (
      /** @class */
      function(_super) {
        __extends(CharCodeFinder2, _super);
        function CharCodeFinder2(targetCharCodes) {
          var _this = _super.call(this) || this;
          _this.targetCharCodes = targetCharCodes;
          _this.found = false;
          return _this;
        }
        CharCodeFinder2.prototype.visitChildren = function(node) {
          if (this.found === true) {
            return;
          }
          switch (node.type) {
            case "Lookahead":
              this.visitLookahead(node);
              return;
            case "NegativeLookahead":
              this.visitNegativeLookahead(node);
              return;
          }
          _super.prototype.visitChildren.call(this, node);
        };
        CharCodeFinder2.prototype.visitCharacter = function(node) {
          if ((0, includes_1.default)(this.targetCharCodes, node.value)) {
            this.found = true;
          }
        };
        CharCodeFinder2.prototype.visitSet = function(node) {
          if (node.complement) {
            if (findCode(node, this.targetCharCodes) === void 0) {
              this.found = true;
            }
          } else {
            if (findCode(node, this.targetCharCodes) !== void 0) {
              this.found = true;
            }
          }
        };
        return CharCodeFinder2;
      }(regexp_to_ast_1.BaseRegExpVisitor)
    );
    function canMatchCharCode(charCodes, pattern) {
      if (pattern instanceof RegExp) {
        var ast = (0, reg_exp_parser_1.getRegExpAst)(pattern);
        var charCodeFinder = new CharCodeFinder(charCodes);
        charCodeFinder.visit(ast);
        return charCodeFinder.found;
      } else {
        return (0, find_1.default)(pattern, function(char) {
          return (0, includes_1.default)(charCodes, char.charCodeAt(0));
        }) !== void 0;
      }
    }
    exports2.canMatchCharCode = canMatchCharCode;
  }
});

// node_modules/chevrotain/lib/src/scan/lexer.js
var require_lexer = __commonJS({
  "node_modules/chevrotain/lib/src/scan/lexer.js"(exports2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || function() {
      var extendStatics = function(d, b5) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b6) {
          d2.__proto__ = b6;
        } || function(d2, b6) {
          for (var p in b6)
            if (Object.prototype.hasOwnProperty.call(b6, p))
              d2[p] = b6[p];
        };
        return extendStatics(d, b5);
      };
      return function(d, b5) {
        if (typeof b5 !== "function" && b5 !== null)
          throw new TypeError("Class extends value " + String(b5) + " is not a constructor or null");
        extendStatics(d, b5);
        function __() {
          this.constructor = d;
        }
        d.prototype = b5 === null ? Object.create(b5) : (__.prototype = b5.prototype, new __());
      };
    }();
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.charCodeToOptimizedIndex = exports2.minOptimizationVal = exports2.buildLineBreakIssueMessage = exports2.LineTerminatorOptimizedTester = exports2.isShortPattern = exports2.isCustomPattern = exports2.cloneEmptyGroups = exports2.performWarningRuntimeChecks = exports2.performRuntimeChecks = exports2.addStickyFlag = exports2.addStartOfInput = exports2.findUnreachablePatterns = exports2.findModesThatDoNotExist = exports2.findInvalidGroupType = exports2.findDuplicatePatterns = exports2.findUnsupportedFlags = exports2.findStartOfInputAnchor = exports2.findEmptyMatchRegExps = exports2.findEndOfInputAnchor = exports2.findInvalidPatterns = exports2.findMissingPatterns = exports2.validatePatterns = exports2.analyzeTokenTypes = exports2.enableSticky = exports2.disableSticky = exports2.SUPPORT_STICKY = exports2.MODES = exports2.DEFAULT_MODE = void 0;
    var regexp_to_ast_1 = require_regexp_to_ast();
    var lexer_public_1 = require_lexer_public();
    var first_1 = __importDefault(require_first2());
    var isEmpty_1 = __importDefault(require_isEmpty());
    var compact_1 = __importDefault(require_compact());
    var isArray_1 = __importDefault(require_isArray());
    var values_1 = __importDefault(require_values());
    var flatten_1 = __importDefault(require_flatten());
    var reject_1 = __importDefault(require_reject());
    var difference_1 = __importDefault(require_difference());
    var indexOf_1 = __importDefault(require_indexOf());
    var map_1 = __importDefault(require_map());
    var forEach_1 = __importDefault(require_forEach());
    var isString_1 = __importDefault(require_isString());
    var isFunction_1 = __importDefault(require_isFunction());
    var isUndefined_1 = __importDefault(require_isUndefined());
    var find_1 = __importDefault(require_find());
    var has_1 = __importDefault(require_has());
    var keys_1 = __importDefault(require_keys());
    var isRegExp_1 = __importDefault(require_isRegExp());
    var filter_1 = __importDefault(require_filter());
    var defaults_1 = __importDefault(require_defaults());
    var reduce_1 = __importDefault(require_reduce());
    var includes_1 = __importDefault(require_includes());
    var utils_1 = require_api();
    var reg_exp_1 = require_reg_exp();
    var reg_exp_parser_1 = require_reg_exp_parser();
    var PATTERN = "PATTERN";
    exports2.DEFAULT_MODE = "defaultMode";
    exports2.MODES = "modes";
    exports2.SUPPORT_STICKY = typeof new RegExp("(?:)").sticky === "boolean";
    function disableSticky() {
      exports2.SUPPORT_STICKY = false;
    }
    exports2.disableSticky = disableSticky;
    function enableSticky() {
      exports2.SUPPORT_STICKY = true;
    }
    exports2.enableSticky = enableSticky;
    function analyzeTokenTypes(tokenTypes, options) {
      options = (0, defaults_1.default)(options, {
        useSticky: exports2.SUPPORT_STICKY,
        debug: false,
        safeMode: false,
        positionTracking: "full",
        lineTerminatorCharacters: ["\r", "\n"],
        tracer: function(msg, action) {
          return action();
        }
      });
      var tracer = options.tracer;
      tracer("initCharCodeToOptimizedIndexMap", function() {
        initCharCodeToOptimizedIndexMap();
      });
      var onlyRelevantTypes;
      tracer("Reject Lexer.NA", function() {
        onlyRelevantTypes = (0, reject_1.default)(tokenTypes, function(currType) {
          return currType[PATTERN] === lexer_public_1.Lexer.NA;
        });
      });
      var hasCustom = false;
      var allTransformedPatterns;
      tracer("Transform Patterns", function() {
        hasCustom = false;
        allTransformedPatterns = (0, map_1.default)(onlyRelevantTypes, function(currType) {
          var currPattern = currType[PATTERN];
          if ((0, isRegExp_1.default)(currPattern)) {
            var regExpSource = currPattern.source;
            if (regExpSource.length === 1 && // only these regExp meta characters which can appear in a length one regExp
            regExpSource !== "^" && regExpSource !== "$" && regExpSource !== "." && !currPattern.ignoreCase) {
              return regExpSource;
            } else if (regExpSource.length === 2 && regExpSource[0] === "\\" && // not a meta character
            !(0, includes_1.default)([
              "d",
              "D",
              "s",
              "S",
              "t",
              "r",
              "n",
              "t",
              "0",
              "c",
              "b",
              "B",
              "f",
              "v",
              "w",
              "W"
            ], regExpSource[1])) {
              return regExpSource[1];
            } else {
              return options.useSticky ? addStickyFlag(currPattern) : addStartOfInput(currPattern);
            }
          } else if ((0, isFunction_1.default)(currPattern)) {
            hasCustom = true;
            return { exec: currPattern };
          } else if (typeof currPattern === "object") {
            hasCustom = true;
            return currPattern;
          } else if (typeof currPattern === "string") {
            if (currPattern.length === 1) {
              return currPattern;
            } else {
              var escapedRegExpString = currPattern.replace(/[\\^$.*+?()[\]{}|]/g, "\\$&");
              var wrappedRegExp = new RegExp(escapedRegExpString);
              return options.useSticky ? addStickyFlag(wrappedRegExp) : addStartOfInput(wrappedRegExp);
            }
          } else {
            throw Error("non exhaustive match");
          }
        });
      });
      var patternIdxToType;
      var patternIdxToGroup;
      var patternIdxToLongerAltIdxArr;
      var patternIdxToPushMode;
      var patternIdxToPopMode;
      tracer("misc mapping", function() {
        patternIdxToType = (0, map_1.default)(onlyRelevantTypes, function(currType) {
          return currType.tokenTypeIdx;
        });
        patternIdxToGroup = (0, map_1.default)(onlyRelevantTypes, function(clazz) {
          var groupName = clazz.GROUP;
          if (groupName === lexer_public_1.Lexer.SKIPPED) {
            return void 0;
          } else if ((0, isString_1.default)(groupName)) {
            return groupName;
          } else if ((0, isUndefined_1.default)(groupName)) {
            return false;
          } else {
            throw Error("non exhaustive match");
          }
        });
        patternIdxToLongerAltIdxArr = (0, map_1.default)(onlyRelevantTypes, function(clazz) {
          var longerAltType = clazz.LONGER_ALT;
          if (longerAltType) {
            var longerAltIdxArr = (0, isArray_1.default)(longerAltType) ? (0, map_1.default)(longerAltType, function(type) {
              return (0, indexOf_1.default)(onlyRelevantTypes, type);
            }) : [(0, indexOf_1.default)(onlyRelevantTypes, longerAltType)];
            return longerAltIdxArr;
          }
        });
        patternIdxToPushMode = (0, map_1.default)(onlyRelevantTypes, function(clazz) {
          return clazz.PUSH_MODE;
        });
        patternIdxToPopMode = (0, map_1.default)(onlyRelevantTypes, function(clazz) {
          return (0, has_1.default)(clazz, "POP_MODE");
        });
      });
      var patternIdxToCanLineTerminator;
      tracer("Line Terminator Handling", function() {
        var lineTerminatorCharCodes = getCharCodes(options.lineTerminatorCharacters);
        patternIdxToCanLineTerminator = (0, map_1.default)(onlyRelevantTypes, function(tokType) {
          return false;
        });
        if (options.positionTracking !== "onlyOffset") {
          patternIdxToCanLineTerminator = (0, map_1.default)(onlyRelevantTypes, function(tokType) {
            if ((0, has_1.default)(tokType, "LINE_BREAKS")) {
              return !!tokType.LINE_BREAKS;
            } else {
              return checkLineBreaksIssues(tokType, lineTerminatorCharCodes) === false && (0, reg_exp_1.canMatchCharCode)(lineTerminatorCharCodes, tokType.PATTERN);
            }
          });
        }
      });
      var patternIdxToIsCustom;
      var patternIdxToShort;
      var emptyGroups;
      var patternIdxToConfig;
      tracer("Misc Mapping #2", function() {
        patternIdxToIsCustom = (0, map_1.default)(onlyRelevantTypes, isCustomPattern);
        patternIdxToShort = (0, map_1.default)(allTransformedPatterns, isShortPattern);
        emptyGroups = (0, reduce_1.default)(onlyRelevantTypes, function(acc, clazz) {
          var groupName = clazz.GROUP;
          if ((0, isString_1.default)(groupName) && !(groupName === lexer_public_1.Lexer.SKIPPED)) {
            acc[groupName] = [];
          }
          return acc;
        }, {});
        patternIdxToConfig = (0, map_1.default)(allTransformedPatterns, function(x, idx) {
          return {
            pattern: allTransformedPatterns[idx],
            longerAlt: patternIdxToLongerAltIdxArr[idx],
            canLineTerminator: patternIdxToCanLineTerminator[idx],
            isCustom: patternIdxToIsCustom[idx],
            short: patternIdxToShort[idx],
            group: patternIdxToGroup[idx],
            push: patternIdxToPushMode[idx],
            pop: patternIdxToPopMode[idx],
            tokenTypeIdx: patternIdxToType[idx],
            tokenType: onlyRelevantTypes[idx]
          };
        });
      });
      var canBeOptimized = true;
      var charCodeToPatternIdxToConfig = [];
      if (!options.safeMode) {
        tracer("First Char Optimization", function() {
          charCodeToPatternIdxToConfig = (0, reduce_1.default)(onlyRelevantTypes, function(result, currTokType, idx) {
            if (typeof currTokType.PATTERN === "string") {
              var charCode = currTokType.PATTERN.charCodeAt(0);
              var optimizedIdx = charCodeToOptimizedIndex(charCode);
              addToMapOfArrays(result, optimizedIdx, patternIdxToConfig[idx]);
            } else if ((0, isArray_1.default)(currTokType.START_CHARS_HINT)) {
              var lastOptimizedIdx_1;
              (0, forEach_1.default)(currTokType.START_CHARS_HINT, function(charOrInt) {
                var charCode2 = typeof charOrInt === "string" ? charOrInt.charCodeAt(0) : charOrInt;
                var currOptimizedIdx = charCodeToOptimizedIndex(charCode2);
                if (lastOptimizedIdx_1 !== currOptimizedIdx) {
                  lastOptimizedIdx_1 = currOptimizedIdx;
                  addToMapOfArrays(result, currOptimizedIdx, patternIdxToConfig[idx]);
                }
              });
            } else if ((0, isRegExp_1.default)(currTokType.PATTERN)) {
              if (currTokType.PATTERN.unicode) {
                canBeOptimized = false;
                if (options.ensureOptimizations) {
                  (0, utils_1.PRINT_ERROR)("".concat(reg_exp_1.failedOptimizationPrefixMsg) + "	Unable to analyze < ".concat(currTokType.PATTERN.toString(), " > pattern.\n") + "	The regexp unicode flag is not currently supported by the regexp-to-ast library.\n	This will disable the lexer's first char optimizations.\n	For details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#UNICODE_OPTIMIZE");
                }
              } else {
                var optimizedCodes = (0, reg_exp_1.getOptimizedStartCodesIndices)(currTokType.PATTERN, options.ensureOptimizations);
                if ((0, isEmpty_1.default)(optimizedCodes)) {
                  canBeOptimized = false;
                }
                (0, forEach_1.default)(optimizedCodes, function(code) {
                  addToMapOfArrays(result, code, patternIdxToConfig[idx]);
                });
              }
            } else {
              if (options.ensureOptimizations) {
                (0, utils_1.PRINT_ERROR)("".concat(reg_exp_1.failedOptimizationPrefixMsg) + "	TokenType: <".concat(currTokType.name, "> is using a custom token pattern without providing <start_chars_hint> parameter.\n") + "	This will disable the lexer's first char optimizations.\n	For details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#CUSTOM_OPTIMIZE");
              }
              canBeOptimized = false;
            }
            return result;
          }, []);
        });
      }
      return {
        emptyGroups,
        patternIdxToConfig,
        charCodeToPatternIdxToConfig,
        hasCustom,
        canBeOptimized
      };
    }
    exports2.analyzeTokenTypes = analyzeTokenTypes;
    function validatePatterns(tokenTypes, validModesNames) {
      var errors = [];
      var missingResult = findMissingPatterns(tokenTypes);
      errors = errors.concat(missingResult.errors);
      var invalidResult = findInvalidPatterns(missingResult.valid);
      var validTokenTypes = invalidResult.valid;
      errors = errors.concat(invalidResult.errors);
      errors = errors.concat(validateRegExpPattern(validTokenTypes));
      errors = errors.concat(findInvalidGroupType(validTokenTypes));
      errors = errors.concat(findModesThatDoNotExist(validTokenTypes, validModesNames));
      errors = errors.concat(findUnreachablePatterns(validTokenTypes));
      return errors;
    }
    exports2.validatePatterns = validatePatterns;
    function validateRegExpPattern(tokenTypes) {
      var errors = [];
      var withRegExpPatterns = (0, filter_1.default)(tokenTypes, function(currTokType) {
        return (0, isRegExp_1.default)(currTokType[PATTERN]);
      });
      errors = errors.concat(findEndOfInputAnchor(withRegExpPatterns));
      errors = errors.concat(findStartOfInputAnchor(withRegExpPatterns));
      errors = errors.concat(findUnsupportedFlags(withRegExpPatterns));
      errors = errors.concat(findDuplicatePatterns(withRegExpPatterns));
      errors = errors.concat(findEmptyMatchRegExps(withRegExpPatterns));
      return errors;
    }
    function findMissingPatterns(tokenTypes) {
      var tokenTypesWithMissingPattern = (0, filter_1.default)(tokenTypes, function(currType) {
        return !(0, has_1.default)(currType, PATTERN);
      });
      var errors = (0, map_1.default)(tokenTypesWithMissingPattern, function(currType) {
        return {
          message: "Token Type: ->" + currType.name + "<- missing static 'PATTERN' property",
          type: lexer_public_1.LexerDefinitionErrorType.MISSING_PATTERN,
          tokenTypes: [currType]
        };
      });
      var valid = (0, difference_1.default)(tokenTypes, tokenTypesWithMissingPattern);
      return { errors, valid };
    }
    exports2.findMissingPatterns = findMissingPatterns;
    function findInvalidPatterns(tokenTypes) {
      var tokenTypesWithInvalidPattern = (0, filter_1.default)(tokenTypes, function(currType) {
        var pattern = currType[PATTERN];
        return !(0, isRegExp_1.default)(pattern) && !(0, isFunction_1.default)(pattern) && !(0, has_1.default)(pattern, "exec") && !(0, isString_1.default)(pattern);
      });
      var errors = (0, map_1.default)(tokenTypesWithInvalidPattern, function(currType) {
        return {
          message: "Token Type: ->" + currType.name + "<- static 'PATTERN' can only be a RegExp, a Function matching the {CustomPatternMatcherFunc} type or an Object matching the {ICustomPattern} interface.",
          type: lexer_public_1.LexerDefinitionErrorType.INVALID_PATTERN,
          tokenTypes: [currType]
        };
      });
      var valid = (0, difference_1.default)(tokenTypes, tokenTypesWithInvalidPattern);
      return { errors, valid };
    }
    exports2.findInvalidPatterns = findInvalidPatterns;
    var end_of_input = /[^\\][$]/;
    function findEndOfInputAnchor(tokenTypes) {
      var EndAnchorFinder = (
        /** @class */
        function(_super) {
          __extends(EndAnchorFinder2, _super);
          function EndAnchorFinder2() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.found = false;
            return _this;
          }
          EndAnchorFinder2.prototype.visitEndAnchor = function(node) {
            this.found = true;
          };
          return EndAnchorFinder2;
        }(regexp_to_ast_1.BaseRegExpVisitor)
      );
      var invalidRegex = (0, filter_1.default)(tokenTypes, function(currType) {
        var pattern = currType.PATTERN;
        try {
          var regexpAst = (0, reg_exp_parser_1.getRegExpAst)(pattern);
          var endAnchorVisitor = new EndAnchorFinder();
          endAnchorVisitor.visit(regexpAst);
          return endAnchorVisitor.found;
        } catch (e) {
          return end_of_input.test(pattern.source);
        }
      });
      var errors = (0, map_1.default)(invalidRegex, function(currType) {
        return {
          message: "Unexpected RegExp Anchor Error:\n	Token Type: ->" + currType.name + "<- static 'PATTERN' cannot contain end of input anchor '$'\n	See chevrotain.io/docs/guide/resolving_lexer_errors.html#ANCHORS	for details.",
          type: lexer_public_1.LexerDefinitionErrorType.EOI_ANCHOR_FOUND,
          tokenTypes: [currType]
        };
      });
      return errors;
    }
    exports2.findEndOfInputAnchor = findEndOfInputAnchor;
    function findEmptyMatchRegExps(tokenTypes) {
      var matchesEmptyString = (0, filter_1.default)(tokenTypes, function(currType) {
        var pattern = currType.PATTERN;
        return pattern.test("");
      });
      var errors = (0, map_1.default)(matchesEmptyString, function(currType) {
        return {
          message: "Token Type: ->" + currType.name + "<- static 'PATTERN' must not match an empty string",
          type: lexer_public_1.LexerDefinitionErrorType.EMPTY_MATCH_PATTERN,
          tokenTypes: [currType]
        };
      });
      return errors;
    }
    exports2.findEmptyMatchRegExps = findEmptyMatchRegExps;
    var start_of_input = /[^\\[][\^]|^\^/;
    function findStartOfInputAnchor(tokenTypes) {
      var StartAnchorFinder = (
        /** @class */
        function(_super) {
          __extends(StartAnchorFinder2, _super);
          function StartAnchorFinder2() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.found = false;
            return _this;
          }
          StartAnchorFinder2.prototype.visitStartAnchor = function(node) {
            this.found = true;
          };
          return StartAnchorFinder2;
        }(regexp_to_ast_1.BaseRegExpVisitor)
      );
      var invalidRegex = (0, filter_1.default)(tokenTypes, function(currType) {
        var pattern = currType.PATTERN;
        try {
          var regexpAst = (0, reg_exp_parser_1.getRegExpAst)(pattern);
          var startAnchorVisitor = new StartAnchorFinder();
          startAnchorVisitor.visit(regexpAst);
          return startAnchorVisitor.found;
        } catch (e) {
          return start_of_input.test(pattern.source);
        }
      });
      var errors = (0, map_1.default)(invalidRegex, function(currType) {
        return {
          message: "Unexpected RegExp Anchor Error:\n	Token Type: ->" + currType.name + "<- static 'PATTERN' cannot contain start of input anchor '^'\n	See https://chevrotain.io/docs/guide/resolving_lexer_errors.html#ANCHORS	for details.",
          type: lexer_public_1.LexerDefinitionErrorType.SOI_ANCHOR_FOUND,
          tokenTypes: [currType]
        };
      });
      return errors;
    }
    exports2.findStartOfInputAnchor = findStartOfInputAnchor;
    function findUnsupportedFlags(tokenTypes) {
      var invalidFlags = (0, filter_1.default)(tokenTypes, function(currType) {
        var pattern = currType[PATTERN];
        return pattern instanceof RegExp && (pattern.multiline || pattern.global);
      });
      var errors = (0, map_1.default)(invalidFlags, function(currType) {
        return {
          message: "Token Type: ->" + currType.name + "<- static 'PATTERN' may NOT contain global('g') or multiline('m')",
          type: lexer_public_1.LexerDefinitionErrorType.UNSUPPORTED_FLAGS_FOUND,
          tokenTypes: [currType]
        };
      });
      return errors;
    }
    exports2.findUnsupportedFlags = findUnsupportedFlags;
    function findDuplicatePatterns(tokenTypes) {
      var found = [];
      var identicalPatterns = (0, map_1.default)(tokenTypes, function(outerType) {
        return (0, reduce_1.default)(tokenTypes, function(result, innerType) {
          if (outerType.PATTERN.source === innerType.PATTERN.source && !(0, includes_1.default)(found, innerType) && innerType.PATTERN !== lexer_public_1.Lexer.NA) {
            found.push(innerType);
            result.push(innerType);
            return result;
          }
          return result;
        }, []);
      });
      identicalPatterns = (0, compact_1.default)(identicalPatterns);
      var duplicatePatterns = (0, filter_1.default)(identicalPatterns, function(currIdenticalSet) {
        return currIdenticalSet.length > 1;
      });
      var errors = (0, map_1.default)(duplicatePatterns, function(setOfIdentical) {
        var tokenTypeNames = (0, map_1.default)(setOfIdentical, function(currType) {
          return currType.name;
        });
        var dupPatternSrc = (0, first_1.default)(setOfIdentical).PATTERN;
        return {
          message: "The same RegExp pattern ->".concat(dupPatternSrc, "<-") + "has been used in all of the following Token Types: ".concat(tokenTypeNames.join(", "), " <-"),
          type: lexer_public_1.LexerDefinitionErrorType.DUPLICATE_PATTERNS_FOUND,
          tokenTypes: setOfIdentical
        };
      });
      return errors;
    }
    exports2.findDuplicatePatterns = findDuplicatePatterns;
    function findInvalidGroupType(tokenTypes) {
      var invalidTypes = (0, filter_1.default)(tokenTypes, function(clazz) {
        if (!(0, has_1.default)(clazz, "GROUP")) {
          return false;
        }
        var group = clazz.GROUP;
        return group !== lexer_public_1.Lexer.SKIPPED && group !== lexer_public_1.Lexer.NA && !(0, isString_1.default)(group);
      });
      var errors = (0, map_1.default)(invalidTypes, function(currType) {
        return {
          message: "Token Type: ->" + currType.name + "<- static 'GROUP' can only be Lexer.SKIPPED/Lexer.NA/A String",
          type: lexer_public_1.LexerDefinitionErrorType.INVALID_GROUP_TYPE_FOUND,
          tokenTypes: [currType]
        };
      });
      return errors;
    }
    exports2.findInvalidGroupType = findInvalidGroupType;
    function findModesThatDoNotExist(tokenTypes, validModes) {
      var invalidModes = (0, filter_1.default)(tokenTypes, function(clazz) {
        return clazz.PUSH_MODE !== void 0 && !(0, includes_1.default)(validModes, clazz.PUSH_MODE);
      });
      var errors = (0, map_1.default)(invalidModes, function(tokType) {
        var msg = "Token Type: ->".concat(tokType.name, "<- static 'PUSH_MODE' value cannot refer to a Lexer Mode ->").concat(tokType.PUSH_MODE, "<-") + "which does not exist";
        return {
          message: msg,
          type: lexer_public_1.LexerDefinitionErrorType.PUSH_MODE_DOES_NOT_EXIST,
          tokenTypes: [tokType]
        };
      });
      return errors;
    }
    exports2.findModesThatDoNotExist = findModesThatDoNotExist;
    function findUnreachablePatterns(tokenTypes) {
      var errors = [];
      var canBeTested = (0, reduce_1.default)(tokenTypes, function(result, tokType, idx) {
        var pattern = tokType.PATTERN;
        if (pattern === lexer_public_1.Lexer.NA) {
          return result;
        }
        if ((0, isString_1.default)(pattern)) {
          result.push({ str: pattern, idx, tokenType: tokType });
        } else if ((0, isRegExp_1.default)(pattern) && noMetaChar(pattern)) {
          result.push({ str: pattern.source, idx, tokenType: tokType });
        }
        return result;
      }, []);
      (0, forEach_1.default)(tokenTypes, function(tokType, testIdx) {
        (0, forEach_1.default)(canBeTested, function(_a4) {
          var str = _a4.str, idx = _a4.idx, tokenType = _a4.tokenType;
          if (testIdx < idx && testTokenType(str, tokType.PATTERN)) {
            var msg = "Token: ->".concat(tokenType.name, "<- can never be matched.\n") + "Because it appears AFTER the Token Type ->".concat(tokType.name, "<-") + "in the lexer's definition.\nSee https://chevrotain.io/docs/guide/resolving_lexer_errors.html#UNREACHABLE";
            errors.push({
              message: msg,
              type: lexer_public_1.LexerDefinitionErrorType.UNREACHABLE_PATTERN,
              tokenTypes: [tokType, tokenType]
            });
          }
        });
      });
      return errors;
    }
    exports2.findUnreachablePatterns = findUnreachablePatterns;
    function testTokenType(str, pattern) {
      if ((0, isRegExp_1.default)(pattern)) {
        var regExpArray = pattern.exec(str);
        return regExpArray !== null && regExpArray.index === 0;
      } else if ((0, isFunction_1.default)(pattern)) {
        return pattern(str, 0, [], {});
      } else if ((0, has_1.default)(pattern, "exec")) {
        return pattern.exec(str, 0, [], {});
      } else if (typeof pattern === "string") {
        return pattern === str;
      } else {
        throw Error("non exhaustive match");
      }
    }
    function noMetaChar(regExp) {
      var metaChars = [
        ".",
        "\\",
        "[",
        "]",
        "|",
        "^",
        "$",
        "(",
        ")",
        "?",
        "*",
        "+",
        "{"
      ];
      return (0, find_1.default)(metaChars, function(char) {
        return regExp.source.indexOf(char) !== -1;
      }) === void 0;
    }
    function addStartOfInput(pattern) {
      var flags = pattern.ignoreCase ? "i" : "";
      return new RegExp("^(?:".concat(pattern.source, ")"), flags);
    }
    exports2.addStartOfInput = addStartOfInput;
    function addStickyFlag(pattern) {
      var flags = pattern.ignoreCase ? "iy" : "y";
      return new RegExp("".concat(pattern.source), flags);
    }
    exports2.addStickyFlag = addStickyFlag;
    function performRuntimeChecks(lexerDefinition, trackLines, lineTerminatorCharacters) {
      var errors = [];
      if (!(0, has_1.default)(lexerDefinition, exports2.DEFAULT_MODE)) {
        errors.push({
          message: "A MultiMode Lexer cannot be initialized without a <" + exports2.DEFAULT_MODE + "> property in its definition\n",
          type: lexer_public_1.LexerDefinitionErrorType.MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE
        });
      }
      if (!(0, has_1.default)(lexerDefinition, exports2.MODES)) {
        errors.push({
          message: "A MultiMode Lexer cannot be initialized without a <" + exports2.MODES + "> property in its definition\n",
          type: lexer_public_1.LexerDefinitionErrorType.MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY
        });
      }
      if ((0, has_1.default)(lexerDefinition, exports2.MODES) && (0, has_1.default)(lexerDefinition, exports2.DEFAULT_MODE) && !(0, has_1.default)(lexerDefinition.modes, lexerDefinition.defaultMode)) {
        errors.push({
          message: "A MultiMode Lexer cannot be initialized with a ".concat(exports2.DEFAULT_MODE, ": <").concat(lexerDefinition.defaultMode, ">") + "which does not exist\n",
          type: lexer_public_1.LexerDefinitionErrorType.MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST
        });
      }
      if ((0, has_1.default)(lexerDefinition, exports2.MODES)) {
        (0, forEach_1.default)(lexerDefinition.modes, function(currModeValue, currModeName) {
          (0, forEach_1.default)(currModeValue, function(currTokType, currIdx) {
            if ((0, isUndefined_1.default)(currTokType)) {
              errors.push({
                message: "A Lexer cannot be initialized using an undefined Token Type. Mode:" + "<".concat(currModeName, "> at index: <").concat(currIdx, ">\n"),
                type: lexer_public_1.LexerDefinitionErrorType.LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED
              });
            } else if ((0, has_1.default)(currTokType, "LONGER_ALT")) {
              var longerAlt = (0, isArray_1.default)(currTokType.LONGER_ALT) ? currTokType.LONGER_ALT : [currTokType.LONGER_ALT];
              (0, forEach_1.default)(longerAlt, function(currLongerAlt) {
                if (!(0, isUndefined_1.default)(currLongerAlt) && !(0, includes_1.default)(currModeValue, currLongerAlt)) {
                  errors.push({
                    message: "A MultiMode Lexer cannot be initialized with a longer_alt <".concat(currLongerAlt.name, "> on token <").concat(currTokType.name, "> outside of mode <").concat(currModeName, ">\n"),
                    type: lexer_public_1.LexerDefinitionErrorType.MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE
                  });
                }
              });
            }
          });
        });
      }
      return errors;
    }
    exports2.performRuntimeChecks = performRuntimeChecks;
    function performWarningRuntimeChecks(lexerDefinition, trackLines, lineTerminatorCharacters) {
      var warnings = [];
      var hasAnyLineBreak = false;
      var allTokenTypes = (0, compact_1.default)((0, flatten_1.default)((0, values_1.default)(lexerDefinition.modes)));
      var concreteTokenTypes = (0, reject_1.default)(allTokenTypes, function(currType) {
        return currType[PATTERN] === lexer_public_1.Lexer.NA;
      });
      var terminatorCharCodes = getCharCodes(lineTerminatorCharacters);
      if (trackLines) {
        (0, forEach_1.default)(concreteTokenTypes, function(tokType) {
          var currIssue = checkLineBreaksIssues(tokType, terminatorCharCodes);
          if (currIssue !== false) {
            var message = buildLineBreakIssueMessage(tokType, currIssue);
            var warningDescriptor = {
              message,
              type: currIssue.issue,
              tokenType: tokType
            };
            warnings.push(warningDescriptor);
          } else {
            if ((0, has_1.default)(tokType, "LINE_BREAKS")) {
              if (tokType.LINE_BREAKS === true) {
                hasAnyLineBreak = true;
              }
            } else {
              if ((0, reg_exp_1.canMatchCharCode)(terminatorCharCodes, tokType.PATTERN)) {
                hasAnyLineBreak = true;
              }
            }
          }
        });
      }
      if (trackLines && !hasAnyLineBreak) {
        warnings.push({
          message: "Warning: No LINE_BREAKS Found.\n	This Lexer has been defined to track line and column information,\n	But none of the Token Types can be identified as matching a line terminator.\n	See https://chevrotain.io/docs/guide/resolving_lexer_errors.html#LINE_BREAKS \n	for details.",
          type: lexer_public_1.LexerDefinitionErrorType.NO_LINE_BREAKS_FLAGS
        });
      }
      return warnings;
    }
    exports2.performWarningRuntimeChecks = performWarningRuntimeChecks;
    function cloneEmptyGroups(emptyGroups) {
      var clonedResult = {};
      var groupKeys = (0, keys_1.default)(emptyGroups);
      (0, forEach_1.default)(groupKeys, function(currKey) {
        var currGroupValue = emptyGroups[currKey];
        if ((0, isArray_1.default)(currGroupValue)) {
          clonedResult[currKey] = [];
        } else {
          throw Error("non exhaustive match");
        }
      });
      return clonedResult;
    }
    exports2.cloneEmptyGroups = cloneEmptyGroups;
    function isCustomPattern(tokenType) {
      var pattern = tokenType.PATTERN;
      if ((0, isRegExp_1.default)(pattern)) {
        return false;
      } else if ((0, isFunction_1.default)(pattern)) {
        return true;
      } else if ((0, has_1.default)(pattern, "exec")) {
        return true;
      } else if ((0, isString_1.default)(pattern)) {
        return false;
      } else {
        throw Error("non exhaustive match");
      }
    }
    exports2.isCustomPattern = isCustomPattern;
    function isShortPattern(pattern) {
      if ((0, isString_1.default)(pattern) && pattern.length === 1) {
        return pattern.charCodeAt(0);
      } else {
        return false;
      }
    }
    exports2.isShortPattern = isShortPattern;
    exports2.LineTerminatorOptimizedTester = {
      // implements /\n|\r\n?/g.test
      test: function(text) {
        var len = text.length;
        for (var i3 = this.lastIndex; i3 < len; i3++) {
          var c3 = text.charCodeAt(i3);
          if (c3 === 10) {
            this.lastIndex = i3 + 1;
            return true;
          } else if (c3 === 13) {
            if (text.charCodeAt(i3 + 1) === 10) {
              this.lastIndex = i3 + 2;
            } else {
              this.lastIndex = i3 + 1;
            }
            return true;
          }
        }
        return false;
      },
      lastIndex: 0
    };
    function checkLineBreaksIssues(tokType, lineTerminatorCharCodes) {
      if ((0, has_1.default)(tokType, "LINE_BREAKS")) {
        return false;
      } else {
        if ((0, isRegExp_1.default)(tokType.PATTERN)) {
          try {
            (0, reg_exp_1.canMatchCharCode)(lineTerminatorCharCodes, tokType.PATTERN);
          } catch (e) {
            return {
              issue: lexer_public_1.LexerDefinitionErrorType.IDENTIFY_TERMINATOR,
              errMsg: e.message
            };
          }
          return false;
        } else if ((0, isString_1.default)(tokType.PATTERN)) {
          return false;
        } else if (isCustomPattern(tokType)) {
          return { issue: lexer_public_1.LexerDefinitionErrorType.CUSTOM_LINE_BREAK };
        } else {
          throw Error("non exhaustive match");
        }
      }
    }
    function buildLineBreakIssueMessage(tokType, details) {
      if (details.issue === lexer_public_1.LexerDefinitionErrorType.IDENTIFY_TERMINATOR) {
        return "Warning: unable to identify line terminator usage in pattern.\n" + "	The problem is in the <".concat(tokType.name, "> Token Type\n") + "	 Root cause: ".concat(details.errMsg, ".\n") + "	For details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#IDENTIFY_TERMINATOR";
      } else if (details.issue === lexer_public_1.LexerDefinitionErrorType.CUSTOM_LINE_BREAK) {
        return "Warning: A Custom Token Pattern should specify the <line_breaks> option.\n" + "	The problem is in the <".concat(tokType.name, "> Token Type\n") + "	For details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#CUSTOM_LINE_BREAK";
      } else {
        throw Error("non exhaustive match");
      }
    }
    exports2.buildLineBreakIssueMessage = buildLineBreakIssueMessage;
    function getCharCodes(charsOrCodes) {
      var charCodes = (0, map_1.default)(charsOrCodes, function(numOrString) {
        if ((0, isString_1.default)(numOrString)) {
          return numOrString.charCodeAt(0);
        } else {
          return numOrString;
        }
      });
      return charCodes;
    }
    function addToMapOfArrays(map2, key, value) {
      if (map2[key] === void 0) {
        map2[key] = [value];
      } else {
        map2[key].push(value);
      }
    }
    exports2.minOptimizationVal = 256;
    var charCodeToOptimizedIdxMap = [];
    function charCodeToOptimizedIndex(charCode) {
      return charCode < exports2.minOptimizationVal ? charCode : charCodeToOptimizedIdxMap[charCode];
    }
    exports2.charCodeToOptimizedIndex = charCodeToOptimizedIndex;
    function initCharCodeToOptimizedIndexMap() {
      if ((0, isEmpty_1.default)(charCodeToOptimizedIdxMap)) {
        charCodeToOptimizedIdxMap = new Array(65536);
        for (var i3 = 0; i3 < 65536; i3++) {
          charCodeToOptimizedIdxMap[i3] = i3 > 255 ? 255 + ~~(i3 / 255) : i3;
        }
      }
    }
  }
});

// node_modules/lodash/last.js
var require_last = __commonJS({
  "node_modules/lodash/last.js"(exports2, module2) {
    function last(array) {
      var length = array == null ? 0 : array.length;
      return length ? array[length - 1] : void 0;
    }
    module2.exports = last;
  }
});

// node_modules/chevrotain/lib/src/scan/tokens.js
var require_tokens = __commonJS({
  "node_modules/chevrotain/lib/src/scan/tokens.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isTokenType = exports2.hasExtendingTokensTypesMapProperty = exports2.hasExtendingTokensTypesProperty = exports2.hasCategoriesProperty = exports2.hasShortKeyProperty = exports2.singleAssignCategoriesToksMap = exports2.assignCategoriesMapProp = exports2.assignCategoriesTokensProp = exports2.assignTokenDefaultProps = exports2.expandCategories = exports2.augmentTokenTypes = exports2.tokenIdxToClass = exports2.tokenShortNameIdx = exports2.tokenStructuredMatcherNoCategories = exports2.tokenStructuredMatcher = void 0;
    var isEmpty_1 = __importDefault(require_isEmpty());
    var compact_1 = __importDefault(require_compact());
    var isArray_1 = __importDefault(require_isArray());
    var flatten_1 = __importDefault(require_flatten());
    var difference_1 = __importDefault(require_difference());
    var map_1 = __importDefault(require_map());
    var forEach_1 = __importDefault(require_forEach());
    var has_1 = __importDefault(require_has());
    var includes_1 = __importDefault(require_includes());
    var clone_1 = __importDefault(require_clone());
    function tokenStructuredMatcher(tokInstance, tokConstructor) {
      var instanceType = tokInstance.tokenTypeIdx;
      if (instanceType === tokConstructor.tokenTypeIdx) {
        return true;
      } else {
        return tokConstructor.isParent === true && tokConstructor.categoryMatchesMap[instanceType] === true;
      }
    }
    exports2.tokenStructuredMatcher = tokenStructuredMatcher;
    function tokenStructuredMatcherNoCategories(token, tokType) {
      return token.tokenTypeIdx === tokType.tokenTypeIdx;
    }
    exports2.tokenStructuredMatcherNoCategories = tokenStructuredMatcherNoCategories;
    exports2.tokenShortNameIdx = 1;
    exports2.tokenIdxToClass = {};
    function augmentTokenTypes(tokenTypes) {
      var tokenTypesAndParents = expandCategories(tokenTypes);
      assignTokenDefaultProps(tokenTypesAndParents);
      assignCategoriesMapProp(tokenTypesAndParents);
      assignCategoriesTokensProp(tokenTypesAndParents);
      (0, forEach_1.default)(tokenTypesAndParents, function(tokType) {
        tokType.isParent = tokType.categoryMatches.length > 0;
      });
    }
    exports2.augmentTokenTypes = augmentTokenTypes;
    function expandCategories(tokenTypes) {
      var result = (0, clone_1.default)(tokenTypes);
      var categories = tokenTypes;
      var searching = true;
      while (searching) {
        categories = (0, compact_1.default)((0, flatten_1.default)((0, map_1.default)(categories, function(currTokType) {
          return currTokType.CATEGORIES;
        })));
        var newCategories = (0, difference_1.default)(categories, result);
        result = result.concat(newCategories);
        if ((0, isEmpty_1.default)(newCategories)) {
          searching = false;
        } else {
          categories = newCategories;
        }
      }
      return result;
    }
    exports2.expandCategories = expandCategories;
    function assignTokenDefaultProps(tokenTypes) {
      (0, forEach_1.default)(tokenTypes, function(currTokType) {
        if (!hasShortKeyProperty(currTokType)) {
          exports2.tokenIdxToClass[exports2.tokenShortNameIdx] = currTokType;
          currTokType.tokenTypeIdx = exports2.tokenShortNameIdx++;
        }
        if (hasCategoriesProperty(currTokType) && !(0, isArray_1.default)(currTokType.CATEGORIES)) {
          currTokType.CATEGORIES = [currTokType.CATEGORIES];
        }
        if (!hasCategoriesProperty(currTokType)) {
          currTokType.CATEGORIES = [];
        }
        if (!hasExtendingTokensTypesProperty(currTokType)) {
          currTokType.categoryMatches = [];
        }
        if (!hasExtendingTokensTypesMapProperty(currTokType)) {
          currTokType.categoryMatchesMap = {};
        }
      });
    }
    exports2.assignTokenDefaultProps = assignTokenDefaultProps;
    function assignCategoriesTokensProp(tokenTypes) {
      (0, forEach_1.default)(tokenTypes, function(currTokType) {
        currTokType.categoryMatches = [];
        (0, forEach_1.default)(currTokType.categoryMatchesMap, function(val, key) {
          currTokType.categoryMatches.push(exports2.tokenIdxToClass[key].tokenTypeIdx);
        });
      });
    }
    exports2.assignCategoriesTokensProp = assignCategoriesTokensProp;
    function assignCategoriesMapProp(tokenTypes) {
      (0, forEach_1.default)(tokenTypes, function(currTokType) {
        singleAssignCategoriesToksMap([], currTokType);
      });
    }
    exports2.assignCategoriesMapProp = assignCategoriesMapProp;
    function singleAssignCategoriesToksMap(path, nextNode) {
      (0, forEach_1.default)(path, function(pathNode) {
        nextNode.categoryMatchesMap[pathNode.tokenTypeIdx] = true;
      });
      (0, forEach_1.default)(nextNode.CATEGORIES, function(nextCategory) {
        var newPath = path.concat(nextNode);
        if (!(0, includes_1.default)(newPath, nextCategory)) {
          singleAssignCategoriesToksMap(newPath, nextCategory);
        }
      });
    }
    exports2.singleAssignCategoriesToksMap = singleAssignCategoriesToksMap;
    function hasShortKeyProperty(tokType) {
      return (0, has_1.default)(tokType, "tokenTypeIdx");
    }
    exports2.hasShortKeyProperty = hasShortKeyProperty;
    function hasCategoriesProperty(tokType) {
      return (0, has_1.default)(tokType, "CATEGORIES");
    }
    exports2.hasCategoriesProperty = hasCategoriesProperty;
    function hasExtendingTokensTypesProperty(tokType) {
      return (0, has_1.default)(tokType, "categoryMatches");
    }
    exports2.hasExtendingTokensTypesProperty = hasExtendingTokensTypesProperty;
    function hasExtendingTokensTypesMapProperty(tokType) {
      return (0, has_1.default)(tokType, "categoryMatchesMap");
    }
    exports2.hasExtendingTokensTypesMapProperty = hasExtendingTokensTypesMapProperty;
    function isTokenType(tokType) {
      return (0, has_1.default)(tokType, "tokenTypeIdx");
    }
    exports2.isTokenType = isTokenType;
  }
});

// node_modules/chevrotain/lib/src/scan/lexer_errors_public.js
var require_lexer_errors_public = __commonJS({
  "node_modules/chevrotain/lib/src/scan/lexer_errors_public.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.defaultLexerErrorProvider = void 0;
    exports2.defaultLexerErrorProvider = {
      buildUnableToPopLexerModeMessage: function(token) {
        return "Unable to pop Lexer Mode after encountering Token ->".concat(token.image, "<- The Mode Stack is empty");
      },
      buildUnexpectedCharactersMessage: function(fullText, startOffset, length, line2, column) {
        return "unexpected character: ->".concat(fullText.charAt(startOffset), "<- at offset: ").concat(startOffset, ",") + " skipped ".concat(length, " characters.");
      }
    };
  }
});

// node_modules/chevrotain/lib/src/scan/lexer_public.js
var require_lexer_public = __commonJS({
  "node_modules/chevrotain/lib/src/scan/lexer_public.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Lexer = exports2.LexerDefinitionErrorType = void 0;
    var lexer_1 = require_lexer();
    var noop_1 = __importDefault(require_noop());
    var isEmpty_1 = __importDefault(require_isEmpty());
    var isArray_1 = __importDefault(require_isArray());
    var last_1 = __importDefault(require_last());
    var reject_1 = __importDefault(require_reject());
    var map_1 = __importDefault(require_map());
    var forEach_1 = __importDefault(require_forEach());
    var keys_1 = __importDefault(require_keys());
    var isUndefined_1 = __importDefault(require_isUndefined());
    var identity_1 = __importDefault(require_identity());
    var assign_1 = __importDefault(require_assign());
    var reduce_1 = __importDefault(require_reduce());
    var clone_1 = __importDefault(require_clone());
    var utils_1 = require_api();
    var tokens_1 = require_tokens();
    var lexer_errors_public_1 = require_lexer_errors_public();
    var reg_exp_parser_1 = require_reg_exp_parser();
    var LexerDefinitionErrorType2;
    (function(LexerDefinitionErrorType3) {
      LexerDefinitionErrorType3[LexerDefinitionErrorType3["MISSING_PATTERN"] = 0] = "MISSING_PATTERN";
      LexerDefinitionErrorType3[LexerDefinitionErrorType3["INVALID_PATTERN"] = 1] = "INVALID_PATTERN";
      LexerDefinitionErrorType3[LexerDefinitionErrorType3["EOI_ANCHOR_FOUND"] = 2] = "EOI_ANCHOR_FOUND";
      LexerDefinitionErrorType3[LexerDefinitionErrorType3["UNSUPPORTED_FLAGS_FOUND"] = 3] = "UNSUPPORTED_FLAGS_FOUND";
      LexerDefinitionErrorType3[LexerDefinitionErrorType3["DUPLICATE_PATTERNS_FOUND"] = 4] = "DUPLICATE_PATTERNS_FOUND";
      LexerDefinitionErrorType3[LexerDefinitionErrorType3["INVALID_GROUP_TYPE_FOUND"] = 5] = "INVALID_GROUP_TYPE_FOUND";
      LexerDefinitionErrorType3[LexerDefinitionErrorType3["PUSH_MODE_DOES_NOT_EXIST"] = 6] = "PUSH_MODE_DOES_NOT_EXIST";
      LexerDefinitionErrorType3[LexerDefinitionErrorType3["MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE"] = 7] = "MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE";
      LexerDefinitionErrorType3[LexerDefinitionErrorType3["MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY"] = 8] = "MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY";
      LexerDefinitionErrorType3[LexerDefinitionErrorType3["MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST"] = 9] = "MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST";
      LexerDefinitionErrorType3[LexerDefinitionErrorType3["LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED"] = 10] = "LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED";
      LexerDefinitionErrorType3[LexerDefinitionErrorType3["SOI_ANCHOR_FOUND"] = 11] = "SOI_ANCHOR_FOUND";
      LexerDefinitionErrorType3[LexerDefinitionErrorType3["EMPTY_MATCH_PATTERN"] = 12] = "EMPTY_MATCH_PATTERN";
      LexerDefinitionErrorType3[LexerDefinitionErrorType3["NO_LINE_BREAKS_FLAGS"] = 13] = "NO_LINE_BREAKS_FLAGS";
      LexerDefinitionErrorType3[LexerDefinitionErrorType3["UNREACHABLE_PATTERN"] = 14] = "UNREACHABLE_PATTERN";
      LexerDefinitionErrorType3[LexerDefinitionErrorType3["IDENTIFY_TERMINATOR"] = 15] = "IDENTIFY_TERMINATOR";
      LexerDefinitionErrorType3[LexerDefinitionErrorType3["CUSTOM_LINE_BREAK"] = 16] = "CUSTOM_LINE_BREAK";
      LexerDefinitionErrorType3[LexerDefinitionErrorType3["MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE"] = 17] = "MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE";
    })(LexerDefinitionErrorType2 = exports2.LexerDefinitionErrorType || (exports2.LexerDefinitionErrorType = {}));
    var DEFAULT_LEXER_CONFIG = {
      deferDefinitionErrorsHandling: false,
      positionTracking: "full",
      lineTerminatorsPattern: /\n|\r\n?/g,
      lineTerminatorCharacters: ["\n", "\r"],
      ensureOptimizations: false,
      safeMode: false,
      errorMessageProvider: lexer_errors_public_1.defaultLexerErrorProvider,
      traceInitPerf: false,
      skipValidations: false,
      recoveryEnabled: true
    };
    Object.freeze(DEFAULT_LEXER_CONFIG);
    var Lexer2 = (
      /** @class */
      function() {
        function Lexer3(lexerDefinition, config3) {
          if (config3 === void 0) {
            config3 = DEFAULT_LEXER_CONFIG;
          }
          var _this = this;
          this.lexerDefinition = lexerDefinition;
          this.lexerDefinitionErrors = [];
          this.lexerDefinitionWarning = [];
          this.patternIdxToConfig = {};
          this.charCodeToPatternIdxToConfig = {};
          this.modes = [];
          this.emptyGroups = {};
          this.trackStartLines = true;
          this.trackEndLines = true;
          this.hasCustom = false;
          this.canModeBeOptimized = {};
          this.TRACE_INIT = function(phaseDesc, phaseImpl) {
            if (_this.traceInitPerf === true) {
              _this.traceInitIndent++;
              var indent = new Array(_this.traceInitIndent + 1).join("	");
              if (_this.traceInitIndent < _this.traceInitMaxIdent) {
                console.log("".concat(indent, "--> <").concat(phaseDesc, ">"));
              }
              var _a4 = (0, utils_1.timer)(phaseImpl), time = _a4.time, value = _a4.value;
              var traceMethod = time > 10 ? console.warn : console.log;
              if (_this.traceInitIndent < _this.traceInitMaxIdent) {
                traceMethod("".concat(indent, "<-- <").concat(phaseDesc, "> time: ").concat(time, "ms"));
              }
              _this.traceInitIndent--;
              return value;
            } else {
              return phaseImpl();
            }
          };
          if (typeof config3 === "boolean") {
            throw Error("The second argument to the Lexer constructor is now an ILexerConfig Object.\na boolean 2nd argument is no longer supported");
          }
          this.config = (0, assign_1.default)({}, DEFAULT_LEXER_CONFIG, config3);
          var traceInitVal = this.config.traceInitPerf;
          if (traceInitVal === true) {
            this.traceInitMaxIdent = Infinity;
            this.traceInitPerf = true;
          } else if (typeof traceInitVal === "number") {
            this.traceInitMaxIdent = traceInitVal;
            this.traceInitPerf = true;
          }
          this.traceInitIndent = -1;
          this.TRACE_INIT("Lexer Constructor", function() {
            var actualDefinition;
            var hasOnlySingleMode = true;
            _this.TRACE_INIT("Lexer Config handling", function() {
              if (_this.config.lineTerminatorsPattern === DEFAULT_LEXER_CONFIG.lineTerminatorsPattern) {
                _this.config.lineTerminatorsPattern = lexer_1.LineTerminatorOptimizedTester;
              } else {
                if (_this.config.lineTerminatorCharacters === DEFAULT_LEXER_CONFIG.lineTerminatorCharacters) {
                  throw Error("Error: Missing <lineTerminatorCharacters> property on the Lexer config.\n	For details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#MISSING_LINE_TERM_CHARS");
                }
              }
              if (config3.safeMode && config3.ensureOptimizations) {
                throw Error('"safeMode" and "ensureOptimizations" flags are mutually exclusive.');
              }
              _this.trackStartLines = /full|onlyStart/i.test(_this.config.positionTracking);
              _this.trackEndLines = /full/i.test(_this.config.positionTracking);
              if ((0, isArray_1.default)(lexerDefinition)) {
                actualDefinition = {
                  modes: { defaultMode: (0, clone_1.default)(lexerDefinition) },
                  defaultMode: lexer_1.DEFAULT_MODE
                };
              } else {
                hasOnlySingleMode = false;
                actualDefinition = (0, clone_1.default)(lexerDefinition);
              }
            });
            if (_this.config.skipValidations === false) {
              _this.TRACE_INIT("performRuntimeChecks", function() {
                _this.lexerDefinitionErrors = _this.lexerDefinitionErrors.concat((0, lexer_1.performRuntimeChecks)(actualDefinition, _this.trackStartLines, _this.config.lineTerminatorCharacters));
              });
              _this.TRACE_INIT("performWarningRuntimeChecks", function() {
                _this.lexerDefinitionWarning = _this.lexerDefinitionWarning.concat((0, lexer_1.performWarningRuntimeChecks)(actualDefinition, _this.trackStartLines, _this.config.lineTerminatorCharacters));
              });
            }
            actualDefinition.modes = actualDefinition.modes ? actualDefinition.modes : {};
            (0, forEach_1.default)(actualDefinition.modes, function(currModeValue, currModeName) {
              actualDefinition.modes[currModeName] = (0, reject_1.default)(currModeValue, function(currTokType) {
                return (0, isUndefined_1.default)(currTokType);
              });
            });
            var allModeNames = (0, keys_1.default)(actualDefinition.modes);
            (0, forEach_1.default)(actualDefinition.modes, function(currModDef, currModName) {
              _this.TRACE_INIT("Mode: <".concat(currModName, "> processing"), function() {
                _this.modes.push(currModName);
                if (_this.config.skipValidations === false) {
                  _this.TRACE_INIT("validatePatterns", function() {
                    _this.lexerDefinitionErrors = _this.lexerDefinitionErrors.concat((0, lexer_1.validatePatterns)(currModDef, allModeNames));
                  });
                }
                if ((0, isEmpty_1.default)(_this.lexerDefinitionErrors)) {
                  (0, tokens_1.augmentTokenTypes)(currModDef);
                  var currAnalyzeResult_1;
                  _this.TRACE_INIT("analyzeTokenTypes", function() {
                    currAnalyzeResult_1 = (0, lexer_1.analyzeTokenTypes)(currModDef, {
                      lineTerminatorCharacters: _this.config.lineTerminatorCharacters,
                      positionTracking: config3.positionTracking,
                      ensureOptimizations: config3.ensureOptimizations,
                      safeMode: config3.safeMode,
                      tracer: _this.TRACE_INIT
                    });
                  });
                  _this.patternIdxToConfig[currModName] = currAnalyzeResult_1.patternIdxToConfig;
                  _this.charCodeToPatternIdxToConfig[currModName] = currAnalyzeResult_1.charCodeToPatternIdxToConfig;
                  _this.emptyGroups = (0, assign_1.default)({}, _this.emptyGroups, currAnalyzeResult_1.emptyGroups);
                  _this.hasCustom = currAnalyzeResult_1.hasCustom || _this.hasCustom;
                  _this.canModeBeOptimized[currModName] = currAnalyzeResult_1.canBeOptimized;
                }
              });
            });
            _this.defaultMode = actualDefinition.defaultMode;
            if (!(0, isEmpty_1.default)(_this.lexerDefinitionErrors) && !_this.config.deferDefinitionErrorsHandling) {
              var allErrMessages = (0, map_1.default)(_this.lexerDefinitionErrors, function(error) {
                return error.message;
              });
              var allErrMessagesString = allErrMessages.join("-----------------------\n");
              throw new Error("Errors detected in definition of Lexer:\n" + allErrMessagesString);
            }
            (0, forEach_1.default)(_this.lexerDefinitionWarning, function(warningDescriptor) {
              (0, utils_1.PRINT_WARNING)(warningDescriptor.message);
            });
            _this.TRACE_INIT("Choosing sub-methods implementations", function() {
              if (lexer_1.SUPPORT_STICKY) {
                _this.chopInput = identity_1.default;
                _this.match = _this.matchWithTest;
              } else {
                _this.updateLastIndex = noop_1.default;
                _this.match = _this.matchWithExec;
              }
              if (hasOnlySingleMode) {
                _this.handleModes = noop_1.default;
              }
              if (_this.trackStartLines === false) {
                _this.computeNewColumn = identity_1.default;
              }
              if (_this.trackEndLines === false) {
                _this.updateTokenEndLineColumnLocation = noop_1.default;
              }
              if (/full/i.test(_this.config.positionTracking)) {
                _this.createTokenInstance = _this.createFullToken;
              } else if (/onlyStart/i.test(_this.config.positionTracking)) {
                _this.createTokenInstance = _this.createStartOnlyToken;
              } else if (/onlyOffset/i.test(_this.config.positionTracking)) {
                _this.createTokenInstance = _this.createOffsetOnlyToken;
              } else {
                throw Error('Invalid <positionTracking> config option: "'.concat(_this.config.positionTracking, '"'));
              }
              if (_this.hasCustom) {
                _this.addToken = _this.addTokenUsingPush;
                _this.handlePayload = _this.handlePayloadWithCustom;
              } else {
                _this.addToken = _this.addTokenUsingMemberAccess;
                _this.handlePayload = _this.handlePayloadNoCustom;
              }
            });
            _this.TRACE_INIT("Failed Optimization Warnings", function() {
              var unOptimizedModes = (0, reduce_1.default)(_this.canModeBeOptimized, function(cannotBeOptimized, canBeOptimized, modeName) {
                if (canBeOptimized === false) {
                  cannotBeOptimized.push(modeName);
                }
                return cannotBeOptimized;
              }, []);
              if (config3.ensureOptimizations && !(0, isEmpty_1.default)(unOptimizedModes)) {
                throw Error("Lexer Modes: < ".concat(unOptimizedModes.join(", "), " > cannot be optimized.\n") + '	 Disable the "ensureOptimizations" lexer config flag to silently ignore this and run the lexer in an un-optimized mode.\n	 Or inspect the console log for details on how to resolve these issues.');
              }
            });
            _this.TRACE_INIT("clearRegExpParserCache", function() {
              (0, reg_exp_parser_1.clearRegExpParserCache)();
            });
            _this.TRACE_INIT("toFastProperties", function() {
              (0, utils_1.toFastProperties)(_this);
            });
          });
        }
        Lexer3.prototype.tokenize = function(text, initialMode) {
          if (initialMode === void 0) {
            initialMode = this.defaultMode;
          }
          if (!(0, isEmpty_1.default)(this.lexerDefinitionErrors)) {
            var allErrMessages = (0, map_1.default)(this.lexerDefinitionErrors, function(error) {
              return error.message;
            });
            var allErrMessagesString = allErrMessages.join("-----------------------\n");
            throw new Error("Unable to Tokenize because Errors detected in definition of Lexer:\n" + allErrMessagesString);
          }
          return this.tokenizeInternal(text, initialMode);
        };
        Lexer3.prototype.tokenizeInternal = function(text, initialMode) {
          var _this = this;
          var i3, j, k, matchAltImage, longerAlt, matchedImage, payload, altPayload, imageLength, group, tokType, newToken, errLength, droppedChar, msg, match;
          var orgText = text;
          var orgLength = orgText.length;
          var offset = 0;
          var matchedTokensIndex = 0;
          var guessedNumberOfTokens = this.hasCustom ? 0 : Math.floor(text.length / 10);
          var matchedTokens = new Array(guessedNumberOfTokens);
          var errors = [];
          var line2 = this.trackStartLines ? 1 : void 0;
          var column = this.trackStartLines ? 1 : void 0;
          var groups = (0, lexer_1.cloneEmptyGroups)(this.emptyGroups);
          var trackLines = this.trackStartLines;
          var lineTerminatorPattern = this.config.lineTerminatorsPattern;
          var currModePatternsLength = 0;
          var patternIdxToConfig = [];
          var currCharCodeToPatternIdxToConfig = [];
          var modeStack = [];
          var emptyArray = [];
          Object.freeze(emptyArray);
          var getPossiblePatterns;
          function getPossiblePatternsSlow() {
            return patternIdxToConfig;
          }
          function getPossiblePatternsOptimized(charCode) {
            var optimizedCharIdx = (0, lexer_1.charCodeToOptimizedIndex)(charCode);
            var possiblePatterns = currCharCodeToPatternIdxToConfig[optimizedCharIdx];
            if (possiblePatterns === void 0) {
              return emptyArray;
            } else {
              return possiblePatterns;
            }
          }
          var pop_mode = function(popToken) {
            if (modeStack.length === 1 && // if we have both a POP_MODE and a PUSH_MODE this is in-fact a "transition"
            // So no error should occur.
            popToken.tokenType.PUSH_MODE === void 0) {
              var msg_1 = _this.config.errorMessageProvider.buildUnableToPopLexerModeMessage(popToken);
              errors.push({
                offset: popToken.startOffset,
                line: popToken.startLine,
                column: popToken.startColumn,
                length: popToken.image.length,
                message: msg_1
              });
            } else {
              modeStack.pop();
              var newMode = (0, last_1.default)(modeStack);
              patternIdxToConfig = _this.patternIdxToConfig[newMode];
              currCharCodeToPatternIdxToConfig = _this.charCodeToPatternIdxToConfig[newMode];
              currModePatternsLength = patternIdxToConfig.length;
              var modeCanBeOptimized = _this.canModeBeOptimized[newMode] && _this.config.safeMode === false;
              if (currCharCodeToPatternIdxToConfig && modeCanBeOptimized) {
                getPossiblePatterns = getPossiblePatternsOptimized;
              } else {
                getPossiblePatterns = getPossiblePatternsSlow;
              }
            }
          };
          function push_mode(newMode) {
            modeStack.push(newMode);
            currCharCodeToPatternIdxToConfig = this.charCodeToPatternIdxToConfig[newMode];
            patternIdxToConfig = this.patternIdxToConfig[newMode];
            currModePatternsLength = patternIdxToConfig.length;
            currModePatternsLength = patternIdxToConfig.length;
            var modeCanBeOptimized = this.canModeBeOptimized[newMode] && this.config.safeMode === false;
            if (currCharCodeToPatternIdxToConfig && modeCanBeOptimized) {
              getPossiblePatterns = getPossiblePatternsOptimized;
            } else {
              getPossiblePatterns = getPossiblePatternsSlow;
            }
          }
          push_mode.call(this, initialMode);
          var currConfig;
          var recoveryEnabled = this.config.recoveryEnabled;
          while (offset < orgLength) {
            matchedImage = null;
            var nextCharCode = orgText.charCodeAt(offset);
            var chosenPatternIdxToConfig = getPossiblePatterns(nextCharCode);
            var chosenPatternsLength = chosenPatternIdxToConfig.length;
            for (i3 = 0; i3 < chosenPatternsLength; i3++) {
              currConfig = chosenPatternIdxToConfig[i3];
              var currPattern = currConfig.pattern;
              payload = null;
              var singleCharCode = currConfig.short;
              if (singleCharCode !== false) {
                if (nextCharCode === singleCharCode) {
                  matchedImage = currPattern;
                }
              } else if (currConfig.isCustom === true) {
                match = currPattern.exec(orgText, offset, matchedTokens, groups);
                if (match !== null) {
                  matchedImage = match[0];
                  if (match.payload !== void 0) {
                    payload = match.payload;
                  }
                } else {
                  matchedImage = null;
                }
              } else {
                this.updateLastIndex(currPattern, offset);
                matchedImage = this.match(currPattern, text, offset);
              }
              if (matchedImage !== null) {
                longerAlt = currConfig.longerAlt;
                if (longerAlt !== void 0) {
                  var longerAltLength = longerAlt.length;
                  for (k = 0; k < longerAltLength; k++) {
                    var longerAltConfig = patternIdxToConfig[longerAlt[k]];
                    var longerAltPattern = longerAltConfig.pattern;
                    altPayload = null;
                    if (longerAltConfig.isCustom === true) {
                      match = longerAltPattern.exec(orgText, offset, matchedTokens, groups);
                      if (match !== null) {
                        matchAltImage = match[0];
                        if (match.payload !== void 0) {
                          altPayload = match.payload;
                        }
                      } else {
                        matchAltImage = null;
                      }
                    } else {
                      this.updateLastIndex(longerAltPattern, offset);
                      matchAltImage = this.match(longerAltPattern, text, offset);
                    }
                    if (matchAltImage && matchAltImage.length > matchedImage.length) {
                      matchedImage = matchAltImage;
                      payload = altPayload;
                      currConfig = longerAltConfig;
                      break;
                    }
                  }
                }
                break;
              }
            }
            if (matchedImage !== null) {
              imageLength = matchedImage.length;
              group = currConfig.group;
              if (group !== void 0) {
                tokType = currConfig.tokenTypeIdx;
                newToken = this.createTokenInstance(matchedImage, offset, tokType, currConfig.tokenType, line2, column, imageLength);
                this.handlePayload(newToken, payload);
                if (group === false) {
                  matchedTokensIndex = this.addToken(matchedTokens, matchedTokensIndex, newToken);
                } else {
                  groups[group].push(newToken);
                }
              }
              text = this.chopInput(text, imageLength);
              offset = offset + imageLength;
              column = this.computeNewColumn(column, imageLength);
              if (trackLines === true && currConfig.canLineTerminator === true) {
                var numOfLTsInMatch = 0;
                var foundTerminator = void 0;
                var lastLTEndOffset = void 0;
                lineTerminatorPattern.lastIndex = 0;
                do {
                  foundTerminator = lineTerminatorPattern.test(matchedImage);
                  if (foundTerminator === true) {
                    lastLTEndOffset = lineTerminatorPattern.lastIndex - 1;
                    numOfLTsInMatch++;
                  }
                } while (foundTerminator === true);
                if (numOfLTsInMatch !== 0) {
                  line2 = line2 + numOfLTsInMatch;
                  column = imageLength - lastLTEndOffset;
                  this.updateTokenEndLineColumnLocation(newToken, group, lastLTEndOffset, numOfLTsInMatch, line2, column, imageLength);
                }
              }
              this.handleModes(currConfig, pop_mode, push_mode, newToken);
            } else {
              var errorStartOffset = offset;
              var errorLine = line2;
              var errorColumn = column;
              var foundResyncPoint = recoveryEnabled === false;
              while (foundResyncPoint === false && offset < orgLength) {
                text = this.chopInput(text, 1);
                offset++;
                for (j = 0; j < currModePatternsLength; j++) {
                  var currConfig_1 = patternIdxToConfig[j];
                  var currPattern = currConfig_1.pattern;
                  var singleCharCode = currConfig_1.short;
                  if (singleCharCode !== false) {
                    if (orgText.charCodeAt(offset) === singleCharCode) {
                      foundResyncPoint = true;
                    }
                  } else if (currConfig_1.isCustom === true) {
                    foundResyncPoint = currPattern.exec(orgText, offset, matchedTokens, groups) !== null;
                  } else {
                    this.updateLastIndex(currPattern, offset);
                    foundResyncPoint = currPattern.exec(text) !== null;
                  }
                  if (foundResyncPoint === true) {
                    break;
                  }
                }
              }
              errLength = offset - errorStartOffset;
              msg = this.config.errorMessageProvider.buildUnexpectedCharactersMessage(orgText, errorStartOffset, errLength, errorLine, errorColumn);
              errors.push({
                offset: errorStartOffset,
                line: errorLine,
                column: errorColumn,
                length: errLength,
                message: msg
              });
              if (recoveryEnabled === false) {
                break;
              }
            }
          }
          if (!this.hasCustom) {
            matchedTokens.length = matchedTokensIndex;
          }
          return {
            tokens: matchedTokens,
            groups,
            errors
          };
        };
        Lexer3.prototype.handleModes = function(config3, pop_mode, push_mode, newToken) {
          if (config3.pop === true) {
            var pushMode = config3.push;
            pop_mode(newToken);
            if (pushMode !== void 0) {
              push_mode.call(this, pushMode);
            }
          } else if (config3.push !== void 0) {
            push_mode.call(this, config3.push);
          }
        };
        Lexer3.prototype.chopInput = function(text, length) {
          return text.substring(length);
        };
        Lexer3.prototype.updateLastIndex = function(regExp, newLastIndex) {
          regExp.lastIndex = newLastIndex;
        };
        Lexer3.prototype.updateTokenEndLineColumnLocation = function(newToken, group, lastLTIdx, numOfLTsInMatch, line2, column, imageLength) {
          var lastCharIsLT, fixForEndingInLT;
          if (group !== void 0) {
            lastCharIsLT = lastLTIdx === imageLength - 1;
            fixForEndingInLT = lastCharIsLT ? -1 : 0;
            if (!(numOfLTsInMatch === 1 && lastCharIsLT === true)) {
              newToken.endLine = line2 + fixForEndingInLT;
              newToken.endColumn = column - 1 + -fixForEndingInLT;
            }
          }
        };
        Lexer3.prototype.computeNewColumn = function(oldColumn, imageLength) {
          return oldColumn + imageLength;
        };
        Lexer3.prototype.createOffsetOnlyToken = function(image, startOffset, tokenTypeIdx, tokenType) {
          return {
            image,
            startOffset,
            tokenTypeIdx,
            tokenType
          };
        };
        Lexer3.prototype.createStartOnlyToken = function(image, startOffset, tokenTypeIdx, tokenType, startLine, startColumn) {
          return {
            image,
            startOffset,
            startLine,
            startColumn,
            tokenTypeIdx,
            tokenType
          };
        };
        Lexer3.prototype.createFullToken = function(image, startOffset, tokenTypeIdx, tokenType, startLine, startColumn, imageLength) {
          return {
            image,
            startOffset,
            endOffset: startOffset + imageLength - 1,
            startLine,
            endLine: startLine,
            startColumn,
            endColumn: startColumn + imageLength - 1,
            tokenTypeIdx,
            tokenType
          };
        };
        Lexer3.prototype.addTokenUsingPush = function(tokenVector, index, tokenToAdd) {
          tokenVector.push(tokenToAdd);
          return index;
        };
        Lexer3.prototype.addTokenUsingMemberAccess = function(tokenVector, index, tokenToAdd) {
          tokenVector[index] = tokenToAdd;
          index++;
          return index;
        };
        Lexer3.prototype.handlePayloadNoCustom = function(token, payload) {
        };
        Lexer3.prototype.handlePayloadWithCustom = function(token, payload) {
          if (payload !== null) {
            token.payload = payload;
          }
        };
        Lexer3.prototype.matchWithTest = function(pattern, text, offset) {
          var found = pattern.test(text);
          if (found === true) {
            return text.substring(offset, pattern.lastIndex);
          }
          return null;
        };
        Lexer3.prototype.matchWithExec = function(pattern, text) {
          var regExpArray = pattern.exec(text);
          return regExpArray !== null ? regExpArray[0] : null;
        };
        Lexer3.SKIPPED = "This marks a skipped Token pattern, this means each token identified by it willbe consumed and then thrown into oblivion, this can be used to for example to completely ignore whitespace.";
        Lexer3.NA = /NOT_APPLICABLE/;
        return Lexer3;
      }()
    );
    exports2.Lexer = Lexer2;
  }
});

// node_modules/chevrotain/lib/src/scan/tokens_public.js
var require_tokens_public = __commonJS({
  "node_modules/chevrotain/lib/src/scan/tokens_public.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.tokenMatcher = exports2.createTokenInstance = exports2.EOF = exports2.createToken = exports2.hasTokenLabel = exports2.tokenName = exports2.tokenLabel = void 0;
    var isString_1 = __importDefault(require_isString());
    var has_1 = __importDefault(require_has());
    var isUndefined_1 = __importDefault(require_isUndefined());
    var lexer_public_1 = require_lexer_public();
    var tokens_1 = require_tokens();
    function tokenLabel2(tokType) {
      if (hasTokenLabel(tokType)) {
        return tokType.LABEL;
      } else {
        return tokType.name;
      }
    }
    exports2.tokenLabel = tokenLabel2;
    function tokenName2(tokType) {
      return tokType.name;
    }
    exports2.tokenName = tokenName2;
    function hasTokenLabel(obj) {
      return (0, isString_1.default)(obj.LABEL) && obj.LABEL !== "";
    }
    exports2.hasTokenLabel = hasTokenLabel;
    var PARENT = "parent";
    var CATEGORIES = "categories";
    var LABEL = "label";
    var GROUP = "group";
    var PUSH_MODE = "push_mode";
    var POP_MODE = "pop_mode";
    var LONGER_ALT = "longer_alt";
    var LINE_BREAKS = "line_breaks";
    var START_CHARS_HINT = "start_chars_hint";
    function createToken2(config3) {
      return createTokenInternal(config3);
    }
    exports2.createToken = createToken2;
    function createTokenInternal(config3) {
      var pattern = config3.pattern;
      var tokenType = {};
      tokenType.name = config3.name;
      if (!(0, isUndefined_1.default)(pattern)) {
        tokenType.PATTERN = pattern;
      }
      if ((0, has_1.default)(config3, PARENT)) {
        throw "The parent property is no longer supported.\nSee: https://github.com/chevrotain/chevrotain/issues/564#issuecomment-349062346 for details.";
      }
      if ((0, has_1.default)(config3, CATEGORIES)) {
        tokenType.CATEGORIES = config3[CATEGORIES];
      }
      (0, tokens_1.augmentTokenTypes)([tokenType]);
      if ((0, has_1.default)(config3, LABEL)) {
        tokenType.LABEL = config3[LABEL];
      }
      if ((0, has_1.default)(config3, GROUP)) {
        tokenType.GROUP = config3[GROUP];
      }
      if ((0, has_1.default)(config3, POP_MODE)) {
        tokenType.POP_MODE = config3[POP_MODE];
      }
      if ((0, has_1.default)(config3, PUSH_MODE)) {
        tokenType.PUSH_MODE = config3[PUSH_MODE];
      }
      if ((0, has_1.default)(config3, LONGER_ALT)) {
        tokenType.LONGER_ALT = config3[LONGER_ALT];
      }
      if ((0, has_1.default)(config3, LINE_BREAKS)) {
        tokenType.LINE_BREAKS = config3[LINE_BREAKS];
      }
      if ((0, has_1.default)(config3, START_CHARS_HINT)) {
        tokenType.START_CHARS_HINT = config3[START_CHARS_HINT];
      }
      return tokenType;
    }
    exports2.EOF = createToken2({ name: "EOF", pattern: lexer_public_1.Lexer.NA });
    (0, tokens_1.augmentTokenTypes)([exports2.EOF]);
    function createTokenInstance2(tokType, image, startOffset, endOffset, startLine, endLine, startColumn, endColumn) {
      return {
        image,
        startOffset,
        endOffset,
        startLine,
        endLine,
        startColumn,
        endColumn,
        tokenTypeIdx: tokType.tokenTypeIdx,
        tokenType: tokType
      };
    }
    exports2.createTokenInstance = createTokenInstance2;
    function tokenMatcher2(token, tokType) {
      return (0, tokens_1.tokenStructuredMatcher)(token, tokType);
    }
    exports2.tokenMatcher = tokenMatcher2;
  }
});

// node_modules/chevrotain/lib/src/parse/errors_public.js
var require_errors_public = __commonJS({
  "node_modules/chevrotain/lib/src/parse/errors_public.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.defaultGrammarValidatorErrorProvider = exports2.defaultGrammarResolverErrorProvider = exports2.defaultParserErrorProvider = void 0;
    var tokens_public_1 = require_tokens_public();
    var first_1 = __importDefault(require_first2());
    var map_1 = __importDefault(require_map());
    var reduce_1 = __importDefault(require_reduce());
    var gast_1 = require_api2();
    var gast_2 = require_api2();
    exports2.defaultParserErrorProvider = {
      buildMismatchTokenMessage: function(_a4) {
        var expected = _a4.expected, actual = _a4.actual, previous = _a4.previous, ruleName = _a4.ruleName;
        var hasLabel = (0, tokens_public_1.hasTokenLabel)(expected);
        var expectedMsg = hasLabel ? "--> ".concat((0, tokens_public_1.tokenLabel)(expected), " <--") : "token of type --> ".concat(expected.name, " <--");
        var msg = "Expecting ".concat(expectedMsg, " but found --> '").concat(actual.image, "' <--");
        return msg;
      },
      buildNotAllInputParsedMessage: function(_a4) {
        var firstRedundant = _a4.firstRedundant, ruleName = _a4.ruleName;
        return "Redundant input, expecting EOF but found: " + firstRedundant.image;
      },
      buildNoViableAltMessage: function(_a4) {
        var expectedPathsPerAlt = _a4.expectedPathsPerAlt, actual = _a4.actual, previous = _a4.previous, customUserDescription = _a4.customUserDescription, ruleName = _a4.ruleName;
        var errPrefix = "Expecting: ";
        var actualText = (0, first_1.default)(actual).image;
        var errSuffix = "\nbut found: '" + actualText + "'";
        if (customUserDescription) {
          return errPrefix + customUserDescription + errSuffix;
        } else {
          var allLookAheadPaths = (0, reduce_1.default)(expectedPathsPerAlt, function(result, currAltPaths) {
            return result.concat(currAltPaths);
          }, []);
          var nextValidTokenSequences = (0, map_1.default)(allLookAheadPaths, function(currPath) {
            return "[".concat((0, map_1.default)(currPath, function(currTokenType) {
              return (0, tokens_public_1.tokenLabel)(currTokenType);
            }).join(", "), "]");
          });
          var nextValidSequenceItems = (0, map_1.default)(nextValidTokenSequences, function(itemMsg, idx) {
            return "  ".concat(idx + 1, ". ").concat(itemMsg);
          });
          var calculatedDescription = "one of these possible Token sequences:\n".concat(nextValidSequenceItems.join("\n"));
          return errPrefix + calculatedDescription + errSuffix;
        }
      },
      buildEarlyExitMessage: function(_a4) {
        var expectedIterationPaths = _a4.expectedIterationPaths, actual = _a4.actual, customUserDescription = _a4.customUserDescription, ruleName = _a4.ruleName;
        var errPrefix = "Expecting: ";
        var actualText = (0, first_1.default)(actual).image;
        var errSuffix = "\nbut found: '" + actualText + "'";
        if (customUserDescription) {
          return errPrefix + customUserDescription + errSuffix;
        } else {
          var nextValidTokenSequences = (0, map_1.default)(expectedIterationPaths, function(currPath) {
            return "[".concat((0, map_1.default)(currPath, function(currTokenType) {
              return (0, tokens_public_1.tokenLabel)(currTokenType);
            }).join(","), "]");
          });
          var calculatedDescription = "expecting at least one iteration which starts with one of these possible Token sequences::\n  " + "<".concat(nextValidTokenSequences.join(" ,"), ">");
          return errPrefix + calculatedDescription + errSuffix;
        }
      }
    };
    Object.freeze(exports2.defaultParserErrorProvider);
    exports2.defaultGrammarResolverErrorProvider = {
      buildRuleNotFoundError: function(topLevelRule, undefinedRule) {
        var msg = "Invalid grammar, reference to a rule which is not defined: ->" + undefinedRule.nonTerminalName + "<-\ninside top level rule: ->" + topLevelRule.name + "<-";
        return msg;
      }
    };
    exports2.defaultGrammarValidatorErrorProvider = {
      buildDuplicateFoundError: function(topLevelRule, duplicateProds) {
        function getExtraProductionArgument(prod) {
          if (prod instanceof gast_1.Terminal) {
            return prod.terminalType.name;
          } else if (prod instanceof gast_1.NonTerminal) {
            return prod.nonTerminalName;
          } else {
            return "";
          }
        }
        var topLevelName = topLevelRule.name;
        var duplicateProd = (0, first_1.default)(duplicateProds);
        var index = duplicateProd.idx;
        var dslName = (0, gast_2.getProductionDslName)(duplicateProd);
        var extraArgument = getExtraProductionArgument(duplicateProd);
        var hasExplicitIndex = index > 0;
        var msg = "->".concat(dslName).concat(hasExplicitIndex ? index : "", "<- ").concat(extraArgument ? "with argument: ->".concat(extraArgument, "<-") : "", "\n                  appears more than once (").concat(duplicateProds.length, " times) in the top level rule: ->").concat(topLevelName, "<-.                  \n                  For further details see: https://chevrotain.io/docs/FAQ.html#NUMERICAL_SUFFIXES \n                  ");
        msg = msg.replace(/[ \t]+/g, " ");
        msg = msg.replace(/\s\s+/g, "\n");
        return msg;
      },
      buildNamespaceConflictError: function(rule) {
        var errMsg = "Namespace conflict found in grammar.\n" + "The grammar has both a Terminal(Token) and a Non-Terminal(Rule) named: <".concat(rule.name, ">.\n") + "To resolve this make sure each Terminal and Non-Terminal names are unique\nThis is easy to accomplish by using the convention that Terminal names start with an uppercase letter\nand Non-Terminal names start with a lower case letter.";
        return errMsg;
      },
      buildAlternationPrefixAmbiguityError: function(options) {
        var pathMsg = (0, map_1.default)(options.prefixPath, function(currTok) {
          return (0, tokens_public_1.tokenLabel)(currTok);
        }).join(", ");
        var occurrence = options.alternation.idx === 0 ? "" : options.alternation.idx;
        var errMsg = "Ambiguous alternatives: <".concat(options.ambiguityIndices.join(" ,"), "> due to common lookahead prefix\n") + "in <OR".concat(occurrence, "> inside <").concat(options.topLevelRule.name, "> Rule,\n") + "<".concat(pathMsg, "> may appears as a prefix path in all these alternatives.\n") + "See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#COMMON_PREFIX\nFor Further details.";
        return errMsg;
      },
      buildAlternationAmbiguityError: function(options) {
        var pathMsg = (0, map_1.default)(options.prefixPath, function(currtok) {
          return (0, tokens_public_1.tokenLabel)(currtok);
        }).join(", ");
        var occurrence = options.alternation.idx === 0 ? "" : options.alternation.idx;
        var currMessage = "Ambiguous Alternatives Detected: <".concat(options.ambiguityIndices.join(" ,"), "> in <OR").concat(occurrence, ">") + " inside <".concat(options.topLevelRule.name, "> Rule,\n") + "<".concat(pathMsg, "> may appears as a prefix path in all these alternatives.\n");
        currMessage = currMessage + "See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#AMBIGUOUS_ALTERNATIVES\nFor Further details.";
        return currMessage;
      },
      buildEmptyRepetitionError: function(options) {
        var dslName = (0, gast_2.getProductionDslName)(options.repetition);
        if (options.repetition.idx !== 0) {
          dslName += options.repetition.idx;
        }
        var errMsg = "The repetition <".concat(dslName, "> within Rule <").concat(options.topLevelRule.name, "> can never consume any tokens.\n") + "This could lead to an infinite loop.";
        return errMsg;
      },
      // TODO: remove - `errors_public` from nyc.config.js exclude
      //       once this method is fully removed from this file
      buildTokenNameError: function(options) {
        return "deprecated";
      },
      buildEmptyAlternationError: function(options) {
        var errMsg = "Ambiguous empty alternative: <".concat(options.emptyChoiceIdx + 1, ">") + " in <OR".concat(options.alternation.idx, "> inside <").concat(options.topLevelRule.name, "> Rule.\n") + "Only the last alternative may be an empty alternative.";
        return errMsg;
      },
      buildTooManyAlternativesError: function(options) {
        var errMsg = "An Alternation cannot have more than 256 alternatives:\n" + "<OR".concat(options.alternation.idx, "> inside <").concat(options.topLevelRule.name, "> Rule.\n has ").concat(options.alternation.definition.length + 1, " alternatives.");
        return errMsg;
      },
      buildLeftRecursionError: function(options) {
        var ruleName = options.topLevelRule.name;
        var pathNames = (0, map_1.default)(options.leftRecursionPath, function(currRule) {
          return currRule.name;
        });
        var leftRecursivePath = "".concat(ruleName, " --> ").concat(pathNames.concat([ruleName]).join(" --> "));
        var errMsg = "Left Recursion found in grammar.\n" + "rule: <".concat(ruleName, "> can be invoked from itself (directly or indirectly)\n") + "without consuming any Tokens. The grammar path that causes this is: \n ".concat(leftRecursivePath, "\n") + " To fix this refactor your grammar to remove the left recursion.\nsee: https://en.wikipedia.org/wiki/LL_parser#Left_factoring.";
        return errMsg;
      },
      // TODO: remove - `errors_public` from nyc.config.js exclude
      //       once this method is fully removed from this file
      buildInvalidRuleNameError: function(options) {
        return "deprecated";
      },
      buildDuplicateRuleNameError: function(options) {
        var ruleName;
        if (options.topLevelRule instanceof gast_1.Rule) {
          ruleName = options.topLevelRule.name;
        } else {
          ruleName = options.topLevelRule;
        }
        var errMsg = "Duplicate definition, rule: ->".concat(ruleName, "<- is already defined in the grammar: ->").concat(options.grammarName, "<-");
        return errMsg;
      }
    };
  }
});

// node_modules/chevrotain/lib/src/parse/grammar/resolver.js
var require_resolver = __commonJS({
  "node_modules/chevrotain/lib/src/parse/grammar/resolver.js"(exports2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || function() {
      var extendStatics = function(d, b5) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b6) {
          d2.__proto__ = b6;
        } || function(d2, b6) {
          for (var p in b6)
            if (Object.prototype.hasOwnProperty.call(b6, p))
              d2[p] = b6[p];
        };
        return extendStatics(d, b5);
      };
      return function(d, b5) {
        if (typeof b5 !== "function" && b5 !== null)
          throw new TypeError("Class extends value " + String(b5) + " is not a constructor or null");
        extendStatics(d, b5);
        function __() {
          this.constructor = d;
        }
        d.prototype = b5 === null ? Object.create(b5) : (__.prototype = b5.prototype, new __());
      };
    }();
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.GastRefResolverVisitor = exports2.resolveGrammar = void 0;
    var parser_1 = require_parser();
    var forEach_1 = __importDefault(require_forEach());
    var values_1 = __importDefault(require_values());
    var gast_1 = require_api2();
    function resolveGrammar(topLevels, errMsgProvider) {
      var refResolver = new GastRefResolverVisitor(topLevels, errMsgProvider);
      refResolver.resolveRefs();
      return refResolver.errors;
    }
    exports2.resolveGrammar = resolveGrammar;
    var GastRefResolverVisitor = (
      /** @class */
      function(_super) {
        __extends(GastRefResolverVisitor2, _super);
        function GastRefResolverVisitor2(nameToTopRule, errMsgProvider) {
          var _this = _super.call(this) || this;
          _this.nameToTopRule = nameToTopRule;
          _this.errMsgProvider = errMsgProvider;
          _this.errors = [];
          return _this;
        }
        GastRefResolverVisitor2.prototype.resolveRefs = function() {
          var _this = this;
          (0, forEach_1.default)((0, values_1.default)(this.nameToTopRule), function(prod) {
            _this.currTopLevel = prod;
            prod.accept(_this);
          });
        };
        GastRefResolverVisitor2.prototype.visitNonTerminal = function(node) {
          var ref = this.nameToTopRule[node.nonTerminalName];
          if (!ref) {
            var msg = this.errMsgProvider.buildRuleNotFoundError(this.currTopLevel, node);
            this.errors.push({
              message: msg,
              type: parser_1.ParserDefinitionErrorType.UNRESOLVED_SUBRULE_REF,
              ruleName: this.currTopLevel.name,
              unresolvedRefName: node.nonTerminalName
            });
          } else {
            node.referencedRule = ref;
          }
        };
        return GastRefResolverVisitor2;
      }(gast_1.GAstVisitor)
    );
    exports2.GastRefResolverVisitor = GastRefResolverVisitor;
  }
});

// node_modules/lodash/_arrayAggregator.js
var require_arrayAggregator = __commonJS({
  "node_modules/lodash/_arrayAggregator.js"(exports2, module2) {
    function arrayAggregator(array, setter, iteratee, accumulator) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        var value = array[index];
        setter(accumulator, value, iteratee(value), array);
      }
      return accumulator;
    }
    module2.exports = arrayAggregator;
  }
});

// node_modules/lodash/_baseAggregator.js
var require_baseAggregator = __commonJS({
  "node_modules/lodash/_baseAggregator.js"(exports2, module2) {
    var baseEach = require_baseEach();
    function baseAggregator(collection, setter, iteratee, accumulator) {
      baseEach(collection, function(value, key, collection2) {
        setter(accumulator, value, iteratee(value), collection2);
      });
      return accumulator;
    }
    module2.exports = baseAggregator;
  }
});

// node_modules/lodash/_createAggregator.js
var require_createAggregator = __commonJS({
  "node_modules/lodash/_createAggregator.js"(exports2, module2) {
    var arrayAggregator = require_arrayAggregator();
    var baseAggregator = require_baseAggregator();
    var baseIteratee = require_baseIteratee();
    var isArray = require_isArray();
    function createAggregator(setter, initializer) {
      return function(collection, iteratee) {
        var func = isArray(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
        return func(collection, setter, baseIteratee(iteratee, 2), accumulator);
      };
    }
    module2.exports = createAggregator;
  }
});

// node_modules/lodash/groupBy.js
var require_groupBy = __commonJS({
  "node_modules/lodash/groupBy.js"(exports2, module2) {
    var baseAssignValue = require_baseAssignValue();
    var createAggregator = require_createAggregator();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var groupBy = createAggregator(function(result, value, key) {
      if (hasOwnProperty.call(result, key)) {
        result[key].push(value);
      } else {
        baseAssignValue(result, key, [value]);
      }
    });
    module2.exports = groupBy;
  }
});

// node_modules/lodash/flatMap.js
var require_flatMap = __commonJS({
  "node_modules/lodash/flatMap.js"(exports2, module2) {
    var baseFlatten = require_baseFlatten();
    var map2 = require_map();
    function flatMap(collection, iteratee) {
      return baseFlatten(map2(collection, iteratee), 1);
    }
    module2.exports = flatMap;
  }
});

// node_modules/lodash/dropRight.js
var require_dropRight = __commonJS({
  "node_modules/lodash/dropRight.js"(exports2, module2) {
    var baseSlice = require_baseSlice();
    var toInteger = require_toInteger();
    function dropRight(array, n, guard) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      n = guard || n === void 0 ? 1 : toInteger(n);
      n = length - n;
      return baseSlice(array, 0, n < 0 ? 0 : n);
    }
    module2.exports = dropRight;
  }
});

// node_modules/chevrotain/lib/src/parse/grammar/interpreter.js
var require_interpreter = __commonJS({
  "node_modules/chevrotain/lib/src/parse/grammar/interpreter.js"(exports2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || function() {
      var extendStatics = function(d, b5) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b6) {
          d2.__proto__ = b6;
        } || function(d2, b6) {
          for (var p in b6)
            if (Object.prototype.hasOwnProperty.call(b6, p))
              d2[p] = b6[p];
        };
        return extendStatics(d, b5);
      };
      return function(d, b5) {
        if (typeof b5 !== "function" && b5 !== null)
          throw new TypeError("Class extends value " + String(b5) + " is not a constructor or null");
        extendStatics(d, b5);
        function __() {
          this.constructor = d;
        }
        d.prototype = b5 === null ? Object.create(b5) : (__.prototype = b5.prototype, new __());
      };
    }();
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.nextPossibleTokensAfter = exports2.possiblePathsFrom = exports2.NextTerminalAfterAtLeastOneSepWalker = exports2.NextTerminalAfterAtLeastOneWalker = exports2.NextTerminalAfterManySepWalker = exports2.NextTerminalAfterManyWalker = exports2.AbstractNextTerminalAfterProductionWalker = exports2.NextAfterTokenWalker = exports2.AbstractNextPossibleTokensWalker = void 0;
    var rest_1 = require_rest();
    var first_1 = __importDefault(require_first2());
    var isEmpty_1 = __importDefault(require_isEmpty());
    var dropRight_1 = __importDefault(require_dropRight());
    var drop_1 = __importDefault(require_drop());
    var last_1 = __importDefault(require_last());
    var forEach_1 = __importDefault(require_forEach());
    var clone_1 = __importDefault(require_clone());
    var first_2 = require_first();
    var gast_1 = require_api2();
    var AbstractNextPossibleTokensWalker = (
      /** @class */
      function(_super) {
        __extends(AbstractNextPossibleTokensWalker2, _super);
        function AbstractNextPossibleTokensWalker2(topProd, path) {
          var _this = _super.call(this) || this;
          _this.topProd = topProd;
          _this.path = path;
          _this.possibleTokTypes = [];
          _this.nextProductionName = "";
          _this.nextProductionOccurrence = 0;
          _this.found = false;
          _this.isAtEndOfPath = false;
          return _this;
        }
        AbstractNextPossibleTokensWalker2.prototype.startWalking = function() {
          this.found = false;
          if (this.path.ruleStack[0] !== this.topProd.name) {
            throw Error("The path does not start with the walker's top Rule!");
          }
          this.ruleStack = (0, clone_1.default)(this.path.ruleStack).reverse();
          this.occurrenceStack = (0, clone_1.default)(this.path.occurrenceStack).reverse();
          this.ruleStack.pop();
          this.occurrenceStack.pop();
          this.updateExpectedNext();
          this.walk(this.topProd);
          return this.possibleTokTypes;
        };
        AbstractNextPossibleTokensWalker2.prototype.walk = function(prod, prevRest) {
          if (prevRest === void 0) {
            prevRest = [];
          }
          if (!this.found) {
            _super.prototype.walk.call(this, prod, prevRest);
          }
        };
        AbstractNextPossibleTokensWalker2.prototype.walkProdRef = function(refProd, currRest, prevRest) {
          if (refProd.referencedRule.name === this.nextProductionName && refProd.idx === this.nextProductionOccurrence) {
            var fullRest = currRest.concat(prevRest);
            this.updateExpectedNext();
            this.walk(refProd.referencedRule, fullRest);
          }
        };
        AbstractNextPossibleTokensWalker2.prototype.updateExpectedNext = function() {
          if ((0, isEmpty_1.default)(this.ruleStack)) {
            this.nextProductionName = "";
            this.nextProductionOccurrence = 0;
            this.isAtEndOfPath = true;
          } else {
            this.nextProductionName = this.ruleStack.pop();
            this.nextProductionOccurrence = this.occurrenceStack.pop();
          }
        };
        return AbstractNextPossibleTokensWalker2;
      }(rest_1.RestWalker)
    );
    exports2.AbstractNextPossibleTokensWalker = AbstractNextPossibleTokensWalker;
    var NextAfterTokenWalker = (
      /** @class */
      function(_super) {
        __extends(NextAfterTokenWalker2, _super);
        function NextAfterTokenWalker2(topProd, path) {
          var _this = _super.call(this, topProd, path) || this;
          _this.path = path;
          _this.nextTerminalName = "";
          _this.nextTerminalOccurrence = 0;
          _this.nextTerminalName = _this.path.lastTok.name;
          _this.nextTerminalOccurrence = _this.path.lastTokOccurrence;
          return _this;
        }
        NextAfterTokenWalker2.prototype.walkTerminal = function(terminal, currRest, prevRest) {
          if (this.isAtEndOfPath && terminal.terminalType.name === this.nextTerminalName && terminal.idx === this.nextTerminalOccurrence && !this.found) {
            var fullRest = currRest.concat(prevRest);
            var restProd = new gast_1.Alternative({ definition: fullRest });
            this.possibleTokTypes = (0, first_2.first)(restProd);
            this.found = true;
          }
        };
        return NextAfterTokenWalker2;
      }(AbstractNextPossibleTokensWalker)
    );
    exports2.NextAfterTokenWalker = NextAfterTokenWalker;
    var AbstractNextTerminalAfterProductionWalker = (
      /** @class */
      function(_super) {
        __extends(AbstractNextTerminalAfterProductionWalker2, _super);
        function AbstractNextTerminalAfterProductionWalker2(topRule, occurrence) {
          var _this = _super.call(this) || this;
          _this.topRule = topRule;
          _this.occurrence = occurrence;
          _this.result = {
            token: void 0,
            occurrence: void 0,
            isEndOfRule: void 0
          };
          return _this;
        }
        AbstractNextTerminalAfterProductionWalker2.prototype.startWalking = function() {
          this.walk(this.topRule);
          return this.result;
        };
        return AbstractNextTerminalAfterProductionWalker2;
      }(rest_1.RestWalker)
    );
    exports2.AbstractNextTerminalAfterProductionWalker = AbstractNextTerminalAfterProductionWalker;
    var NextTerminalAfterManyWalker = (
      /** @class */
      function(_super) {
        __extends(NextTerminalAfterManyWalker2, _super);
        function NextTerminalAfterManyWalker2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        NextTerminalAfterManyWalker2.prototype.walkMany = function(manyProd, currRest, prevRest) {
          if (manyProd.idx === this.occurrence) {
            var firstAfterMany = (0, first_1.default)(currRest.concat(prevRest));
            this.result.isEndOfRule = firstAfterMany === void 0;
            if (firstAfterMany instanceof gast_1.Terminal) {
              this.result.token = firstAfterMany.terminalType;
              this.result.occurrence = firstAfterMany.idx;
            }
          } else {
            _super.prototype.walkMany.call(this, manyProd, currRest, prevRest);
          }
        };
        return NextTerminalAfterManyWalker2;
      }(AbstractNextTerminalAfterProductionWalker)
    );
    exports2.NextTerminalAfterManyWalker = NextTerminalAfterManyWalker;
    var NextTerminalAfterManySepWalker = (
      /** @class */
      function(_super) {
        __extends(NextTerminalAfterManySepWalker2, _super);
        function NextTerminalAfterManySepWalker2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        NextTerminalAfterManySepWalker2.prototype.walkManySep = function(manySepProd, currRest, prevRest) {
          if (manySepProd.idx === this.occurrence) {
            var firstAfterManySep = (0, first_1.default)(currRest.concat(prevRest));
            this.result.isEndOfRule = firstAfterManySep === void 0;
            if (firstAfterManySep instanceof gast_1.Terminal) {
              this.result.token = firstAfterManySep.terminalType;
              this.result.occurrence = firstAfterManySep.idx;
            }
          } else {
            _super.prototype.walkManySep.call(this, manySepProd, currRest, prevRest);
          }
        };
        return NextTerminalAfterManySepWalker2;
      }(AbstractNextTerminalAfterProductionWalker)
    );
    exports2.NextTerminalAfterManySepWalker = NextTerminalAfterManySepWalker;
    var NextTerminalAfterAtLeastOneWalker = (
      /** @class */
      function(_super) {
        __extends(NextTerminalAfterAtLeastOneWalker2, _super);
        function NextTerminalAfterAtLeastOneWalker2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        NextTerminalAfterAtLeastOneWalker2.prototype.walkAtLeastOne = function(atLeastOneProd, currRest, prevRest) {
          if (atLeastOneProd.idx === this.occurrence) {
            var firstAfterAtLeastOne = (0, first_1.default)(currRest.concat(prevRest));
            this.result.isEndOfRule = firstAfterAtLeastOne === void 0;
            if (firstAfterAtLeastOne instanceof gast_1.Terminal) {
              this.result.token = firstAfterAtLeastOne.terminalType;
              this.result.occurrence = firstAfterAtLeastOne.idx;
            }
          } else {
            _super.prototype.walkAtLeastOne.call(this, atLeastOneProd, currRest, prevRest);
          }
        };
        return NextTerminalAfterAtLeastOneWalker2;
      }(AbstractNextTerminalAfterProductionWalker)
    );
    exports2.NextTerminalAfterAtLeastOneWalker = NextTerminalAfterAtLeastOneWalker;
    var NextTerminalAfterAtLeastOneSepWalker = (
      /** @class */
      function(_super) {
        __extends(NextTerminalAfterAtLeastOneSepWalker2, _super);
        function NextTerminalAfterAtLeastOneSepWalker2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        NextTerminalAfterAtLeastOneSepWalker2.prototype.walkAtLeastOneSep = function(atleastOneSepProd, currRest, prevRest) {
          if (atleastOneSepProd.idx === this.occurrence) {
            var firstAfterfirstAfterAtLeastOneSep = (0, first_1.default)(currRest.concat(prevRest));
            this.result.isEndOfRule = firstAfterfirstAfterAtLeastOneSep === void 0;
            if (firstAfterfirstAfterAtLeastOneSep instanceof gast_1.Terminal) {
              this.result.token = firstAfterfirstAfterAtLeastOneSep.terminalType;
              this.result.occurrence = firstAfterfirstAfterAtLeastOneSep.idx;
            }
          } else {
            _super.prototype.walkAtLeastOneSep.call(this, atleastOneSepProd, currRest, prevRest);
          }
        };
        return NextTerminalAfterAtLeastOneSepWalker2;
      }(AbstractNextTerminalAfterProductionWalker)
    );
    exports2.NextTerminalAfterAtLeastOneSepWalker = NextTerminalAfterAtLeastOneSepWalker;
    function possiblePathsFrom(targetDef, maxLength, currPath) {
      if (currPath === void 0) {
        currPath = [];
      }
      currPath = (0, clone_1.default)(currPath);
      var result = [];
      var i3 = 0;
      function remainingPathWith(nextDef) {
        return nextDef.concat((0, drop_1.default)(targetDef, i3 + 1));
      }
      function getAlternativesForProd(definition) {
        var alternatives = possiblePathsFrom(remainingPathWith(definition), maxLength, currPath);
        return result.concat(alternatives);
      }
      while (currPath.length < maxLength && i3 < targetDef.length) {
        var prod = targetDef[i3];
        if (prod instanceof gast_1.Alternative) {
          return getAlternativesForProd(prod.definition);
        } else if (prod instanceof gast_1.NonTerminal) {
          return getAlternativesForProd(prod.definition);
        } else if (prod instanceof gast_1.Option) {
          result = getAlternativesForProd(prod.definition);
        } else if (prod instanceof gast_1.RepetitionMandatory) {
          var newDef = prod.definition.concat([
            new gast_1.Repetition({
              definition: prod.definition
            })
          ]);
          return getAlternativesForProd(newDef);
        } else if (prod instanceof gast_1.RepetitionMandatoryWithSeparator) {
          var newDef = [
            new gast_1.Alternative({ definition: prod.definition }),
            new gast_1.Repetition({
              definition: [new gast_1.Terminal({ terminalType: prod.separator })].concat(prod.definition)
            })
          ];
          return getAlternativesForProd(newDef);
        } else if (prod instanceof gast_1.RepetitionWithSeparator) {
          var newDef = prod.definition.concat([
            new gast_1.Repetition({
              definition: [new gast_1.Terminal({ terminalType: prod.separator })].concat(prod.definition)
            })
          ]);
          result = getAlternativesForProd(newDef);
        } else if (prod instanceof gast_1.Repetition) {
          var newDef = prod.definition.concat([
            new gast_1.Repetition({
              definition: prod.definition
            })
          ]);
          result = getAlternativesForProd(newDef);
        } else if (prod instanceof gast_1.Alternation) {
          (0, forEach_1.default)(prod.definition, function(currAlt) {
            if ((0, isEmpty_1.default)(currAlt.definition) === false) {
              result = getAlternativesForProd(currAlt.definition);
            }
          });
          return result;
        } else if (prod instanceof gast_1.Terminal) {
          currPath.push(prod.terminalType);
        } else {
          throw Error("non exhaustive match");
        }
        i3++;
      }
      result.push({
        partialPath: currPath,
        suffixDef: (0, drop_1.default)(targetDef, i3)
      });
      return result;
    }
    exports2.possiblePathsFrom = possiblePathsFrom;
    function nextPossibleTokensAfter(initialDef, tokenVector, tokMatcher, maxLookAhead) {
      var EXIT_NON_TERMINAL = "EXIT_NONE_TERMINAL";
      var EXIT_NON_TERMINAL_ARR = [EXIT_NON_TERMINAL];
      var EXIT_ALTERNATIVE = "EXIT_ALTERNATIVE";
      var foundCompletePath = false;
      var tokenVectorLength = tokenVector.length;
      var minimalAlternativesIndex = tokenVectorLength - maxLookAhead - 1;
      var result = [];
      var possiblePaths = [];
      possiblePaths.push({
        idx: -1,
        def: initialDef,
        ruleStack: [],
        occurrenceStack: []
      });
      while (!(0, isEmpty_1.default)(possiblePaths)) {
        var currPath = possiblePaths.pop();
        if (currPath === EXIT_ALTERNATIVE) {
          if (foundCompletePath && (0, last_1.default)(possiblePaths).idx <= minimalAlternativesIndex) {
            possiblePaths.pop();
          }
          continue;
        }
        var currDef = currPath.def;
        var currIdx = currPath.idx;
        var currRuleStack = currPath.ruleStack;
        var currOccurrenceStack = currPath.occurrenceStack;
        if ((0, isEmpty_1.default)(currDef)) {
          continue;
        }
        var prod = currDef[0];
        if (prod === EXIT_NON_TERMINAL) {
          var nextPath = {
            idx: currIdx,
            def: (0, drop_1.default)(currDef),
            ruleStack: (0, dropRight_1.default)(currRuleStack),
            occurrenceStack: (0, dropRight_1.default)(currOccurrenceStack)
          };
          possiblePaths.push(nextPath);
        } else if (prod instanceof gast_1.Terminal) {
          if (currIdx < tokenVectorLength - 1) {
            var nextIdx = currIdx + 1;
            var actualToken = tokenVector[nextIdx];
            if (tokMatcher(actualToken, prod.terminalType)) {
              var nextPath = {
                idx: nextIdx,
                def: (0, drop_1.default)(currDef),
                ruleStack: currRuleStack,
                occurrenceStack: currOccurrenceStack
              };
              possiblePaths.push(nextPath);
            }
          } else if (currIdx === tokenVectorLength - 1) {
            result.push({
              nextTokenType: prod.terminalType,
              nextTokenOccurrence: prod.idx,
              ruleStack: currRuleStack,
              occurrenceStack: currOccurrenceStack
            });
            foundCompletePath = true;
          } else {
            throw Error("non exhaustive match");
          }
        } else if (prod instanceof gast_1.NonTerminal) {
          var newRuleStack = (0, clone_1.default)(currRuleStack);
          newRuleStack.push(prod.nonTerminalName);
          var newOccurrenceStack = (0, clone_1.default)(currOccurrenceStack);
          newOccurrenceStack.push(prod.idx);
          var nextPath = {
            idx: currIdx,
            def: prod.definition.concat(EXIT_NON_TERMINAL_ARR, (0, drop_1.default)(currDef)),
            ruleStack: newRuleStack,
            occurrenceStack: newOccurrenceStack
          };
          possiblePaths.push(nextPath);
        } else if (prod instanceof gast_1.Option) {
          var nextPathWithout = {
            idx: currIdx,
            def: (0, drop_1.default)(currDef),
            ruleStack: currRuleStack,
            occurrenceStack: currOccurrenceStack
          };
          possiblePaths.push(nextPathWithout);
          possiblePaths.push(EXIT_ALTERNATIVE);
          var nextPathWith = {
            idx: currIdx,
            def: prod.definition.concat((0, drop_1.default)(currDef)),
            ruleStack: currRuleStack,
            occurrenceStack: currOccurrenceStack
          };
          possiblePaths.push(nextPathWith);
        } else if (prod instanceof gast_1.RepetitionMandatory) {
          var secondIteration = new gast_1.Repetition({
            definition: prod.definition,
            idx: prod.idx
          });
          var nextDef = prod.definition.concat([secondIteration], (0, drop_1.default)(currDef));
          var nextPath = {
            idx: currIdx,
            def: nextDef,
            ruleStack: currRuleStack,
            occurrenceStack: currOccurrenceStack
          };
          possiblePaths.push(nextPath);
        } else if (prod instanceof gast_1.RepetitionMandatoryWithSeparator) {
          var separatorGast = new gast_1.Terminal({
            terminalType: prod.separator
          });
          var secondIteration = new gast_1.Repetition({
            definition: [separatorGast].concat(prod.definition),
            idx: prod.idx
          });
          var nextDef = prod.definition.concat([secondIteration], (0, drop_1.default)(currDef));
          var nextPath = {
            idx: currIdx,
            def: nextDef,
            ruleStack: currRuleStack,
            occurrenceStack: currOccurrenceStack
          };
          possiblePaths.push(nextPath);
        } else if (prod instanceof gast_1.RepetitionWithSeparator) {
          var nextPathWithout = {
            idx: currIdx,
            def: (0, drop_1.default)(currDef),
            ruleStack: currRuleStack,
            occurrenceStack: currOccurrenceStack
          };
          possiblePaths.push(nextPathWithout);
          possiblePaths.push(EXIT_ALTERNATIVE);
          var separatorGast = new gast_1.Terminal({
            terminalType: prod.separator
          });
          var nthRepetition = new gast_1.Repetition({
            definition: [separatorGast].concat(prod.definition),
            idx: prod.idx
          });
          var nextDef = prod.definition.concat([nthRepetition], (0, drop_1.default)(currDef));
          var nextPathWith = {
            idx: currIdx,
            def: nextDef,
            ruleStack: currRuleStack,
            occurrenceStack: currOccurrenceStack
          };
          possiblePaths.push(nextPathWith);
        } else if (prod instanceof gast_1.Repetition) {
          var nextPathWithout = {
            idx: currIdx,
            def: (0, drop_1.default)(currDef),
            ruleStack: currRuleStack,
            occurrenceStack: currOccurrenceStack
          };
          possiblePaths.push(nextPathWithout);
          possiblePaths.push(EXIT_ALTERNATIVE);
          var nthRepetition = new gast_1.Repetition({
            definition: prod.definition,
            idx: prod.idx
          });
          var nextDef = prod.definition.concat([nthRepetition], (0, drop_1.default)(currDef));
          var nextPathWith = {
            idx: currIdx,
            def: nextDef,
            ruleStack: currRuleStack,
            occurrenceStack: currOccurrenceStack
          };
          possiblePaths.push(nextPathWith);
        } else if (prod instanceof gast_1.Alternation) {
          for (var i3 = prod.definition.length - 1; i3 >= 0; i3--) {
            var currAlt = prod.definition[i3];
            var currAltPath = {
              idx: currIdx,
              def: currAlt.definition.concat((0, drop_1.default)(currDef)),
              ruleStack: currRuleStack,
              occurrenceStack: currOccurrenceStack
            };
            possiblePaths.push(currAltPath);
            possiblePaths.push(EXIT_ALTERNATIVE);
          }
        } else if (prod instanceof gast_1.Alternative) {
          possiblePaths.push({
            idx: currIdx,
            def: prod.definition.concat((0, drop_1.default)(currDef)),
            ruleStack: currRuleStack,
            occurrenceStack: currOccurrenceStack
          });
        } else if (prod instanceof gast_1.Rule) {
          possiblePaths.push(expandTopLevelRule(prod, currIdx, currRuleStack, currOccurrenceStack));
        } else {
          throw Error("non exhaustive match");
        }
      }
      return result;
    }
    exports2.nextPossibleTokensAfter = nextPossibleTokensAfter;
    function expandTopLevelRule(topRule, currIdx, currRuleStack, currOccurrenceStack) {
      var newRuleStack = (0, clone_1.default)(currRuleStack);
      newRuleStack.push(topRule.name);
      var newCurrOccurrenceStack = (0, clone_1.default)(currOccurrenceStack);
      newCurrOccurrenceStack.push(1);
      return {
        idx: currIdx,
        def: topRule.definition,
        ruleStack: newRuleStack,
        occurrenceStack: newCurrOccurrenceStack
      };
    }
  }
});

// node_modules/chevrotain/lib/src/parse/grammar/lookahead.js
var require_lookahead = __commonJS({
  "node_modules/chevrotain/lib/src/parse/grammar/lookahead.js"(exports2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || function() {
      var extendStatics = function(d, b5) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b6) {
          d2.__proto__ = b6;
        } || function(d2, b6) {
          for (var p in b6)
            if (Object.prototype.hasOwnProperty.call(b6, p))
              d2[p] = b6[p];
        };
        return extendStatics(d, b5);
      };
      return function(d, b5) {
        if (typeof b5 !== "function" && b5 !== null)
          throw new TypeError("Class extends value " + String(b5) + " is not a constructor or null");
        extendStatics(d, b5);
        function __() {
          this.constructor = d;
        }
        d.prototype = b5 === null ? Object.create(b5) : (__.prototype = b5.prototype, new __());
      };
    }();
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.areTokenCategoriesNotUsed = exports2.isStrictPrefixOfPath = exports2.containsPath = exports2.getLookaheadPathsForOptionalProd = exports2.getLookaheadPathsForOr = exports2.lookAheadSequenceFromAlternatives = exports2.buildSingleAlternativeLookaheadFunction = exports2.buildAlternativesLookAheadFunc = exports2.buildLookaheadFuncForOptionalProd = exports2.buildLookaheadFuncForOr = exports2.getLookaheadPaths = exports2.getProdType = exports2.PROD_TYPE = void 0;
    var isEmpty_1 = __importDefault(require_isEmpty());
    var flatten_1 = __importDefault(require_flatten());
    var every_1 = __importDefault(require_every());
    var map_1 = __importDefault(require_map());
    var forEach_1 = __importDefault(require_forEach());
    var has_1 = __importDefault(require_has());
    var reduce_1 = __importDefault(require_reduce());
    var interpreter_1 = require_interpreter();
    var rest_1 = require_rest();
    var tokens_1 = require_tokens();
    var gast_1 = require_api2();
    var gast_2 = require_api2();
    var PROD_TYPE;
    (function(PROD_TYPE2) {
      PROD_TYPE2[PROD_TYPE2["OPTION"] = 0] = "OPTION";
      PROD_TYPE2[PROD_TYPE2["REPETITION"] = 1] = "REPETITION";
      PROD_TYPE2[PROD_TYPE2["REPETITION_MANDATORY"] = 2] = "REPETITION_MANDATORY";
      PROD_TYPE2[PROD_TYPE2["REPETITION_MANDATORY_WITH_SEPARATOR"] = 3] = "REPETITION_MANDATORY_WITH_SEPARATOR";
      PROD_TYPE2[PROD_TYPE2["REPETITION_WITH_SEPARATOR"] = 4] = "REPETITION_WITH_SEPARATOR";
      PROD_TYPE2[PROD_TYPE2["ALTERNATION"] = 5] = "ALTERNATION";
    })(PROD_TYPE = exports2.PROD_TYPE || (exports2.PROD_TYPE = {}));
    function getProdType(prod) {
      if (prod instanceof gast_1.Option || prod === "Option") {
        return PROD_TYPE.OPTION;
      } else if (prod instanceof gast_1.Repetition || prod === "Repetition") {
        return PROD_TYPE.REPETITION;
      } else if (prod instanceof gast_1.RepetitionMandatory || prod === "RepetitionMandatory") {
        return PROD_TYPE.REPETITION_MANDATORY;
      } else if (prod instanceof gast_1.RepetitionMandatoryWithSeparator || prod === "RepetitionMandatoryWithSeparator") {
        return PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR;
      } else if (prod instanceof gast_1.RepetitionWithSeparator || prod === "RepetitionWithSeparator") {
        return PROD_TYPE.REPETITION_WITH_SEPARATOR;
      } else if (prod instanceof gast_1.Alternation || prod === "Alternation") {
        return PROD_TYPE.ALTERNATION;
      } else {
        throw Error("non exhaustive match");
      }
    }
    exports2.getProdType = getProdType;
    function getLookaheadPaths2(options) {
      var occurrence = options.occurrence, rule = options.rule, prodType = options.prodType, maxLookahead = options.maxLookahead;
      var type = getProdType(prodType);
      if (type === PROD_TYPE.ALTERNATION) {
        return getLookaheadPathsForOr(occurrence, rule, maxLookahead);
      } else {
        return getLookaheadPathsForOptionalProd(occurrence, rule, type, maxLookahead);
      }
    }
    exports2.getLookaheadPaths = getLookaheadPaths2;
    function buildLookaheadFuncForOr(occurrence, ruleGrammar, maxLookahead, hasPredicates, dynamicTokensEnabled, laFuncBuilder) {
      var lookAheadPaths = getLookaheadPathsForOr(occurrence, ruleGrammar, maxLookahead);
      var tokenMatcher2 = areTokenCategoriesNotUsed(lookAheadPaths) ? tokens_1.tokenStructuredMatcherNoCategories : tokens_1.tokenStructuredMatcher;
      return laFuncBuilder(lookAheadPaths, hasPredicates, tokenMatcher2, dynamicTokensEnabled);
    }
    exports2.buildLookaheadFuncForOr = buildLookaheadFuncForOr;
    function buildLookaheadFuncForOptionalProd(occurrence, ruleGrammar, k, dynamicTokensEnabled, prodType, lookaheadBuilder) {
      var lookAheadPaths = getLookaheadPathsForOptionalProd(occurrence, ruleGrammar, prodType, k);
      var tokenMatcher2 = areTokenCategoriesNotUsed(lookAheadPaths) ? tokens_1.tokenStructuredMatcherNoCategories : tokens_1.tokenStructuredMatcher;
      return lookaheadBuilder(lookAheadPaths[0], tokenMatcher2, dynamicTokensEnabled);
    }
    exports2.buildLookaheadFuncForOptionalProd = buildLookaheadFuncForOptionalProd;
    function buildAlternativesLookAheadFunc(alts, hasPredicates, tokenMatcher2, dynamicTokensEnabled) {
      var numOfAlts = alts.length;
      var areAllOneTokenLookahead = (0, every_1.default)(alts, function(currAlt) {
        return (0, every_1.default)(currAlt, function(currPath) {
          return currPath.length === 1;
        });
      });
      if (hasPredicates) {
        return function(orAlts) {
          var predicates = (0, map_1.default)(orAlts, function(currAlt2) {
            return currAlt2.GATE;
          });
          for (var t2 = 0; t2 < numOfAlts; t2++) {
            var currAlt = alts[t2];
            var currNumOfPaths = currAlt.length;
            var currPredicate = predicates[t2];
            if (currPredicate !== void 0 && currPredicate.call(this) === false) {
              continue;
            }
            nextPath:
              for (var j = 0; j < currNumOfPaths; j++) {
                var currPath = currAlt[j];
                var currPathLength = currPath.length;
                for (var i3 = 0; i3 < currPathLength; i3++) {
                  var nextToken = this.LA(i3 + 1);
                  if (tokenMatcher2(nextToken, currPath[i3]) === false) {
                    continue nextPath;
                  }
                }
                return t2;
              }
          }
          return void 0;
        };
      } else if (areAllOneTokenLookahead && !dynamicTokensEnabled) {
        var singleTokenAlts = (0, map_1.default)(alts, function(currAlt) {
          return (0, flatten_1.default)(currAlt);
        });
        var choiceToAlt_1 = (0, reduce_1.default)(singleTokenAlts, function(result, currAlt, idx) {
          (0, forEach_1.default)(currAlt, function(currTokType) {
            if (!(0, has_1.default)(result, currTokType.tokenTypeIdx)) {
              result[currTokType.tokenTypeIdx] = idx;
            }
            (0, forEach_1.default)(currTokType.categoryMatches, function(currExtendingType) {
              if (!(0, has_1.default)(result, currExtendingType)) {
                result[currExtendingType] = idx;
              }
            });
          });
          return result;
        }, {});
        return function() {
          var nextToken = this.LA(1);
          return choiceToAlt_1[nextToken.tokenTypeIdx];
        };
      } else {
        return function() {
          for (var t2 = 0; t2 < numOfAlts; t2++) {
            var currAlt = alts[t2];
            var currNumOfPaths = currAlt.length;
            nextPath:
              for (var j = 0; j < currNumOfPaths; j++) {
                var currPath = currAlt[j];
                var currPathLength = currPath.length;
                for (var i3 = 0; i3 < currPathLength; i3++) {
                  var nextToken = this.LA(i3 + 1);
                  if (tokenMatcher2(nextToken, currPath[i3]) === false) {
                    continue nextPath;
                  }
                }
                return t2;
              }
          }
          return void 0;
        };
      }
    }
    exports2.buildAlternativesLookAheadFunc = buildAlternativesLookAheadFunc;
    function buildSingleAlternativeLookaheadFunction(alt, tokenMatcher2, dynamicTokensEnabled) {
      var areAllOneTokenLookahead = (0, every_1.default)(alt, function(currPath) {
        return currPath.length === 1;
      });
      var numOfPaths = alt.length;
      if (areAllOneTokenLookahead && !dynamicTokensEnabled) {
        var singleTokensTypes = (0, flatten_1.default)(alt);
        if (singleTokensTypes.length === 1 && (0, isEmpty_1.default)(singleTokensTypes[0].categoryMatches)) {
          var expectedTokenType = singleTokensTypes[0];
          var expectedTokenUniqueKey_1 = expectedTokenType.tokenTypeIdx;
          return function() {
            return this.LA(1).tokenTypeIdx === expectedTokenUniqueKey_1;
          };
        } else {
          var choiceToAlt_2 = (0, reduce_1.default)(singleTokensTypes, function(result, currTokType, idx) {
            result[currTokType.tokenTypeIdx] = true;
            (0, forEach_1.default)(currTokType.categoryMatches, function(currExtendingType) {
              result[currExtendingType] = true;
            });
            return result;
          }, []);
          return function() {
            var nextToken = this.LA(1);
            return choiceToAlt_2[nextToken.tokenTypeIdx] === true;
          };
        }
      } else {
        return function() {
          nextPath:
            for (var j = 0; j < numOfPaths; j++) {
              var currPath = alt[j];
              var currPathLength = currPath.length;
              for (var i3 = 0; i3 < currPathLength; i3++) {
                var nextToken = this.LA(i3 + 1);
                if (tokenMatcher2(nextToken, currPath[i3]) === false) {
                  continue nextPath;
                }
              }
              return true;
            }
          return false;
        };
      }
    }
    exports2.buildSingleAlternativeLookaheadFunction = buildSingleAlternativeLookaheadFunction;
    var RestDefinitionFinderWalker = (
      /** @class */
      function(_super) {
        __extends(RestDefinitionFinderWalker2, _super);
        function RestDefinitionFinderWalker2(topProd, targetOccurrence, targetProdType) {
          var _this = _super.call(this) || this;
          _this.topProd = topProd;
          _this.targetOccurrence = targetOccurrence;
          _this.targetProdType = targetProdType;
          return _this;
        }
        RestDefinitionFinderWalker2.prototype.startWalking = function() {
          this.walk(this.topProd);
          return this.restDef;
        };
        RestDefinitionFinderWalker2.prototype.checkIsTarget = function(node, expectedProdType, currRest, prevRest) {
          if (node.idx === this.targetOccurrence && this.targetProdType === expectedProdType) {
            this.restDef = currRest.concat(prevRest);
            return true;
          }
          return false;
        };
        RestDefinitionFinderWalker2.prototype.walkOption = function(optionProd, currRest, prevRest) {
          if (!this.checkIsTarget(optionProd, PROD_TYPE.OPTION, currRest, prevRest)) {
            _super.prototype.walkOption.call(this, optionProd, currRest, prevRest);
          }
        };
        RestDefinitionFinderWalker2.prototype.walkAtLeastOne = function(atLeastOneProd, currRest, prevRest) {
          if (!this.checkIsTarget(atLeastOneProd, PROD_TYPE.REPETITION_MANDATORY, currRest, prevRest)) {
            _super.prototype.walkOption.call(this, atLeastOneProd, currRest, prevRest);
          }
        };
        RestDefinitionFinderWalker2.prototype.walkAtLeastOneSep = function(atLeastOneSepProd, currRest, prevRest) {
          if (!this.checkIsTarget(atLeastOneSepProd, PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR, currRest, prevRest)) {
            _super.prototype.walkOption.call(this, atLeastOneSepProd, currRest, prevRest);
          }
        };
        RestDefinitionFinderWalker2.prototype.walkMany = function(manyProd, currRest, prevRest) {
          if (!this.checkIsTarget(manyProd, PROD_TYPE.REPETITION, currRest, prevRest)) {
            _super.prototype.walkOption.call(this, manyProd, currRest, prevRest);
          }
        };
        RestDefinitionFinderWalker2.prototype.walkManySep = function(manySepProd, currRest, prevRest) {
          if (!this.checkIsTarget(manySepProd, PROD_TYPE.REPETITION_WITH_SEPARATOR, currRest, prevRest)) {
            _super.prototype.walkOption.call(this, manySepProd, currRest, prevRest);
          }
        };
        return RestDefinitionFinderWalker2;
      }(rest_1.RestWalker)
    );
    var InsideDefinitionFinderVisitor = (
      /** @class */
      function(_super) {
        __extends(InsideDefinitionFinderVisitor2, _super);
        function InsideDefinitionFinderVisitor2(targetOccurrence, targetProdType, targetRef) {
          var _this = _super.call(this) || this;
          _this.targetOccurrence = targetOccurrence;
          _this.targetProdType = targetProdType;
          _this.targetRef = targetRef;
          _this.result = [];
          return _this;
        }
        InsideDefinitionFinderVisitor2.prototype.checkIsTarget = function(node, expectedProdName) {
          if (node.idx === this.targetOccurrence && this.targetProdType === expectedProdName && (this.targetRef === void 0 || node === this.targetRef)) {
            this.result = node.definition;
          }
        };
        InsideDefinitionFinderVisitor2.prototype.visitOption = function(node) {
          this.checkIsTarget(node, PROD_TYPE.OPTION);
        };
        InsideDefinitionFinderVisitor2.prototype.visitRepetition = function(node) {
          this.checkIsTarget(node, PROD_TYPE.REPETITION);
        };
        InsideDefinitionFinderVisitor2.prototype.visitRepetitionMandatory = function(node) {
          this.checkIsTarget(node, PROD_TYPE.REPETITION_MANDATORY);
        };
        InsideDefinitionFinderVisitor2.prototype.visitRepetitionMandatoryWithSeparator = function(node) {
          this.checkIsTarget(node, PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR);
        };
        InsideDefinitionFinderVisitor2.prototype.visitRepetitionWithSeparator = function(node) {
          this.checkIsTarget(node, PROD_TYPE.REPETITION_WITH_SEPARATOR);
        };
        InsideDefinitionFinderVisitor2.prototype.visitAlternation = function(node) {
          this.checkIsTarget(node, PROD_TYPE.ALTERNATION);
        };
        return InsideDefinitionFinderVisitor2;
      }(gast_2.GAstVisitor)
    );
    function initializeArrayOfArrays(size2) {
      var result = new Array(size2);
      for (var i3 = 0; i3 < size2; i3++) {
        result[i3] = [];
      }
      return result;
    }
    function pathToHashKeys(path) {
      var keys = [""];
      for (var i3 = 0; i3 < path.length; i3++) {
        var tokType = path[i3];
        var longerKeys = [];
        for (var j = 0; j < keys.length; j++) {
          var currShorterKey = keys[j];
          longerKeys.push(currShorterKey + "_" + tokType.tokenTypeIdx);
          for (var t2 = 0; t2 < tokType.categoryMatches.length; t2++) {
            var categoriesKeySuffix = "_" + tokType.categoryMatches[t2];
            longerKeys.push(currShorterKey + categoriesKeySuffix);
          }
        }
        keys = longerKeys;
      }
      return keys;
    }
    function isUniquePrefixHash(altKnownPathsKeys, searchPathKeys, idx) {
      for (var currAltIdx = 0; currAltIdx < altKnownPathsKeys.length; currAltIdx++) {
        if (currAltIdx === idx) {
          continue;
        }
        var otherAltKnownPathsKeys = altKnownPathsKeys[currAltIdx];
        for (var searchIdx = 0; searchIdx < searchPathKeys.length; searchIdx++) {
          var searchKey = searchPathKeys[searchIdx];
          if (otherAltKnownPathsKeys[searchKey] === true) {
            return false;
          }
        }
      }
      return true;
    }
    function lookAheadSequenceFromAlternatives(altsDefs, k) {
      var partialAlts = (0, map_1.default)(altsDefs, function(currAlt) {
        return (0, interpreter_1.possiblePathsFrom)([currAlt], 1);
      });
      var finalResult = initializeArrayOfArrays(partialAlts.length);
      var altsHashes = (0, map_1.default)(partialAlts, function(currAltPaths) {
        var dict = {};
        (0, forEach_1.default)(currAltPaths, function(item) {
          var keys = pathToHashKeys(item.partialPath);
          (0, forEach_1.default)(keys, function(currKey) {
            dict[currKey] = true;
          });
        });
        return dict;
      });
      var newData = partialAlts;
      for (var pathLength = 1; pathLength <= k; pathLength++) {
        var currDataset = newData;
        newData = initializeArrayOfArrays(currDataset.length);
        var _loop_1 = function(altIdx2) {
          var currAltPathsAndSuffixes = currDataset[altIdx2];
          for (var currPathIdx = 0; currPathIdx < currAltPathsAndSuffixes.length; currPathIdx++) {
            var currPathPrefix = currAltPathsAndSuffixes[currPathIdx].partialPath;
            var suffixDef = currAltPathsAndSuffixes[currPathIdx].suffixDef;
            var prefixKeys = pathToHashKeys(currPathPrefix);
            var isUnique = isUniquePrefixHash(altsHashes, prefixKeys, altIdx2);
            if (isUnique || (0, isEmpty_1.default)(suffixDef) || currPathPrefix.length === k) {
              var currAltResult = finalResult[altIdx2];
              if (containsPath(currAltResult, currPathPrefix) === false) {
                currAltResult.push(currPathPrefix);
                for (var j = 0; j < prefixKeys.length; j++) {
                  var currKey = prefixKeys[j];
                  altsHashes[altIdx2][currKey] = true;
                }
              }
            } else {
              var newPartialPathsAndSuffixes = (0, interpreter_1.possiblePathsFrom)(suffixDef, pathLength + 1, currPathPrefix);
              newData[altIdx2] = newData[altIdx2].concat(newPartialPathsAndSuffixes);
              (0, forEach_1.default)(newPartialPathsAndSuffixes, function(item) {
                var prefixKeys2 = pathToHashKeys(item.partialPath);
                (0, forEach_1.default)(prefixKeys2, function(key) {
                  altsHashes[altIdx2][key] = true;
                });
              });
            }
          }
        };
        for (var altIdx = 0; altIdx < currDataset.length; altIdx++) {
          _loop_1(altIdx);
        }
      }
      return finalResult;
    }
    exports2.lookAheadSequenceFromAlternatives = lookAheadSequenceFromAlternatives;
    function getLookaheadPathsForOr(occurrence, ruleGrammar, k, orProd) {
      var visitor = new InsideDefinitionFinderVisitor(occurrence, PROD_TYPE.ALTERNATION, orProd);
      ruleGrammar.accept(visitor);
      return lookAheadSequenceFromAlternatives(visitor.result, k);
    }
    exports2.getLookaheadPathsForOr = getLookaheadPathsForOr;
    function getLookaheadPathsForOptionalProd(occurrence, ruleGrammar, prodType, k) {
      var insideDefVisitor = new InsideDefinitionFinderVisitor(occurrence, prodType);
      ruleGrammar.accept(insideDefVisitor);
      var insideDef = insideDefVisitor.result;
      var afterDefWalker = new RestDefinitionFinderWalker(ruleGrammar, occurrence, prodType);
      var afterDef = afterDefWalker.startWalking();
      var insideFlat = new gast_1.Alternative({ definition: insideDef });
      var afterFlat = new gast_1.Alternative({ definition: afterDef });
      return lookAheadSequenceFromAlternatives([insideFlat, afterFlat], k);
    }
    exports2.getLookaheadPathsForOptionalProd = getLookaheadPathsForOptionalProd;
    function containsPath(alternative, searchPath) {
      compareOtherPath:
        for (var i3 = 0; i3 < alternative.length; i3++) {
          var otherPath = alternative[i3];
          if (otherPath.length !== searchPath.length) {
            continue;
          }
          for (var j = 0; j < otherPath.length; j++) {
            var searchTok = searchPath[j];
            var otherTok = otherPath[j];
            var matchingTokens = searchTok === otherTok || otherTok.categoryMatchesMap[searchTok.tokenTypeIdx] !== void 0;
            if (matchingTokens === false) {
              continue compareOtherPath;
            }
          }
          return true;
        }
      return false;
    }
    exports2.containsPath = containsPath;
    function isStrictPrefixOfPath(prefix, other) {
      return prefix.length < other.length && (0, every_1.default)(prefix, function(tokType, idx) {
        var otherTokType = other[idx];
        return tokType === otherTokType || otherTokType.categoryMatchesMap[tokType.tokenTypeIdx];
      });
    }
    exports2.isStrictPrefixOfPath = isStrictPrefixOfPath;
    function areTokenCategoriesNotUsed(lookAheadPaths) {
      return (0, every_1.default)(lookAheadPaths, function(singleAltPaths) {
        return (0, every_1.default)(singleAltPaths, function(singlePath) {
          return (0, every_1.default)(singlePath, function(token) {
            return (0, isEmpty_1.default)(token.categoryMatches);
          });
        });
      });
    }
    exports2.areTokenCategoriesNotUsed = areTokenCategoriesNotUsed;
  }
});

// node_modules/chevrotain/lib/src/parse/grammar/checks.js
var require_checks = __commonJS({
  "node_modules/chevrotain/lib/src/parse/grammar/checks.js"(exports2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || function() {
      var extendStatics = function(d, b5) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b6) {
          d2.__proto__ = b6;
        } || function(d2, b6) {
          for (var p in b6)
            if (Object.prototype.hasOwnProperty.call(b6, p))
              d2[p] = b6[p];
        };
        return extendStatics(d, b5);
      };
      return function(d, b5) {
        if (typeof b5 !== "function" && b5 !== null)
          throw new TypeError("Class extends value " + String(b5) + " is not a constructor or null");
        extendStatics(d, b5);
        function __() {
          this.constructor = d;
        }
        d.prototype = b5 === null ? Object.create(b5) : (__.prototype = b5.prototype, new __());
      };
    }();
    var __assign = exports2 && exports2.__assign || function() {
      __assign = Object.assign || function(t2) {
        for (var s, i3 = 1, n = arguments.length; i3 < n; i3++) {
          s = arguments[i3];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t2[p] = s[p];
        }
        return t2;
      };
      return __assign.apply(this, arguments);
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.checkPrefixAlternativesAmbiguities = exports2.validateSomeNonEmptyLookaheadPath = exports2.validateTooManyAlts = exports2.RepetitionCollector = exports2.validateAmbiguousAlternationAlternatives = exports2.validateEmptyOrAlternative = exports2.getFirstNoneTerminal = exports2.validateNoLeftRecursion = exports2.validateRuleIsOverridden = exports2.validateRuleDoesNotAlreadyExist = exports2.OccurrenceValidationCollector = exports2.identifyProductionForDuplicates = exports2.validateGrammar = exports2.validateLookahead = void 0;
    var first_1 = __importDefault(require_first2());
    var isEmpty_1 = __importDefault(require_isEmpty());
    var drop_1 = __importDefault(require_drop());
    var flatten_1 = __importDefault(require_flatten());
    var filter_1 = __importDefault(require_filter());
    var reject_1 = __importDefault(require_reject());
    var difference_1 = __importDefault(require_difference());
    var map_1 = __importDefault(require_map());
    var forEach_1 = __importDefault(require_forEach());
    var groupBy_1 = __importDefault(require_groupBy());
    var reduce_1 = __importDefault(require_reduce());
    var pickBy_1 = __importDefault(require_pickBy());
    var values_1 = __importDefault(require_values());
    var includes_1 = __importDefault(require_includes());
    var flatMap_1 = __importDefault(require_flatMap());
    var clone_1 = __importDefault(require_clone());
    var parser_1 = require_parser();
    var gast_1 = require_api2();
    var lookahead_1 = require_lookahead();
    var interpreter_1 = require_interpreter();
    var gast_2 = require_api2();
    var gast_3 = require_api2();
    var dropRight_1 = __importDefault(require_dropRight());
    var compact_1 = __importDefault(require_compact());
    var tokens_1 = require_tokens();
    function validateLookahead(options) {
      var lookaheadValidationErrorMessages = options.lookaheadStrategy.validate({
        rules: options.rules,
        tokenTypes: options.tokenTypes,
        grammarName: options.grammarName
      });
      return (0, map_1.default)(lookaheadValidationErrorMessages, function(errorMessage) {
        return __assign({ type: parser_1.ParserDefinitionErrorType.CUSTOM_LOOKAHEAD_VALIDATION }, errorMessage);
      });
    }
    exports2.validateLookahead = validateLookahead;
    function validateGrammar(topLevels, tokenTypes, errMsgProvider, grammarName) {
      var duplicateErrors = (0, flatMap_1.default)(topLevels, function(currTopLevel) {
        return validateDuplicateProductions(currTopLevel, errMsgProvider);
      });
      var termsNamespaceConflictErrors = checkTerminalAndNoneTerminalsNameSpace(topLevels, tokenTypes, errMsgProvider);
      var tooManyAltsErrors = (0, flatMap_1.default)(topLevels, function(curRule) {
        return validateTooManyAlts(curRule, errMsgProvider);
      });
      var duplicateRulesError = (0, flatMap_1.default)(topLevels, function(curRule) {
        return validateRuleDoesNotAlreadyExist(curRule, topLevels, grammarName, errMsgProvider);
      });
      return duplicateErrors.concat(termsNamespaceConflictErrors, tooManyAltsErrors, duplicateRulesError);
    }
    exports2.validateGrammar = validateGrammar;
    function validateDuplicateProductions(topLevelRule, errMsgProvider) {
      var collectorVisitor = new OccurrenceValidationCollector();
      topLevelRule.accept(collectorVisitor);
      var allRuleProductions = collectorVisitor.allProductions;
      var productionGroups = (0, groupBy_1.default)(allRuleProductions, identifyProductionForDuplicates);
      var duplicates = (0, pickBy_1.default)(productionGroups, function(currGroup) {
        return currGroup.length > 1;
      });
      var errors = (0, map_1.default)((0, values_1.default)(duplicates), function(currDuplicates) {
        var firstProd = (0, first_1.default)(currDuplicates);
        var msg = errMsgProvider.buildDuplicateFoundError(topLevelRule, currDuplicates);
        var dslName = (0, gast_1.getProductionDslName)(firstProd);
        var defError = {
          message: msg,
          type: parser_1.ParserDefinitionErrorType.DUPLICATE_PRODUCTIONS,
          ruleName: topLevelRule.name,
          dslName,
          occurrence: firstProd.idx
        };
        var param = getExtraProductionArgument(firstProd);
        if (param) {
          defError.parameter = param;
        }
        return defError;
      });
      return errors;
    }
    function identifyProductionForDuplicates(prod) {
      return "".concat((0, gast_1.getProductionDslName)(prod), "_#_").concat(prod.idx, "_#_").concat(getExtraProductionArgument(prod));
    }
    exports2.identifyProductionForDuplicates = identifyProductionForDuplicates;
    function getExtraProductionArgument(prod) {
      if (prod instanceof gast_2.Terminal) {
        return prod.terminalType.name;
      } else if (prod instanceof gast_2.NonTerminal) {
        return prod.nonTerminalName;
      } else {
        return "";
      }
    }
    var OccurrenceValidationCollector = (
      /** @class */
      function(_super) {
        __extends(OccurrenceValidationCollector2, _super);
        function OccurrenceValidationCollector2() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this.allProductions = [];
          return _this;
        }
        OccurrenceValidationCollector2.prototype.visitNonTerminal = function(subrule) {
          this.allProductions.push(subrule);
        };
        OccurrenceValidationCollector2.prototype.visitOption = function(option) {
          this.allProductions.push(option);
        };
        OccurrenceValidationCollector2.prototype.visitRepetitionWithSeparator = function(manySep) {
          this.allProductions.push(manySep);
        };
        OccurrenceValidationCollector2.prototype.visitRepetitionMandatory = function(atLeastOne) {
          this.allProductions.push(atLeastOne);
        };
        OccurrenceValidationCollector2.prototype.visitRepetitionMandatoryWithSeparator = function(atLeastOneSep) {
          this.allProductions.push(atLeastOneSep);
        };
        OccurrenceValidationCollector2.prototype.visitRepetition = function(many) {
          this.allProductions.push(many);
        };
        OccurrenceValidationCollector2.prototype.visitAlternation = function(or) {
          this.allProductions.push(or);
        };
        OccurrenceValidationCollector2.prototype.visitTerminal = function(terminal) {
          this.allProductions.push(terminal);
        };
        return OccurrenceValidationCollector2;
      }(gast_3.GAstVisitor)
    );
    exports2.OccurrenceValidationCollector = OccurrenceValidationCollector;
    function validateRuleDoesNotAlreadyExist(rule, allRules, className, errMsgProvider) {
      var errors = [];
      var occurrences = (0, reduce_1.default)(allRules, function(result, curRule) {
        if (curRule.name === rule.name) {
          return result + 1;
        }
        return result;
      }, 0);
      if (occurrences > 1) {
        var errMsg = errMsgProvider.buildDuplicateRuleNameError({
          topLevelRule: rule,
          grammarName: className
        });
        errors.push({
          message: errMsg,
          type: parser_1.ParserDefinitionErrorType.DUPLICATE_RULE_NAME,
          ruleName: rule.name
        });
      }
      return errors;
    }
    exports2.validateRuleDoesNotAlreadyExist = validateRuleDoesNotAlreadyExist;
    function validateRuleIsOverridden(ruleName, definedRulesNames, className) {
      var errors = [];
      var errMsg;
      if (!(0, includes_1.default)(definedRulesNames, ruleName)) {
        errMsg = "Invalid rule override, rule: ->".concat(ruleName, "<- cannot be overridden in the grammar: ->").concat(className, "<-") + "as it is not defined in any of the super grammars ";
        errors.push({
          message: errMsg,
          type: parser_1.ParserDefinitionErrorType.INVALID_RULE_OVERRIDE,
          ruleName
        });
      }
      return errors;
    }
    exports2.validateRuleIsOverridden = validateRuleIsOverridden;
    function validateNoLeftRecursion(topRule, currRule, errMsgProvider, path) {
      if (path === void 0) {
        path = [];
      }
      var errors = [];
      var nextNonTerminals = getFirstNoneTerminal(currRule.definition);
      if ((0, isEmpty_1.default)(nextNonTerminals)) {
        return [];
      } else {
        var ruleName = topRule.name;
        var foundLeftRecursion = (0, includes_1.default)(nextNonTerminals, topRule);
        if (foundLeftRecursion) {
          errors.push({
            message: errMsgProvider.buildLeftRecursionError({
              topLevelRule: topRule,
              leftRecursionPath: path
            }),
            type: parser_1.ParserDefinitionErrorType.LEFT_RECURSION,
            ruleName
          });
        }
        var validNextSteps = (0, difference_1.default)(nextNonTerminals, path.concat([topRule]));
        var errorsFromNextSteps = (0, flatMap_1.default)(validNextSteps, function(currRefRule) {
          var newPath = (0, clone_1.default)(path);
          newPath.push(currRefRule);
          return validateNoLeftRecursion(topRule, currRefRule, errMsgProvider, newPath);
        });
        return errors.concat(errorsFromNextSteps);
      }
    }
    exports2.validateNoLeftRecursion = validateNoLeftRecursion;
    function getFirstNoneTerminal(definition) {
      var result = [];
      if ((0, isEmpty_1.default)(definition)) {
        return result;
      }
      var firstProd = (0, first_1.default)(definition);
      if (firstProd instanceof gast_2.NonTerminal) {
        result.push(firstProd.referencedRule);
      } else if (firstProd instanceof gast_2.Alternative || firstProd instanceof gast_2.Option || firstProd instanceof gast_2.RepetitionMandatory || firstProd instanceof gast_2.RepetitionMandatoryWithSeparator || firstProd instanceof gast_2.RepetitionWithSeparator || firstProd instanceof gast_2.Repetition) {
        result = result.concat(getFirstNoneTerminal(firstProd.definition));
      } else if (firstProd instanceof gast_2.Alternation) {
        result = (0, flatten_1.default)((0, map_1.default)(firstProd.definition, function(currSubDef) {
          return getFirstNoneTerminal(currSubDef.definition);
        }));
      } else if (firstProd instanceof gast_2.Terminal) {
      } else {
        throw Error("non exhaustive match");
      }
      var isFirstOptional = (0, gast_1.isOptionalProd)(firstProd);
      var hasMore = definition.length > 1;
      if (isFirstOptional && hasMore) {
        var rest = (0, drop_1.default)(definition);
        return result.concat(getFirstNoneTerminal(rest));
      } else {
        return result;
      }
    }
    exports2.getFirstNoneTerminal = getFirstNoneTerminal;
    var OrCollector = (
      /** @class */
      function(_super) {
        __extends(OrCollector2, _super);
        function OrCollector2() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this.alternations = [];
          return _this;
        }
        OrCollector2.prototype.visitAlternation = function(node) {
          this.alternations.push(node);
        };
        return OrCollector2;
      }(gast_3.GAstVisitor)
    );
    function validateEmptyOrAlternative(topLevelRule, errMsgProvider) {
      var orCollector = new OrCollector();
      topLevelRule.accept(orCollector);
      var ors = orCollector.alternations;
      var errors = (0, flatMap_1.default)(ors, function(currOr) {
        var exceptLast = (0, dropRight_1.default)(currOr.definition);
        return (0, flatMap_1.default)(exceptLast, function(currAlternative, currAltIdx) {
          var possibleFirstInAlt = (0, interpreter_1.nextPossibleTokensAfter)([currAlternative], [], tokens_1.tokenStructuredMatcher, 1);
          if ((0, isEmpty_1.default)(possibleFirstInAlt)) {
            return [
              {
                message: errMsgProvider.buildEmptyAlternationError({
                  topLevelRule,
                  alternation: currOr,
                  emptyChoiceIdx: currAltIdx
                }),
                type: parser_1.ParserDefinitionErrorType.NONE_LAST_EMPTY_ALT,
                ruleName: topLevelRule.name,
                occurrence: currOr.idx,
                alternative: currAltIdx + 1
              }
            ];
          } else {
            return [];
          }
        });
      });
      return errors;
    }
    exports2.validateEmptyOrAlternative = validateEmptyOrAlternative;
    function validateAmbiguousAlternationAlternatives(topLevelRule, globalMaxLookahead, errMsgProvider) {
      var orCollector = new OrCollector();
      topLevelRule.accept(orCollector);
      var ors = orCollector.alternations;
      ors = (0, reject_1.default)(ors, function(currOr) {
        return currOr.ignoreAmbiguities === true;
      });
      var errors = (0, flatMap_1.default)(ors, function(currOr) {
        var currOccurrence = currOr.idx;
        var actualMaxLookahead = currOr.maxLookahead || globalMaxLookahead;
        var alternatives = (0, lookahead_1.getLookaheadPathsForOr)(currOccurrence, topLevelRule, actualMaxLookahead, currOr);
        var altsAmbiguityErrors = checkAlternativesAmbiguities(alternatives, currOr, topLevelRule, errMsgProvider);
        var altsPrefixAmbiguityErrors = checkPrefixAlternativesAmbiguities(alternatives, currOr, topLevelRule, errMsgProvider);
        return altsAmbiguityErrors.concat(altsPrefixAmbiguityErrors);
      });
      return errors;
    }
    exports2.validateAmbiguousAlternationAlternatives = validateAmbiguousAlternationAlternatives;
    var RepetitionCollector = (
      /** @class */
      function(_super) {
        __extends(RepetitionCollector2, _super);
        function RepetitionCollector2() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this.allProductions = [];
          return _this;
        }
        RepetitionCollector2.prototype.visitRepetitionWithSeparator = function(manySep) {
          this.allProductions.push(manySep);
        };
        RepetitionCollector2.prototype.visitRepetitionMandatory = function(atLeastOne) {
          this.allProductions.push(atLeastOne);
        };
        RepetitionCollector2.prototype.visitRepetitionMandatoryWithSeparator = function(atLeastOneSep) {
          this.allProductions.push(atLeastOneSep);
        };
        RepetitionCollector2.prototype.visitRepetition = function(many) {
          this.allProductions.push(many);
        };
        return RepetitionCollector2;
      }(gast_3.GAstVisitor)
    );
    exports2.RepetitionCollector = RepetitionCollector;
    function validateTooManyAlts(topLevelRule, errMsgProvider) {
      var orCollector = new OrCollector();
      topLevelRule.accept(orCollector);
      var ors = orCollector.alternations;
      var errors = (0, flatMap_1.default)(ors, function(currOr) {
        if (currOr.definition.length > 255) {
          return [
            {
              message: errMsgProvider.buildTooManyAlternativesError({
                topLevelRule,
                alternation: currOr
              }),
              type: parser_1.ParserDefinitionErrorType.TOO_MANY_ALTS,
              ruleName: topLevelRule.name,
              occurrence: currOr.idx
            }
          ];
        } else {
          return [];
        }
      });
      return errors;
    }
    exports2.validateTooManyAlts = validateTooManyAlts;
    function validateSomeNonEmptyLookaheadPath(topLevelRules, maxLookahead, errMsgProvider) {
      var errors = [];
      (0, forEach_1.default)(topLevelRules, function(currTopRule) {
        var collectorVisitor = new RepetitionCollector();
        currTopRule.accept(collectorVisitor);
        var allRuleProductions = collectorVisitor.allProductions;
        (0, forEach_1.default)(allRuleProductions, function(currProd) {
          var prodType = (0, lookahead_1.getProdType)(currProd);
          var actualMaxLookahead = currProd.maxLookahead || maxLookahead;
          var currOccurrence = currProd.idx;
          var paths = (0, lookahead_1.getLookaheadPathsForOptionalProd)(currOccurrence, currTopRule, prodType, actualMaxLookahead);
          var pathsInsideProduction = paths[0];
          if ((0, isEmpty_1.default)((0, flatten_1.default)(pathsInsideProduction))) {
            var errMsg = errMsgProvider.buildEmptyRepetitionError({
              topLevelRule: currTopRule,
              repetition: currProd
            });
            errors.push({
              message: errMsg,
              type: parser_1.ParserDefinitionErrorType.NO_NON_EMPTY_LOOKAHEAD,
              ruleName: currTopRule.name
            });
          }
        });
      });
      return errors;
    }
    exports2.validateSomeNonEmptyLookaheadPath = validateSomeNonEmptyLookaheadPath;
    function checkAlternativesAmbiguities(alternatives, alternation, rule, errMsgProvider) {
      var foundAmbiguousPaths = [];
      var identicalAmbiguities = (0, reduce_1.default)(alternatives, function(result, currAlt, currAltIdx) {
        if (alternation.definition[currAltIdx].ignoreAmbiguities === true) {
          return result;
        }
        (0, forEach_1.default)(currAlt, function(currPath) {
          var altsCurrPathAppearsIn = [currAltIdx];
          (0, forEach_1.default)(alternatives, function(currOtherAlt, currOtherAltIdx) {
            if (currAltIdx !== currOtherAltIdx && (0, lookahead_1.containsPath)(currOtherAlt, currPath) && // ignore (skip) ambiguities with this "other" alternative
            alternation.definition[currOtherAltIdx].ignoreAmbiguities !== true) {
              altsCurrPathAppearsIn.push(currOtherAltIdx);
            }
          });
          if (altsCurrPathAppearsIn.length > 1 && !(0, lookahead_1.containsPath)(foundAmbiguousPaths, currPath)) {
            foundAmbiguousPaths.push(currPath);
            result.push({
              alts: altsCurrPathAppearsIn,
              path: currPath
            });
          }
        });
        return result;
      }, []);
      var currErrors = (0, map_1.default)(identicalAmbiguities, function(currAmbDescriptor) {
        var ambgIndices = (0, map_1.default)(currAmbDescriptor.alts, function(currAltIdx) {
          return currAltIdx + 1;
        });
        var currMessage = errMsgProvider.buildAlternationAmbiguityError({
          topLevelRule: rule,
          alternation,
          ambiguityIndices: ambgIndices,
          prefixPath: currAmbDescriptor.path
        });
        return {
          message: currMessage,
          type: parser_1.ParserDefinitionErrorType.AMBIGUOUS_ALTS,
          ruleName: rule.name,
          occurrence: alternation.idx,
          alternatives: currAmbDescriptor.alts
        };
      });
      return currErrors;
    }
    function checkPrefixAlternativesAmbiguities(alternatives, alternation, rule, errMsgProvider) {
      var pathsAndIndices = (0, reduce_1.default)(alternatives, function(result, currAlt, idx) {
        var currPathsAndIdx = (0, map_1.default)(currAlt, function(currPath) {
          return { idx, path: currPath };
        });
        return result.concat(currPathsAndIdx);
      }, []);
      var errors = (0, compact_1.default)((0, flatMap_1.default)(pathsAndIndices, function(currPathAndIdx) {
        var alternativeGast = alternation.definition[currPathAndIdx.idx];
        if (alternativeGast.ignoreAmbiguities === true) {
          return [];
        }
        var targetIdx = currPathAndIdx.idx;
        var targetPath = currPathAndIdx.path;
        var prefixAmbiguitiesPathsAndIndices = (0, filter_1.default)(pathsAndIndices, function(searchPathAndIdx) {
          return (
            // ignore (skip) ambiguities with this "other" alternative
            alternation.definition[searchPathAndIdx.idx].ignoreAmbiguities !== true && searchPathAndIdx.idx < targetIdx && // checking for strict prefix because identical lookaheads
            // will be be detected using a different validation.
            (0, lookahead_1.isStrictPrefixOfPath)(searchPathAndIdx.path, targetPath)
          );
        });
        var currPathPrefixErrors = (0, map_1.default)(prefixAmbiguitiesPathsAndIndices, function(currAmbPathAndIdx) {
          var ambgIndices = [currAmbPathAndIdx.idx + 1, targetIdx + 1];
          var occurrence = alternation.idx === 0 ? "" : alternation.idx;
          var message = errMsgProvider.buildAlternationPrefixAmbiguityError({
            topLevelRule: rule,
            alternation,
            ambiguityIndices: ambgIndices,
            prefixPath: currAmbPathAndIdx.path
          });
          return {
            message,
            type: parser_1.ParserDefinitionErrorType.AMBIGUOUS_PREFIX_ALTS,
            ruleName: rule.name,
            occurrence,
            alternatives: ambgIndices
          };
        });
        return currPathPrefixErrors;
      }));
      return errors;
    }
    exports2.checkPrefixAlternativesAmbiguities = checkPrefixAlternativesAmbiguities;
    function checkTerminalAndNoneTerminalsNameSpace(topLevels, tokenTypes, errMsgProvider) {
      var errors = [];
      var tokenNames = (0, map_1.default)(tokenTypes, function(currToken) {
        return currToken.name;
      });
      (0, forEach_1.default)(topLevels, function(currRule) {
        var currRuleName = currRule.name;
        if ((0, includes_1.default)(tokenNames, currRuleName)) {
          var errMsg = errMsgProvider.buildNamespaceConflictError(currRule);
          errors.push({
            message: errMsg,
            type: parser_1.ParserDefinitionErrorType.CONFLICT_TOKENS_RULES_NAMESPACE,
            ruleName: currRuleName
          });
        }
      });
      return errors;
    }
  }
});

// node_modules/chevrotain/lib/src/parse/grammar/gast/gast_resolver_public.js
var require_gast_resolver_public = __commonJS({
  "node_modules/chevrotain/lib/src/parse/grammar/gast/gast_resolver_public.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateGrammar = exports2.resolveGrammar = void 0;
    var forEach_1 = __importDefault(require_forEach());
    var defaults_1 = __importDefault(require_defaults());
    var resolver_1 = require_resolver();
    var checks_1 = require_checks();
    var errors_public_1 = require_errors_public();
    function resolveGrammar(options) {
      var actualOptions = (0, defaults_1.default)(options, {
        errMsgProvider: errors_public_1.defaultGrammarResolverErrorProvider
      });
      var topRulesTable = {};
      (0, forEach_1.default)(options.rules, function(rule) {
        topRulesTable[rule.name] = rule;
      });
      return (0, resolver_1.resolveGrammar)(topRulesTable, actualOptions.errMsgProvider);
    }
    exports2.resolveGrammar = resolveGrammar;
    function validateGrammar(options) {
      options = (0, defaults_1.default)(options, {
        errMsgProvider: errors_public_1.defaultGrammarValidatorErrorProvider
      });
      return (0, checks_1.validateGrammar)(options.rules, options.tokenTypes, options.errMsgProvider, options.grammarName);
    }
    exports2.validateGrammar = validateGrammar;
  }
});

// node_modules/chevrotain/lib/src/parse/exceptions_public.js
var require_exceptions_public = __commonJS({
  "node_modules/chevrotain/lib/src/parse/exceptions_public.js"(exports2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || function() {
      var extendStatics = function(d, b5) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b6) {
          d2.__proto__ = b6;
        } || function(d2, b6) {
          for (var p in b6)
            if (Object.prototype.hasOwnProperty.call(b6, p))
              d2[p] = b6[p];
        };
        return extendStatics(d, b5);
      };
      return function(d, b5) {
        if (typeof b5 !== "function" && b5 !== null)
          throw new TypeError("Class extends value " + String(b5) + " is not a constructor or null");
        extendStatics(d, b5);
        function __() {
          this.constructor = d;
        }
        d.prototype = b5 === null ? Object.create(b5) : (__.prototype = b5.prototype, new __());
      };
    }();
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.EarlyExitException = exports2.NotAllInputParsedException = exports2.NoViableAltException = exports2.MismatchedTokenException = exports2.isRecognitionException = void 0;
    var includes_1 = __importDefault(require_includes());
    var MISMATCHED_TOKEN_EXCEPTION = "MismatchedTokenException";
    var NO_VIABLE_ALT_EXCEPTION = "NoViableAltException";
    var EARLY_EXIT_EXCEPTION = "EarlyExitException";
    var NOT_ALL_INPUT_PARSED_EXCEPTION = "NotAllInputParsedException";
    var RECOGNITION_EXCEPTION_NAMES = [
      MISMATCHED_TOKEN_EXCEPTION,
      NO_VIABLE_ALT_EXCEPTION,
      EARLY_EXIT_EXCEPTION,
      NOT_ALL_INPUT_PARSED_EXCEPTION
    ];
    Object.freeze(RECOGNITION_EXCEPTION_NAMES);
    function isRecognitionException2(error) {
      return (0, includes_1.default)(RECOGNITION_EXCEPTION_NAMES, error.name);
    }
    exports2.isRecognitionException = isRecognitionException2;
    var RecognitionException = (
      /** @class */
      function(_super) {
        __extends(RecognitionException2, _super);
        function RecognitionException2(message, token) {
          var _newTarget = this.constructor;
          var _this = _super.call(this, message) || this;
          _this.token = token;
          _this.resyncedTokens = [];
          Object.setPrototypeOf(_this, _newTarget.prototype);
          if (Error.captureStackTrace) {
            Error.captureStackTrace(_this, _this.constructor);
          }
          return _this;
        }
        return RecognitionException2;
      }(Error)
    );
    var MismatchedTokenException2 = (
      /** @class */
      function(_super) {
        __extends(MismatchedTokenException3, _super);
        function MismatchedTokenException3(message, token, previousToken) {
          var _this = _super.call(this, message, token) || this;
          _this.previousToken = previousToken;
          _this.name = MISMATCHED_TOKEN_EXCEPTION;
          return _this;
        }
        return MismatchedTokenException3;
      }(RecognitionException)
    );
    exports2.MismatchedTokenException = MismatchedTokenException2;
    var NoViableAltException2 = (
      /** @class */
      function(_super) {
        __extends(NoViableAltException3, _super);
        function NoViableAltException3(message, token, previousToken) {
          var _this = _super.call(this, message, token) || this;
          _this.previousToken = previousToken;
          _this.name = NO_VIABLE_ALT_EXCEPTION;
          return _this;
        }
        return NoViableAltException3;
      }(RecognitionException)
    );
    exports2.NoViableAltException = NoViableAltException2;
    var NotAllInputParsedException2 = (
      /** @class */
      function(_super) {
        __extends(NotAllInputParsedException3, _super);
        function NotAllInputParsedException3(message, token) {
          var _this = _super.call(this, message, token) || this;
          _this.name = NOT_ALL_INPUT_PARSED_EXCEPTION;
          return _this;
        }
        return NotAllInputParsedException3;
      }(RecognitionException)
    );
    exports2.NotAllInputParsedException = NotAllInputParsedException2;
    var EarlyExitException2 = (
      /** @class */
      function(_super) {
        __extends(EarlyExitException3, _super);
        function EarlyExitException3(message, token, previousToken) {
          var _this = _super.call(this, message, token) || this;
          _this.previousToken = previousToken;
          _this.name = EARLY_EXIT_EXCEPTION;
          return _this;
        }
        return EarlyExitException3;
      }(RecognitionException)
    );
    exports2.EarlyExitException = EarlyExitException2;
  }
});

// node_modules/chevrotain/lib/src/parse/parser/traits/recoverable.js
var require_recoverable = __commonJS({
  "node_modules/chevrotain/lib/src/parse/parser/traits/recoverable.js"(exports2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || function() {
      var extendStatics = function(d, b5) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b6) {
          d2.__proto__ = b6;
        } || function(d2, b6) {
          for (var p in b6)
            if (Object.prototype.hasOwnProperty.call(b6, p))
              d2[p] = b6[p];
        };
        return extendStatics(d, b5);
      };
      return function(d, b5) {
        if (typeof b5 !== "function" && b5 !== null)
          throw new TypeError("Class extends value " + String(b5) + " is not a constructor or null");
        extendStatics(d, b5);
        function __() {
          this.constructor = d;
        }
        d.prototype = b5 === null ? Object.create(b5) : (__.prototype = b5.prototype, new __());
      };
    }();
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.attemptInRepetitionRecovery = exports2.Recoverable = exports2.InRuleRecoveryException = exports2.IN_RULE_RECOVERY_EXCEPTION = exports2.EOF_FOLLOW_KEY = void 0;
    var tokens_public_1 = require_tokens_public();
    var isEmpty_1 = __importDefault(require_isEmpty());
    var dropRight_1 = __importDefault(require_dropRight());
    var flatten_1 = __importDefault(require_flatten());
    var map_1 = __importDefault(require_map());
    var find_1 = __importDefault(require_find());
    var has_1 = __importDefault(require_has());
    var includes_1 = __importDefault(require_includes());
    var clone_1 = __importDefault(require_clone());
    var exceptions_public_1 = require_exceptions_public();
    var constants_1 = require_constants();
    var parser_1 = require_parser();
    exports2.EOF_FOLLOW_KEY = {};
    exports2.IN_RULE_RECOVERY_EXCEPTION = "InRuleRecoveryException";
    var InRuleRecoveryException = (
      /** @class */
      function(_super) {
        __extends(InRuleRecoveryException2, _super);
        function InRuleRecoveryException2(message) {
          var _this = _super.call(this, message) || this;
          _this.name = exports2.IN_RULE_RECOVERY_EXCEPTION;
          return _this;
        }
        return InRuleRecoveryException2;
      }(Error)
    );
    exports2.InRuleRecoveryException = InRuleRecoveryException;
    var Recoverable = (
      /** @class */
      function() {
        function Recoverable2() {
        }
        Recoverable2.prototype.initRecoverable = function(config3) {
          this.firstAfterRepMap = {};
          this.resyncFollows = {};
          this.recoveryEnabled = (0, has_1.default)(config3, "recoveryEnabled") ? config3.recoveryEnabled : parser_1.DEFAULT_PARSER_CONFIG.recoveryEnabled;
          if (this.recoveryEnabled) {
            this.attemptInRepetitionRecovery = attemptInRepetitionRecovery;
          }
        };
        Recoverable2.prototype.getTokenToInsert = function(tokType) {
          var tokToInsert = (0, tokens_public_1.createTokenInstance)(tokType, "", NaN, NaN, NaN, NaN, NaN, NaN);
          tokToInsert.isInsertedInRecovery = true;
          return tokToInsert;
        };
        Recoverable2.prototype.canTokenTypeBeInsertedInRecovery = function(tokType) {
          return true;
        };
        Recoverable2.prototype.canTokenTypeBeDeletedInRecovery = function(tokType) {
          return true;
        };
        Recoverable2.prototype.tryInRepetitionRecovery = function(grammarRule, grammarRuleArgs, lookAheadFunc, expectedTokType) {
          var _this = this;
          var reSyncTokType = this.findReSyncTokenType();
          var savedLexerState = this.exportLexerState();
          var resyncedTokens = [];
          var passedResyncPoint = false;
          var nextTokenWithoutResync = this.LA(1);
          var currToken = this.LA(1);
          var generateErrorMessage = function() {
            var previousToken = _this.LA(0);
            var msg = _this.errorMessageProvider.buildMismatchTokenMessage({
              expected: expectedTokType,
              actual: nextTokenWithoutResync,
              previous: previousToken,
              ruleName: _this.getCurrRuleFullName()
            });
            var error = new exceptions_public_1.MismatchedTokenException(msg, nextTokenWithoutResync, _this.LA(0));
            error.resyncedTokens = (0, dropRight_1.default)(resyncedTokens);
            _this.SAVE_ERROR(error);
          };
          while (!passedResyncPoint) {
            if (this.tokenMatcher(currToken, expectedTokType)) {
              generateErrorMessage();
              return;
            } else if (lookAheadFunc.call(this)) {
              generateErrorMessage();
              grammarRule.apply(this, grammarRuleArgs);
              return;
            } else if (this.tokenMatcher(currToken, reSyncTokType)) {
              passedResyncPoint = true;
            } else {
              currToken = this.SKIP_TOKEN();
              this.addToResyncTokens(currToken, resyncedTokens);
            }
          }
          this.importLexerState(savedLexerState);
        };
        Recoverable2.prototype.shouldInRepetitionRecoveryBeTried = function(expectTokAfterLastMatch, nextTokIdx, notStuck) {
          if (notStuck === false) {
            return false;
          }
          if (this.tokenMatcher(this.LA(1), expectTokAfterLastMatch)) {
            return false;
          }
          if (this.isBackTracking()) {
            return false;
          }
          if (this.canPerformInRuleRecovery(expectTokAfterLastMatch, this.getFollowsForInRuleRecovery(expectTokAfterLastMatch, nextTokIdx))) {
            return false;
          }
          return true;
        };
        Recoverable2.prototype.getFollowsForInRuleRecovery = function(tokType, tokIdxInRule) {
          var grammarPath = this.getCurrentGrammarPath(tokType, tokIdxInRule);
          var follows = this.getNextPossibleTokenTypes(grammarPath);
          return follows;
        };
        Recoverable2.prototype.tryInRuleRecovery = function(expectedTokType, follows) {
          if (this.canRecoverWithSingleTokenInsertion(expectedTokType, follows)) {
            var tokToInsert = this.getTokenToInsert(expectedTokType);
            return tokToInsert;
          }
          if (this.canRecoverWithSingleTokenDeletion(expectedTokType)) {
            var nextTok = this.SKIP_TOKEN();
            this.consumeToken();
            return nextTok;
          }
          throw new InRuleRecoveryException("sad sad panda");
        };
        Recoverable2.prototype.canPerformInRuleRecovery = function(expectedToken, follows) {
          return this.canRecoverWithSingleTokenInsertion(expectedToken, follows) || this.canRecoverWithSingleTokenDeletion(expectedToken);
        };
        Recoverable2.prototype.canRecoverWithSingleTokenInsertion = function(expectedTokType, follows) {
          var _this = this;
          if (!this.canTokenTypeBeInsertedInRecovery(expectedTokType)) {
            return false;
          }
          if ((0, isEmpty_1.default)(follows)) {
            return false;
          }
          var mismatchedTok = this.LA(1);
          var isMisMatchedTokInFollows = (0, find_1.default)(follows, function(possibleFollowsTokType) {
            return _this.tokenMatcher(mismatchedTok, possibleFollowsTokType);
          }) !== void 0;
          return isMisMatchedTokInFollows;
        };
        Recoverable2.prototype.canRecoverWithSingleTokenDeletion = function(expectedTokType) {
          if (!this.canTokenTypeBeDeletedInRecovery(expectedTokType)) {
            return false;
          }
          var isNextTokenWhatIsExpected = this.tokenMatcher(this.LA(2), expectedTokType);
          return isNextTokenWhatIsExpected;
        };
        Recoverable2.prototype.isInCurrentRuleReSyncSet = function(tokenTypeIdx) {
          var followKey = this.getCurrFollowKey();
          var currentRuleReSyncSet = this.getFollowSetFromFollowKey(followKey);
          return (0, includes_1.default)(currentRuleReSyncSet, tokenTypeIdx);
        };
        Recoverable2.prototype.findReSyncTokenType = function() {
          var allPossibleReSyncTokTypes = this.flattenFollowSet();
          var nextToken = this.LA(1);
          var k = 2;
          while (true) {
            var foundMatch = (0, find_1.default)(allPossibleReSyncTokTypes, function(resyncTokType) {
              var canMatch = (0, tokens_public_1.tokenMatcher)(nextToken, resyncTokType);
              return canMatch;
            });
            if (foundMatch !== void 0) {
              return foundMatch;
            }
            nextToken = this.LA(k);
            k++;
          }
        };
        Recoverable2.prototype.getCurrFollowKey = function() {
          if (this.RULE_STACK.length === 1) {
            return exports2.EOF_FOLLOW_KEY;
          }
          var currRuleShortName = this.getLastExplicitRuleShortName();
          var currRuleIdx = this.getLastExplicitRuleOccurrenceIndex();
          var prevRuleShortName = this.getPreviousExplicitRuleShortName();
          return {
            ruleName: this.shortRuleNameToFullName(currRuleShortName),
            idxInCallingRule: currRuleIdx,
            inRule: this.shortRuleNameToFullName(prevRuleShortName)
          };
        };
        Recoverable2.prototype.buildFullFollowKeyStack = function() {
          var _this = this;
          var explicitRuleStack = this.RULE_STACK;
          var explicitOccurrenceStack = this.RULE_OCCURRENCE_STACK;
          return (0, map_1.default)(explicitRuleStack, function(ruleName, idx) {
            if (idx === 0) {
              return exports2.EOF_FOLLOW_KEY;
            }
            return {
              ruleName: _this.shortRuleNameToFullName(ruleName),
              idxInCallingRule: explicitOccurrenceStack[idx],
              inRule: _this.shortRuleNameToFullName(explicitRuleStack[idx - 1])
            };
          });
        };
        Recoverable2.prototype.flattenFollowSet = function() {
          var _this = this;
          var followStack = (0, map_1.default)(this.buildFullFollowKeyStack(), function(currKey) {
            return _this.getFollowSetFromFollowKey(currKey);
          });
          return (0, flatten_1.default)(followStack);
        };
        Recoverable2.prototype.getFollowSetFromFollowKey = function(followKey) {
          if (followKey === exports2.EOF_FOLLOW_KEY) {
            return [tokens_public_1.EOF];
          }
          var followName = followKey.ruleName + followKey.idxInCallingRule + constants_1.IN + followKey.inRule;
          return this.resyncFollows[followName];
        };
        Recoverable2.prototype.addToResyncTokens = function(token, resyncTokens) {
          if (!this.tokenMatcher(token, tokens_public_1.EOF)) {
            resyncTokens.push(token);
          }
          return resyncTokens;
        };
        Recoverable2.prototype.reSyncTo = function(tokType) {
          var resyncedTokens = [];
          var nextTok = this.LA(1);
          while (this.tokenMatcher(nextTok, tokType) === false) {
            nextTok = this.SKIP_TOKEN();
            this.addToResyncTokens(nextTok, resyncedTokens);
          }
          return (0, dropRight_1.default)(resyncedTokens);
        };
        Recoverable2.prototype.attemptInRepetitionRecovery = function(prodFunc, args, lookaheadFunc, dslMethodIdx, prodOccurrence, nextToksWalker, notStuck) {
        };
        Recoverable2.prototype.getCurrentGrammarPath = function(tokType, tokIdxInRule) {
          var pathRuleStack = this.getHumanReadableRuleStack();
          var pathOccurrenceStack = (0, clone_1.default)(this.RULE_OCCURRENCE_STACK);
          var grammarPath = {
            ruleStack: pathRuleStack,
            occurrenceStack: pathOccurrenceStack,
            lastTok: tokType,
            lastTokOccurrence: tokIdxInRule
          };
          return grammarPath;
        };
        Recoverable2.prototype.getHumanReadableRuleStack = function() {
          var _this = this;
          return (0, map_1.default)(this.RULE_STACK, function(currShortName) {
            return _this.shortRuleNameToFullName(currShortName);
          });
        };
        return Recoverable2;
      }()
    );
    exports2.Recoverable = Recoverable;
    function attemptInRepetitionRecovery(prodFunc, args, lookaheadFunc, dslMethodIdx, prodOccurrence, nextToksWalker, notStuck) {
      var key = this.getKeyForAutomaticLookahead(dslMethodIdx, prodOccurrence);
      var firstAfterRepInfo = this.firstAfterRepMap[key];
      if (firstAfterRepInfo === void 0) {
        var currRuleName = this.getCurrRuleFullName();
        var ruleGrammar = this.getGAstProductions()[currRuleName];
        var walker = new nextToksWalker(ruleGrammar, prodOccurrence);
        firstAfterRepInfo = walker.startWalking();
        this.firstAfterRepMap[key] = firstAfterRepInfo;
      }
      var expectTokAfterLastMatch = firstAfterRepInfo.token;
      var nextTokIdx = firstAfterRepInfo.occurrence;
      var isEndOfRule = firstAfterRepInfo.isEndOfRule;
      if (this.RULE_STACK.length === 1 && isEndOfRule && expectTokAfterLastMatch === void 0) {
        expectTokAfterLastMatch = tokens_public_1.EOF;
        nextTokIdx = 1;
      }
      if (expectTokAfterLastMatch === void 0 || nextTokIdx === void 0) {
        return;
      }
      if (this.shouldInRepetitionRecoveryBeTried(expectTokAfterLastMatch, nextTokIdx, notStuck)) {
        this.tryInRepetitionRecovery(prodFunc, args, lookaheadFunc, expectTokAfterLastMatch);
      }
    }
    exports2.attemptInRepetitionRecovery = attemptInRepetitionRecovery;
  }
});

// node_modules/chevrotain/lib/src/parse/grammar/keys.js
var require_keys2 = __commonJS({
  "node_modules/chevrotain/lib/src/parse/grammar/keys.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getKeyForAutomaticLookahead = exports2.AT_LEAST_ONE_SEP_IDX = exports2.MANY_SEP_IDX = exports2.AT_LEAST_ONE_IDX = exports2.MANY_IDX = exports2.OPTION_IDX = exports2.OR_IDX = exports2.BITS_FOR_ALT_IDX = exports2.BITS_FOR_RULE_IDX = exports2.BITS_FOR_OCCURRENCE_IDX = exports2.BITS_FOR_METHOD_TYPE = void 0;
    exports2.BITS_FOR_METHOD_TYPE = 4;
    exports2.BITS_FOR_OCCURRENCE_IDX = 8;
    exports2.BITS_FOR_RULE_IDX = 12;
    exports2.BITS_FOR_ALT_IDX = 8;
    exports2.OR_IDX = 1 << exports2.BITS_FOR_OCCURRENCE_IDX;
    exports2.OPTION_IDX = 2 << exports2.BITS_FOR_OCCURRENCE_IDX;
    exports2.MANY_IDX = 3 << exports2.BITS_FOR_OCCURRENCE_IDX;
    exports2.AT_LEAST_ONE_IDX = 4 << exports2.BITS_FOR_OCCURRENCE_IDX;
    exports2.MANY_SEP_IDX = 5 << exports2.BITS_FOR_OCCURRENCE_IDX;
    exports2.AT_LEAST_ONE_SEP_IDX = 6 << exports2.BITS_FOR_OCCURRENCE_IDX;
    function getKeyForAutomaticLookahead(ruleIdx, dslMethodIdx, occurrence) {
      return occurrence | dslMethodIdx | ruleIdx;
    }
    exports2.getKeyForAutomaticLookahead = getKeyForAutomaticLookahead;
    var BITS_START_FOR_ALT_IDX = 32 - exports2.BITS_FOR_ALT_IDX;
  }
});

// node_modules/chevrotain/lib/src/parse/grammar/llk_lookahead.js
var require_llk_lookahead = __commonJS({
  "node_modules/chevrotain/lib/src/parse/grammar/llk_lookahead.js"(exports2) {
    "use strict";
    var __spreadArray = exports2 && exports2.__spreadArray || function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i3 = 0, l = from.length, ar; i3 < l; i3++) {
          if (ar || !(i3 in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i3);
            ar[i3] = from[i3];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LLkLookaheadStrategy = void 0;
    var flatMap_1 = __importDefault(require_flatMap());
    var isEmpty_1 = __importDefault(require_isEmpty());
    var errors_public_1 = require_errors_public();
    var parser_1 = require_parser();
    var checks_1 = require_checks();
    var lookahead_1 = require_lookahead();
    var LLkLookaheadStrategy2 = (
      /** @class */
      function() {
        function LLkLookaheadStrategy3(options) {
          var _a4;
          this.maxLookahead = (_a4 = options === null || options === void 0 ? void 0 : options.maxLookahead) !== null && _a4 !== void 0 ? _a4 : parser_1.DEFAULT_PARSER_CONFIG.maxLookahead;
        }
        LLkLookaheadStrategy3.prototype.validate = function(options) {
          var leftRecursionErrors = this.validateNoLeftRecursion(options.rules);
          if ((0, isEmpty_1.default)(leftRecursionErrors)) {
            var emptyAltErrors = this.validateEmptyOrAlternatives(options.rules);
            var ambiguousAltsErrors = this.validateAmbiguousAlternationAlternatives(options.rules, this.maxLookahead);
            var emptyRepetitionErrors = this.validateSomeNonEmptyLookaheadPath(options.rules, this.maxLookahead);
            var allErrors = __spreadArray(__spreadArray(__spreadArray(__spreadArray([], leftRecursionErrors, true), emptyAltErrors, true), ambiguousAltsErrors, true), emptyRepetitionErrors, true);
            return allErrors;
          }
          return leftRecursionErrors;
        };
        LLkLookaheadStrategy3.prototype.validateNoLeftRecursion = function(rules) {
          return (0, flatMap_1.default)(rules, function(currTopRule) {
            return (0, checks_1.validateNoLeftRecursion)(currTopRule, currTopRule, errors_public_1.defaultGrammarValidatorErrorProvider);
          });
        };
        LLkLookaheadStrategy3.prototype.validateEmptyOrAlternatives = function(rules) {
          return (0, flatMap_1.default)(rules, function(currTopRule) {
            return (0, checks_1.validateEmptyOrAlternative)(currTopRule, errors_public_1.defaultGrammarValidatorErrorProvider);
          });
        };
        LLkLookaheadStrategy3.prototype.validateAmbiguousAlternationAlternatives = function(rules, maxLookahead) {
          return (0, flatMap_1.default)(rules, function(currTopRule) {
            return (0, checks_1.validateAmbiguousAlternationAlternatives)(currTopRule, maxLookahead, errors_public_1.defaultGrammarValidatorErrorProvider);
          });
        };
        LLkLookaheadStrategy3.prototype.validateSomeNonEmptyLookaheadPath = function(rules, maxLookahead) {
          return (0, checks_1.validateSomeNonEmptyLookaheadPath)(rules, maxLookahead, errors_public_1.defaultGrammarValidatorErrorProvider);
        };
        LLkLookaheadStrategy3.prototype.buildLookaheadForAlternation = function(options) {
          return (0, lookahead_1.buildLookaheadFuncForOr)(options.prodOccurrence, options.rule, options.maxLookahead, options.hasPredicates, options.dynamicTokensEnabled, lookahead_1.buildAlternativesLookAheadFunc);
        };
        LLkLookaheadStrategy3.prototype.buildLookaheadForOptional = function(options) {
          return (0, lookahead_1.buildLookaheadFuncForOptionalProd)(options.prodOccurrence, options.rule, options.maxLookahead, options.dynamicTokensEnabled, (0, lookahead_1.getProdType)(options.prodType), lookahead_1.buildSingleAlternativeLookaheadFunction);
        };
        return LLkLookaheadStrategy3;
      }()
    );
    exports2.LLkLookaheadStrategy = LLkLookaheadStrategy2;
  }
});

// node_modules/chevrotain/lib/src/parse/parser/traits/looksahead.js
var require_looksahead = __commonJS({
  "node_modules/chevrotain/lib/src/parse/parser/traits/looksahead.js"(exports2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || function() {
      var extendStatics = function(d, b5) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b6) {
          d2.__proto__ = b6;
        } || function(d2, b6) {
          for (var p in b6)
            if (Object.prototype.hasOwnProperty.call(b6, p))
              d2[p] = b6[p];
        };
        return extendStatics(d, b5);
      };
      return function(d, b5) {
        if (typeof b5 !== "function" && b5 !== null)
          throw new TypeError("Class extends value " + String(b5) + " is not a constructor or null");
        extendStatics(d, b5);
        function __() {
          this.constructor = d;
        }
        d.prototype = b5 === null ? Object.create(b5) : (__.prototype = b5.prototype, new __());
      };
    }();
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.collectMethods = exports2.LooksAhead = void 0;
    var forEach_1 = __importDefault(require_forEach());
    var has_1 = __importDefault(require_has());
    var parser_1 = require_parser();
    var keys_1 = require_keys2();
    var gast_1 = require_api2();
    var gast_2 = require_api2();
    var llk_lookahead_1 = require_llk_lookahead();
    var LooksAhead = (
      /** @class */
      function() {
        function LooksAhead2() {
        }
        LooksAhead2.prototype.initLooksAhead = function(config3) {
          this.dynamicTokensEnabled = (0, has_1.default)(config3, "dynamicTokensEnabled") ? config3.dynamicTokensEnabled : parser_1.DEFAULT_PARSER_CONFIG.dynamicTokensEnabled;
          this.maxLookahead = (0, has_1.default)(config3, "maxLookahead") ? config3.maxLookahead : parser_1.DEFAULT_PARSER_CONFIG.maxLookahead;
          this.lookaheadStrategy = (0, has_1.default)(config3, "lookaheadStrategy") ? config3.lookaheadStrategy : new llk_lookahead_1.LLkLookaheadStrategy({ maxLookahead: this.maxLookahead });
          this.lookAheadFuncsCache = /* @__PURE__ */ new Map();
        };
        LooksAhead2.prototype.preComputeLookaheadFunctions = function(rules) {
          var _this = this;
          (0, forEach_1.default)(rules, function(currRule) {
            _this.TRACE_INIT("".concat(currRule.name, " Rule Lookahead"), function() {
              var _a4 = collectMethods(currRule), alternation = _a4.alternation, repetition = _a4.repetition, option = _a4.option, repetitionMandatory = _a4.repetitionMandatory, repetitionMandatoryWithSeparator = _a4.repetitionMandatoryWithSeparator, repetitionWithSeparator = _a4.repetitionWithSeparator;
              (0, forEach_1.default)(alternation, function(currProd) {
                var prodIdx = currProd.idx === 0 ? "" : currProd.idx;
                _this.TRACE_INIT("".concat((0, gast_2.getProductionDslName)(currProd)).concat(prodIdx), function() {
                  var laFunc = _this.lookaheadStrategy.buildLookaheadForAlternation({
                    prodOccurrence: currProd.idx,
                    rule: currRule,
                    maxLookahead: currProd.maxLookahead || _this.maxLookahead,
                    hasPredicates: currProd.hasPredicates,
                    dynamicTokensEnabled: _this.dynamicTokensEnabled
                  });
                  var key = (0, keys_1.getKeyForAutomaticLookahead)(_this.fullRuleNameToShort[currRule.name], keys_1.OR_IDX, currProd.idx);
                  _this.setLaFuncCache(key, laFunc);
                });
              });
              (0, forEach_1.default)(repetition, function(currProd) {
                _this.computeLookaheadFunc(currRule, currProd.idx, keys_1.MANY_IDX, "Repetition", currProd.maxLookahead, (0, gast_2.getProductionDslName)(currProd));
              });
              (0, forEach_1.default)(option, function(currProd) {
                _this.computeLookaheadFunc(currRule, currProd.idx, keys_1.OPTION_IDX, "Option", currProd.maxLookahead, (0, gast_2.getProductionDslName)(currProd));
              });
              (0, forEach_1.default)(repetitionMandatory, function(currProd) {
                _this.computeLookaheadFunc(currRule, currProd.idx, keys_1.AT_LEAST_ONE_IDX, "RepetitionMandatory", currProd.maxLookahead, (0, gast_2.getProductionDslName)(currProd));
              });
              (0, forEach_1.default)(repetitionMandatoryWithSeparator, function(currProd) {
                _this.computeLookaheadFunc(currRule, currProd.idx, keys_1.AT_LEAST_ONE_SEP_IDX, "RepetitionMandatoryWithSeparator", currProd.maxLookahead, (0, gast_2.getProductionDslName)(currProd));
              });
              (0, forEach_1.default)(repetitionWithSeparator, function(currProd) {
                _this.computeLookaheadFunc(currRule, currProd.idx, keys_1.MANY_SEP_IDX, "RepetitionWithSeparator", currProd.maxLookahead, (0, gast_2.getProductionDslName)(currProd));
              });
            });
          });
        };
        LooksAhead2.prototype.computeLookaheadFunc = function(rule, prodOccurrence, prodKey, prodType, prodMaxLookahead, dslMethodName) {
          var _this = this;
          this.TRACE_INIT("".concat(dslMethodName).concat(prodOccurrence === 0 ? "" : prodOccurrence), function() {
            var laFunc = _this.lookaheadStrategy.buildLookaheadForOptional({
              prodOccurrence,
              rule,
              maxLookahead: prodMaxLookahead || _this.maxLookahead,
              dynamicTokensEnabled: _this.dynamicTokensEnabled,
              prodType
            });
            var key = (0, keys_1.getKeyForAutomaticLookahead)(_this.fullRuleNameToShort[rule.name], prodKey, prodOccurrence);
            _this.setLaFuncCache(key, laFunc);
          });
        };
        LooksAhead2.prototype.getKeyForAutomaticLookahead = function(dslMethodIdx, occurrence) {
          var currRuleShortName = this.getLastExplicitRuleShortName();
          return (0, keys_1.getKeyForAutomaticLookahead)(currRuleShortName, dslMethodIdx, occurrence);
        };
        LooksAhead2.prototype.getLaFuncFromCache = function(key) {
          return this.lookAheadFuncsCache.get(key);
        };
        LooksAhead2.prototype.setLaFuncCache = function(key, value) {
          this.lookAheadFuncsCache.set(key, value);
        };
        return LooksAhead2;
      }()
    );
    exports2.LooksAhead = LooksAhead;
    var DslMethodsCollectorVisitor = (
      /** @class */
      function(_super) {
        __extends(DslMethodsCollectorVisitor2, _super);
        function DslMethodsCollectorVisitor2() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this.dslMethods = {
            option: [],
            alternation: [],
            repetition: [],
            repetitionWithSeparator: [],
            repetitionMandatory: [],
            repetitionMandatoryWithSeparator: []
          };
          return _this;
        }
        DslMethodsCollectorVisitor2.prototype.reset = function() {
          this.dslMethods = {
            option: [],
            alternation: [],
            repetition: [],
            repetitionWithSeparator: [],
            repetitionMandatory: [],
            repetitionMandatoryWithSeparator: []
          };
        };
        DslMethodsCollectorVisitor2.prototype.visitOption = function(option) {
          this.dslMethods.option.push(option);
        };
        DslMethodsCollectorVisitor2.prototype.visitRepetitionWithSeparator = function(manySep) {
          this.dslMethods.repetitionWithSeparator.push(manySep);
        };
        DslMethodsCollectorVisitor2.prototype.visitRepetitionMandatory = function(atLeastOne) {
          this.dslMethods.repetitionMandatory.push(atLeastOne);
        };
        DslMethodsCollectorVisitor2.prototype.visitRepetitionMandatoryWithSeparator = function(atLeastOneSep) {
          this.dslMethods.repetitionMandatoryWithSeparator.push(atLeastOneSep);
        };
        DslMethodsCollectorVisitor2.prototype.visitRepetition = function(many) {
          this.dslMethods.repetition.push(many);
        };
        DslMethodsCollectorVisitor2.prototype.visitAlternation = function(or) {
          this.dslMethods.alternation.push(or);
        };
        return DslMethodsCollectorVisitor2;
      }(gast_1.GAstVisitor)
    );
    var collectorVisitor = new DslMethodsCollectorVisitor();
    function collectMethods(rule) {
      collectorVisitor.reset();
      rule.accept(collectorVisitor);
      var dslMethods = collectorVisitor.dslMethods;
      collectorVisitor.reset();
      return dslMethods;
    }
    exports2.collectMethods = collectMethods;
  }
});

// node_modules/chevrotain/lib/src/parse/cst/cst.js
var require_cst = __commonJS({
  "node_modules/chevrotain/lib/src/parse/cst/cst.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.addNoneTerminalToCst = exports2.addTerminalToCst = exports2.setNodeLocationFull = exports2.setNodeLocationOnlyOffset = void 0;
    function setNodeLocationOnlyOffset(currNodeLocation, newLocationInfo) {
      if (isNaN(currNodeLocation.startOffset) === true) {
        currNodeLocation.startOffset = newLocationInfo.startOffset;
        currNodeLocation.endOffset = newLocationInfo.endOffset;
      } else if (currNodeLocation.endOffset < newLocationInfo.endOffset === true) {
        currNodeLocation.endOffset = newLocationInfo.endOffset;
      }
    }
    exports2.setNodeLocationOnlyOffset = setNodeLocationOnlyOffset;
    function setNodeLocationFull(currNodeLocation, newLocationInfo) {
      if (isNaN(currNodeLocation.startOffset) === true) {
        currNodeLocation.startOffset = newLocationInfo.startOffset;
        currNodeLocation.startColumn = newLocationInfo.startColumn;
        currNodeLocation.startLine = newLocationInfo.startLine;
        currNodeLocation.endOffset = newLocationInfo.endOffset;
        currNodeLocation.endColumn = newLocationInfo.endColumn;
        currNodeLocation.endLine = newLocationInfo.endLine;
      } else if (currNodeLocation.endOffset < newLocationInfo.endOffset === true) {
        currNodeLocation.endOffset = newLocationInfo.endOffset;
        currNodeLocation.endColumn = newLocationInfo.endColumn;
        currNodeLocation.endLine = newLocationInfo.endLine;
      }
    }
    exports2.setNodeLocationFull = setNodeLocationFull;
    function addTerminalToCst(node, token, tokenTypeName) {
      if (node.children[tokenTypeName] === void 0) {
        node.children[tokenTypeName] = [token];
      } else {
        node.children[tokenTypeName].push(token);
      }
    }
    exports2.addTerminalToCst = addTerminalToCst;
    function addNoneTerminalToCst(node, ruleName, ruleResult) {
      if (node.children[ruleName] === void 0) {
        node.children[ruleName] = [ruleResult];
      } else {
        node.children[ruleName].push(ruleResult);
      }
    }
    exports2.addNoneTerminalToCst = addNoneTerminalToCst;
  }
});

// node_modules/chevrotain/lib/src/lang/lang_extensions.js
var require_lang_extensions = __commonJS({
  "node_modules/chevrotain/lib/src/lang/lang_extensions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.defineNameProp = void 0;
    var NAME = "name";
    function defineNameProp(obj, nameValue) {
      Object.defineProperty(obj, NAME, {
        enumerable: false,
        configurable: true,
        writable: false,
        value: nameValue
      });
    }
    exports2.defineNameProp = defineNameProp;
  }
});

// node_modules/chevrotain/lib/src/parse/cst/cst_visitor.js
var require_cst_visitor = __commonJS({
  "node_modules/chevrotain/lib/src/parse/cst/cst_visitor.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateMissingCstMethods = exports2.validateVisitor = exports2.CstVisitorDefinitionError = exports2.createBaseVisitorConstructorWithDefaults = exports2.createBaseSemanticVisitorConstructor = exports2.defaultVisit = void 0;
    var isEmpty_1 = __importDefault(require_isEmpty());
    var compact_1 = __importDefault(require_compact());
    var isArray_1 = __importDefault(require_isArray());
    var map_1 = __importDefault(require_map());
    var forEach_1 = __importDefault(require_forEach());
    var filter_1 = __importDefault(require_filter());
    var keys_1 = __importDefault(require_keys());
    var isFunction_1 = __importDefault(require_isFunction());
    var isUndefined_1 = __importDefault(require_isUndefined());
    var lang_extensions_1 = require_lang_extensions();
    function defaultVisit(ctx, param) {
      var childrenNames = (0, keys_1.default)(ctx);
      var childrenNamesLength = childrenNames.length;
      for (var i3 = 0; i3 < childrenNamesLength; i3++) {
        var currChildName = childrenNames[i3];
        var currChildArray = ctx[currChildName];
        var currChildArrayLength = currChildArray.length;
        for (var j = 0; j < currChildArrayLength; j++) {
          var currChild = currChildArray[j];
          if (currChild.tokenTypeIdx === void 0) {
            this[currChild.name](currChild.children, param);
          }
        }
      }
    }
    exports2.defaultVisit = defaultVisit;
    function createBaseSemanticVisitorConstructor(grammarName, ruleNames) {
      var derivedConstructor = function() {
      };
      (0, lang_extensions_1.defineNameProp)(derivedConstructor, grammarName + "BaseSemantics");
      var semanticProto = {
        visit: function(cstNode, param) {
          if ((0, isArray_1.default)(cstNode)) {
            cstNode = cstNode[0];
          }
          if ((0, isUndefined_1.default)(cstNode)) {
            return void 0;
          }
          return this[cstNode.name](cstNode.children, param);
        },
        validateVisitor: function() {
          var semanticDefinitionErrors = validateVisitor(this, ruleNames);
          if (!(0, isEmpty_1.default)(semanticDefinitionErrors)) {
            var errorMessages = (0, map_1.default)(semanticDefinitionErrors, function(currDefError) {
              return currDefError.msg;
            });
            throw Error("Errors Detected in CST Visitor <".concat(this.constructor.name, ">:\n	") + "".concat(errorMessages.join("\n\n").replace(/\n/g, "\n	")));
          }
        }
      };
      derivedConstructor.prototype = semanticProto;
      derivedConstructor.prototype.constructor = derivedConstructor;
      derivedConstructor._RULE_NAMES = ruleNames;
      return derivedConstructor;
    }
    exports2.createBaseSemanticVisitorConstructor = createBaseSemanticVisitorConstructor;
    function createBaseVisitorConstructorWithDefaults(grammarName, ruleNames, baseConstructor) {
      var derivedConstructor = function() {
      };
      (0, lang_extensions_1.defineNameProp)(derivedConstructor, grammarName + "BaseSemanticsWithDefaults");
      var withDefaultsProto = Object.create(baseConstructor.prototype);
      (0, forEach_1.default)(ruleNames, function(ruleName) {
        withDefaultsProto[ruleName] = defaultVisit;
      });
      derivedConstructor.prototype = withDefaultsProto;
      derivedConstructor.prototype.constructor = derivedConstructor;
      return derivedConstructor;
    }
    exports2.createBaseVisitorConstructorWithDefaults = createBaseVisitorConstructorWithDefaults;
    var CstVisitorDefinitionError;
    (function(CstVisitorDefinitionError2) {
      CstVisitorDefinitionError2[CstVisitorDefinitionError2["REDUNDANT_METHOD"] = 0] = "REDUNDANT_METHOD";
      CstVisitorDefinitionError2[CstVisitorDefinitionError2["MISSING_METHOD"] = 1] = "MISSING_METHOD";
    })(CstVisitorDefinitionError = exports2.CstVisitorDefinitionError || (exports2.CstVisitorDefinitionError = {}));
    function validateVisitor(visitorInstance, ruleNames) {
      var missingErrors = validateMissingCstMethods(visitorInstance, ruleNames);
      return missingErrors;
    }
    exports2.validateVisitor = validateVisitor;
    function validateMissingCstMethods(visitorInstance, ruleNames) {
      var missingRuleNames = (0, filter_1.default)(ruleNames, function(currRuleName) {
        return (0, isFunction_1.default)(visitorInstance[currRuleName]) === false;
      });
      var errors = (0, map_1.default)(missingRuleNames, function(currRuleName) {
        return {
          msg: "Missing visitor method: <".concat(currRuleName, "> on ").concat(visitorInstance.constructor.name, " CST Visitor."),
          type: CstVisitorDefinitionError.MISSING_METHOD,
          methodName: currRuleName
        };
      });
      return (0, compact_1.default)(errors);
    }
    exports2.validateMissingCstMethods = validateMissingCstMethods;
  }
});

// node_modules/chevrotain/lib/src/parse/parser/traits/tree_builder.js
var require_tree_builder = __commonJS({
  "node_modules/chevrotain/lib/src/parse/parser/traits/tree_builder.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TreeBuilder = void 0;
    var cst_1 = require_cst();
    var noop_1 = __importDefault(require_noop());
    var has_1 = __importDefault(require_has());
    var keys_1 = __importDefault(require_keys());
    var isUndefined_1 = __importDefault(require_isUndefined());
    var cst_visitor_1 = require_cst_visitor();
    var parser_1 = require_parser();
    var TreeBuilder = (
      /** @class */
      function() {
        function TreeBuilder2() {
        }
        TreeBuilder2.prototype.initTreeBuilder = function(config3) {
          this.CST_STACK = [];
          this.outputCst = config3.outputCst;
          this.nodeLocationTracking = (0, has_1.default)(config3, "nodeLocationTracking") ? config3.nodeLocationTracking : parser_1.DEFAULT_PARSER_CONFIG.nodeLocationTracking;
          if (!this.outputCst) {
            this.cstInvocationStateUpdate = noop_1.default;
            this.cstFinallyStateUpdate = noop_1.default;
            this.cstPostTerminal = noop_1.default;
            this.cstPostNonTerminal = noop_1.default;
            this.cstPostRule = noop_1.default;
          } else {
            if (/full/i.test(this.nodeLocationTracking)) {
              if (this.recoveryEnabled) {
                this.setNodeLocationFromToken = cst_1.setNodeLocationFull;
                this.setNodeLocationFromNode = cst_1.setNodeLocationFull;
                this.cstPostRule = noop_1.default;
                this.setInitialNodeLocation = this.setInitialNodeLocationFullRecovery;
              } else {
                this.setNodeLocationFromToken = noop_1.default;
                this.setNodeLocationFromNode = noop_1.default;
                this.cstPostRule = this.cstPostRuleFull;
                this.setInitialNodeLocation = this.setInitialNodeLocationFullRegular;
              }
            } else if (/onlyOffset/i.test(this.nodeLocationTracking)) {
              if (this.recoveryEnabled) {
                this.setNodeLocationFromToken = cst_1.setNodeLocationOnlyOffset;
                this.setNodeLocationFromNode = cst_1.setNodeLocationOnlyOffset;
                this.cstPostRule = noop_1.default;
                this.setInitialNodeLocation = this.setInitialNodeLocationOnlyOffsetRecovery;
              } else {
                this.setNodeLocationFromToken = noop_1.default;
                this.setNodeLocationFromNode = noop_1.default;
                this.cstPostRule = this.cstPostRuleOnlyOffset;
                this.setInitialNodeLocation = this.setInitialNodeLocationOnlyOffsetRegular;
              }
            } else if (/none/i.test(this.nodeLocationTracking)) {
              this.setNodeLocationFromToken = noop_1.default;
              this.setNodeLocationFromNode = noop_1.default;
              this.cstPostRule = noop_1.default;
              this.setInitialNodeLocation = noop_1.default;
            } else {
              throw Error('Invalid <nodeLocationTracking> config option: "'.concat(config3.nodeLocationTracking, '"'));
            }
          }
        };
        TreeBuilder2.prototype.setInitialNodeLocationOnlyOffsetRecovery = function(cstNode) {
          cstNode.location = {
            startOffset: NaN,
            endOffset: NaN
          };
        };
        TreeBuilder2.prototype.setInitialNodeLocationOnlyOffsetRegular = function(cstNode) {
          cstNode.location = {
            // without error recovery the starting Location of a new CstNode is guaranteed
            // To be the next Token's startOffset (for valid inputs).
            // For invalid inputs there won't be any CSTOutput so this potential
            // inaccuracy does not matter
            startOffset: this.LA(1).startOffset,
            endOffset: NaN
          };
        };
        TreeBuilder2.prototype.setInitialNodeLocationFullRecovery = function(cstNode) {
          cstNode.location = {
            startOffset: NaN,
            startLine: NaN,
            startColumn: NaN,
            endOffset: NaN,
            endLine: NaN,
            endColumn: NaN
          };
        };
        TreeBuilder2.prototype.setInitialNodeLocationFullRegular = function(cstNode) {
          var nextToken = this.LA(1);
          cstNode.location = {
            startOffset: nextToken.startOffset,
            startLine: nextToken.startLine,
            startColumn: nextToken.startColumn,
            endOffset: NaN,
            endLine: NaN,
            endColumn: NaN
          };
        };
        TreeBuilder2.prototype.cstInvocationStateUpdate = function(fullRuleName) {
          var cstNode = {
            name: fullRuleName,
            children: /* @__PURE__ */ Object.create(null)
          };
          this.setInitialNodeLocation(cstNode);
          this.CST_STACK.push(cstNode);
        };
        TreeBuilder2.prototype.cstFinallyStateUpdate = function() {
          this.CST_STACK.pop();
        };
        TreeBuilder2.prototype.cstPostRuleFull = function(ruleCstNode) {
          var prevToken = this.LA(0);
          var loc = ruleCstNode.location;
          if (loc.startOffset <= prevToken.startOffset === true) {
            loc.endOffset = prevToken.endOffset;
            loc.endLine = prevToken.endLine;
            loc.endColumn = prevToken.endColumn;
          } else {
            loc.startOffset = NaN;
            loc.startLine = NaN;
            loc.startColumn = NaN;
          }
        };
        TreeBuilder2.prototype.cstPostRuleOnlyOffset = function(ruleCstNode) {
          var prevToken = this.LA(0);
          var loc = ruleCstNode.location;
          if (loc.startOffset <= prevToken.startOffset === true) {
            loc.endOffset = prevToken.endOffset;
          } else {
            loc.startOffset = NaN;
          }
        };
        TreeBuilder2.prototype.cstPostTerminal = function(key, consumedToken) {
          var rootCst = this.CST_STACK[this.CST_STACK.length - 1];
          (0, cst_1.addTerminalToCst)(rootCst, consumedToken, key);
          this.setNodeLocationFromToken(rootCst.location, consumedToken);
        };
        TreeBuilder2.prototype.cstPostNonTerminal = function(ruleCstResult, ruleName) {
          var preCstNode = this.CST_STACK[this.CST_STACK.length - 1];
          (0, cst_1.addNoneTerminalToCst)(preCstNode, ruleName, ruleCstResult);
          this.setNodeLocationFromNode(preCstNode.location, ruleCstResult.location);
        };
        TreeBuilder2.prototype.getBaseCstVisitorConstructor = function() {
          if ((0, isUndefined_1.default)(this.baseCstVisitorConstructor)) {
            var newBaseCstVisitorConstructor = (0, cst_visitor_1.createBaseSemanticVisitorConstructor)(this.className, (0, keys_1.default)(this.gastProductionsCache));
            this.baseCstVisitorConstructor = newBaseCstVisitorConstructor;
            return newBaseCstVisitorConstructor;
          }
          return this.baseCstVisitorConstructor;
        };
        TreeBuilder2.prototype.getBaseCstVisitorConstructorWithDefaults = function() {
          if ((0, isUndefined_1.default)(this.baseCstVisitorWithDefaultsConstructor)) {
            var newConstructor = (0, cst_visitor_1.createBaseVisitorConstructorWithDefaults)(this.className, (0, keys_1.default)(this.gastProductionsCache), this.getBaseCstVisitorConstructor());
            this.baseCstVisitorWithDefaultsConstructor = newConstructor;
            return newConstructor;
          }
          return this.baseCstVisitorWithDefaultsConstructor;
        };
        TreeBuilder2.prototype.getLastExplicitRuleShortName = function() {
          var ruleStack = this.RULE_STACK;
          return ruleStack[ruleStack.length - 1];
        };
        TreeBuilder2.prototype.getPreviousExplicitRuleShortName = function() {
          var ruleStack = this.RULE_STACK;
          return ruleStack[ruleStack.length - 2];
        };
        TreeBuilder2.prototype.getLastExplicitRuleOccurrenceIndex = function() {
          var occurrenceStack = this.RULE_OCCURRENCE_STACK;
          return occurrenceStack[occurrenceStack.length - 1];
        };
        return TreeBuilder2;
      }()
    );
    exports2.TreeBuilder = TreeBuilder;
  }
});

// node_modules/chevrotain/lib/src/parse/parser/traits/lexer_adapter.js
var require_lexer_adapter = __commonJS({
  "node_modules/chevrotain/lib/src/parse/parser/traits/lexer_adapter.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LexerAdapter = void 0;
    var parser_1 = require_parser();
    var LexerAdapter = (
      /** @class */
      function() {
        function LexerAdapter2() {
        }
        LexerAdapter2.prototype.initLexerAdapter = function() {
          this.tokVector = [];
          this.tokVectorLength = 0;
          this.currIdx = -1;
        };
        Object.defineProperty(LexerAdapter2.prototype, "input", {
          get: function() {
            return this.tokVector;
          },
          set: function(newInput) {
            if (this.selfAnalysisDone !== true) {
              throw Error("Missing <performSelfAnalysis> invocation at the end of the Parser's constructor.");
            }
            this.reset();
            this.tokVector = newInput;
            this.tokVectorLength = newInput.length;
          },
          enumerable: false,
          configurable: true
        });
        LexerAdapter2.prototype.SKIP_TOKEN = function() {
          if (this.currIdx <= this.tokVector.length - 2) {
            this.consumeToken();
            return this.LA(1);
          } else {
            return parser_1.END_OF_FILE;
          }
        };
        LexerAdapter2.prototype.LA = function(howMuch) {
          var soughtIdx = this.currIdx + howMuch;
          if (soughtIdx < 0 || this.tokVectorLength <= soughtIdx) {
            return parser_1.END_OF_FILE;
          } else {
            return this.tokVector[soughtIdx];
          }
        };
        LexerAdapter2.prototype.consumeToken = function() {
          this.currIdx++;
        };
        LexerAdapter2.prototype.exportLexerState = function() {
          return this.currIdx;
        };
        LexerAdapter2.prototype.importLexerState = function(newState) {
          this.currIdx = newState;
        };
        LexerAdapter2.prototype.resetLexerState = function() {
          this.currIdx = -1;
        };
        LexerAdapter2.prototype.moveToTerminatedState = function() {
          this.currIdx = this.tokVector.length - 1;
        };
        LexerAdapter2.prototype.getLexerPosition = function() {
          return this.exportLexerState();
        };
        return LexerAdapter2;
      }()
    );
    exports2.LexerAdapter = LexerAdapter;
  }
});

// node_modules/chevrotain/lib/src/parse/parser/traits/recognizer_api.js
var require_recognizer_api = __commonJS({
  "node_modules/chevrotain/lib/src/parse/parser/traits/recognizer_api.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RecognizerApi = void 0;
    var values_1 = __importDefault(require_values());
    var includes_1 = __importDefault(require_includes());
    var exceptions_public_1 = require_exceptions_public();
    var parser_1 = require_parser();
    var errors_public_1 = require_errors_public();
    var checks_1 = require_checks();
    var gast_1 = require_api2();
    var RecognizerApi = (
      /** @class */
      function() {
        function RecognizerApi2() {
        }
        RecognizerApi2.prototype.ACTION = function(impl) {
          return impl.call(this);
        };
        RecognizerApi2.prototype.consume = function(idx, tokType, options) {
          return this.consumeInternal(tokType, idx, options);
        };
        RecognizerApi2.prototype.subrule = function(idx, ruleToCall, options) {
          return this.subruleInternal(ruleToCall, idx, options);
        };
        RecognizerApi2.prototype.option = function(idx, actionORMethodDef) {
          return this.optionInternal(actionORMethodDef, idx);
        };
        RecognizerApi2.prototype.or = function(idx, altsOrOpts) {
          return this.orInternal(altsOrOpts, idx);
        };
        RecognizerApi2.prototype.many = function(idx, actionORMethodDef) {
          return this.manyInternal(idx, actionORMethodDef);
        };
        RecognizerApi2.prototype.atLeastOne = function(idx, actionORMethodDef) {
          return this.atLeastOneInternal(idx, actionORMethodDef);
        };
        RecognizerApi2.prototype.CONSUME = function(tokType, options) {
          return this.consumeInternal(tokType, 0, options);
        };
        RecognizerApi2.prototype.CONSUME1 = function(tokType, options) {
          return this.consumeInternal(tokType, 1, options);
        };
        RecognizerApi2.prototype.CONSUME2 = function(tokType, options) {
          return this.consumeInternal(tokType, 2, options);
        };
        RecognizerApi2.prototype.CONSUME3 = function(tokType, options) {
          return this.consumeInternal(tokType, 3, options);
        };
        RecognizerApi2.prototype.CONSUME4 = function(tokType, options) {
          return this.consumeInternal(tokType, 4, options);
        };
        RecognizerApi2.prototype.CONSUME5 = function(tokType, options) {
          return this.consumeInternal(tokType, 5, options);
        };
        RecognizerApi2.prototype.CONSUME6 = function(tokType, options) {
          return this.consumeInternal(tokType, 6, options);
        };
        RecognizerApi2.prototype.CONSUME7 = function(tokType, options) {
          return this.consumeInternal(tokType, 7, options);
        };
        RecognizerApi2.prototype.CONSUME8 = function(tokType, options) {
          return this.consumeInternal(tokType, 8, options);
        };
        RecognizerApi2.prototype.CONSUME9 = function(tokType, options) {
          return this.consumeInternal(tokType, 9, options);
        };
        RecognizerApi2.prototype.SUBRULE = function(ruleToCall, options) {
          return this.subruleInternal(ruleToCall, 0, options);
        };
        RecognizerApi2.prototype.SUBRULE1 = function(ruleToCall, options) {
          return this.subruleInternal(ruleToCall, 1, options);
        };
        RecognizerApi2.prototype.SUBRULE2 = function(ruleToCall, options) {
          return this.subruleInternal(ruleToCall, 2, options);
        };
        RecognizerApi2.prototype.SUBRULE3 = function(ruleToCall, options) {
          return this.subruleInternal(ruleToCall, 3, options);
        };
        RecognizerApi2.prototype.SUBRULE4 = function(ruleToCall, options) {
          return this.subruleInternal(ruleToCall, 4, options);
        };
        RecognizerApi2.prototype.SUBRULE5 = function(ruleToCall, options) {
          return this.subruleInternal(ruleToCall, 5, options);
        };
        RecognizerApi2.prototype.SUBRULE6 = function(ruleToCall, options) {
          return this.subruleInternal(ruleToCall, 6, options);
        };
        RecognizerApi2.prototype.SUBRULE7 = function(ruleToCall, options) {
          return this.subruleInternal(ruleToCall, 7, options);
        };
        RecognizerApi2.prototype.SUBRULE8 = function(ruleToCall, options) {
          return this.subruleInternal(ruleToCall, 8, options);
        };
        RecognizerApi2.prototype.SUBRULE9 = function(ruleToCall, options) {
          return this.subruleInternal(ruleToCall, 9, options);
        };
        RecognizerApi2.prototype.OPTION = function(actionORMethodDef) {
          return this.optionInternal(actionORMethodDef, 0);
        };
        RecognizerApi2.prototype.OPTION1 = function(actionORMethodDef) {
          return this.optionInternal(actionORMethodDef, 1);
        };
        RecognizerApi2.prototype.OPTION2 = function(actionORMethodDef) {
          return this.optionInternal(actionORMethodDef, 2);
        };
        RecognizerApi2.prototype.OPTION3 = function(actionORMethodDef) {
          return this.optionInternal(actionORMethodDef, 3);
        };
        RecognizerApi2.prototype.OPTION4 = function(actionORMethodDef) {
          return this.optionInternal(actionORMethodDef, 4);
        };
        RecognizerApi2.prototype.OPTION5 = function(actionORMethodDef) {
          return this.optionInternal(actionORMethodDef, 5);
        };
        RecognizerApi2.prototype.OPTION6 = function(actionORMethodDef) {
          return this.optionInternal(actionORMethodDef, 6);
        };
        RecognizerApi2.prototype.OPTION7 = function(actionORMethodDef) {
          return this.optionInternal(actionORMethodDef, 7);
        };
        RecognizerApi2.prototype.OPTION8 = function(actionORMethodDef) {
          return this.optionInternal(actionORMethodDef, 8);
        };
        RecognizerApi2.prototype.OPTION9 = function(actionORMethodDef) {
          return this.optionInternal(actionORMethodDef, 9);
        };
        RecognizerApi2.prototype.OR = function(altsOrOpts) {
          return this.orInternal(altsOrOpts, 0);
        };
        RecognizerApi2.prototype.OR1 = function(altsOrOpts) {
          return this.orInternal(altsOrOpts, 1);
        };
        RecognizerApi2.prototype.OR2 = function(altsOrOpts) {
          return this.orInternal(altsOrOpts, 2);
        };
        RecognizerApi2.prototype.OR3 = function(altsOrOpts) {
          return this.orInternal(altsOrOpts, 3);
        };
        RecognizerApi2.prototype.OR4 = function(altsOrOpts) {
          return this.orInternal(altsOrOpts, 4);
        };
        RecognizerApi2.prototype.OR5 = function(altsOrOpts) {
          return this.orInternal(altsOrOpts, 5);
        };
        RecognizerApi2.prototype.OR6 = function(altsOrOpts) {
          return this.orInternal(altsOrOpts, 6);
        };
        RecognizerApi2.prototype.OR7 = function(altsOrOpts) {
          return this.orInternal(altsOrOpts, 7);
        };
        RecognizerApi2.prototype.OR8 = function(altsOrOpts) {
          return this.orInternal(altsOrOpts, 8);
        };
        RecognizerApi2.prototype.OR9 = function(altsOrOpts) {
          return this.orInternal(altsOrOpts, 9);
        };
        RecognizerApi2.prototype.MANY = function(actionORMethodDef) {
          this.manyInternal(0, actionORMethodDef);
        };
        RecognizerApi2.prototype.MANY1 = function(actionORMethodDef) {
          this.manyInternal(1, actionORMethodDef);
        };
        RecognizerApi2.prototype.MANY2 = function(actionORMethodDef) {
          this.manyInternal(2, actionORMethodDef);
        };
        RecognizerApi2.prototype.MANY3 = function(actionORMethodDef) {
          this.manyInternal(3, actionORMethodDef);
        };
        RecognizerApi2.prototype.MANY4 = function(actionORMethodDef) {
          this.manyInternal(4, actionORMethodDef);
        };
        RecognizerApi2.prototype.MANY5 = function(actionORMethodDef) {
          this.manyInternal(5, actionORMethodDef);
        };
        RecognizerApi2.prototype.MANY6 = function(actionORMethodDef) {
          this.manyInternal(6, actionORMethodDef);
        };
        RecognizerApi2.prototype.MANY7 = function(actionORMethodDef) {
          this.manyInternal(7, actionORMethodDef);
        };
        RecognizerApi2.prototype.MANY8 = function(actionORMethodDef) {
          this.manyInternal(8, actionORMethodDef);
        };
        RecognizerApi2.prototype.MANY9 = function(actionORMethodDef) {
          this.manyInternal(9, actionORMethodDef);
        };
        RecognizerApi2.prototype.MANY_SEP = function(options) {
          this.manySepFirstInternal(0, options);
        };
        RecognizerApi2.prototype.MANY_SEP1 = function(options) {
          this.manySepFirstInternal(1, options);
        };
        RecognizerApi2.prototype.MANY_SEP2 = function(options) {
          this.manySepFirstInternal(2, options);
        };
        RecognizerApi2.prototype.MANY_SEP3 = function(options) {
          this.manySepFirstInternal(3, options);
        };
        RecognizerApi2.prototype.MANY_SEP4 = function(options) {
          this.manySepFirstInternal(4, options);
        };
        RecognizerApi2.prototype.MANY_SEP5 = function(options) {
          this.manySepFirstInternal(5, options);
        };
        RecognizerApi2.prototype.MANY_SEP6 = function(options) {
          this.manySepFirstInternal(6, options);
        };
        RecognizerApi2.prototype.MANY_SEP7 = function(options) {
          this.manySepFirstInternal(7, options);
        };
        RecognizerApi2.prototype.MANY_SEP8 = function(options) {
          this.manySepFirstInternal(8, options);
        };
        RecognizerApi2.prototype.MANY_SEP9 = function(options) {
          this.manySepFirstInternal(9, options);
        };
        RecognizerApi2.prototype.AT_LEAST_ONE = function(actionORMethodDef) {
          this.atLeastOneInternal(0, actionORMethodDef);
        };
        RecognizerApi2.prototype.AT_LEAST_ONE1 = function(actionORMethodDef) {
          return this.atLeastOneInternal(1, actionORMethodDef);
        };
        RecognizerApi2.prototype.AT_LEAST_ONE2 = function(actionORMethodDef) {
          this.atLeastOneInternal(2, actionORMethodDef);
        };
        RecognizerApi2.prototype.AT_LEAST_ONE3 = function(actionORMethodDef) {
          this.atLeastOneInternal(3, actionORMethodDef);
        };
        RecognizerApi2.prototype.AT_LEAST_ONE4 = function(actionORMethodDef) {
          this.atLeastOneInternal(4, actionORMethodDef);
        };
        RecognizerApi2.prototype.AT_LEAST_ONE5 = function(actionORMethodDef) {
          this.atLeastOneInternal(5, actionORMethodDef);
        };
        RecognizerApi2.prototype.AT_LEAST_ONE6 = function(actionORMethodDef) {
          this.atLeastOneInternal(6, actionORMethodDef);
        };
        RecognizerApi2.prototype.AT_LEAST_ONE7 = function(actionORMethodDef) {
          this.atLeastOneInternal(7, actionORMethodDef);
        };
        RecognizerApi2.prototype.AT_LEAST_ONE8 = function(actionORMethodDef) {
          this.atLeastOneInternal(8, actionORMethodDef);
        };
        RecognizerApi2.prototype.AT_LEAST_ONE9 = function(actionORMethodDef) {
          this.atLeastOneInternal(9, actionORMethodDef);
        };
        RecognizerApi2.prototype.AT_LEAST_ONE_SEP = function(options) {
          this.atLeastOneSepFirstInternal(0, options);
        };
        RecognizerApi2.prototype.AT_LEAST_ONE_SEP1 = function(options) {
          this.atLeastOneSepFirstInternal(1, options);
        };
        RecognizerApi2.prototype.AT_LEAST_ONE_SEP2 = function(options) {
          this.atLeastOneSepFirstInternal(2, options);
        };
        RecognizerApi2.prototype.AT_LEAST_ONE_SEP3 = function(options) {
          this.atLeastOneSepFirstInternal(3, options);
        };
        RecognizerApi2.prototype.AT_LEAST_ONE_SEP4 = function(options) {
          this.atLeastOneSepFirstInternal(4, options);
        };
        RecognizerApi2.prototype.AT_LEAST_ONE_SEP5 = function(options) {
          this.atLeastOneSepFirstInternal(5, options);
        };
        RecognizerApi2.prototype.AT_LEAST_ONE_SEP6 = function(options) {
          this.atLeastOneSepFirstInternal(6, options);
        };
        RecognizerApi2.prototype.AT_LEAST_ONE_SEP7 = function(options) {
          this.atLeastOneSepFirstInternal(7, options);
        };
        RecognizerApi2.prototype.AT_LEAST_ONE_SEP8 = function(options) {
          this.atLeastOneSepFirstInternal(8, options);
        };
        RecognizerApi2.prototype.AT_LEAST_ONE_SEP9 = function(options) {
          this.atLeastOneSepFirstInternal(9, options);
        };
        RecognizerApi2.prototype.RULE = function(name, implementation, config3) {
          if (config3 === void 0) {
            config3 = parser_1.DEFAULT_RULE_CONFIG;
          }
          if ((0, includes_1.default)(this.definedRulesNames, name)) {
            var errMsg = errors_public_1.defaultGrammarValidatorErrorProvider.buildDuplicateRuleNameError({
              topLevelRule: name,
              grammarName: this.className
            });
            var error = {
              message: errMsg,
              type: parser_1.ParserDefinitionErrorType.DUPLICATE_RULE_NAME,
              ruleName: name
            };
            this.definitionErrors.push(error);
          }
          this.definedRulesNames.push(name);
          var ruleImplementation = this.defineRule(name, implementation, config3);
          this[name] = ruleImplementation;
          return ruleImplementation;
        };
        RecognizerApi2.prototype.OVERRIDE_RULE = function(name, impl, config3) {
          if (config3 === void 0) {
            config3 = parser_1.DEFAULT_RULE_CONFIG;
          }
          var ruleErrors = (0, checks_1.validateRuleIsOverridden)(name, this.definedRulesNames, this.className);
          this.definitionErrors = this.definitionErrors.concat(ruleErrors);
          var ruleImplementation = this.defineRule(name, impl, config3);
          this[name] = ruleImplementation;
          return ruleImplementation;
        };
        RecognizerApi2.prototype.BACKTRACK = function(grammarRule, args) {
          return function() {
            this.isBackTrackingStack.push(1);
            var orgState = this.saveRecogState();
            try {
              grammarRule.apply(this, args);
              return true;
            } catch (e) {
              if ((0, exceptions_public_1.isRecognitionException)(e)) {
                return false;
              } else {
                throw e;
              }
            } finally {
              this.reloadRecogState(orgState);
              this.isBackTrackingStack.pop();
            }
          };
        };
        RecognizerApi2.prototype.getGAstProductions = function() {
          return this.gastProductionsCache;
        };
        RecognizerApi2.prototype.getSerializedGastProductions = function() {
          return (0, gast_1.serializeGrammar)((0, values_1.default)(this.gastProductionsCache));
        };
        return RecognizerApi2;
      }()
    );
    exports2.RecognizerApi = RecognizerApi;
  }
});

// node_modules/chevrotain/lib/src/parse/parser/traits/recognizer_engine.js
var require_recognizer_engine = __commonJS({
  "node_modules/chevrotain/lib/src/parse/parser/traits/recognizer_engine.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RecognizerEngine = void 0;
    var isEmpty_1 = __importDefault(require_isEmpty());
    var isArray_1 = __importDefault(require_isArray());
    var flatten_1 = __importDefault(require_flatten());
    var every_1 = __importDefault(require_every());
    var uniq_1 = __importDefault(require_uniq());
    var isObject_1 = __importDefault(require_isObject());
    var has_1 = __importDefault(require_has());
    var values_1 = __importDefault(require_values());
    var reduce_1 = __importDefault(require_reduce());
    var clone_1 = __importDefault(require_clone());
    var keys_1 = require_keys2();
    var exceptions_public_1 = require_exceptions_public();
    var lookahead_1 = require_lookahead();
    var interpreter_1 = require_interpreter();
    var parser_1 = require_parser();
    var recoverable_1 = require_recoverable();
    var tokens_public_1 = require_tokens_public();
    var tokens_1 = require_tokens();
    var RecognizerEngine = (
      /** @class */
      function() {
        function RecognizerEngine2() {
        }
        RecognizerEngine2.prototype.initRecognizerEngine = function(tokenVocabulary, config3) {
          this.className = this.constructor.name;
          this.shortRuleNameToFull = {};
          this.fullRuleNameToShort = {};
          this.ruleShortNameIdx = 256;
          this.tokenMatcher = tokens_1.tokenStructuredMatcherNoCategories;
          this.subruleIdx = 0;
          this.definedRulesNames = [];
          this.tokensMap = {};
          this.isBackTrackingStack = [];
          this.RULE_STACK = [];
          this.RULE_OCCURRENCE_STACK = [];
          this.gastProductionsCache = {};
          if ((0, has_1.default)(config3, "serializedGrammar")) {
            throw Error("The Parser's configuration can no longer contain a <serializedGrammar> property.\n	See: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_6-0-0\n	For Further details.");
          }
          if ((0, isArray_1.default)(tokenVocabulary)) {
            if ((0, isEmpty_1.default)(tokenVocabulary)) {
              throw Error("A Token Vocabulary cannot be empty.\n	Note that the first argument for the parser constructor\n	is no longer a Token vector (since v4.0).");
            }
            if (typeof tokenVocabulary[0].startOffset === "number") {
              throw Error("The Parser constructor no longer accepts a token vector as the first argument.\n	See: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_4-0-0\n	For Further details.");
            }
          }
          if ((0, isArray_1.default)(tokenVocabulary)) {
            this.tokensMap = (0, reduce_1.default)(tokenVocabulary, function(acc, tokType) {
              acc[tokType.name] = tokType;
              return acc;
            }, {});
          } else if ((0, has_1.default)(tokenVocabulary, "modes") && (0, every_1.default)((0, flatten_1.default)((0, values_1.default)(tokenVocabulary.modes)), tokens_1.isTokenType)) {
            var allTokenTypes_1 = (0, flatten_1.default)((0, values_1.default)(tokenVocabulary.modes));
            var uniqueTokens = (0, uniq_1.default)(allTokenTypes_1);
            this.tokensMap = (0, reduce_1.default)(uniqueTokens, function(acc, tokType) {
              acc[tokType.name] = tokType;
              return acc;
            }, {});
          } else if ((0, isObject_1.default)(tokenVocabulary)) {
            this.tokensMap = (0, clone_1.default)(tokenVocabulary);
          } else {
            throw new Error("<tokensDictionary> argument must be An Array of Token constructors, A dictionary of Token constructors or an IMultiModeLexerDefinition");
          }
          this.tokensMap["EOF"] = tokens_public_1.EOF;
          var allTokenTypes = (0, has_1.default)(tokenVocabulary, "modes") ? (0, flatten_1.default)((0, values_1.default)(tokenVocabulary.modes)) : (0, values_1.default)(tokenVocabulary);
          var noTokenCategoriesUsed = (0, every_1.default)(allTokenTypes, function(tokenConstructor) {
            return (0, isEmpty_1.default)(tokenConstructor.categoryMatches);
          });
          this.tokenMatcher = noTokenCategoriesUsed ? tokens_1.tokenStructuredMatcherNoCategories : tokens_1.tokenStructuredMatcher;
          (0, tokens_1.augmentTokenTypes)((0, values_1.default)(this.tokensMap));
        };
        RecognizerEngine2.prototype.defineRule = function(ruleName, impl, config3) {
          if (this.selfAnalysisDone) {
            throw Error("Grammar rule <".concat(ruleName, "> may not be defined after the 'performSelfAnalysis' method has been called'\n") + "Make sure that all grammar rule definitions are done before 'performSelfAnalysis' is called.");
          }
          var resyncEnabled = (0, has_1.default)(config3, "resyncEnabled") ? config3.resyncEnabled : parser_1.DEFAULT_RULE_CONFIG.resyncEnabled;
          var recoveryValueFunc = (0, has_1.default)(config3, "recoveryValueFunc") ? config3.recoveryValueFunc : parser_1.DEFAULT_RULE_CONFIG.recoveryValueFunc;
          var shortName = this.ruleShortNameIdx << keys_1.BITS_FOR_METHOD_TYPE + keys_1.BITS_FOR_OCCURRENCE_IDX;
          this.ruleShortNameIdx++;
          this.shortRuleNameToFull[shortName] = ruleName;
          this.fullRuleNameToShort[ruleName] = shortName;
          var invokeRuleWithTry;
          if (this.outputCst === true) {
            invokeRuleWithTry = function invokeRuleWithTry2() {
              var args = [];
              for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
              }
              try {
                this.ruleInvocationStateUpdate(shortName, ruleName, this.subruleIdx);
                impl.apply(this, args);
                var cst = this.CST_STACK[this.CST_STACK.length - 1];
                this.cstPostRule(cst);
                return cst;
              } catch (e) {
                return this.invokeRuleCatch(e, resyncEnabled, recoveryValueFunc);
              } finally {
                this.ruleFinallyStateUpdate();
              }
            };
          } else {
            invokeRuleWithTry = function invokeRuleWithTryCst() {
              var args = [];
              for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
              }
              try {
                this.ruleInvocationStateUpdate(shortName, ruleName, this.subruleIdx);
                return impl.apply(this, args);
              } catch (e) {
                return this.invokeRuleCatch(e, resyncEnabled, recoveryValueFunc);
              } finally {
                this.ruleFinallyStateUpdate();
              }
            };
          }
          var wrappedGrammarRule = Object.assign(invokeRuleWithTry, { ruleName, originalGrammarAction: impl });
          return wrappedGrammarRule;
        };
        RecognizerEngine2.prototype.invokeRuleCatch = function(e, resyncEnabledConfig, recoveryValueFunc) {
          var isFirstInvokedRule = this.RULE_STACK.length === 1;
          var reSyncEnabled = resyncEnabledConfig && !this.isBackTracking() && this.recoveryEnabled;
          if ((0, exceptions_public_1.isRecognitionException)(e)) {
            var recogError = e;
            if (reSyncEnabled) {
              var reSyncTokType = this.findReSyncTokenType();
              if (this.isInCurrentRuleReSyncSet(reSyncTokType)) {
                recogError.resyncedTokens = this.reSyncTo(reSyncTokType);
                if (this.outputCst) {
                  var partialCstResult = this.CST_STACK[this.CST_STACK.length - 1];
                  partialCstResult.recoveredNode = true;
                  return partialCstResult;
                } else {
                  return recoveryValueFunc(e);
                }
              } else {
                if (this.outputCst) {
                  var partialCstResult = this.CST_STACK[this.CST_STACK.length - 1];
                  partialCstResult.recoveredNode = true;
                  recogError.partialCstResult = partialCstResult;
                }
                throw recogError;
              }
            } else if (isFirstInvokedRule) {
              this.moveToTerminatedState();
              return recoveryValueFunc(e);
            } else {
              throw recogError;
            }
          } else {
            throw e;
          }
        };
        RecognizerEngine2.prototype.optionInternal = function(actionORMethodDef, occurrence) {
          var key = this.getKeyForAutomaticLookahead(keys_1.OPTION_IDX, occurrence);
          return this.optionInternalLogic(actionORMethodDef, occurrence, key);
        };
        RecognizerEngine2.prototype.optionInternalLogic = function(actionORMethodDef, occurrence, key) {
          var _this = this;
          var lookAheadFunc = this.getLaFuncFromCache(key);
          var action;
          if (typeof actionORMethodDef !== "function") {
            action = actionORMethodDef.DEF;
            var predicate_1 = actionORMethodDef.GATE;
            if (predicate_1 !== void 0) {
              var orgLookaheadFunction_1 = lookAheadFunc;
              lookAheadFunc = function() {
                return predicate_1.call(_this) && orgLookaheadFunction_1.call(_this);
              };
            }
          } else {
            action = actionORMethodDef;
          }
          if (lookAheadFunc.call(this) === true) {
            return action.call(this);
          }
          return void 0;
        };
        RecognizerEngine2.prototype.atLeastOneInternal = function(prodOccurrence, actionORMethodDef) {
          var laKey = this.getKeyForAutomaticLookahead(keys_1.AT_LEAST_ONE_IDX, prodOccurrence);
          return this.atLeastOneInternalLogic(prodOccurrence, actionORMethodDef, laKey);
        };
        RecognizerEngine2.prototype.atLeastOneInternalLogic = function(prodOccurrence, actionORMethodDef, key) {
          var _this = this;
          var lookAheadFunc = this.getLaFuncFromCache(key);
          var action;
          if (typeof actionORMethodDef !== "function") {
            action = actionORMethodDef.DEF;
            var predicate_2 = actionORMethodDef.GATE;
            if (predicate_2 !== void 0) {
              var orgLookaheadFunction_2 = lookAheadFunc;
              lookAheadFunc = function() {
                return predicate_2.call(_this) && orgLookaheadFunction_2.call(_this);
              };
            }
          } else {
            action = actionORMethodDef;
          }
          if (lookAheadFunc.call(this) === true) {
            var notStuck = this.doSingleRepetition(action);
            while (lookAheadFunc.call(this) === true && notStuck === true) {
              notStuck = this.doSingleRepetition(action);
            }
          } else {
            throw this.raiseEarlyExitException(prodOccurrence, lookahead_1.PROD_TYPE.REPETITION_MANDATORY, actionORMethodDef.ERR_MSG);
          }
          this.attemptInRepetitionRecovery(this.atLeastOneInternal, [prodOccurrence, actionORMethodDef], lookAheadFunc, keys_1.AT_LEAST_ONE_IDX, prodOccurrence, interpreter_1.NextTerminalAfterAtLeastOneWalker);
        };
        RecognizerEngine2.prototype.atLeastOneSepFirstInternal = function(prodOccurrence, options) {
          var laKey = this.getKeyForAutomaticLookahead(keys_1.AT_LEAST_ONE_SEP_IDX, prodOccurrence);
          this.atLeastOneSepFirstInternalLogic(prodOccurrence, options, laKey);
        };
        RecognizerEngine2.prototype.atLeastOneSepFirstInternalLogic = function(prodOccurrence, options, key) {
          var _this = this;
          var action = options.DEF;
          var separator = options.SEP;
          var firstIterationLookaheadFunc = this.getLaFuncFromCache(key);
          if (firstIterationLookaheadFunc.call(this) === true) {
            ;
            action.call(this);
            var separatorLookAheadFunc = function() {
              return _this.tokenMatcher(_this.LA(1), separator);
            };
            while (this.tokenMatcher(this.LA(1), separator) === true) {
              this.CONSUME(separator);
              action.call(this);
            }
            this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [
              prodOccurrence,
              separator,
              separatorLookAheadFunc,
              action,
              interpreter_1.NextTerminalAfterAtLeastOneSepWalker
            ], separatorLookAheadFunc, keys_1.AT_LEAST_ONE_SEP_IDX, prodOccurrence, interpreter_1.NextTerminalAfterAtLeastOneSepWalker);
          } else {
            throw this.raiseEarlyExitException(prodOccurrence, lookahead_1.PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR, options.ERR_MSG);
          }
        };
        RecognizerEngine2.prototype.manyInternal = function(prodOccurrence, actionORMethodDef) {
          var laKey = this.getKeyForAutomaticLookahead(keys_1.MANY_IDX, prodOccurrence);
          return this.manyInternalLogic(prodOccurrence, actionORMethodDef, laKey);
        };
        RecognizerEngine2.prototype.manyInternalLogic = function(prodOccurrence, actionORMethodDef, key) {
          var _this = this;
          var lookaheadFunction = this.getLaFuncFromCache(key);
          var action;
          if (typeof actionORMethodDef !== "function") {
            action = actionORMethodDef.DEF;
            var predicate_3 = actionORMethodDef.GATE;
            if (predicate_3 !== void 0) {
              var orgLookaheadFunction_3 = lookaheadFunction;
              lookaheadFunction = function() {
                return predicate_3.call(_this) && orgLookaheadFunction_3.call(_this);
              };
            }
          } else {
            action = actionORMethodDef;
          }
          var notStuck = true;
          while (lookaheadFunction.call(this) === true && notStuck === true) {
            notStuck = this.doSingleRepetition(action);
          }
          this.attemptInRepetitionRecovery(
            this.manyInternal,
            [prodOccurrence, actionORMethodDef],
            lookaheadFunction,
            keys_1.MANY_IDX,
            prodOccurrence,
            interpreter_1.NextTerminalAfterManyWalker,
            // The notStuck parameter is only relevant when "attemptInRepetitionRecovery"
            // is invoked from manyInternal, in the MANY_SEP case and AT_LEAST_ONE[_SEP]
            // An infinite loop cannot occur as:
            // - Either the lookahead is guaranteed to consume something (Single Token Separator)
            // - AT_LEAST_ONE by definition is guaranteed to consume something (or error out).
            notStuck
          );
        };
        RecognizerEngine2.prototype.manySepFirstInternal = function(prodOccurrence, options) {
          var laKey = this.getKeyForAutomaticLookahead(keys_1.MANY_SEP_IDX, prodOccurrence);
          this.manySepFirstInternalLogic(prodOccurrence, options, laKey);
        };
        RecognizerEngine2.prototype.manySepFirstInternalLogic = function(prodOccurrence, options, key) {
          var _this = this;
          var action = options.DEF;
          var separator = options.SEP;
          var firstIterationLaFunc = this.getLaFuncFromCache(key);
          if (firstIterationLaFunc.call(this) === true) {
            action.call(this);
            var separatorLookAheadFunc = function() {
              return _this.tokenMatcher(_this.LA(1), separator);
            };
            while (this.tokenMatcher(this.LA(1), separator) === true) {
              this.CONSUME(separator);
              action.call(this);
            }
            this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [
              prodOccurrence,
              separator,
              separatorLookAheadFunc,
              action,
              interpreter_1.NextTerminalAfterManySepWalker
            ], separatorLookAheadFunc, keys_1.MANY_SEP_IDX, prodOccurrence, interpreter_1.NextTerminalAfterManySepWalker);
          }
        };
        RecognizerEngine2.prototype.repetitionSepSecondInternal = function(prodOccurrence, separator, separatorLookAheadFunc, action, nextTerminalAfterWalker) {
          while (separatorLookAheadFunc()) {
            this.CONSUME(separator);
            action.call(this);
          }
          this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [
            prodOccurrence,
            separator,
            separatorLookAheadFunc,
            action,
            nextTerminalAfterWalker
          ], separatorLookAheadFunc, keys_1.AT_LEAST_ONE_SEP_IDX, prodOccurrence, nextTerminalAfterWalker);
        };
        RecognizerEngine2.prototype.doSingleRepetition = function(action) {
          var beforeIteration = this.getLexerPosition();
          action.call(this);
          var afterIteration = this.getLexerPosition();
          return afterIteration > beforeIteration;
        };
        RecognizerEngine2.prototype.orInternal = function(altsOrOpts, occurrence) {
          var laKey = this.getKeyForAutomaticLookahead(keys_1.OR_IDX, occurrence);
          var alts = (0, isArray_1.default)(altsOrOpts) ? altsOrOpts : altsOrOpts.DEF;
          var laFunc = this.getLaFuncFromCache(laKey);
          var altIdxToTake = laFunc.call(this, alts);
          if (altIdxToTake !== void 0) {
            var chosenAlternative = alts[altIdxToTake];
            return chosenAlternative.ALT.call(this);
          }
          this.raiseNoAltException(occurrence, altsOrOpts.ERR_MSG);
        };
        RecognizerEngine2.prototype.ruleFinallyStateUpdate = function() {
          this.RULE_STACK.pop();
          this.RULE_OCCURRENCE_STACK.pop();
          this.cstFinallyStateUpdate();
          if (this.RULE_STACK.length === 0 && this.isAtEndOfInput() === false) {
            var firstRedundantTok = this.LA(1);
            var errMsg = this.errorMessageProvider.buildNotAllInputParsedMessage({
              firstRedundant: firstRedundantTok,
              ruleName: this.getCurrRuleFullName()
            });
            this.SAVE_ERROR(new exceptions_public_1.NotAllInputParsedException(errMsg, firstRedundantTok));
          }
        };
        RecognizerEngine2.prototype.subruleInternal = function(ruleToCall, idx, options) {
          var ruleResult;
          try {
            var args = options !== void 0 ? options.ARGS : void 0;
            this.subruleIdx = idx;
            ruleResult = ruleToCall.apply(this, args);
            this.cstPostNonTerminal(ruleResult, options !== void 0 && options.LABEL !== void 0 ? options.LABEL : ruleToCall.ruleName);
            return ruleResult;
          } catch (e) {
            throw this.subruleInternalError(e, options, ruleToCall.ruleName);
          }
        };
        RecognizerEngine2.prototype.subruleInternalError = function(e, options, ruleName) {
          if ((0, exceptions_public_1.isRecognitionException)(e) && e.partialCstResult !== void 0) {
            this.cstPostNonTerminal(e.partialCstResult, options !== void 0 && options.LABEL !== void 0 ? options.LABEL : ruleName);
            delete e.partialCstResult;
          }
          throw e;
        };
        RecognizerEngine2.prototype.consumeInternal = function(tokType, idx, options) {
          var consumedToken;
          try {
            var nextToken = this.LA(1);
            if (this.tokenMatcher(nextToken, tokType) === true) {
              this.consumeToken();
              consumedToken = nextToken;
            } else {
              this.consumeInternalError(tokType, nextToken, options);
            }
          } catch (eFromConsumption) {
            consumedToken = this.consumeInternalRecovery(tokType, idx, eFromConsumption);
          }
          this.cstPostTerminal(options !== void 0 && options.LABEL !== void 0 ? options.LABEL : tokType.name, consumedToken);
          return consumedToken;
        };
        RecognizerEngine2.prototype.consumeInternalError = function(tokType, nextToken, options) {
          var msg;
          var previousToken = this.LA(0);
          if (options !== void 0 && options.ERR_MSG) {
            msg = options.ERR_MSG;
          } else {
            msg = this.errorMessageProvider.buildMismatchTokenMessage({
              expected: tokType,
              actual: nextToken,
              previous: previousToken,
              ruleName: this.getCurrRuleFullName()
            });
          }
          throw this.SAVE_ERROR(new exceptions_public_1.MismatchedTokenException(msg, nextToken, previousToken));
        };
        RecognizerEngine2.prototype.consumeInternalRecovery = function(tokType, idx, eFromConsumption) {
          if (this.recoveryEnabled && // TODO: more robust checking of the exception type. Perhaps Typescript extending expressions?
          eFromConsumption.name === "MismatchedTokenException" && !this.isBackTracking()) {
            var follows = this.getFollowsForInRuleRecovery(tokType, idx);
            try {
              return this.tryInRuleRecovery(tokType, follows);
            } catch (eFromInRuleRecovery) {
              if (eFromInRuleRecovery.name === recoverable_1.IN_RULE_RECOVERY_EXCEPTION) {
                throw eFromConsumption;
              } else {
                throw eFromInRuleRecovery;
              }
            }
          } else {
            throw eFromConsumption;
          }
        };
        RecognizerEngine2.prototype.saveRecogState = function() {
          var savedErrors = this.errors;
          var savedRuleStack = (0, clone_1.default)(this.RULE_STACK);
          return {
            errors: savedErrors,
            lexerState: this.exportLexerState(),
            RULE_STACK: savedRuleStack,
            CST_STACK: this.CST_STACK
          };
        };
        RecognizerEngine2.prototype.reloadRecogState = function(newState) {
          this.errors = newState.errors;
          this.importLexerState(newState.lexerState);
          this.RULE_STACK = newState.RULE_STACK;
        };
        RecognizerEngine2.prototype.ruleInvocationStateUpdate = function(shortName, fullName, idxInCallingRule) {
          this.RULE_OCCURRENCE_STACK.push(idxInCallingRule);
          this.RULE_STACK.push(shortName);
          this.cstInvocationStateUpdate(fullName);
        };
        RecognizerEngine2.prototype.isBackTracking = function() {
          return this.isBackTrackingStack.length !== 0;
        };
        RecognizerEngine2.prototype.getCurrRuleFullName = function() {
          var shortName = this.getLastExplicitRuleShortName();
          return this.shortRuleNameToFull[shortName];
        };
        RecognizerEngine2.prototype.shortRuleNameToFullName = function(shortName) {
          return this.shortRuleNameToFull[shortName];
        };
        RecognizerEngine2.prototype.isAtEndOfInput = function() {
          return this.tokenMatcher(this.LA(1), tokens_public_1.EOF);
        };
        RecognizerEngine2.prototype.reset = function() {
          this.resetLexerState();
          this.subruleIdx = 0;
          this.isBackTrackingStack = [];
          this.errors = [];
          this.RULE_STACK = [];
          this.CST_STACK = [];
          this.RULE_OCCURRENCE_STACK = [];
        };
        return RecognizerEngine2;
      }()
    );
    exports2.RecognizerEngine = RecognizerEngine;
  }
});

// node_modules/chevrotain/lib/src/parse/parser/traits/error_handler.js
var require_error_handler = __commonJS({
  "node_modules/chevrotain/lib/src/parse/parser/traits/error_handler.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ErrorHandler = void 0;
    var exceptions_public_1 = require_exceptions_public();
    var has_1 = __importDefault(require_has());
    var clone_1 = __importDefault(require_clone());
    var lookahead_1 = require_lookahead();
    var parser_1 = require_parser();
    var ErrorHandler = (
      /** @class */
      function() {
        function ErrorHandler2() {
        }
        ErrorHandler2.prototype.initErrorHandler = function(config3) {
          this._errors = [];
          this.errorMessageProvider = (0, has_1.default)(config3, "errorMessageProvider") ? config3.errorMessageProvider : parser_1.DEFAULT_PARSER_CONFIG.errorMessageProvider;
        };
        ErrorHandler2.prototype.SAVE_ERROR = function(error) {
          if ((0, exceptions_public_1.isRecognitionException)(error)) {
            error.context = {
              ruleStack: this.getHumanReadableRuleStack(),
              ruleOccurrenceStack: (0, clone_1.default)(this.RULE_OCCURRENCE_STACK)
            };
            this._errors.push(error);
            return error;
          } else {
            throw Error("Trying to save an Error which is not a RecognitionException");
          }
        };
        Object.defineProperty(ErrorHandler2.prototype, "errors", {
          get: function() {
            return (0, clone_1.default)(this._errors);
          },
          set: function(newErrors) {
            this._errors = newErrors;
          },
          enumerable: false,
          configurable: true
        });
        ErrorHandler2.prototype.raiseEarlyExitException = function(occurrence, prodType, userDefinedErrMsg) {
          var ruleName = this.getCurrRuleFullName();
          var ruleGrammar = this.getGAstProductions()[ruleName];
          var lookAheadPathsPerAlternative = (0, lookahead_1.getLookaheadPathsForOptionalProd)(occurrence, ruleGrammar, prodType, this.maxLookahead);
          var insideProdPaths = lookAheadPathsPerAlternative[0];
          var actualTokens = [];
          for (var i3 = 1; i3 <= this.maxLookahead; i3++) {
            actualTokens.push(this.LA(i3));
          }
          var msg = this.errorMessageProvider.buildEarlyExitMessage({
            expectedIterationPaths: insideProdPaths,
            actual: actualTokens,
            previous: this.LA(0),
            customUserDescription: userDefinedErrMsg,
            ruleName
          });
          throw this.SAVE_ERROR(new exceptions_public_1.EarlyExitException(msg, this.LA(1), this.LA(0)));
        };
        ErrorHandler2.prototype.raiseNoAltException = function(occurrence, errMsgTypes) {
          var ruleName = this.getCurrRuleFullName();
          var ruleGrammar = this.getGAstProductions()[ruleName];
          var lookAheadPathsPerAlternative = (0, lookahead_1.getLookaheadPathsForOr)(occurrence, ruleGrammar, this.maxLookahead);
          var actualTokens = [];
          for (var i3 = 1; i3 <= this.maxLookahead; i3++) {
            actualTokens.push(this.LA(i3));
          }
          var previousToken = this.LA(0);
          var errMsg = this.errorMessageProvider.buildNoViableAltMessage({
            expectedPathsPerAlt: lookAheadPathsPerAlternative,
            actual: actualTokens,
            previous: previousToken,
            customUserDescription: errMsgTypes,
            ruleName: this.getCurrRuleFullName()
          });
          throw this.SAVE_ERROR(new exceptions_public_1.NoViableAltException(errMsg, this.LA(1), previousToken));
        };
        return ErrorHandler2;
      }()
    );
    exports2.ErrorHandler = ErrorHandler;
  }
});

// node_modules/chevrotain/lib/src/parse/parser/traits/context_assist.js
var require_context_assist = __commonJS({
  "node_modules/chevrotain/lib/src/parse/parser/traits/context_assist.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ContentAssist = void 0;
    var interpreter_1 = require_interpreter();
    var first_1 = __importDefault(require_first2());
    var isUndefined_1 = __importDefault(require_isUndefined());
    var ContentAssist = (
      /** @class */
      function() {
        function ContentAssist2() {
        }
        ContentAssist2.prototype.initContentAssist = function() {
        };
        ContentAssist2.prototype.computeContentAssist = function(startRuleName, precedingInput) {
          var startRuleGast = this.gastProductionsCache[startRuleName];
          if ((0, isUndefined_1.default)(startRuleGast)) {
            throw Error("Rule ->".concat(startRuleName, "<- does not exist in this grammar."));
          }
          return (0, interpreter_1.nextPossibleTokensAfter)([startRuleGast], precedingInput, this.tokenMatcher, this.maxLookahead);
        };
        ContentAssist2.prototype.getNextPossibleTokenTypes = function(grammarPath) {
          var topRuleName = (0, first_1.default)(grammarPath.ruleStack);
          var gastProductions = this.getGAstProductions();
          var topProduction = gastProductions[topRuleName];
          var nextPossibleTokenTypes = new interpreter_1.NextAfterTokenWalker(topProduction, grammarPath).startWalking();
          return nextPossibleTokenTypes;
        };
        return ContentAssist2;
      }()
    );
    exports2.ContentAssist = ContentAssist;
  }
});

// node_modules/chevrotain/lib/src/parse/parser/traits/gast_recorder.js
var require_gast_recorder = __commonJS({
  "node_modules/chevrotain/lib/src/parse/parser/traits/gast_recorder.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.GastRecorder = void 0;
    var last_1 = __importDefault(require_last());
    var isArray_1 = __importDefault(require_isArray());
    var some_1 = __importDefault(require_some());
    var forEach_1 = __importDefault(require_forEach());
    var isFunction_1 = __importDefault(require_isFunction());
    var has_1 = __importDefault(require_has());
    var gast_1 = require_api2();
    var lexer_public_1 = require_lexer_public();
    var tokens_1 = require_tokens();
    var tokens_public_1 = require_tokens_public();
    var parser_1 = require_parser();
    var keys_1 = require_keys2();
    var RECORDING_NULL_OBJECT = {
      description: "This Object indicates the Parser is during Recording Phase"
    };
    Object.freeze(RECORDING_NULL_OBJECT);
    var HANDLE_SEPARATOR = true;
    var MAX_METHOD_IDX = Math.pow(2, keys_1.BITS_FOR_OCCURRENCE_IDX) - 1;
    var RFT = (0, tokens_public_1.createToken)({ name: "RECORDING_PHASE_TOKEN", pattern: lexer_public_1.Lexer.NA });
    (0, tokens_1.augmentTokenTypes)([RFT]);
    var RECORDING_PHASE_TOKEN = (0, tokens_public_1.createTokenInstance)(
      RFT,
      "This IToken indicates the Parser is in Recording Phase\n	See: https://chevrotain.io/docs/guide/internals.html#grammar-recording for details",
      // Using "-1" instead of NaN (as in EOF) because an actual number is less likely to
      // cause errors if the output of LA or CONSUME would be (incorrectly) used during the recording phase.
      -1,
      -1,
      -1,
      -1,
      -1,
      -1
    );
    Object.freeze(RECORDING_PHASE_TOKEN);
    var RECORDING_PHASE_CSTNODE = {
      name: "This CSTNode indicates the Parser is in Recording Phase\n	See: https://chevrotain.io/docs/guide/internals.html#grammar-recording for details",
      children: {}
    };
    var GastRecorder = (
      /** @class */
      function() {
        function GastRecorder2() {
        }
        GastRecorder2.prototype.initGastRecorder = function(config3) {
          this.recordingProdStack = [];
          this.RECORDING_PHASE = false;
        };
        GastRecorder2.prototype.enableRecording = function() {
          var _this = this;
          this.RECORDING_PHASE = true;
          this.TRACE_INIT("Enable Recording", function() {
            var _loop_1 = function(i4) {
              var idx = i4 > 0 ? i4 : "";
              _this["CONSUME".concat(idx)] = function(arg1, arg2) {
                return this.consumeInternalRecord(arg1, i4, arg2);
              };
              _this["SUBRULE".concat(idx)] = function(arg1, arg2) {
                return this.subruleInternalRecord(arg1, i4, arg2);
              };
              _this["OPTION".concat(idx)] = function(arg1) {
                return this.optionInternalRecord(arg1, i4);
              };
              _this["OR".concat(idx)] = function(arg1) {
                return this.orInternalRecord(arg1, i4);
              };
              _this["MANY".concat(idx)] = function(arg1) {
                this.manyInternalRecord(i4, arg1);
              };
              _this["MANY_SEP".concat(idx)] = function(arg1) {
                this.manySepFirstInternalRecord(i4, arg1);
              };
              _this["AT_LEAST_ONE".concat(idx)] = function(arg1) {
                this.atLeastOneInternalRecord(i4, arg1);
              };
              _this["AT_LEAST_ONE_SEP".concat(idx)] = function(arg1) {
                this.atLeastOneSepFirstInternalRecord(i4, arg1);
              };
            };
            for (var i3 = 0; i3 < 10; i3++) {
              _loop_1(i3);
            }
            _this["consume"] = function(idx, arg1, arg2) {
              return this.consumeInternalRecord(arg1, idx, arg2);
            };
            _this["subrule"] = function(idx, arg1, arg2) {
              return this.subruleInternalRecord(arg1, idx, arg2);
            };
            _this["option"] = function(idx, arg1) {
              return this.optionInternalRecord(arg1, idx);
            };
            _this["or"] = function(idx, arg1) {
              return this.orInternalRecord(arg1, idx);
            };
            _this["many"] = function(idx, arg1) {
              this.manyInternalRecord(idx, arg1);
            };
            _this["atLeastOne"] = function(idx, arg1) {
              this.atLeastOneInternalRecord(idx, arg1);
            };
            _this.ACTION = _this.ACTION_RECORD;
            _this.BACKTRACK = _this.BACKTRACK_RECORD;
            _this.LA = _this.LA_RECORD;
          });
        };
        GastRecorder2.prototype.disableRecording = function() {
          var _this = this;
          this.RECORDING_PHASE = false;
          this.TRACE_INIT("Deleting Recording methods", function() {
            var that = _this;
            for (var i3 = 0; i3 < 10; i3++) {
              var idx = i3 > 0 ? i3 : "";
              delete that["CONSUME".concat(idx)];
              delete that["SUBRULE".concat(idx)];
              delete that["OPTION".concat(idx)];
              delete that["OR".concat(idx)];
              delete that["MANY".concat(idx)];
              delete that["MANY_SEP".concat(idx)];
              delete that["AT_LEAST_ONE".concat(idx)];
              delete that["AT_LEAST_ONE_SEP".concat(idx)];
            }
            delete that["consume"];
            delete that["subrule"];
            delete that["option"];
            delete that["or"];
            delete that["many"];
            delete that["atLeastOne"];
            delete that.ACTION;
            delete that.BACKTRACK;
            delete that.LA;
          });
        };
        GastRecorder2.prototype.ACTION_RECORD = function(impl) {
        };
        GastRecorder2.prototype.BACKTRACK_RECORD = function(grammarRule, args) {
          return function() {
            return true;
          };
        };
        GastRecorder2.prototype.LA_RECORD = function(howMuch) {
          return parser_1.END_OF_FILE;
        };
        GastRecorder2.prototype.topLevelRuleRecord = function(name, def) {
          try {
            var newTopLevelRule = new gast_1.Rule({ definition: [], name });
            newTopLevelRule.name = name;
            this.recordingProdStack.push(newTopLevelRule);
            def.call(this);
            this.recordingProdStack.pop();
            return newTopLevelRule;
          } catch (originalError) {
            if (originalError.KNOWN_RECORDER_ERROR !== true) {
              try {
                originalError.message = originalError.message + '\n	 This error was thrown during the "grammar recording phase" For more info see:\n	https://chevrotain.io/docs/guide/internals.html#grammar-recording';
              } catch (mutabilityError) {
                throw originalError;
              }
            }
            throw originalError;
          }
        };
        GastRecorder2.prototype.optionInternalRecord = function(actionORMethodDef, occurrence) {
          return recordProd.call(this, gast_1.Option, actionORMethodDef, occurrence);
        };
        GastRecorder2.prototype.atLeastOneInternalRecord = function(occurrence, actionORMethodDef) {
          recordProd.call(this, gast_1.RepetitionMandatory, actionORMethodDef, occurrence);
        };
        GastRecorder2.prototype.atLeastOneSepFirstInternalRecord = function(occurrence, options) {
          recordProd.call(this, gast_1.RepetitionMandatoryWithSeparator, options, occurrence, HANDLE_SEPARATOR);
        };
        GastRecorder2.prototype.manyInternalRecord = function(occurrence, actionORMethodDef) {
          recordProd.call(this, gast_1.Repetition, actionORMethodDef, occurrence);
        };
        GastRecorder2.prototype.manySepFirstInternalRecord = function(occurrence, options) {
          recordProd.call(this, gast_1.RepetitionWithSeparator, options, occurrence, HANDLE_SEPARATOR);
        };
        GastRecorder2.prototype.orInternalRecord = function(altsOrOpts, occurrence) {
          return recordOrProd.call(this, altsOrOpts, occurrence);
        };
        GastRecorder2.prototype.subruleInternalRecord = function(ruleToCall, occurrence, options) {
          assertMethodIdxIsValid(occurrence);
          if (!ruleToCall || (0, has_1.default)(ruleToCall, "ruleName") === false) {
            var error = new Error("<SUBRULE".concat(getIdxSuffix(occurrence), "> argument is invalid") + " expecting a Parser method reference but got: <".concat(JSON.stringify(ruleToCall), ">") + "\n inside top level rule: <".concat(this.recordingProdStack[0].name, ">"));
            error.KNOWN_RECORDER_ERROR = true;
            throw error;
          }
          var prevProd = (0, last_1.default)(this.recordingProdStack);
          var ruleName = ruleToCall.ruleName;
          var newNoneTerminal = new gast_1.NonTerminal({
            idx: occurrence,
            nonTerminalName: ruleName,
            label: options === null || options === void 0 ? void 0 : options.LABEL,
            // The resolving of the `referencedRule` property will be done once all the Rule's GASTs have been created
            referencedRule: void 0
          });
          prevProd.definition.push(newNoneTerminal);
          return this.outputCst ? RECORDING_PHASE_CSTNODE : RECORDING_NULL_OBJECT;
        };
        GastRecorder2.prototype.consumeInternalRecord = function(tokType, occurrence, options) {
          assertMethodIdxIsValid(occurrence);
          if (!(0, tokens_1.hasShortKeyProperty)(tokType)) {
            var error = new Error("<CONSUME".concat(getIdxSuffix(occurrence), "> argument is invalid") + " expecting a TokenType reference but got: <".concat(JSON.stringify(tokType), ">") + "\n inside top level rule: <".concat(this.recordingProdStack[0].name, ">"));
            error.KNOWN_RECORDER_ERROR = true;
            throw error;
          }
          var prevProd = (0, last_1.default)(this.recordingProdStack);
          var newNoneTerminal = new gast_1.Terminal({
            idx: occurrence,
            terminalType: tokType,
            label: options === null || options === void 0 ? void 0 : options.LABEL
          });
          prevProd.definition.push(newNoneTerminal);
          return RECORDING_PHASE_TOKEN;
        };
        return GastRecorder2;
      }()
    );
    exports2.GastRecorder = GastRecorder;
    function recordProd(prodConstructor, mainProdArg, occurrence, handleSep) {
      if (handleSep === void 0) {
        handleSep = false;
      }
      assertMethodIdxIsValid(occurrence);
      var prevProd = (0, last_1.default)(this.recordingProdStack);
      var grammarAction = (0, isFunction_1.default)(mainProdArg) ? mainProdArg : mainProdArg.DEF;
      var newProd = new prodConstructor({ definition: [], idx: occurrence });
      if (handleSep) {
        newProd.separator = mainProdArg.SEP;
      }
      if ((0, has_1.default)(mainProdArg, "MAX_LOOKAHEAD")) {
        newProd.maxLookahead = mainProdArg.MAX_LOOKAHEAD;
      }
      this.recordingProdStack.push(newProd);
      grammarAction.call(this);
      prevProd.definition.push(newProd);
      this.recordingProdStack.pop();
      return RECORDING_NULL_OBJECT;
    }
    function recordOrProd(mainProdArg, occurrence) {
      var _this = this;
      assertMethodIdxIsValid(occurrence);
      var prevProd = (0, last_1.default)(this.recordingProdStack);
      var hasOptions = (0, isArray_1.default)(mainProdArg) === false;
      var alts = hasOptions === false ? mainProdArg : mainProdArg.DEF;
      var newOrProd = new gast_1.Alternation({
        definition: [],
        idx: occurrence,
        ignoreAmbiguities: hasOptions && mainProdArg.IGNORE_AMBIGUITIES === true
      });
      if ((0, has_1.default)(mainProdArg, "MAX_LOOKAHEAD")) {
        newOrProd.maxLookahead = mainProdArg.MAX_LOOKAHEAD;
      }
      var hasPredicates = (0, some_1.default)(alts, function(currAlt) {
        return (0, isFunction_1.default)(currAlt.GATE);
      });
      newOrProd.hasPredicates = hasPredicates;
      prevProd.definition.push(newOrProd);
      (0, forEach_1.default)(alts, function(currAlt) {
        var currAltFlat = new gast_1.Alternative({ definition: [] });
        newOrProd.definition.push(currAltFlat);
        if ((0, has_1.default)(currAlt, "IGNORE_AMBIGUITIES")) {
          currAltFlat.ignoreAmbiguities = currAlt.IGNORE_AMBIGUITIES;
        } else if ((0, has_1.default)(currAlt, "GATE")) {
          currAltFlat.ignoreAmbiguities = true;
        }
        _this.recordingProdStack.push(currAltFlat);
        currAlt.ALT.call(_this);
        _this.recordingProdStack.pop();
      });
      return RECORDING_NULL_OBJECT;
    }
    function getIdxSuffix(idx) {
      return idx === 0 ? "" : "".concat(idx);
    }
    function assertMethodIdxIsValid(idx) {
      if (idx < 0 || idx > MAX_METHOD_IDX) {
        var error = new Error(
          // The stack trace will contain all the needed details
          "Invalid DSL Method idx value: <".concat(idx, ">\n	") + "Idx value must be a none negative value smaller than ".concat(MAX_METHOD_IDX + 1)
        );
        error.KNOWN_RECORDER_ERROR = true;
        throw error;
      }
    }
  }
});

// node_modules/chevrotain/lib/src/parse/parser/traits/perf_tracer.js
var require_perf_tracer = __commonJS({
  "node_modules/chevrotain/lib/src/parse/parser/traits/perf_tracer.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PerformanceTracer = void 0;
    var has_1 = __importDefault(require_has());
    var utils_1 = require_api();
    var parser_1 = require_parser();
    var PerformanceTracer = (
      /** @class */
      function() {
        function PerformanceTracer2() {
        }
        PerformanceTracer2.prototype.initPerformanceTracer = function(config3) {
          if ((0, has_1.default)(config3, "traceInitPerf")) {
            var userTraceInitPerf = config3.traceInitPerf;
            var traceIsNumber = typeof userTraceInitPerf === "number";
            this.traceInitMaxIdent = traceIsNumber ? userTraceInitPerf : Infinity;
            this.traceInitPerf = traceIsNumber ? userTraceInitPerf > 0 : userTraceInitPerf;
          } else {
            this.traceInitMaxIdent = 0;
            this.traceInitPerf = parser_1.DEFAULT_PARSER_CONFIG.traceInitPerf;
          }
          this.traceInitIndent = -1;
        };
        PerformanceTracer2.prototype.TRACE_INIT = function(phaseDesc, phaseImpl) {
          if (this.traceInitPerf === true) {
            this.traceInitIndent++;
            var indent = new Array(this.traceInitIndent + 1).join("	");
            if (this.traceInitIndent < this.traceInitMaxIdent) {
              console.log("".concat(indent, "--> <").concat(phaseDesc, ">"));
            }
            var _a4 = (0, utils_1.timer)(phaseImpl), time = _a4.time, value = _a4.value;
            var traceMethod = time > 10 ? console.warn : console.log;
            if (this.traceInitIndent < this.traceInitMaxIdent) {
              traceMethod("".concat(indent, "<-- <").concat(phaseDesc, "> time: ").concat(time, "ms"));
            }
            this.traceInitIndent--;
            return value;
          } else {
            return phaseImpl();
          }
        };
        return PerformanceTracer2;
      }()
    );
    exports2.PerformanceTracer = PerformanceTracer;
  }
});

// node_modules/chevrotain/lib/src/parse/parser/utils/apply_mixins.js
var require_apply_mixins = __commonJS({
  "node_modules/chevrotain/lib/src/parse/parser/utils/apply_mixins.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.applyMixins = void 0;
    function applyMixins(derivedCtor, baseCtors) {
      baseCtors.forEach(function(baseCtor) {
        var baseProto = baseCtor.prototype;
        Object.getOwnPropertyNames(baseProto).forEach(function(propName) {
          if (propName === "constructor") {
            return;
          }
          var basePropDescriptor = Object.getOwnPropertyDescriptor(baseProto, propName);
          if (basePropDescriptor && (basePropDescriptor.get || basePropDescriptor.set)) {
            Object.defineProperty(derivedCtor.prototype, propName, basePropDescriptor);
          } else {
            derivedCtor.prototype[propName] = baseCtor.prototype[propName];
          }
        });
      });
    }
    exports2.applyMixins = applyMixins;
  }
});

// node_modules/chevrotain/lib/src/parse/parser/parser.js
var require_parser = __commonJS({
  "node_modules/chevrotain/lib/src/parse/parser/parser.js"(exports2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || function() {
      var extendStatics = function(d, b5) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b6) {
          d2.__proto__ = b6;
        } || function(d2, b6) {
          for (var p in b6)
            if (Object.prototype.hasOwnProperty.call(b6, p))
              d2[p] = b6[p];
        };
        return extendStatics(d, b5);
      };
      return function(d, b5) {
        if (typeof b5 !== "function" && b5 !== null)
          throw new TypeError("Class extends value " + String(b5) + " is not a constructor or null");
        extendStatics(d, b5);
        function __() {
          this.constructor = d;
        }
        d.prototype = b5 === null ? Object.create(b5) : (__.prototype = b5.prototype, new __());
      };
    }();
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.EmbeddedActionsParser = exports2.CstParser = exports2.Parser = exports2.EMPTY_ALT = exports2.ParserDefinitionErrorType = exports2.DEFAULT_RULE_CONFIG = exports2.DEFAULT_PARSER_CONFIG = exports2.END_OF_FILE = void 0;
    var isEmpty_1 = __importDefault(require_isEmpty());
    var map_1 = __importDefault(require_map());
    var forEach_1 = __importDefault(require_forEach());
    var values_1 = __importDefault(require_values());
    var has_1 = __importDefault(require_has());
    var clone_1 = __importDefault(require_clone());
    var utils_1 = require_api();
    var follow_1 = require_follow();
    var tokens_public_1 = require_tokens_public();
    var errors_public_1 = require_errors_public();
    var gast_resolver_public_1 = require_gast_resolver_public();
    var recoverable_1 = require_recoverable();
    var looksahead_1 = require_looksahead();
    var tree_builder_1 = require_tree_builder();
    var lexer_adapter_1 = require_lexer_adapter();
    var recognizer_api_1 = require_recognizer_api();
    var recognizer_engine_1 = require_recognizer_engine();
    var error_handler_1 = require_error_handler();
    var context_assist_1 = require_context_assist();
    var gast_recorder_1 = require_gast_recorder();
    var perf_tracer_1 = require_perf_tracer();
    var apply_mixins_1 = require_apply_mixins();
    var checks_1 = require_checks();
    exports2.END_OF_FILE = (0, tokens_public_1.createTokenInstance)(tokens_public_1.EOF, "", NaN, NaN, NaN, NaN, NaN, NaN);
    Object.freeze(exports2.END_OF_FILE);
    exports2.DEFAULT_PARSER_CONFIG = Object.freeze({
      recoveryEnabled: false,
      maxLookahead: 3,
      dynamicTokensEnabled: false,
      outputCst: true,
      errorMessageProvider: errors_public_1.defaultParserErrorProvider,
      nodeLocationTracking: "none",
      traceInitPerf: false,
      skipValidations: false
    });
    exports2.DEFAULT_RULE_CONFIG = Object.freeze({
      recoveryValueFunc: function() {
        return void 0;
      },
      resyncEnabled: true
    });
    var ParserDefinitionErrorType2;
    (function(ParserDefinitionErrorType3) {
      ParserDefinitionErrorType3[ParserDefinitionErrorType3["INVALID_RULE_NAME"] = 0] = "INVALID_RULE_NAME";
      ParserDefinitionErrorType3[ParserDefinitionErrorType3["DUPLICATE_RULE_NAME"] = 1] = "DUPLICATE_RULE_NAME";
      ParserDefinitionErrorType3[ParserDefinitionErrorType3["INVALID_RULE_OVERRIDE"] = 2] = "INVALID_RULE_OVERRIDE";
      ParserDefinitionErrorType3[ParserDefinitionErrorType3["DUPLICATE_PRODUCTIONS"] = 3] = "DUPLICATE_PRODUCTIONS";
      ParserDefinitionErrorType3[ParserDefinitionErrorType3["UNRESOLVED_SUBRULE_REF"] = 4] = "UNRESOLVED_SUBRULE_REF";
      ParserDefinitionErrorType3[ParserDefinitionErrorType3["LEFT_RECURSION"] = 5] = "LEFT_RECURSION";
      ParserDefinitionErrorType3[ParserDefinitionErrorType3["NONE_LAST_EMPTY_ALT"] = 6] = "NONE_LAST_EMPTY_ALT";
      ParserDefinitionErrorType3[ParserDefinitionErrorType3["AMBIGUOUS_ALTS"] = 7] = "AMBIGUOUS_ALTS";
      ParserDefinitionErrorType3[ParserDefinitionErrorType3["CONFLICT_TOKENS_RULES_NAMESPACE"] = 8] = "CONFLICT_TOKENS_RULES_NAMESPACE";
      ParserDefinitionErrorType3[ParserDefinitionErrorType3["INVALID_TOKEN_NAME"] = 9] = "INVALID_TOKEN_NAME";
      ParserDefinitionErrorType3[ParserDefinitionErrorType3["NO_NON_EMPTY_LOOKAHEAD"] = 10] = "NO_NON_EMPTY_LOOKAHEAD";
      ParserDefinitionErrorType3[ParserDefinitionErrorType3["AMBIGUOUS_PREFIX_ALTS"] = 11] = "AMBIGUOUS_PREFIX_ALTS";
      ParserDefinitionErrorType3[ParserDefinitionErrorType3["TOO_MANY_ALTS"] = 12] = "TOO_MANY_ALTS";
      ParserDefinitionErrorType3[ParserDefinitionErrorType3["CUSTOM_LOOKAHEAD_VALIDATION"] = 13] = "CUSTOM_LOOKAHEAD_VALIDATION";
    })(ParserDefinitionErrorType2 = exports2.ParserDefinitionErrorType || (exports2.ParserDefinitionErrorType = {}));
    function EMPTY_ALT2(value) {
      if (value === void 0) {
        value = void 0;
      }
      return function() {
        return value;
      };
    }
    exports2.EMPTY_ALT = EMPTY_ALT2;
    var Parser4 = (
      /** @class */
      function() {
        function Parser5(tokenVocabulary, config3) {
          this.definitionErrors = [];
          this.selfAnalysisDone = false;
          var that = this;
          that.initErrorHandler(config3);
          that.initLexerAdapter();
          that.initLooksAhead(config3);
          that.initRecognizerEngine(tokenVocabulary, config3);
          that.initRecoverable(config3);
          that.initTreeBuilder(config3);
          that.initContentAssist();
          that.initGastRecorder(config3);
          that.initPerformanceTracer(config3);
          if ((0, has_1.default)(config3, "ignoredIssues")) {
            throw new Error("The <ignoredIssues> IParserConfig property has been deprecated.\n	Please use the <IGNORE_AMBIGUITIES> flag on the relevant DSL method instead.\n	See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#IGNORING_AMBIGUITIES\n	For further details.");
          }
          this.skipValidations = (0, has_1.default)(config3, "skipValidations") ? config3.skipValidations : exports2.DEFAULT_PARSER_CONFIG.skipValidations;
        }
        Parser5.performSelfAnalysis = function(parserInstance) {
          throw Error("The **static** `performSelfAnalysis` method has been deprecated.	\nUse the **instance** method with the same name instead.");
        };
        Parser5.prototype.performSelfAnalysis = function() {
          var _this = this;
          this.TRACE_INIT("performSelfAnalysis", function() {
            var defErrorsMsgs;
            _this.selfAnalysisDone = true;
            var className = _this.className;
            _this.TRACE_INIT("toFastProps", function() {
              (0, utils_1.toFastProperties)(_this);
            });
            _this.TRACE_INIT("Grammar Recording", function() {
              try {
                _this.enableRecording();
                (0, forEach_1.default)(_this.definedRulesNames, function(currRuleName) {
                  var wrappedRule = _this[currRuleName];
                  var originalGrammarAction = wrappedRule["originalGrammarAction"];
                  var recordedRuleGast;
                  _this.TRACE_INIT("".concat(currRuleName, " Rule"), function() {
                    recordedRuleGast = _this.topLevelRuleRecord(currRuleName, originalGrammarAction);
                  });
                  _this.gastProductionsCache[currRuleName] = recordedRuleGast;
                });
              } finally {
                _this.disableRecording();
              }
            });
            var resolverErrors = [];
            _this.TRACE_INIT("Grammar Resolving", function() {
              resolverErrors = (0, gast_resolver_public_1.resolveGrammar)({
                rules: (0, values_1.default)(_this.gastProductionsCache)
              });
              _this.definitionErrors = _this.definitionErrors.concat(resolverErrors);
            });
            _this.TRACE_INIT("Grammar Validations", function() {
              if ((0, isEmpty_1.default)(resolverErrors) && _this.skipValidations === false) {
                var validationErrors = (0, gast_resolver_public_1.validateGrammar)({
                  rules: (0, values_1.default)(_this.gastProductionsCache),
                  tokenTypes: (0, values_1.default)(_this.tokensMap),
                  errMsgProvider: errors_public_1.defaultGrammarValidatorErrorProvider,
                  grammarName: className
                });
                var lookaheadValidationErrors = (0, checks_1.validateLookahead)({
                  lookaheadStrategy: _this.lookaheadStrategy,
                  rules: (0, values_1.default)(_this.gastProductionsCache),
                  tokenTypes: (0, values_1.default)(_this.tokensMap),
                  grammarName: className
                });
                _this.definitionErrors = _this.definitionErrors.concat(validationErrors, lookaheadValidationErrors);
              }
            });
            if ((0, isEmpty_1.default)(_this.definitionErrors)) {
              if (_this.recoveryEnabled) {
                _this.TRACE_INIT("computeAllProdsFollows", function() {
                  var allFollows = (0, follow_1.computeAllProdsFollows)((0, values_1.default)(_this.gastProductionsCache));
                  _this.resyncFollows = allFollows;
                });
              }
              _this.TRACE_INIT("ComputeLookaheadFunctions", function() {
                var _a4, _b4;
                (_b4 = (_a4 = _this.lookaheadStrategy).initialize) === null || _b4 === void 0 ? void 0 : _b4.call(_a4, {
                  rules: (0, values_1.default)(_this.gastProductionsCache)
                });
                _this.preComputeLookaheadFunctions((0, values_1.default)(_this.gastProductionsCache));
              });
            }
            if (!Parser5.DEFER_DEFINITION_ERRORS_HANDLING && !(0, isEmpty_1.default)(_this.definitionErrors)) {
              defErrorsMsgs = (0, map_1.default)(_this.definitionErrors, function(defError) {
                return defError.message;
              });
              throw new Error("Parser Definition Errors detected:\n ".concat(defErrorsMsgs.join("\n-------------------------------\n")));
            }
          });
        };
        Parser5.DEFER_DEFINITION_ERRORS_HANDLING = false;
        return Parser5;
      }()
    );
    exports2.Parser = Parser4;
    (0, apply_mixins_1.applyMixins)(Parser4, [
      recoverable_1.Recoverable,
      looksahead_1.LooksAhead,
      tree_builder_1.TreeBuilder,
      lexer_adapter_1.LexerAdapter,
      recognizer_engine_1.RecognizerEngine,
      recognizer_api_1.RecognizerApi,
      error_handler_1.ErrorHandler,
      context_assist_1.ContentAssist,
      gast_recorder_1.GastRecorder,
      perf_tracer_1.PerformanceTracer
    ]);
    var CstParser2 = (
      /** @class */
      function(_super) {
        __extends(CstParser3, _super);
        function CstParser3(tokenVocabulary, config3) {
          if (config3 === void 0) {
            config3 = exports2.DEFAULT_PARSER_CONFIG;
          }
          var configClone = (0, clone_1.default)(config3);
          configClone.outputCst = true;
          return _super.call(this, tokenVocabulary, configClone) || this;
        }
        return CstParser3;
      }(Parser4)
    );
    exports2.CstParser = CstParser2;
    var EmbeddedActionsParser2 = (
      /** @class */
      function(_super) {
        __extends(EmbeddedActionsParser3, _super);
        function EmbeddedActionsParser3(tokenVocabulary, config3) {
          if (config3 === void 0) {
            config3 = exports2.DEFAULT_PARSER_CONFIG;
          }
          var configClone = (0, clone_1.default)(config3);
          configClone.outputCst = false;
          return _super.call(this, tokenVocabulary, configClone) || this;
        }
        return EmbeddedActionsParser3;
      }(Parser4)
    );
    exports2.EmbeddedActionsParser = EmbeddedActionsParser2;
  }
});

// node_modules/@chevrotain/cst-dts-gen/lib/src/model.js
var require_model2 = __commonJS({
  "node_modules/@chevrotain/cst-dts-gen/lib/src/model.js"(exports2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || function() {
      var extendStatics = function(d, b5) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b6) {
          d2.__proto__ = b6;
        } || function(d2, b6) {
          for (var p in b6)
            if (Object.prototype.hasOwnProperty.call(b6, p))
              d2[p] = b6[p];
        };
        return extendStatics(d, b5);
      };
      return function(d, b5) {
        if (typeof b5 !== "function" && b5 !== null)
          throw new TypeError("Class extends value " + String(b5) + " is not a constructor or null");
        extendStatics(d, b5);
        function __() {
          this.constructor = d;
        }
        d.prototype = b5 === null ? Object.create(b5) : (__.prototype = b5.prototype, new __());
      };
    }();
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.buildModel = void 0;
    var gast_1 = require_api2();
    var map_1 = __importDefault(require_map());
    var flatten_1 = __importDefault(require_flatten());
    var values_1 = __importDefault(require_values());
    var some_1 = __importDefault(require_some());
    var groupBy_1 = __importDefault(require_groupBy());
    var assign_1 = __importDefault(require_assign());
    function buildModel(productions) {
      var generator = new CstNodeDefinitionGenerator();
      var allRules = (0, values_1.default)(productions);
      return (0, map_1.default)(allRules, function(rule) {
        return generator.visitRule(rule);
      });
    }
    exports2.buildModel = buildModel;
    var CstNodeDefinitionGenerator = (
      /** @class */
      function(_super) {
        __extends(CstNodeDefinitionGenerator2, _super);
        function CstNodeDefinitionGenerator2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        CstNodeDefinitionGenerator2.prototype.visitRule = function(node) {
          var rawElements = this.visitEach(node.definition);
          var grouped = (0, groupBy_1.default)(rawElements, function(el) {
            return el.propertyName;
          });
          var properties = (0, map_1.default)(grouped, function(group, propertyName) {
            var allNullable = !(0, some_1.default)(group, function(el) {
              return !el.canBeNull;
            });
            var propertyType = group[0].type;
            if (group.length > 1) {
              propertyType = (0, map_1.default)(group, function(g2) {
                return g2.type;
              });
            }
            return {
              name: propertyName,
              type: propertyType,
              optional: allNullable
            };
          });
          return {
            name: node.name,
            properties
          };
        };
        CstNodeDefinitionGenerator2.prototype.visitAlternative = function(node) {
          return this.visitEachAndOverrideWith(node.definition, { canBeNull: true });
        };
        CstNodeDefinitionGenerator2.prototype.visitOption = function(node) {
          return this.visitEachAndOverrideWith(node.definition, { canBeNull: true });
        };
        CstNodeDefinitionGenerator2.prototype.visitRepetition = function(node) {
          return this.visitEachAndOverrideWith(node.definition, { canBeNull: true });
        };
        CstNodeDefinitionGenerator2.prototype.visitRepetitionMandatory = function(node) {
          return this.visitEach(node.definition);
        };
        CstNodeDefinitionGenerator2.prototype.visitRepetitionMandatoryWithSeparator = function(node) {
          return this.visitEach(node.definition).concat({
            propertyName: node.separator.name,
            canBeNull: true,
            type: getType(node.separator)
          });
        };
        CstNodeDefinitionGenerator2.prototype.visitRepetitionWithSeparator = function(node) {
          return this.visitEachAndOverrideWith(node.definition, {
            canBeNull: true
          }).concat({
            propertyName: node.separator.name,
            canBeNull: true,
            type: getType(node.separator)
          });
        };
        CstNodeDefinitionGenerator2.prototype.visitAlternation = function(node) {
          return this.visitEachAndOverrideWith(node.definition, { canBeNull: true });
        };
        CstNodeDefinitionGenerator2.prototype.visitTerminal = function(node) {
          return [
            {
              propertyName: node.label || node.terminalType.name,
              canBeNull: false,
              type: getType(node)
            }
          ];
        };
        CstNodeDefinitionGenerator2.prototype.visitNonTerminal = function(node) {
          return [
            {
              propertyName: node.label || node.nonTerminalName,
              canBeNull: false,
              type: getType(node)
            }
          ];
        };
        CstNodeDefinitionGenerator2.prototype.visitEachAndOverrideWith = function(definition, override) {
          return (0, map_1.default)(this.visitEach(definition), function(definition2) {
            return (0, assign_1.default)({}, definition2, override);
          });
        };
        CstNodeDefinitionGenerator2.prototype.visitEach = function(definition) {
          var _this = this;
          return (0, flatten_1.default)((0, map_1.default)(definition, function(definition2) {
            return _this.visit(definition2);
          }));
        };
        return CstNodeDefinitionGenerator2;
      }(gast_1.GAstVisitor)
    );
    function getType(production) {
      if (production instanceof gast_1.NonTerminal) {
        return {
          kind: "rule",
          name: production.referencedRule.name
        };
      }
      return { kind: "token" };
    }
  }
});

// node_modules/lodash/_castSlice.js
var require_castSlice = __commonJS({
  "node_modules/lodash/_castSlice.js"(exports2, module2) {
    var baseSlice = require_baseSlice();
    function castSlice(array, start, end) {
      var length = array.length;
      end = end === void 0 ? length : end;
      return !start && end >= length ? array : baseSlice(array, start, end);
    }
    module2.exports = castSlice;
  }
});

// node_modules/lodash/_hasUnicode.js
var require_hasUnicode = __commonJS({
  "node_modules/lodash/_hasUnicode.js"(exports2, module2) {
    var rsAstralRange = "\\ud800-\\udfff";
    var rsComboMarksRange = "\\u0300-\\u036f";
    var reComboHalfMarksRange = "\\ufe20-\\ufe2f";
    var rsComboSymbolsRange = "\\u20d0-\\u20ff";
    var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
    var rsVarRange = "\\ufe0e\\ufe0f";
    var rsZWJ = "\\u200d";
    var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
    function hasUnicode(string) {
      return reHasUnicode.test(string);
    }
    module2.exports = hasUnicode;
  }
});

// node_modules/lodash/_asciiToArray.js
var require_asciiToArray = __commonJS({
  "node_modules/lodash/_asciiToArray.js"(exports2, module2) {
    function asciiToArray(string) {
      return string.split("");
    }
    module2.exports = asciiToArray;
  }
});

// node_modules/lodash/_unicodeToArray.js
var require_unicodeToArray = __commonJS({
  "node_modules/lodash/_unicodeToArray.js"(exports2, module2) {
    var rsAstralRange = "\\ud800-\\udfff";
    var rsComboMarksRange = "\\u0300-\\u036f";
    var reComboHalfMarksRange = "\\ufe20-\\ufe2f";
    var rsComboSymbolsRange = "\\u20d0-\\u20ff";
    var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
    var rsVarRange = "\\ufe0e\\ufe0f";
    var rsAstral = "[" + rsAstralRange + "]";
    var rsCombo = "[" + rsComboRange + "]";
    var rsFitz = "\\ud83c[\\udffb-\\udfff]";
    var rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")";
    var rsNonAstral = "[^" + rsAstralRange + "]";
    var rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}";
    var rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]";
    var rsZWJ = "\\u200d";
    var reOptMod = rsModifier + "?";
    var rsOptVar = "[" + rsVarRange + "]?";
    var rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*";
    var rsSeq = rsOptVar + reOptMod + rsOptJoin;
    var rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
    var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
    function unicodeToArray(string) {
      return string.match(reUnicode) || [];
    }
    module2.exports = unicodeToArray;
  }
});

// node_modules/lodash/_stringToArray.js
var require_stringToArray = __commonJS({
  "node_modules/lodash/_stringToArray.js"(exports2, module2) {
    var asciiToArray = require_asciiToArray();
    var hasUnicode = require_hasUnicode();
    var unicodeToArray = require_unicodeToArray();
    function stringToArray(string) {
      return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
    }
    module2.exports = stringToArray;
  }
});

// node_modules/lodash/_createCaseFirst.js
var require_createCaseFirst = __commonJS({
  "node_modules/lodash/_createCaseFirst.js"(exports2, module2) {
    var castSlice = require_castSlice();
    var hasUnicode = require_hasUnicode();
    var stringToArray = require_stringToArray();
    var toString = require_toString();
    function createCaseFirst(methodName) {
      return function(string) {
        string = toString(string);
        var strSymbols = hasUnicode(string) ? stringToArray(string) : void 0;
        var chr = strSymbols ? strSymbols[0] : string.charAt(0);
        var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
        return chr[methodName]() + trailing;
      };
    }
    module2.exports = createCaseFirst;
  }
});

// node_modules/lodash/upperFirst.js
var require_upperFirst = __commonJS({
  "node_modules/lodash/upperFirst.js"(exports2, module2) {
    var createCaseFirst = require_createCaseFirst();
    var upperFirst = createCaseFirst("toUpperCase");
    module2.exports = upperFirst;
  }
});

// node_modules/@chevrotain/cst-dts-gen/lib/src/generate.js
var require_generate = __commonJS({
  "node_modules/@chevrotain/cst-dts-gen/lib/src/generate.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.genDts = void 0;
    var flatten_1 = __importDefault(require_flatten());
    var isArray_1 = __importDefault(require_isArray());
    var map_1 = __importDefault(require_map());
    var reduce_1 = __importDefault(require_reduce());
    var uniq_1 = __importDefault(require_uniq());
    var upperFirst_1 = __importDefault(require_upperFirst());
    function genDts(model, options) {
      var contentParts = [];
      contentParts = contentParts.concat('import type { CstNode, ICstVisitor, IToken } from "chevrotain";');
      contentParts = contentParts.concat((0, flatten_1.default)((0, map_1.default)(model, function(node) {
        return genCstNodeTypes(node);
      })));
      if (options.includeVisitorInterface) {
        contentParts = contentParts.concat(genVisitor(options.visitorInterfaceName, model));
      }
      return contentParts.join("\n\n") + "\n";
    }
    exports2.genDts = genDts;
    function genCstNodeTypes(node) {
      var nodeCstInterface = genNodeInterface(node);
      var nodeChildrenInterface = genNodeChildrenType(node);
      return [nodeCstInterface, nodeChildrenInterface];
    }
    function genNodeInterface(node) {
      var nodeInterfaceName = getNodeInterfaceName(node.name);
      var childrenTypeName = getNodeChildrenTypeName(node.name);
      return "export interface ".concat(nodeInterfaceName, ' extends CstNode {\n  name: "').concat(node.name, '";\n  children: ').concat(childrenTypeName, ";\n}");
    }
    function genNodeChildrenType(node) {
      var typeName = getNodeChildrenTypeName(node.name);
      return "export type ".concat(typeName, " = {\n  ").concat((0, map_1.default)(node.properties, function(property) {
        return genChildProperty(property);
      }).join("\n  "), "\n};");
    }
    function genChildProperty(prop) {
      var typeName = buildTypeString(prop.type);
      return "".concat(prop.name).concat(prop.optional ? "?" : "", ": ").concat(typeName, "[];");
    }
    function genVisitor(name, nodes) {
      return "export interface ".concat(name, "<IN, OUT> extends ICstVisitor<IN, OUT> {\n  ").concat((0, map_1.default)(nodes, function(node) {
        return genVisitorFunction(node);
      }).join("\n  "), "\n}");
    }
    function genVisitorFunction(node) {
      var childrenTypeName = getNodeChildrenTypeName(node.name);
      return "".concat(node.name, "(children: ").concat(childrenTypeName, ", param?: IN): OUT;");
    }
    function buildTypeString(type) {
      if ((0, isArray_1.default)(type)) {
        var typeNames = (0, uniq_1.default)((0, map_1.default)(type, function(t2) {
          return getTypeString(t2);
        }));
        var typeString = (0, reduce_1.default)(typeNames, function(sum, t2) {
          return sum + " | " + t2;
        });
        return "(" + typeString + ")";
      } else {
        return getTypeString(type);
      }
    }
    function getTypeString(type) {
      if (type.kind === "token") {
        return "IToken";
      }
      return getNodeInterfaceName(type.name);
    }
    function getNodeInterfaceName(ruleName) {
      return (0, upperFirst_1.default)(ruleName) + "CstNode";
    }
    function getNodeChildrenTypeName(ruleName) {
      return (0, upperFirst_1.default)(ruleName) + "CstChildren";
    }
  }
});

// node_modules/@chevrotain/cst-dts-gen/lib/src/api.js
var require_api3 = __commonJS({
  "node_modules/@chevrotain/cst-dts-gen/lib/src/api.js"(exports2) {
    "use strict";
    var __assign = exports2 && exports2.__assign || function() {
      __assign = Object.assign || function(t2) {
        for (var s, i3 = 1, n = arguments.length; i3 < n; i3++) {
          s = arguments[i3];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t2[p] = s[p];
        }
        return t2;
      };
      return __assign.apply(this, arguments);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.generateCstDts = void 0;
    var model_1 = require_model2();
    var generate_1 = require_generate();
    var defaultOptions = {
      includeVisitorInterface: true,
      visitorInterfaceName: "ICstNodeVisitor"
    };
    function generateCstDts2(productions, options) {
      var effectiveOptions = __assign(__assign({}, defaultOptions), options);
      var model = (0, model_1.buildModel)(productions);
      return (0, generate_1.genDts)(model, effectiveOptions);
    }
    exports2.generateCstDts = generateCstDts2;
  }
});

// node_modules/chevrotain/lib/src/diagrams/render_public.js
var require_render_public = __commonJS({
  "node_modules/chevrotain/lib/src/diagrams/render_public.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createSyntaxDiagramsCode = void 0;
    var version_1 = require_version();
    function createSyntaxDiagramsCode2(grammar, _a4) {
      var _b4 = _a4 === void 0 ? {} : _a4, _c = _b4.resourceBase, resourceBase = _c === void 0 ? "https://unpkg.com/chevrotain@".concat(version_1.VERSION, "/diagrams/") : _c, _d = _b4.css, css = _d === void 0 ? "https://unpkg.com/chevrotain@".concat(version_1.VERSION, "/diagrams/diagrams.css") : _d;
      var header = '\n<!-- This is a generated file -->\n<!DOCTYPE html>\n<meta charset="utf-8">\n<style>\n  body {\n    background-color: hsl(30, 20%, 95%)\n  }\n</style>\n\n';
      var cssHtml = "\n<link rel='stylesheet' href='".concat(css, "'>\n");
      var scripts = "\n<script src='".concat(resourceBase, "vendor/railroad-diagrams.js'><\/script>\n<script src='").concat(resourceBase, "src/diagrams_builder.js'><\/script>\n<script src='").concat(resourceBase, "src/diagrams_behavior.js'><\/script>\n<script src='").concat(resourceBase, "src/main.js'><\/script>\n");
      var diagramsDiv = '\n<div id="diagrams" align="center"></div>    \n';
      var serializedGrammar = "\n<script>\n    window.serializedGrammar = ".concat(JSON.stringify(grammar, null, "  "), ";\n<\/script>\n");
      var initLogic = '\n<script>\n    var diagramsDiv = document.getElementById("diagrams");\n    main.drawDiagramsFromSerializedGrammar(serializedGrammar, diagramsDiv);\n<\/script>\n';
      return header + cssHtml + scripts + diagramsDiv + serializedGrammar + initLogic;
    }
    exports2.createSyntaxDiagramsCode = createSyntaxDiagramsCode2;
  }
});

// node_modules/chevrotain/lib/src/api.js
var require_api4 = __commonJS({
  "node_modules/chevrotain/lib/src/api.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Parser = exports2.createSyntaxDiagramsCode = exports2.clearCache = exports2.generateCstDts = exports2.GAstVisitor = exports2.serializeProduction = exports2.serializeGrammar = exports2.Terminal = exports2.Rule = exports2.RepetitionWithSeparator = exports2.RepetitionMandatoryWithSeparator = exports2.RepetitionMandatory = exports2.Repetition = exports2.Option = exports2.NonTerminal = exports2.Alternative = exports2.Alternation = exports2.defaultLexerErrorProvider = exports2.NoViableAltException = exports2.NotAllInputParsedException = exports2.MismatchedTokenException = exports2.isRecognitionException = exports2.EarlyExitException = exports2.defaultParserErrorProvider = exports2.LLkLookaheadStrategy = exports2.getLookaheadPaths = exports2.tokenName = exports2.tokenMatcher = exports2.tokenLabel = exports2.EOF = exports2.createTokenInstance = exports2.createToken = exports2.LexerDefinitionErrorType = exports2.Lexer = exports2.EMPTY_ALT = exports2.ParserDefinitionErrorType = exports2.EmbeddedActionsParser = exports2.CstParser = exports2.VERSION = void 0;
    var version_1 = require_version();
    Object.defineProperty(exports2, "VERSION", { enumerable: true, get: function() {
      return version_1.VERSION;
    } });
    var parser_1 = require_parser();
    Object.defineProperty(exports2, "CstParser", { enumerable: true, get: function() {
      return parser_1.CstParser;
    } });
    Object.defineProperty(exports2, "EmbeddedActionsParser", { enumerable: true, get: function() {
      return parser_1.EmbeddedActionsParser;
    } });
    Object.defineProperty(exports2, "ParserDefinitionErrorType", { enumerable: true, get: function() {
      return parser_1.ParserDefinitionErrorType;
    } });
    Object.defineProperty(exports2, "EMPTY_ALT", { enumerable: true, get: function() {
      return parser_1.EMPTY_ALT;
    } });
    var lexer_public_1 = require_lexer_public();
    Object.defineProperty(exports2, "Lexer", { enumerable: true, get: function() {
      return lexer_public_1.Lexer;
    } });
    Object.defineProperty(exports2, "LexerDefinitionErrorType", { enumerable: true, get: function() {
      return lexer_public_1.LexerDefinitionErrorType;
    } });
    var tokens_public_1 = require_tokens_public();
    Object.defineProperty(exports2, "createToken", { enumerable: true, get: function() {
      return tokens_public_1.createToken;
    } });
    Object.defineProperty(exports2, "createTokenInstance", { enumerable: true, get: function() {
      return tokens_public_1.createTokenInstance;
    } });
    Object.defineProperty(exports2, "EOF", { enumerable: true, get: function() {
      return tokens_public_1.EOF;
    } });
    Object.defineProperty(exports2, "tokenLabel", { enumerable: true, get: function() {
      return tokens_public_1.tokenLabel;
    } });
    Object.defineProperty(exports2, "tokenMatcher", { enumerable: true, get: function() {
      return tokens_public_1.tokenMatcher;
    } });
    Object.defineProperty(exports2, "tokenName", { enumerable: true, get: function() {
      return tokens_public_1.tokenName;
    } });
    var lookahead_1 = require_lookahead();
    Object.defineProperty(exports2, "getLookaheadPaths", { enumerable: true, get: function() {
      return lookahead_1.getLookaheadPaths;
    } });
    var llk_lookahead_1 = require_llk_lookahead();
    Object.defineProperty(exports2, "LLkLookaheadStrategy", { enumerable: true, get: function() {
      return llk_lookahead_1.LLkLookaheadStrategy;
    } });
    var errors_public_1 = require_errors_public();
    Object.defineProperty(exports2, "defaultParserErrorProvider", { enumerable: true, get: function() {
      return errors_public_1.defaultParserErrorProvider;
    } });
    var exceptions_public_1 = require_exceptions_public();
    Object.defineProperty(exports2, "EarlyExitException", { enumerable: true, get: function() {
      return exceptions_public_1.EarlyExitException;
    } });
    Object.defineProperty(exports2, "isRecognitionException", { enumerable: true, get: function() {
      return exceptions_public_1.isRecognitionException;
    } });
    Object.defineProperty(exports2, "MismatchedTokenException", { enumerable: true, get: function() {
      return exceptions_public_1.MismatchedTokenException;
    } });
    Object.defineProperty(exports2, "NotAllInputParsedException", { enumerable: true, get: function() {
      return exceptions_public_1.NotAllInputParsedException;
    } });
    Object.defineProperty(exports2, "NoViableAltException", { enumerable: true, get: function() {
      return exceptions_public_1.NoViableAltException;
    } });
    var lexer_errors_public_1 = require_lexer_errors_public();
    Object.defineProperty(exports2, "defaultLexerErrorProvider", { enumerable: true, get: function() {
      return lexer_errors_public_1.defaultLexerErrorProvider;
    } });
    var gast_1 = require_api2();
    Object.defineProperty(exports2, "Alternation", { enumerable: true, get: function() {
      return gast_1.Alternation;
    } });
    Object.defineProperty(exports2, "Alternative", { enumerable: true, get: function() {
      return gast_1.Alternative;
    } });
    Object.defineProperty(exports2, "NonTerminal", { enumerable: true, get: function() {
      return gast_1.NonTerminal;
    } });
    Object.defineProperty(exports2, "Option", { enumerable: true, get: function() {
      return gast_1.Option;
    } });
    Object.defineProperty(exports2, "Repetition", { enumerable: true, get: function() {
      return gast_1.Repetition;
    } });
    Object.defineProperty(exports2, "RepetitionMandatory", { enumerable: true, get: function() {
      return gast_1.RepetitionMandatory;
    } });
    Object.defineProperty(exports2, "RepetitionMandatoryWithSeparator", { enumerable: true, get: function() {
      return gast_1.RepetitionMandatoryWithSeparator;
    } });
    Object.defineProperty(exports2, "RepetitionWithSeparator", { enumerable: true, get: function() {
      return gast_1.RepetitionWithSeparator;
    } });
    Object.defineProperty(exports2, "Rule", { enumerable: true, get: function() {
      return gast_1.Rule;
    } });
    Object.defineProperty(exports2, "Terminal", { enumerable: true, get: function() {
      return gast_1.Terminal;
    } });
    var gast_2 = require_api2();
    Object.defineProperty(exports2, "serializeGrammar", { enumerable: true, get: function() {
      return gast_2.serializeGrammar;
    } });
    Object.defineProperty(exports2, "serializeProduction", { enumerable: true, get: function() {
      return gast_2.serializeProduction;
    } });
    Object.defineProperty(exports2, "GAstVisitor", { enumerable: true, get: function() {
      return gast_2.GAstVisitor;
    } });
    var cst_dts_gen_1 = require_api3();
    Object.defineProperty(exports2, "generateCstDts", { enumerable: true, get: function() {
      return cst_dts_gen_1.generateCstDts;
    } });
    function clearCache2() {
      console.warn("The clearCache function was 'soft' removed from the Chevrotain API.\n	 It performs no action other than printing this message.\n	 Please avoid using it as it will be completely removed in the future");
    }
    exports2.clearCache = clearCache2;
    var render_public_1 = require_render_public();
    Object.defineProperty(exports2, "createSyntaxDiagramsCode", { enumerable: true, get: function() {
      return render_public_1.createSyntaxDiagramsCode;
    } });
    var Parser4 = (
      /** @class */
      function() {
        function Parser5() {
          throw new Error("The Parser class has been deprecated, use CstParser or EmbeddedActionsParser instead.	\nSee: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_7-0-0");
        }
        return Parser5;
      }()
    );
    exports2.Parser = Parser4;
  }
});

// browser-external:fs
var require_fs = __commonJS({
  "browser-external:fs"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "fs" has been externalized for browser compatibility. Cannot access "fs.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/blueimp-md5/js/md5.js
var require_md5 = __commonJS({
  "node_modules/blueimp-md5/js/md5.js"(exports2, module2) {
    (function($) {
      "use strict";
      function safeAdd(x, y) {
        var lsw = (x & 65535) + (y & 65535);
        var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
        return msw << 16 | lsw & 65535;
      }
      function bitRotateLeft(num, cnt) {
        return num << cnt | num >>> 32 - cnt;
      }
      function md5cmn(q, a4, b5, x, s, t2) {
        return safeAdd(bitRotateLeft(safeAdd(safeAdd(a4, q), safeAdd(x, t2)), s), b5);
      }
      function md5ff(a4, b5, c3, d, x, s, t2) {
        return md5cmn(b5 & c3 | ~b5 & d, a4, b5, x, s, t2);
      }
      function md5gg(a4, b5, c3, d, x, s, t2) {
        return md5cmn(b5 & d | c3 & ~d, a4, b5, x, s, t2);
      }
      function md5hh(a4, b5, c3, d, x, s, t2) {
        return md5cmn(b5 ^ c3 ^ d, a4, b5, x, s, t2);
      }
      function md5ii(a4, b5, c3, d, x, s, t2) {
        return md5cmn(c3 ^ (b5 | ~d), a4, b5, x, s, t2);
      }
      function binlMD5(x, len) {
        x[len >> 5] |= 128 << len % 32;
        x[(len + 64 >>> 9 << 4) + 14] = len;
        var i3;
        var olda;
        var oldb;
        var oldc;
        var oldd;
        var a4 = 1732584193;
        var b5 = -271733879;
        var c3 = -1732584194;
        var d = 271733878;
        for (i3 = 0; i3 < x.length; i3 += 16) {
          olda = a4;
          oldb = b5;
          oldc = c3;
          oldd = d;
          a4 = md5ff(a4, b5, c3, d, x[i3], 7, -680876936);
          d = md5ff(d, a4, b5, c3, x[i3 + 1], 12, -389564586);
          c3 = md5ff(c3, d, a4, b5, x[i3 + 2], 17, 606105819);
          b5 = md5ff(b5, c3, d, a4, x[i3 + 3], 22, -1044525330);
          a4 = md5ff(a4, b5, c3, d, x[i3 + 4], 7, -176418897);
          d = md5ff(d, a4, b5, c3, x[i3 + 5], 12, 1200080426);
          c3 = md5ff(c3, d, a4, b5, x[i3 + 6], 17, -1473231341);
          b5 = md5ff(b5, c3, d, a4, x[i3 + 7], 22, -45705983);
          a4 = md5ff(a4, b5, c3, d, x[i3 + 8], 7, 1770035416);
          d = md5ff(d, a4, b5, c3, x[i3 + 9], 12, -1958414417);
          c3 = md5ff(c3, d, a4, b5, x[i3 + 10], 17, -42063);
          b5 = md5ff(b5, c3, d, a4, x[i3 + 11], 22, -1990404162);
          a4 = md5ff(a4, b5, c3, d, x[i3 + 12], 7, 1804603682);
          d = md5ff(d, a4, b5, c3, x[i3 + 13], 12, -40341101);
          c3 = md5ff(c3, d, a4, b5, x[i3 + 14], 17, -1502002290);
          b5 = md5ff(b5, c3, d, a4, x[i3 + 15], 22, 1236535329);
          a4 = md5gg(a4, b5, c3, d, x[i3 + 1], 5, -165796510);
          d = md5gg(d, a4, b5, c3, x[i3 + 6], 9, -1069501632);
          c3 = md5gg(c3, d, a4, b5, x[i3 + 11], 14, 643717713);
          b5 = md5gg(b5, c3, d, a4, x[i3], 20, -373897302);
          a4 = md5gg(a4, b5, c3, d, x[i3 + 5], 5, -701558691);
          d = md5gg(d, a4, b5, c3, x[i3 + 10], 9, 38016083);
          c3 = md5gg(c3, d, a4, b5, x[i3 + 15], 14, -660478335);
          b5 = md5gg(b5, c3, d, a4, x[i3 + 4], 20, -405537848);
          a4 = md5gg(a4, b5, c3, d, x[i3 + 9], 5, 568446438);
          d = md5gg(d, a4, b5, c3, x[i3 + 14], 9, -1019803690);
          c3 = md5gg(c3, d, a4, b5, x[i3 + 3], 14, -187363961);
          b5 = md5gg(b5, c3, d, a4, x[i3 + 8], 20, 1163531501);
          a4 = md5gg(a4, b5, c3, d, x[i3 + 13], 5, -1444681467);
          d = md5gg(d, a4, b5, c3, x[i3 + 2], 9, -51403784);
          c3 = md5gg(c3, d, a4, b5, x[i3 + 7], 14, 1735328473);
          b5 = md5gg(b5, c3, d, a4, x[i3 + 12], 20, -1926607734);
          a4 = md5hh(a4, b5, c3, d, x[i3 + 5], 4, -378558);
          d = md5hh(d, a4, b5, c3, x[i3 + 8], 11, -2022574463);
          c3 = md5hh(c3, d, a4, b5, x[i3 + 11], 16, 1839030562);
          b5 = md5hh(b5, c3, d, a4, x[i3 + 14], 23, -35309556);
          a4 = md5hh(a4, b5, c3, d, x[i3 + 1], 4, -1530992060);
          d = md5hh(d, a4, b5, c3, x[i3 + 4], 11, 1272893353);
          c3 = md5hh(c3, d, a4, b5, x[i3 + 7], 16, -155497632);
          b5 = md5hh(b5, c3, d, a4, x[i3 + 10], 23, -1094730640);
          a4 = md5hh(a4, b5, c3, d, x[i3 + 13], 4, 681279174);
          d = md5hh(d, a4, b5, c3, x[i3], 11, -358537222);
          c3 = md5hh(c3, d, a4, b5, x[i3 + 3], 16, -722521979);
          b5 = md5hh(b5, c3, d, a4, x[i3 + 6], 23, 76029189);
          a4 = md5hh(a4, b5, c3, d, x[i3 + 9], 4, -640364487);
          d = md5hh(d, a4, b5, c3, x[i3 + 12], 11, -421815835);
          c3 = md5hh(c3, d, a4, b5, x[i3 + 15], 16, 530742520);
          b5 = md5hh(b5, c3, d, a4, x[i3 + 2], 23, -995338651);
          a4 = md5ii(a4, b5, c3, d, x[i3], 6, -198630844);
          d = md5ii(d, a4, b5, c3, x[i3 + 7], 10, 1126891415);
          c3 = md5ii(c3, d, a4, b5, x[i3 + 14], 15, -1416354905);
          b5 = md5ii(b5, c3, d, a4, x[i3 + 5], 21, -57434055);
          a4 = md5ii(a4, b5, c3, d, x[i3 + 12], 6, 1700485571);
          d = md5ii(d, a4, b5, c3, x[i3 + 3], 10, -1894986606);
          c3 = md5ii(c3, d, a4, b5, x[i3 + 10], 15, -1051523);
          b5 = md5ii(b5, c3, d, a4, x[i3 + 1], 21, -2054922799);
          a4 = md5ii(a4, b5, c3, d, x[i3 + 8], 6, 1873313359);
          d = md5ii(d, a4, b5, c3, x[i3 + 15], 10, -30611744);
          c3 = md5ii(c3, d, a4, b5, x[i3 + 6], 15, -1560198380);
          b5 = md5ii(b5, c3, d, a4, x[i3 + 13], 21, 1309151649);
          a4 = md5ii(a4, b5, c3, d, x[i3 + 4], 6, -145523070);
          d = md5ii(d, a4, b5, c3, x[i3 + 11], 10, -1120210379);
          c3 = md5ii(c3, d, a4, b5, x[i3 + 2], 15, 718787259);
          b5 = md5ii(b5, c3, d, a4, x[i3 + 9], 21, -343485551);
          a4 = safeAdd(a4, olda);
          b5 = safeAdd(b5, oldb);
          c3 = safeAdd(c3, oldc);
          d = safeAdd(d, oldd);
        }
        return [a4, b5, c3, d];
      }
      function binl2rstr(input) {
        var i3;
        var output = "";
        var length32 = input.length * 32;
        for (i3 = 0; i3 < length32; i3 += 8) {
          output += String.fromCharCode(input[i3 >> 5] >>> i3 % 32 & 255);
        }
        return output;
      }
      function rstr2binl(input) {
        var i3;
        var output = [];
        output[(input.length >> 2) - 1] = void 0;
        for (i3 = 0; i3 < output.length; i3 += 1) {
          output[i3] = 0;
        }
        var length8 = input.length * 8;
        for (i3 = 0; i3 < length8; i3 += 8) {
          output[i3 >> 5] |= (input.charCodeAt(i3 / 8) & 255) << i3 % 32;
        }
        return output;
      }
      function rstrMD5(s) {
        return binl2rstr(binlMD5(rstr2binl(s), s.length * 8));
      }
      function rstrHMACMD5(key, data) {
        var i3;
        var bkey = rstr2binl(key);
        var ipad = [];
        var opad = [];
        var hash2;
        ipad[15] = opad[15] = void 0;
        if (bkey.length > 16) {
          bkey = binlMD5(bkey, key.length * 8);
        }
        for (i3 = 0; i3 < 16; i3 += 1) {
          ipad[i3] = bkey[i3] ^ 909522486;
          opad[i3] = bkey[i3] ^ 1549556828;
        }
        hash2 = binlMD5(ipad.concat(rstr2binl(data)), 512 + data.length * 8);
        return binl2rstr(binlMD5(opad.concat(hash2), 512 + 128));
      }
      function rstr2hex(input) {
        var hexTab = "0123456789abcdef";
        var output = "";
        var x;
        var i3;
        for (i3 = 0; i3 < input.length; i3 += 1) {
          x = input.charCodeAt(i3);
          output += hexTab.charAt(x >>> 4 & 15) + hexTab.charAt(x & 15);
        }
        return output;
      }
      function str2rstrUTF8(input) {
        return unescape(encodeURIComponent(input));
      }
      function rawMD5(s) {
        return rstrMD5(str2rstrUTF8(s));
      }
      function hexMD5(s) {
        return rstr2hex(rawMD5(s));
      }
      function rawHMACMD5(k, d) {
        return rstrHMACMD5(str2rstrUTF8(k), str2rstrUTF8(d));
      }
      function hexHMACMD5(k, d) {
        return rstr2hex(rawHMACMD5(k, d));
      }
      function md52(string, key, raw) {
        if (!key) {
          if (!raw) {
            return hexMD5(string);
          }
          return rawMD5(string);
        }
        if (!raw) {
          return hexHMACMD5(key, string);
        }
        return rawHMACMD5(key, string);
      }
      if (typeof define === "function" && define.amd) {
        define(function() {
          return md52;
        });
      } else if (typeof module2 === "object" && module2.exports) {
        module2.exports = md52;
      } else {
        $.md5 = md52;
      }
    })(exports2);
  }
});

// node_modules/glsl-tokenizer/lib/literals.js
var require_literals = __commonJS({
  "node_modules/glsl-tokenizer/lib/literals.js"(exports2, module2) {
    module2.exports = [
      // current
      "precision",
      "highp",
      "mediump",
      "lowp",
      "attribute",
      "const",
      "uniform",
      "varying",
      "break",
      "continue",
      "do",
      "for",
      "while",
      "if",
      "else",
      "in",
      "out",
      "inout",
      "float",
      "int",
      "uint",
      "void",
      "bool",
      "true",
      "false",
      "discard",
      "return",
      "mat2",
      "mat3",
      "mat4",
      "vec2",
      "vec3",
      "vec4",
      "ivec2",
      "ivec3",
      "ivec4",
      "bvec2",
      "bvec3",
      "bvec4",
      "sampler1D",
      "sampler2D",
      "sampler3D",
      "samplerCube",
      "sampler1DShadow",
      "sampler2DShadow",
      "struct",
      "asm",
      "class",
      "union",
      "enum",
      "typedef",
      "template",
      "this",
      "packed",
      "goto",
      "switch",
      "default",
      "inline",
      "noinline",
      "volatile",
      "public",
      "static",
      "extern",
      "external",
      "interface",
      "long",
      "short",
      "double",
      "half",
      "fixed",
      "unsigned",
      "input",
      "output",
      "hvec2",
      "hvec3",
      "hvec4",
      "dvec2",
      "dvec3",
      "dvec4",
      "fvec2",
      "fvec3",
      "fvec4",
      "sampler2DRect",
      "sampler3DRect",
      "sampler2DRectShadow",
      "sizeof",
      "cast",
      "namespace",
      "using"
    ];
  }
});

// node_modules/glsl-tokenizer/lib/operators.js
var require_operators = __commonJS({
  "node_modules/glsl-tokenizer/lib/operators.js"(exports2, module2) {
    module2.exports = [
      "<<=",
      ">>=",
      "++",
      "--",
      "<<",
      ">>",
      "<=",
      ">=",
      "==",
      "!=",
      "&&",
      "||",
      "+=",
      "-=",
      "*=",
      "/=",
      "%=",
      "&=",
      "^^",
      "^=",
      "|=",
      "(",
      ")",
      "[",
      "]",
      ".",
      "!",
      "~",
      "*",
      "/",
      "%",
      "+",
      "-",
      "<",
      ">",
      "&",
      "^",
      "|",
      "?",
      ":",
      "=",
      ",",
      ";",
      "{",
      "}"
    ];
  }
});

// node_modules/glsl-tokenizer/lib/builtins.js
var require_builtins = __commonJS({
  "node_modules/glsl-tokenizer/lib/builtins.js"(exports2, module2) {
    module2.exports = [
      // Keep this list sorted
      "abs",
      "acos",
      "all",
      "any",
      "asin",
      "atan",
      "ceil",
      "clamp",
      "cos",
      "cross",
      "dFdx",
      "dFdy",
      "degrees",
      "distance",
      "dot",
      "equal",
      "exp",
      "exp2",
      "faceforward",
      "floor",
      "fract",
      "gl_BackColor",
      "gl_BackLightModelProduct",
      "gl_BackLightProduct",
      "gl_BackMaterial",
      "gl_BackSecondaryColor",
      "gl_ClipPlane",
      "gl_ClipVertex",
      "gl_Color",
      "gl_DepthRange",
      "gl_DepthRangeParameters",
      "gl_EyePlaneQ",
      "gl_EyePlaneR",
      "gl_EyePlaneS",
      "gl_EyePlaneT",
      "gl_Fog",
      "gl_FogCoord",
      "gl_FogFragCoord",
      "gl_FogParameters",
      "gl_FragColor",
      "gl_FragCoord",
      "gl_FragData",
      "gl_FragDepth",
      "gl_FragDepthEXT",
      "gl_FrontColor",
      "gl_FrontFacing",
      "gl_FrontLightModelProduct",
      "gl_FrontLightProduct",
      "gl_FrontMaterial",
      "gl_FrontSecondaryColor",
      "gl_LightModel",
      "gl_LightModelParameters",
      "gl_LightModelProducts",
      "gl_LightProducts",
      "gl_LightSource",
      "gl_LightSourceParameters",
      "gl_MaterialParameters",
      "gl_MaxClipPlanes",
      "gl_MaxCombinedTextureImageUnits",
      "gl_MaxDrawBuffers",
      "gl_MaxFragmentUniformComponents",
      "gl_MaxLights",
      "gl_MaxTextureCoords",
      "gl_MaxTextureImageUnits",
      "gl_MaxTextureUnits",
      "gl_MaxVaryingFloats",
      "gl_MaxVertexAttribs",
      "gl_MaxVertexTextureImageUnits",
      "gl_MaxVertexUniformComponents",
      "gl_ModelViewMatrix",
      "gl_ModelViewMatrixInverse",
      "gl_ModelViewMatrixInverseTranspose",
      "gl_ModelViewMatrixTranspose",
      "gl_ModelViewProjectionMatrix",
      "gl_ModelViewProjectionMatrixInverse",
      "gl_ModelViewProjectionMatrixInverseTranspose",
      "gl_ModelViewProjectionMatrixTranspose",
      "gl_MultiTexCoord0",
      "gl_MultiTexCoord1",
      "gl_MultiTexCoord2",
      "gl_MultiTexCoord3",
      "gl_MultiTexCoord4",
      "gl_MultiTexCoord5",
      "gl_MultiTexCoord6",
      "gl_MultiTexCoord7",
      "gl_Normal",
      "gl_NormalMatrix",
      "gl_NormalScale",
      "gl_ObjectPlaneQ",
      "gl_ObjectPlaneR",
      "gl_ObjectPlaneS",
      "gl_ObjectPlaneT",
      "gl_Point",
      "gl_PointCoord",
      "gl_PointParameters",
      "gl_PointSize",
      "gl_Position",
      "gl_ProjectionMatrix",
      "gl_ProjectionMatrixInverse",
      "gl_ProjectionMatrixInverseTranspose",
      "gl_ProjectionMatrixTranspose",
      "gl_SecondaryColor",
      "gl_TexCoord",
      "gl_TextureEnvColor",
      "gl_TextureMatrix",
      "gl_TextureMatrixInverse",
      "gl_TextureMatrixInverseTranspose",
      "gl_TextureMatrixTranspose",
      "gl_Vertex",
      "greaterThan",
      "greaterThanEqual",
      "inversesqrt",
      "length",
      "lessThan",
      "lessThanEqual",
      "log",
      "log2",
      "matrixCompMult",
      "max",
      "min",
      "mix",
      "mod",
      "normalize",
      "not",
      "notEqual",
      "pow",
      "radians",
      "reflect",
      "refract",
      "sign",
      "sin",
      "smoothstep",
      "sqrt",
      "step",
      "tan",
      "texture2D",
      "texture2DLod",
      "texture2DProj",
      "texture2DProjLod",
      "textureCube",
      "textureCubeLod",
      "texture2DLodEXT",
      "texture2DProjLodEXT",
      "textureCubeLodEXT",
      "texture2DGradEXT",
      "texture2DProjGradEXT",
      "textureCubeGradEXT"
    ];
  }
});

// node_modules/glsl-tokenizer/lib/literals-300es.js
var require_literals_300es = __commonJS({
  "node_modules/glsl-tokenizer/lib/literals-300es.js"(exports2, module2) {
    var v100 = require_literals();
    module2.exports = v100.slice().concat([
      "layout",
      "centroid",
      "smooth",
      "case",
      "mat2x2",
      "mat2x3",
      "mat2x4",
      "mat3x2",
      "mat3x3",
      "mat3x4",
      "mat4x2",
      "mat4x3",
      "mat4x4",
      "uvec2",
      "uvec3",
      "uvec4",
      "samplerCubeShadow",
      "sampler2DArray",
      "sampler2DArrayShadow",
      "isampler2D",
      "isampler3D",
      "isamplerCube",
      "isampler2DArray",
      "usampler2D",
      "usampler3D",
      "usamplerCube",
      "usampler2DArray",
      "coherent",
      "restrict",
      "readonly",
      "writeonly",
      "resource",
      "atomic_uint",
      "noperspective",
      "patch",
      "sample",
      "subroutine",
      "common",
      "partition",
      "active",
      "filter",
      "image1D",
      "image2D",
      "image3D",
      "imageCube",
      "iimage1D",
      "iimage2D",
      "iimage3D",
      "iimageCube",
      "uimage1D",
      "uimage2D",
      "uimage3D",
      "uimageCube",
      "image1DArray",
      "image2DArray",
      "iimage1DArray",
      "iimage2DArray",
      "uimage1DArray",
      "uimage2DArray",
      "image1DShadow",
      "image2DShadow",
      "image1DArrayShadow",
      "image2DArrayShadow",
      "imageBuffer",
      "iimageBuffer",
      "uimageBuffer",
      "sampler1DArray",
      "sampler1DArrayShadow",
      "isampler1D",
      "isampler1DArray",
      "usampler1D",
      "usampler1DArray",
      "isampler2DRect",
      "usampler2DRect",
      "samplerBuffer",
      "isamplerBuffer",
      "usamplerBuffer",
      "sampler2DMS",
      "isampler2DMS",
      "usampler2DMS",
      "sampler2DMSArray",
      "isampler2DMSArray",
      "usampler2DMSArray"
    ]);
  }
});

// node_modules/glsl-tokenizer/lib/builtins-300es.js
var require_builtins_300es = __commonJS({
  "node_modules/glsl-tokenizer/lib/builtins-300es.js"(exports2, module2) {
    var v100 = require_builtins();
    v100 = v100.slice().filter(function(b5) {
      return !/^(gl\_|texture)/.test(b5);
    });
    module2.exports = v100.concat([
      // the updated gl_ constants
      "gl_VertexID",
      "gl_InstanceID",
      "gl_Position",
      "gl_PointSize",
      "gl_FragCoord",
      "gl_FrontFacing",
      "gl_FragDepth",
      "gl_PointCoord",
      "gl_MaxVertexAttribs",
      "gl_MaxVertexUniformVectors",
      "gl_MaxVertexOutputVectors",
      "gl_MaxFragmentInputVectors",
      "gl_MaxVertexTextureImageUnits",
      "gl_MaxCombinedTextureImageUnits",
      "gl_MaxTextureImageUnits",
      "gl_MaxFragmentUniformVectors",
      "gl_MaxDrawBuffers",
      "gl_MinProgramTexelOffset",
      "gl_MaxProgramTexelOffset",
      "gl_DepthRangeParameters",
      "gl_DepthRange",
      "trunc",
      "round",
      "roundEven",
      "isnan",
      "isinf",
      "floatBitsToInt",
      "floatBitsToUint",
      "intBitsToFloat",
      "uintBitsToFloat",
      "packSnorm2x16",
      "unpackSnorm2x16",
      "packUnorm2x16",
      "unpackUnorm2x16",
      "packHalf2x16",
      "unpackHalf2x16",
      "outerProduct",
      "transpose",
      "determinant",
      "inverse",
      "texture",
      "textureSize",
      "textureProj",
      "textureLod",
      "textureOffset",
      "texelFetch",
      "texelFetchOffset",
      "textureProjOffset",
      "textureLodOffset",
      "textureProjLod",
      "textureProjLodOffset",
      "textureGrad",
      "textureGradOffset",
      "textureProjGrad",
      "textureProjGradOffset"
    ]);
  }
});

// node_modules/glsl-tokenizer/index.js
var require_glsl_tokenizer = __commonJS({
  "node_modules/glsl-tokenizer/index.js"(exports2, module2) {
    module2.exports = tokenize2;
    var literals100 = require_literals();
    var operators = require_operators();
    var builtins100 = require_builtins();
    var literals300es = require_literals_300es();
    var builtins300es = require_builtins_300es();
    var NORMAL = 999;
    var TOKEN = 9999;
    var BLOCK_COMMENT = 0;
    var LINE_COMMENT = 1;
    var PREPROCESSOR = 2;
    var OPERATOR = 3;
    var INTEGER = 4;
    var FLOAT = 5;
    var IDENT = 6;
    var BUILTIN = 7;
    var KEYWORD = 8;
    var WHITESPACE = 9;
    var EOF2 = 10;
    var HEX = 11;
    var map2 = [
      "block-comment",
      "line-comment",
      "preprocessor",
      "operator",
      "integer",
      "float",
      "ident",
      "builtin",
      "keyword",
      "whitespace",
      "eof",
      "integer"
    ];
    function tokenize2(opt) {
      var i3 = 0, total = 0, mode = NORMAL, c3, last, content = [], tokens = [], token_idx = 0, token_offs = 0, line2 = 1, col = 0, start = 0, isnum = false, isoperator = false, input = "", len;
      opt = opt || {};
      var allBuiltins = builtins100;
      var allLiterals = literals100;
      if (opt.version === "300 es") {
        allBuiltins = builtins300es;
        allLiterals = literals300es;
      }
      var builtinsDict = {}, literalsDict = {};
      for (var i3 = 0; i3 < allBuiltins.length; i3++) {
        builtinsDict[allBuiltins[i3]] = true;
      }
      for (var i3 = 0; i3 < allLiterals.length; i3++) {
        literalsDict[allLiterals[i3]] = true;
      }
      return function(data) {
        tokens = [];
        if (data !== null)
          return write(data);
        return end();
      };
      function token(data) {
        if (data.length) {
          tokens.push({
            type: map2[mode],
            data,
            position: start,
            line: line2,
            column: col
          });
        }
      }
      function write(chunk) {
        i3 = 0;
        if (chunk.toString)
          chunk = chunk.toString();
        input += chunk.replace(/\r\n/g, "\n");
        len = input.length;
        var last2;
        while (c3 = input[i3], i3 < len) {
          last2 = i3;
          switch (mode) {
            case BLOCK_COMMENT:
              i3 = block_comment();
              break;
            case LINE_COMMENT:
              i3 = line_comment();
              break;
            case PREPROCESSOR:
              i3 = preprocessor();
              break;
            case OPERATOR:
              i3 = operator();
              break;
            case INTEGER:
              i3 = integer();
              break;
            case HEX:
              i3 = hex();
              break;
            case FLOAT:
              i3 = decimal();
              break;
            case TOKEN:
              i3 = readtoken();
              break;
            case WHITESPACE:
              i3 = whitespace();
              break;
            case NORMAL:
              i3 = normal();
              break;
          }
          if (last2 !== i3) {
            switch (input[last2]) {
              case "\n":
                col = 0;
                ++line2;
                break;
              default:
                ++col;
                break;
            }
          }
        }
        total += i3;
        input = input.slice(i3);
        return tokens;
      }
      function end(chunk) {
        if (content.length) {
          token(content.join(""));
        }
        mode = EOF2;
        token("(eof)");
        return tokens;
      }
      function normal() {
        content = content.length ? [] : content;
        if (last === "/" && c3 === "*") {
          start = total + i3 - 1;
          mode = BLOCK_COMMENT;
          last = c3;
          return i3 + 1;
        }
        if (last === "/" && c3 === "/") {
          start = total + i3 - 1;
          mode = LINE_COMMENT;
          last = c3;
          return i3 + 1;
        }
        if (c3 === "#") {
          mode = PREPROCESSOR;
          start = total + i3;
          return i3;
        }
        if (/\s/.test(c3)) {
          mode = WHITESPACE;
          start = total + i3;
          return i3;
        }
        isnum = /\d/.test(c3);
        isoperator = /[^\w_]/.test(c3);
        start = total + i3;
        mode = isnum ? INTEGER : isoperator ? OPERATOR : TOKEN;
        return i3;
      }
      function whitespace() {
        if (/[^\s]/g.test(c3)) {
          token(content.join(""));
          mode = NORMAL;
          return i3;
        }
        content.push(c3);
        last = c3;
        return i3 + 1;
      }
      function preprocessor() {
        if ((c3 === "\r" || c3 === "\n") && last !== "\\") {
          token(content.join(""));
          mode = NORMAL;
          return i3;
        }
        content.push(c3);
        last = c3;
        return i3 + 1;
      }
      function line_comment() {
        return preprocessor();
      }
      function block_comment() {
        if (c3 === "/" && last === "*") {
          content.push(c3);
          token(content.join(""));
          mode = NORMAL;
          return i3 + 1;
        }
        content.push(c3);
        last = c3;
        return i3 + 1;
      }
      function operator() {
        if (last === "." && /\d/.test(c3)) {
          mode = FLOAT;
          return i3;
        }
        if (last === "/" && c3 === "*") {
          mode = BLOCK_COMMENT;
          return i3;
        }
        if (last === "/" && c3 === "/") {
          mode = LINE_COMMENT;
          return i3;
        }
        if (c3 === "." && content.length) {
          while (determine_operator(content))
            ;
          mode = FLOAT;
          return i3;
        }
        if (c3 === ";" || c3 === ")" || c3 === "(") {
          if (content.length)
            while (determine_operator(content))
              ;
          token(c3);
          mode = NORMAL;
          return i3 + 1;
        }
        var is_composite_operator = content.length === 2 && c3 !== "=";
        if (/[\w_\d\s]/.test(c3) || is_composite_operator) {
          while (determine_operator(content))
            ;
          mode = NORMAL;
          return i3;
        }
        content.push(c3);
        last = c3;
        return i3 + 1;
      }
      function determine_operator(buf) {
        var j = 0, idx, res;
        do {
          idx = operators.indexOf(buf.slice(0, buf.length + j).join(""));
          res = operators[idx];
          if (idx === -1) {
            if (j-- + buf.length > 0)
              continue;
            res = buf.slice(0, 1).join("");
          }
          token(res);
          start += res.length;
          content = content.slice(res.length);
          return content.length;
        } while (1);
      }
      function hex() {
        if (/[^a-fA-F0-9]/.test(c3)) {
          token(content.join(""));
          mode = NORMAL;
          return i3;
        }
        content.push(c3);
        last = c3;
        return i3 + 1;
      }
      function integer() {
        if (c3 === ".") {
          content.push(c3);
          mode = FLOAT;
          last = c3;
          return i3 + 1;
        }
        if (/[eE]/.test(c3)) {
          content.push(c3);
          mode = FLOAT;
          last = c3;
          return i3 + 1;
        }
        if (c3 === "x" && content.length === 1 && content[0] === "0") {
          mode = HEX;
          content.push(c3);
          last = c3;
          return i3 + 1;
        }
        if (/[^\d]/.test(c3)) {
          token(content.join(""));
          mode = NORMAL;
          return i3;
        }
        content.push(c3);
        last = c3;
        return i3 + 1;
      }
      function decimal() {
        if (c3 === "f") {
          content.push(c3);
          last = c3;
          i3 += 1;
        }
        if (/[eE]/.test(c3)) {
          content.push(c3);
          last = c3;
          return i3 + 1;
        }
        if ((c3 === "-" || c3 === "+") && /[eE]/.test(last)) {
          content.push(c3);
          last = c3;
          return i3 + 1;
        }
        if (/[^\d]/.test(c3)) {
          token(content.join(""));
          mode = NORMAL;
          return i3;
        }
        content.push(c3);
        last = c3;
        return i3 + 1;
      }
      function readtoken() {
        if (/[^\d\w_]/.test(c3)) {
          var contentstr = content.join("");
          if (literalsDict[contentstr]) {
            mode = KEYWORD;
          } else if (builtinsDict[contentstr]) {
            mode = BUILTIN;
          } else {
            mode = IDENT;
          }
          token(content.join(""));
          mode = NORMAL;
          return i3;
        }
        content.push(c3);
        last = c3;
        return i3 + 1;
      }
    }
  }
});

// node_modules/glsl-tokenizer/string.js
var require_string = __commonJS({
  "node_modules/glsl-tokenizer/string.js"(exports2, module2) {
    var tokenize2 = require_glsl_tokenizer();
    module2.exports = tokenizeString;
    function tokenizeString(str, opt) {
      var generator = tokenize2(opt);
      var tokens = [];
      tokens = tokens.concat(generator(str));
      tokens = tokens.concat(generator(null));
      return tokens;
    }
  }
});

// node_modules/glsl-token-string/index.js
var require_glsl_token_string = __commonJS({
  "node_modules/glsl-token-string/index.js"(exports2, module2) {
    module2.exports = toString;
    function toString(tokens) {
      var output = [];
      for (var i3 = 0; i3 < tokens.length; i3++) {
        if (tokens[i3].type === "eof")
          continue;
        output.push(tokens[i3].data);
      }
      return output.join("");
    }
  }
});

// node_modules/glsl-token-functions/index.js
var require_glsl_token_functions = __commonJS({
  "node_modules/glsl-token-functions/index.js"(exports2, module2) {
    module2.exports = functions;
    function functions(tokens) {
      var returnType = null;
      var defnName = null;
      var braceDepth = 0;
      var braceStart = 0;
      var defnStart = 0;
      var argFinish = 0;
      var argStart = 0;
      var output = [];
      var i3, j, token;
      for (i3 = 0, j; i3 < tokens.length; i3++) {
        token = tokens[i3];
        if (token.data === "{") {
          if (braceDepth && braceDepth++)
            continue;
          j = findPrevious(i3, findOp(")"), findOp());
          if (j < 0)
            continue;
          argFinish = j;
          j = findPrevious(j, findOp("("), findOp(")"));
          if (j < 0)
            continue;
          argStart = j;
          j = findPrevious(j, findGlyph);
          if (j < 0)
            continue;
          if (tokens[j].type !== "ident")
            continue;
          defnName = tokens[j].data;
          j = findPrevious(j, findGlyph);
          if (j < 0)
            continue;
          braceDepth = 1;
          braceStart = i3;
          returnType = tokens[j].data;
          defnStart = j;
          var k = findPrevious(j, findGlyph);
          switch (tokens[k] && tokens[k].data) {
            case "lowp":
            case "highp":
            case "mediump":
              defnStart = k;
          }
        } else if (braceDepth && token.data === "}") {
          if (--braceDepth)
            continue;
          output.push({
            name: defnName,
            type: returnType,
            body: [braceStart + 1, i3],
            args: [argStart, argFinish + 1],
            outer: [defnStart, i3 + 1]
          });
        }
      }
      for (i3 = 0; i3 < tokens.length; i3++) {
        token = tokens[i3];
        if (token.data === ";") {
          j = findPrevious(i3, findOp(")"), findOp());
          if (j < 0)
            continue;
          argFinish = j;
          j = findPrevious(j, findOp("("), findOp(")"));
          if (j < 0)
            continue;
          argStart = j;
          j = findPrevious(j, findGlyph);
          if (j < 0)
            continue;
          if (tokens[j].type !== "ident")
            continue;
          defnName = tokens[j].data;
          j = findPrevious(j, findGlyph);
          if (j < 0)
            continue;
          if (tokens[j].type === "operator")
            continue;
          if (tokens[j].data === "return")
            continue;
          returnType = tokens[j].data;
          output.push({
            name: defnName,
            type: returnType,
            body: false,
            args: [argStart, argFinish + 1],
            outer: [j, i3 + 1]
          });
        }
      }
      return output.sort(function(a4, b5) {
        return a4.outer[0] - b5.outer[0];
      });
      function findPrevious(start, match, bail) {
        for (var i4 = start - 1; i4 >= 0; i4--) {
          if (match(tokens[i4]))
            return i4;
          if (bail && bail(tokens[i4]))
            return -1;
        }
        return -1;
      }
    }
    function findOp(data) {
      return function(token) {
        return token.type === "operator" && (!data || token.data === data);
      };
    }
    function findGlyph(token) {
      return token.type !== "whitespace";
    }
  }
});

// node_modules/ev-emitter/ev-emitter.js
var require_ev_emitter = __commonJS({
  "node_modules/ev-emitter/ev-emitter.js"(exports2, module2) {
    (function(global2, factory2) {
      if (typeof module2 == "object" && module2.exports) {
        module2.exports = factory2();
      } else {
        global2.EvEmitter = factory2();
      }
    })(typeof window != "undefined" ? window : exports2, function() {
      function EvEmitter() {
      }
      let proto = EvEmitter.prototype;
      proto.on = function(eventName, listener) {
        if (!eventName || !listener)
          return this;
        let events2 = this._events = this._events || {};
        let listeners = events2[eventName] = events2[eventName] || [];
        if (!listeners.includes(listener)) {
          listeners.push(listener);
        }
        return this;
      };
      proto.once = function(eventName, listener) {
        if (!eventName || !listener)
          return this;
        this.on(eventName, listener);
        let onceEvents = this._onceEvents = this._onceEvents || {};
        let onceListeners = onceEvents[eventName] = onceEvents[eventName] || {};
        onceListeners[listener] = true;
        return this;
      };
      proto.off = function(eventName, listener) {
        let listeners = this._events && this._events[eventName];
        if (!listeners || !listeners.length)
          return this;
        let index = listeners.indexOf(listener);
        if (index != -1) {
          listeners.splice(index, 1);
        }
        return this;
      };
      proto.emitEvent = function(eventName, args) {
        let listeners = this._events && this._events[eventName];
        if (!listeners || !listeners.length)
          return this;
        listeners = listeners.slice(0);
        args = args || [];
        let onceListeners = this._onceEvents && this._onceEvents[eventName];
        for (let listener of listeners) {
          let isOnce = onceListeners && onceListeners[listener];
          if (isOnce) {
            this.off(eventName, listener);
            delete onceListeners[listener];
          }
          listener.apply(this, args);
        }
        return this;
      };
      proto.allOff = function() {
        delete this._events;
        delete this._onceEvents;
        return this;
      };
      return EvEmitter;
    });
  }
});

// node_modules/imagesloaded/imagesloaded.js
var require_imagesloaded = __commonJS({
  "node_modules/imagesloaded/imagesloaded.js"(exports2, module2) {
    (function(window2, factory2) {
      if (typeof module2 == "object" && module2.exports) {
        module2.exports = factory2(window2, require_ev_emitter());
      } else {
        window2.imagesLoaded = factory2(window2, window2.EvEmitter);
      }
    })(
      typeof window !== "undefined" ? window : exports2,
      function factory2(window2, EvEmitter) {
        let $ = window2.jQuery;
        let console2 = window2.console;
        function makeArray(obj) {
          if (Array.isArray(obj))
            return obj;
          let isArrayLike = typeof obj == "object" && typeof obj.length == "number";
          if (isArrayLike)
            return [...obj];
          return [obj];
        }
        function ImagesLoaded(elem, options, onAlways) {
          if (!(this instanceof ImagesLoaded)) {
            return new ImagesLoaded(elem, options, onAlways);
          }
          let queryElem = elem;
          if (typeof elem == "string") {
            queryElem = document.querySelectorAll(elem);
          }
          if (!queryElem) {
            console2.error(`Bad element for imagesLoaded ${queryElem || elem}`);
            return;
          }
          this.elements = makeArray(queryElem);
          this.options = {};
          if (typeof options == "function") {
            onAlways = options;
          } else {
            Object.assign(this.options, options);
          }
          if (onAlways)
            this.on("always", onAlways);
          this.getImages();
          if ($)
            this.jqDeferred = new $.Deferred();
          setTimeout(this.check.bind(this));
        }
        ImagesLoaded.prototype = Object.create(EvEmitter.prototype);
        ImagesLoaded.prototype.getImages = function() {
          this.images = [];
          this.elements.forEach(this.addElementImages, this);
        };
        const elementNodeTypes = [1, 9, 11];
        ImagesLoaded.prototype.addElementImages = function(elem) {
          if (elem.nodeName === "IMG") {
            this.addImage(elem);
          }
          if (this.options.background === true) {
            this.addElementBackgroundImages(elem);
          }
          let { nodeType } = elem;
          if (!nodeType || !elementNodeTypes.includes(nodeType))
            return;
          let childImgs = elem.querySelectorAll("img");
          for (let img of childImgs) {
            this.addImage(img);
          }
          if (typeof this.options.background == "string") {
            let children = elem.querySelectorAll(this.options.background);
            for (let child of children) {
              this.addElementBackgroundImages(child);
            }
          }
        };
        const reURL = /url\((['"])?(.*?)\1\)/gi;
        ImagesLoaded.prototype.addElementBackgroundImages = function(elem) {
          let style = getComputedStyle(elem);
          if (!style)
            return;
          let matches = reURL.exec(style.backgroundImage);
          while (matches !== null) {
            let url = matches && matches[2];
            if (url) {
              this.addBackground(url, elem);
            }
            matches = reURL.exec(style.backgroundImage);
          }
        };
        ImagesLoaded.prototype.addImage = function(img) {
          let loadingImage = new LoadingImage(img);
          this.images.push(loadingImage);
        };
        ImagesLoaded.prototype.addBackground = function(url, elem) {
          let background = new Background(url, elem);
          this.images.push(background);
        };
        ImagesLoaded.prototype.check = function() {
          this.progressedCount = 0;
          this.hasAnyBroken = false;
          if (!this.images.length) {
            this.complete();
            return;
          }
          let onProgress = (image, elem, message) => {
            setTimeout(() => {
              this.progress(image, elem, message);
            });
          };
          this.images.forEach(function(loadingImage) {
            loadingImage.once("progress", onProgress);
            loadingImage.check();
          });
        };
        ImagesLoaded.prototype.progress = function(image, elem, message) {
          this.progressedCount++;
          this.hasAnyBroken = this.hasAnyBroken || !image.isLoaded;
          this.emitEvent("progress", [this, image, elem]);
          if (this.jqDeferred && this.jqDeferred.notify) {
            this.jqDeferred.notify(this, image);
          }
          if (this.progressedCount === this.images.length) {
            this.complete();
          }
          if (this.options.debug && console2) {
            console2.log(`progress: ${message}`, image, elem);
          }
        };
        ImagesLoaded.prototype.complete = function() {
          let eventName = this.hasAnyBroken ? "fail" : "done";
          this.isComplete = true;
          this.emitEvent(eventName, [this]);
          this.emitEvent("always", [this]);
          if (this.jqDeferred) {
            let jqMethod = this.hasAnyBroken ? "reject" : "resolve";
            this.jqDeferred[jqMethod](this);
          }
        };
        function LoadingImage(img) {
          this.img = img;
        }
        LoadingImage.prototype = Object.create(EvEmitter.prototype);
        LoadingImage.prototype.check = function() {
          let isComplete = this.getIsImageComplete();
          if (isComplete) {
            this.confirm(this.img.naturalWidth !== 0, "naturalWidth");
            return;
          }
          this.proxyImage = new Image();
          if (this.img.crossOrigin) {
            this.proxyImage.crossOrigin = this.img.crossOrigin;
          }
          this.proxyImage.addEventListener("load", this);
          this.proxyImage.addEventListener("error", this);
          this.img.addEventListener("load", this);
          this.img.addEventListener("error", this);
          this.proxyImage.src = this.img.currentSrc || this.img.src;
        };
        LoadingImage.prototype.getIsImageComplete = function() {
          return this.img.complete && this.img.naturalWidth;
        };
        LoadingImage.prototype.confirm = function(isLoaded, message) {
          this.isLoaded = isLoaded;
          let { parentNode } = this.img;
          let elem = parentNode.nodeName === "PICTURE" ? parentNode : this.img;
          this.emitEvent("progress", [this, elem, message]);
        };
        LoadingImage.prototype.handleEvent = function(event) {
          let method = "on" + event.type;
          if (this[method]) {
            this[method](event);
          }
        };
        LoadingImage.prototype.onload = function() {
          this.confirm(true, "onload");
          this.unbindEvents();
        };
        LoadingImage.prototype.onerror = function() {
          this.confirm(false, "onerror");
          this.unbindEvents();
        };
        LoadingImage.prototype.unbindEvents = function() {
          this.proxyImage.removeEventListener("load", this);
          this.proxyImage.removeEventListener("error", this);
          this.img.removeEventListener("load", this);
          this.img.removeEventListener("error", this);
        };
        function Background(url, element) {
          this.url = url;
          this.element = element;
          this.img = new Image();
        }
        Background.prototype = Object.create(LoadingImage.prototype);
        Background.prototype.check = function() {
          this.img.addEventListener("load", this);
          this.img.addEventListener("error", this);
          this.img.src = this.url;
          let isComplete = this.getIsImageComplete();
          if (isComplete) {
            this.confirm(this.img.naturalWidth !== 0, "naturalWidth");
            this.unbindEvents();
          }
        };
        Background.prototype.unbindEvents = function() {
          this.img.removeEventListener("load", this);
          this.img.removeEventListener("error", this);
        };
        Background.prototype.confirm = function(isLoaded, message) {
          this.isLoaded = isLoaded;
          this.emitEvent("progress", [this, this.element, message]);
        };
        ImagesLoaded.makeJQueryPlugin = function(jQuery) {
          jQuery = jQuery || window2.jQuery;
          if (!jQuery)
            return;
          $ = jQuery;
          $.fn.imagesLoaded = function(options, onAlways) {
            let instance = new ImagesLoaded(this, options, onAlways);
            return instance.jqDeferred.promise($(this));
          };
        };
        ImagesLoaded.makeJQueryPlugin();
        return ImagesLoaded;
      }
    );
  }
});

// node_modules/three.interactive/build/three.interactive.js
var c = class {
  constructor(e, n) {
    __publicField(this, "target");
    __publicField(this, "name");
    __publicField(this, "intersected");
    __publicField(this, "wasIntersected", false);
    __publicField(this, "distance");
    this.target = e, this.name = n, this.intersected = false, this.distance = 0;
  }
};
var i2 = class {
  constructor(e, n = null) {
    __publicField(this, "type");
    __publicField(this, "cancelBubble");
    __publicField(this, "originalEvent");
    __publicField(this, "coords", new Vector2(0, 0));
    __publicField(this, "distance", 0);
    __publicField(this, "intersected", false);
    this.cancelBubble = false, this.type = e, this.originalEvent = n;
  }
  stopPropagation() {
    this.cancelBubble = true;
  }
};
var a = class {
  constructor(e, n, t2, s) {
    __publicField(this, "renderer");
    __publicField(this, "camera");
    __publicField(this, "domElement");
    __publicField(this, "bindEventsOnBodyElement");
    __publicField(this, "autoAdd");
    __publicField(this, "scene");
    __publicField(this, "mouse");
    __publicField(this, "supportsPointerEvents");
    __publicField(this, "interactiveObjects");
    __publicField(this, "closestObject");
    __publicField(this, "raycaster");
    __publicField(this, "treatTouchEventsAsMouseEvents");
    __publicField(this, "dispose", () => {
      this.domElement.removeEventListener("click", this.onMouseClick), this.supportsPointerEvents && (this.bindEventsOnBodyElement ? this.domElement.ownerDocument.removeEventListener("pointermove", this.onDocumentPointerMove) : this.domElement.removeEventListener("pointermove", this.onDocumentPointerMove), this.domElement.removeEventListener("pointerdown", this.onPointerDown), this.domElement.removeEventListener("pointerup", this.onPointerUp)), this.bindEventsOnBodyElement ? this.domElement.ownerDocument.removeEventListener("mousemove", this.onDocumentMouseMove) : this.domElement.removeEventListener("mousemove", this.onDocumentMouseMove), this.domElement.removeEventListener("mousedown", this.onMouseDown), this.domElement.removeEventListener("mouseup", this.onMouseUp), this.domElement.removeEventListener("touchstart", this.onTouchStart), this.domElement.removeEventListener("touchmove", this.onTouchMove), this.domElement.removeEventListener("touchend", this.onTouchEnd);
    });
    __publicField(this, "add", (e, n = []) => {
      if (e && !this.interactiveObjects.find((t2) => t2.target === e))
        if (n.length > 0)
          n.forEach((t2) => {
            let s = e.getObjectByName(t2);
            if (s) {
              let o = new c(s, t2);
              this.interactiveObjects.push(o);
            }
          });
        else {
          let t2 = new c(e, e.name);
          this.interactiveObjects.push(t2);
        }
    });
    __publicField(this, "remove", (e, n = []) => {
      !e || (n.length > 0 ? n.forEach((t2) => {
        let s = e.getObjectByName(t2);
        s && (this.interactiveObjects = this.interactiveObjects.filter((o) => o.target !== s));
      }) : this.interactiveObjects = this.interactiveObjects.filter((t2) => t2.target !== e));
    });
    __publicField(this, "update", () => {
      this.raycaster.setFromCamera(this.mouse, this.camera), this.interactiveObjects.forEach((s) => {
        s.target && this.checkIntersection(s);
      }), this.interactiveObjects.sort(function(s, o) {
        return s.distance - o.distance;
      });
      let e = this.interactiveObjects.find((s) => s.intersected) ?? null;
      if (e != this.closestObject) {
        if (this.closestObject) {
          let s = new i2("mouseout");
          this.dispatch(this.closestObject, s);
        }
        if (e) {
          let s = new i2("mouseover");
          this.dispatch(e, s);
        }
        this.closestObject = e;
      }
      let n;
      this.interactiveObjects.forEach((s) => {
        !s.intersected && s.wasIntersected && (n || (n = new i2("mouseleave")), this.dispatch(s, n));
      });
      let t2;
      this.interactiveObjects.forEach((s) => {
        s.intersected && !s.wasIntersected && (t2 || (t2 = new i2("mouseenter")), this.dispatch(s, t2));
      });
    });
    __publicField(this, "checkIntersection", (e) => {
      let n = this.raycaster.intersectObjects([e.target], true);
      if (e.wasIntersected = e.intersected, n.length > 0) {
        let t2 = n[0].distance;
        n.forEach((s) => {
          s.distance < t2 && (t2 = s.distance);
        }), e.intersected = true, e.distance = t2;
      } else
        e.intersected = false;
    });
    __publicField(this, "onDocumentMouseMove", (e) => {
      this.mapPositionToPoint(this.mouse, e.clientX, e.clientY);
      let n = new i2("mousemove", e);
      this.interactiveObjects.forEach((t2) => {
        this.dispatch(t2, n);
      });
    });
    __publicField(this, "onDocumentPointerMove", (e) => {
      this.mapPositionToPoint(this.mouse, e.clientX, e.clientY);
      let n = new i2("pointermove", e);
      this.interactiveObjects.forEach((t2) => {
        this.dispatch(t2, n);
      });
    });
    __publicField(this, "onTouchMove", (e) => {
      e.touches.length > 0 && this.mapPositionToPoint(this.mouse, e.touches[0].clientX, e.touches[0].clientY);
      let n = new i2(this.treatTouchEventsAsMouseEvents ? "mousemove" : "touchmove", e);
      this.interactiveObjects.forEach((t2) => {
        this.dispatch(t2, n);
      });
    });
    __publicField(this, "onMouseClick", (e) => {
      this.update();
      let n = new i2("click", e);
      this.interactiveObjects.forEach((t2) => {
        t2.intersected && this.dispatch(t2, n);
      });
    });
    __publicField(this, "onMouseDown", (e) => {
      this.mapPositionToPoint(this.mouse, e.clientX, e.clientY), this.update();
      let n = new i2("mousedown", e);
      this.interactiveObjects.forEach((t2) => {
        t2.intersected && this.dispatch(t2, n);
      });
    });
    __publicField(this, "onPointerDown", (e) => {
      this.mapPositionToPoint(this.mouse, e.clientX, e.clientY), this.update();
      let n = new i2("pointerdown", e);
      this.interactiveObjects.forEach((t2) => {
        t2.intersected && this.dispatch(t2, n);
      });
    });
    __publicField(this, "onTouchStart", (e) => {
      e.touches.length > 0 && this.mapPositionToPoint(this.mouse, e.touches[0].clientX, e.touches[0].clientY), this.update();
      let n = new i2(this.treatTouchEventsAsMouseEvents ? "mousedown" : "touchstart", e);
      this.interactiveObjects.forEach((t2) => {
        t2.intersected && this.dispatch(t2, n);
      });
    });
    __publicField(this, "onMouseUp", (e) => {
      let n = new i2("mouseup", e);
      this.interactiveObjects.forEach((t2) => {
        this.dispatch(t2, n);
      });
    });
    __publicField(this, "onPointerUp", (e) => {
      let n = new i2("pointerup", e);
      this.interactiveObjects.forEach((t2) => {
        this.dispatch(t2, n);
      });
    });
    __publicField(this, "onTouchEnd", (e) => {
      e.touches.length > 0 && this.mapPositionToPoint(this.mouse, e.touches[0].clientX, e.touches[0].clientY), this.update();
      let n = new i2(this.treatTouchEventsAsMouseEvents ? "mouseup" : "touchend", e);
      this.interactiveObjects.forEach((t2) => {
        this.dispatch(t2, n);
      });
    });
    __publicField(this, "dispatch", (e, n) => {
      e.target && !n.cancelBubble && (n.coords = this.mouse, n.distance = e.distance, n.intersected = e.intersected, e.target.dispatchEvent(n));
    });
    __publicField(this, "mapPositionToPoint", (e, n, t2) => {
      let s = this.renderer.domElement.getBoundingClientRect();
      e.x = (n - s.left) / s.width * 2 - 1, e.y = -((t2 - s.top) / s.height) * 2 + 1;
    });
    this.renderer = e, this.camera = n, this.domElement = t2, this.bindEventsOnBodyElement = s && typeof s.bindEventsOnBodyElement < "u" ? s.bindEventsOnBodyElement : true, this.scene = s && typeof s.scene < "u" ? s.scene : null, this.scene && (this.scene.onBeforeRender = () => {
      this.autoAdd && this.scene !== null && this.scene.traverse((o) => {
        this.add(o), o.addEventListener("removed", (u) => {
          this.remove(u.target);
        });
      }), this.update();
    }), this.autoAdd = s && typeof s.autoAdd < "u" ? s.autoAdd : false, this.autoAdd && this.scene === null && console.error("Attention: Options.scene needs to be set when using options.autoAdd"), this.mouse = new Vector2(-1, 1), this.supportsPointerEvents = !!window.PointerEvent, this.interactiveObjects = [], this.closestObject = null, this.raycaster = new Raycaster(), t2.addEventListener("click", this.onMouseClick), this.supportsPointerEvents && (this.bindEventsOnBodyElement ? t2.ownerDocument.addEventListener("pointermove", this.onDocumentPointerMove) : t2.addEventListener("pointermove", this.onDocumentPointerMove), t2.addEventListener("pointerdown", this.onPointerDown), t2.addEventListener("pointerup", this.onPointerUp)), this.bindEventsOnBodyElement ? t2.ownerDocument.addEventListener("mousemove", this.onDocumentMouseMove) : t2.addEventListener("mousemove", this.onDocumentMouseMove), t2.addEventListener("mousedown", this.onMouseDown), t2.addEventListener("mouseup", this.onMouseUp), t2.addEventListener("touchstart", this.onTouchStart, { passive: true }), t2.addEventListener("touchmove", this.onTouchMove, { passive: true }), t2.addEventListener("touchend", this.onTouchEnd, { passive: true }), this.treatTouchEventsAsMouseEvents = true;
  }
};

// node_modules/mitt/dist/mitt.mjs
function mitt_default(n) {
  return { all: n = n || /* @__PURE__ */ new Map(), on: function(t2, e) {
    var i3 = n.get(t2);
    i3 ? i3.push(e) : n.set(t2, [e]);
  }, off: function(t2, e) {
    var i3 = n.get(t2);
    i3 && (e ? i3.splice(i3.indexOf(e) >>> 0, 1) : n.set(t2, []));
  }, emit: function(t2, e) {
    var i3 = n.get(t2);
    i3 && i3.slice().map(function(n2) {
      n2(e);
    }), (i3 = n.get("*")) && i3.slice().map(function(n2) {
      n2(t2, e);
    });
  } };
}

// node_modules/kokomi.js/dist/components/component.js
var Component = class {
  constructor(base) {
    __publicField(this, "base");
    __publicField(this, "emitter");
    __publicField(this, "container");
    this.base = base;
    this.base.update((time) => this.update(time));
    this.emitter = mitt_default();
    this.container = this.base.scene;
  }
  // 将组件添加至当前场景或替换当前场景中已有的组件
  addExisting() {
    1 + 1;
  }
  // 动画帧
  update(time) {
    1 + 1;
  }
  // 监听事件
  on(type, handler) {
    this.emitter.on(type, handler);
  }
  // 移除事件
  off(type, handler) {
    this.emitter.off(type, handler);
  }
  // 触发事件
  emit(type, event = {}) {
    this.emitter.emit(type, event);
  }
};

// node_modules/kokomi.js/dist/components/animationManager.js
var AnimationManager = class extends Component {
  constructor(base, clips, root) {
    super(base);
    __publicField(this, "clips");
    __publicField(this, "root");
    __publicField(this, "mixer");
    this.clips = clips;
    this.root = root;
    this.mixer = new AnimationMixer(root);
  }
  get names() {
    return this.clips.map((item) => item.name);
  }
  get actions() {
    return Object.fromEntries(this.clips.map((item) => [item.name, this.mixer.clipAction(item)]));
  }
  update() {
    this.mixer.update(this.base.clock.deltaTime);
  }
};

// node_modules/kokomi.js/dist/components/animator.js
var Animator = class {
  constructor(base) {
    __publicField(this, "base");
    __publicField(this, "tasks");
    this.base = base;
    this.tasks = [];
  }
  add(fn) {
    this.tasks.push(fn);
  }
  update() {
    this.base.renderer.setAnimationLoop((time) => {
      this.tick(time);
    });
  }
  tick(time = 0) {
    this.tasks.forEach((task) => {
      task(time);
    });
    this.base.render();
  }
};

// node_modules/three-stdlib/math/ConvexHull.js
var _v1 = new Vector3();
var _line3 = new Line3();
var _plane = new Plane();
var _closestPoint = new Vector3();
var _triangle = new Triangle();

// node_modules/three-stdlib/misc/ConvexObjectBreaker.js
var _v12 = new Vector3();

// node_modules/three-stdlib/misc/Gyroscope.js
var _translationObject = new Vector3();
var _quaternionObject = new Quaternion();
var _scaleObject = new Vector3();
var _translationWorld = new Vector3();
var _quaternionWorld = new Quaternion();
var _scaleWorld = new Vector3();

// node_modules/three-stdlib/renderers/CSS2DRenderer.js
var _vector = new Vector3();
var _viewMatrix = new Matrix4();
var _viewProjectionMatrix = new Matrix4();
var _a = new Vector3();
var _b = new Vector3();

// node_modules/three-stdlib/renderers/CSS3DRenderer.js
var _position = new Vector3();
var _quaternion = new Quaternion();
var _scale = new Vector3();
var _matrix = new Matrix4();
var _matrix2 = new Matrix4();

// node_modules/three-stdlib/modifiers/CurveModifier.js
var matrix = new Matrix4();

// node_modules/three-stdlib/utils/BufferGeometryUtils.js
function mergeVertices(geometry2, tolerance = 1e-4) {
  tolerance = Math.max(tolerance, Number.EPSILON);
  const hashToIndex = {};
  const indices = geometry2.getIndex();
  const positions = geometry2.getAttribute("position");
  const vertexCount = indices ? indices.count : positions.count;
  let nextIndex = 0;
  const attributeNames = Object.keys(geometry2.attributes);
  const attrArrays = {};
  const morphAttrsArrays = {};
  const newIndices = [];
  const getters = ["getX", "getY", "getZ", "getW"];
  for (let i3 = 0, l = attributeNames.length; i3 < l; i3++) {
    const name = attributeNames[i3];
    attrArrays[name] = [];
    const morphAttr = geometry2.morphAttributes[name];
    if (morphAttr) {
      morphAttrsArrays[name] = new Array(morphAttr.length).fill(0).map(() => []);
    }
  }
  const decimalShift = Math.log10(1 / tolerance);
  const shiftMultiplier = Math.pow(10, decimalShift);
  for (let i3 = 0; i3 < vertexCount; i3++) {
    const index = indices ? indices.getX(i3) : i3;
    let hash2 = "";
    for (let j = 0, l = attributeNames.length; j < l; j++) {
      const name = attributeNames[j];
      const attribute = geometry2.getAttribute(name);
      const itemSize = attribute.itemSize;
      for (let k = 0; k < itemSize; k++) {
        hash2 += `${~~(attribute[getters[k]](index) * shiftMultiplier)},`;
      }
    }
    if (hash2 in hashToIndex) {
      newIndices.push(hashToIndex[hash2]);
    } else {
      for (let j = 0, l = attributeNames.length; j < l; j++) {
        const name = attributeNames[j];
        const attribute = geometry2.getAttribute(name);
        const morphAttr = geometry2.morphAttributes[name];
        const itemSize = attribute.itemSize;
        const newarray = attrArrays[name];
        const newMorphArrays = morphAttrsArrays[name];
        for (let k = 0; k < itemSize; k++) {
          const getterFunc = getters[k];
          newarray.push(attribute[getterFunc](index));
          if (morphAttr) {
            for (let m = 0, ml = morphAttr.length; m < ml; m++) {
              newMorphArrays[m].push(morphAttr[m][getterFunc](index));
            }
          }
        }
      }
      hashToIndex[hash2] = nextIndex;
      newIndices.push(nextIndex);
      nextIndex++;
    }
  }
  const result = geometry2.clone();
  for (let i3 = 0, l = attributeNames.length; i3 < l; i3++) {
    const name = attributeNames[i3];
    const oldAttribute = geometry2.getAttribute(name);
    const buffer = new oldAttribute.array.constructor(attrArrays[name]);
    const attribute = new BufferAttribute(buffer, oldAttribute.itemSize, oldAttribute.normalized);
    result.setAttribute(name, attribute);
    if (name in morphAttrsArrays) {
      for (let j = 0; j < morphAttrsArrays[name].length; j++) {
        const oldMorphAttribute = geometry2.morphAttributes[name][j];
        const buffer2 = new oldMorphAttribute.array.constructor(morphAttrsArrays[name][j]);
        const morphAttribute = new BufferAttribute(buffer2, oldMorphAttribute.itemSize, oldMorphAttribute.normalized);
        result.morphAttributes[name][j] = morphAttribute;
      }
    }
  }
  result.setIndex(newIndices);
  return result;
}
function toTrianglesDrawMode(geometry2, drawMode) {
  if (drawMode === TrianglesDrawMode) {
    console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.");
    return geometry2;
  }
  if (drawMode === TriangleFanDrawMode || drawMode === TriangleStripDrawMode) {
    let index = geometry2.getIndex();
    if (index === null) {
      const indices = [];
      const position = geometry2.getAttribute("position");
      if (position !== void 0) {
        for (let i3 = 0; i3 < position.count; i3++) {
          indices.push(i3);
        }
        geometry2.setIndex(indices);
        index = geometry2.getIndex();
      } else {
        console.error(
          "THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."
        );
        return geometry2;
      }
    }
    const numberOfTriangles = index.count - 2;
    const newIndices = [];
    if (index) {
      if (drawMode === TriangleFanDrawMode) {
        for (let i3 = 1; i3 <= numberOfTriangles; i3++) {
          newIndices.push(index.getX(0));
          newIndices.push(index.getX(i3));
          newIndices.push(index.getX(i3 + 1));
        }
      } else {
        for (let i3 = 0; i3 < numberOfTriangles; i3++) {
          if (i3 % 2 === 0) {
            newIndices.push(index.getX(i3));
            newIndices.push(index.getX(i3 + 1));
            newIndices.push(index.getX(i3 + 2));
          } else {
            newIndices.push(index.getX(i3 + 2));
            newIndices.push(index.getX(i3 + 1));
            newIndices.push(index.getX(i3));
          }
        }
      }
    }
    if (newIndices.length / 3 !== numberOfTriangles) {
      console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
    }
    const newGeometry = geometry2.clone();
    newGeometry.setIndex(newIndices);
    newGeometry.clearGroups();
    return newGeometry;
  } else {
    console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:", drawMode);
    return geometry2;
  }
}

// node_modules/three-stdlib/modifiers/SimplifyModifier.js
var cb = new Vector3();
var ab = new Vector3();

// node_modules/three-stdlib/exporters/GLTFExporter.js
var _renderer;
var fullscreenQuadGeometry;
var fullscreenQuadMaterial;
var fullscreenQuad;
function decompress(texture, maxTextureSize = Infinity, renderer = null) {
  if (!fullscreenQuadGeometry)
    fullscreenQuadGeometry = new PlaneGeometry(2, 2, 1, 1);
  if (!fullscreenQuadMaterial)
    fullscreenQuadMaterial = new ShaderMaterial({
      uniforms: { blitTexture: new Uniform(texture) },
      vertexShader: (
        /* glsl */
        `
        varying vec2 vUv;
        void main(){
            vUv = uv;
            gl_Position = vec4(position.xy * 1.0,0.,.999999);
        }
      `
      ),
      fragmentShader: (
        /* glsl */
        `
          uniform sampler2D blitTexture; 
          varying vec2 vUv;

          void main(){ 
              gl_FragColor = vec4(vUv.xy, 0, 1);
              
              #ifdef IS_SRGB
              gl_FragColor = LinearTosRGB( texture2D( blitTexture, vUv) );
              #else
              gl_FragColor = texture2D( blitTexture, vUv);
              #endif
          }
      `
      )
    });
  fullscreenQuadMaterial.uniforms.blitTexture.value = texture;
  fullscreenQuadMaterial.defines.IS_SRGB = "colorSpace" in texture ? texture.colorSpace === "srgb" : texture.encoding === 3001;
  fullscreenQuadMaterial.needsUpdate = true;
  if (!fullscreenQuad) {
    fullscreenQuad = new Mesh(fullscreenQuadGeometry, fullscreenQuadMaterial);
    fullscreenQuad.frustrumCulled = false;
  }
  const _camera = new PerspectiveCamera();
  const _scene = new Scene();
  _scene.add(fullscreenQuad);
  if (!renderer) {
    renderer = _renderer = new WebGLRenderer({ antialias: false });
  }
  renderer.setSize(Math.min(texture.image.width, maxTextureSize), Math.min(texture.image.height, maxTextureSize));
  renderer.clear();
  renderer.render(_scene, _camera);
  const readableTexture = new Texture(renderer.domElement);
  readableTexture.minFilter = texture.minFilter;
  readableTexture.magFilter = texture.magFilter;
  readableTexture.wrapS = texture.wrapS;
  readableTexture.wrapT = texture.wrapT;
  readableTexture.name = texture.name;
  if (_renderer) {
    _renderer.dispose();
    _renderer = null;
  }
  return readableTexture;
}
var KHR_mesh_quantization_ExtraAttrTypes = {
  POSITION: [
    "byte",
    "byte normalized",
    "unsigned byte",
    "unsigned byte normalized",
    "short",
    "short normalized",
    "unsigned short",
    "unsigned short normalized"
  ],
  NORMAL: ["byte normalized", "short normalized"],
  TANGENT: ["byte normalized", "short normalized"],
  TEXCOORD: ["byte", "byte normalized", "unsigned byte", "short", "short normalized", "unsigned short"]
};
var GLTFExporter = class {
  constructor() {
    this.pluginCallbacks = [];
    this.register(function(writer) {
      return new GLTFLightExtension(writer);
    });
    this.register(function(writer) {
      return new GLTFMaterialsUnlitExtension(writer);
    });
    this.register(function(writer) {
      return new GLTFMaterialsTransmissionExtension(writer);
    });
    this.register(function(writer) {
      return new GLTFMaterialsVolumeExtension(writer);
    });
    this.register(function(writer) {
      return new GLTFMaterialsIorExtension(writer);
    });
    this.register(function(writer) {
      return new GLTFMaterialsSpecularExtension(writer);
    });
    this.register(function(writer) {
      return new GLTFMaterialsClearcoatExtension(writer);
    });
    this.register(function(writer) {
      return new GLTFMaterialsIridescenceExtension(writer);
    });
    this.register(function(writer) {
      return new GLTFMaterialsSheenExtension(writer);
    });
    this.register(function(writer) {
      return new GLTFMaterialsAnisotropyExtension(writer);
    });
    this.register(function(writer) {
      return new GLTFMaterialsEmissiveStrengthExtension(writer);
    });
  }
  register(callback) {
    if (this.pluginCallbacks.indexOf(callback) === -1) {
      this.pluginCallbacks.push(callback);
    }
    return this;
  }
  unregister(callback) {
    if (this.pluginCallbacks.indexOf(callback) !== -1) {
      this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(callback), 1);
    }
    return this;
  }
  /**
   * Parse scenes and generate GLTF output
   * @param  {Scene or [THREE.Scenes]} input   Scene or Array of THREE.Scenes
   * @param  {Function} onDone  Callback on completed
   * @param  {Function} onError  Callback on errors
   * @param  {Object} options options
   */
  parse(input, onDone, onError, options) {
    const writer = new GLTFWriter();
    const plugins = [];
    for (let i3 = 0, il = this.pluginCallbacks.length; i3 < il; i3++) {
      plugins.push(this.pluginCallbacks[i3](writer));
    }
    writer.setPlugins(plugins);
    writer.write(input, onDone, options).catch(onError);
  }
  parseAsync(input, options) {
    const scope = this;
    return new Promise(function(resolve, reject) {
      scope.parse(input, resolve, reject, options);
    });
  }
};
var WEBGL_CONSTANTS = {
  POINTS: 0,
  LINES: 1,
  LINE_LOOP: 2,
  LINE_STRIP: 3,
  TRIANGLES: 4,
  TRIANGLE_STRIP: 5,
  TRIANGLE_FAN: 6,
  BYTE: 5120,
  UNSIGNED_BYTE: 5121,
  SHORT: 5122,
  UNSIGNED_SHORT: 5123,
  INT: 5124,
  UNSIGNED_INT: 5125,
  FLOAT: 5126,
  ARRAY_BUFFER: 34962,
  ELEMENT_ARRAY_BUFFER: 34963,
  NEAREST: 9728,
  LINEAR: 9729,
  NEAREST_MIPMAP_NEAREST: 9984,
  LINEAR_MIPMAP_NEAREST: 9985,
  NEAREST_MIPMAP_LINEAR: 9986,
  LINEAR_MIPMAP_LINEAR: 9987,
  CLAMP_TO_EDGE: 33071,
  MIRRORED_REPEAT: 33648,
  REPEAT: 10497
};
var KHR_MESH_QUANTIZATION = "KHR_mesh_quantization";
var THREE_TO_WEBGL = {};
THREE_TO_WEBGL[NearestFilter] = WEBGL_CONSTANTS.NEAREST;
THREE_TO_WEBGL[NearestMipmapNearestFilter] = WEBGL_CONSTANTS.NEAREST_MIPMAP_NEAREST;
THREE_TO_WEBGL[NearestMipmapLinearFilter] = WEBGL_CONSTANTS.NEAREST_MIPMAP_LINEAR;
THREE_TO_WEBGL[LinearFilter] = WEBGL_CONSTANTS.LINEAR;
THREE_TO_WEBGL[LinearMipmapNearestFilter] = WEBGL_CONSTANTS.LINEAR_MIPMAP_NEAREST;
THREE_TO_WEBGL[LinearMipmapLinearFilter] = WEBGL_CONSTANTS.LINEAR_MIPMAP_LINEAR;
THREE_TO_WEBGL[ClampToEdgeWrapping] = WEBGL_CONSTANTS.CLAMP_TO_EDGE;
THREE_TO_WEBGL[RepeatWrapping] = WEBGL_CONSTANTS.REPEAT;
THREE_TO_WEBGL[MirroredRepeatWrapping] = WEBGL_CONSTANTS.MIRRORED_REPEAT;
var PATH_PROPERTIES = {
  scale: "scale",
  position: "translation",
  quaternion: "rotation",
  morphTargetInfluences: "weights"
};
var DEFAULT_SPECULAR_COLOR = new Color();
var GLB_HEADER_BYTES = 12;
var GLB_HEADER_MAGIC = 1179937895;
var GLB_VERSION = 2;
var GLB_CHUNK_PREFIX_BYTES = 8;
var GLB_CHUNK_TYPE_JSON = 1313821514;
var GLB_CHUNK_TYPE_BIN = 5130562;
function equalArray(array1, array2) {
  return array1.length === array2.length && array1.every(function(element, index) {
    return element === array2[index];
  });
}
function stringToArrayBuffer(text) {
  return new TextEncoder().encode(text).buffer;
}
function isIdentityMatrix(matrix3) {
  return equalArray(matrix3.elements, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
}
function getMinMax(attribute, start, count) {
  const output = {
    min: new Array(attribute.itemSize).fill(Number.POSITIVE_INFINITY),
    max: new Array(attribute.itemSize).fill(Number.NEGATIVE_INFINITY)
  };
  for (let i3 = start; i3 < start + count; i3++) {
    for (let a4 = 0; a4 < attribute.itemSize; a4++) {
      let value;
      if (attribute.itemSize > 4) {
        value = attribute.array[i3 * attribute.itemSize + a4];
      } else {
        if (a4 === 0)
          value = attribute.getX(i3);
        else if (a4 === 1)
          value = attribute.getY(i3);
        else if (a4 === 2)
          value = attribute.getZ(i3);
        else if (a4 === 3)
          value = attribute.getW(i3);
        if (attribute.normalized === true) {
          value = MathUtils.normalize(value, attribute.array);
        }
      }
      output.min[a4] = Math.min(output.min[a4], value);
      output.max[a4] = Math.max(output.max[a4], value);
    }
  }
  return output;
}
function getPaddedBufferSize(bufferSize) {
  return Math.ceil(bufferSize / 4) * 4;
}
function getPaddedArrayBuffer(arrayBuffer, paddingByte = 0) {
  const paddedLength = getPaddedBufferSize(arrayBuffer.byteLength);
  if (paddedLength !== arrayBuffer.byteLength) {
    const array = new Uint8Array(paddedLength);
    array.set(new Uint8Array(arrayBuffer));
    if (paddingByte !== 0) {
      for (let i3 = arrayBuffer.byteLength; i3 < paddedLength; i3++) {
        array[i3] = paddingByte;
      }
    }
    return array.buffer;
  }
  return arrayBuffer;
}
function getCanvas() {
  if (typeof document === "undefined" && typeof OffscreenCanvas !== "undefined") {
    return new OffscreenCanvas(1, 1);
  }
  return document.createElement("canvas");
}
function getToBlobPromise(canvas, mimeType) {
  if (canvas.toBlob !== void 0) {
    return new Promise((resolve) => canvas.toBlob(resolve, mimeType));
  }
  let quality;
  if (mimeType === "image/jpeg") {
    quality = 0.92;
  } else if (mimeType === "image/webp") {
    quality = 0.8;
  }
  return canvas.convertToBlob({
    type: mimeType,
    quality
  });
}
var GLTFWriter = class {
  constructor() {
    this.plugins = [];
    this.options = {};
    this.pending = [];
    this.buffers = [];
    this.byteOffset = 0;
    this.buffers = [];
    this.nodeMap = /* @__PURE__ */ new Map();
    this.skins = [];
    this.extensionsUsed = {};
    this.extensionsRequired = {};
    this.uids = /* @__PURE__ */ new Map();
    this.uid = 0;
    this.json = {
      asset: {
        version: "2.0",
        generator: "THREE.GLTFExporter"
      }
    };
    this.cache = {
      meshes: /* @__PURE__ */ new Map(),
      attributes: /* @__PURE__ */ new Map(),
      attributesNormalized: /* @__PURE__ */ new Map(),
      materials: /* @__PURE__ */ new Map(),
      textures: /* @__PURE__ */ new Map(),
      images: /* @__PURE__ */ new Map()
    };
  }
  setPlugins(plugins) {
    this.plugins = plugins;
  }
  /**
   * Parse scenes and generate GLTF output
   * @param  {Scene or [THREE.Scenes]} input   Scene or Array of THREE.Scenes
   * @param  {Function} onDone  Callback on completed
   * @param  {Object} options options
   */
  async write(input, onDone, options = {}) {
    this.options = Object.assign(
      {
        // default options
        binary: false,
        trs: false,
        onlyVisible: true,
        maxTextureSize: Infinity,
        animations: [],
        includeCustomExtensions: false
      },
      options
    );
    if (this.options.animations.length > 0) {
      this.options.trs = true;
    }
    this.processInput(input);
    await Promise.all(this.pending);
    const writer = this;
    const buffers = writer.buffers;
    const json = writer.json;
    options = writer.options;
    const extensionsUsed = writer.extensionsUsed;
    const extensionsRequired = writer.extensionsRequired;
    const blob = new Blob(buffers, { type: "application/octet-stream" });
    const extensionsUsedList = Object.keys(extensionsUsed);
    const extensionsRequiredList = Object.keys(extensionsRequired);
    if (extensionsUsedList.length > 0)
      json.extensionsUsed = extensionsUsedList;
    if (extensionsRequiredList.length > 0)
      json.extensionsRequired = extensionsRequiredList;
    if (json.buffers && json.buffers.length > 0)
      json.buffers[0].byteLength = blob.size;
    if (options.binary === true) {
      const reader = new FileReader();
      reader.readAsArrayBuffer(blob);
      reader.onloadend = function() {
        const binaryChunk = getPaddedArrayBuffer(reader.result);
        const binaryChunkPrefix = new DataView(new ArrayBuffer(GLB_CHUNK_PREFIX_BYTES));
        binaryChunkPrefix.setUint32(0, binaryChunk.byteLength, true);
        binaryChunkPrefix.setUint32(4, GLB_CHUNK_TYPE_BIN, true);
        const jsonChunk = getPaddedArrayBuffer(stringToArrayBuffer(JSON.stringify(json)), 32);
        const jsonChunkPrefix = new DataView(new ArrayBuffer(GLB_CHUNK_PREFIX_BYTES));
        jsonChunkPrefix.setUint32(0, jsonChunk.byteLength, true);
        jsonChunkPrefix.setUint32(4, GLB_CHUNK_TYPE_JSON, true);
        const header = new ArrayBuffer(GLB_HEADER_BYTES);
        const headerView = new DataView(header);
        headerView.setUint32(0, GLB_HEADER_MAGIC, true);
        headerView.setUint32(4, GLB_VERSION, true);
        const totalByteLength = GLB_HEADER_BYTES + jsonChunkPrefix.byteLength + jsonChunk.byteLength + binaryChunkPrefix.byteLength + binaryChunk.byteLength;
        headerView.setUint32(8, totalByteLength, true);
        const glbBlob = new Blob([header, jsonChunkPrefix, jsonChunk, binaryChunkPrefix, binaryChunk], {
          type: "application/octet-stream"
        });
        const glbReader = new FileReader();
        glbReader.readAsArrayBuffer(glbBlob);
        glbReader.onloadend = function() {
          onDone(glbReader.result);
        };
      };
    } else {
      if (json.buffers && json.buffers.length > 0) {
        const reader = new FileReader();
        reader.readAsDataURL(blob);
        reader.onloadend = function() {
          const base64data = reader.result;
          json.buffers[0].uri = base64data;
          onDone(json);
        };
      } else {
        onDone(json);
      }
    }
  }
  /**
   * Serializes a userData.
   *
   * @param {THREE.Object3D|THREE.Material} object
   * @param {Object} objectDef
   */
  serializeUserData(object, objectDef) {
    if (Object.keys(object.userData).length === 0)
      return;
    const options = this.options;
    const extensionsUsed = this.extensionsUsed;
    try {
      const json = JSON.parse(JSON.stringify(object.userData));
      if (options.includeCustomExtensions && json.gltfExtensions) {
        if (objectDef.extensions === void 0)
          objectDef.extensions = {};
        for (const extensionName in json.gltfExtensions) {
          objectDef.extensions[extensionName] = json.gltfExtensions[extensionName];
          extensionsUsed[extensionName] = true;
        }
        delete json.gltfExtensions;
      }
      if (Object.keys(json).length > 0)
        objectDef.extras = json;
    } catch (error) {
      console.warn(
        "THREE.GLTFExporter: userData of '" + object.name + "' won't be serialized because of JSON.stringify error - " + error.message
      );
    }
  }
  /**
   * Returns ids for buffer attributes.
   * @param  {Object} object
   * @return {Integer}
   */
  getUID(attribute, isRelativeCopy = false) {
    if (this.uids.has(attribute) === false) {
      const uids2 = /* @__PURE__ */ new Map();
      uids2.set(true, this.uid++);
      uids2.set(false, this.uid++);
      this.uids.set(attribute, uids2);
    }
    const uids = this.uids.get(attribute);
    return uids.get(isRelativeCopy);
  }
  /**
   * Checks if normal attribute values are normalized.
   *
   * @param {BufferAttribute} normal
   * @returns {Boolean}
   */
  isNormalizedNormalAttribute(normal) {
    const cache = this.cache;
    if (cache.attributesNormalized.has(normal))
      return false;
    const v = new Vector3();
    for (let i3 = 0, il = normal.count; i3 < il; i3++) {
      if (Math.abs(v.fromBufferAttribute(normal, i3).length() - 1) > 5e-4)
        return false;
    }
    return true;
  }
  /**
   * Creates normalized normal buffer attribute.
   *
   * @param {BufferAttribute} normal
   * @returns {BufferAttribute}
   *
   */
  createNormalizedNormalAttribute(normal) {
    const cache = this.cache;
    if (cache.attributesNormalized.has(normal))
      return cache.attributesNormalized.get(normal);
    const attribute = normal.clone();
    const v = new Vector3();
    for (let i3 = 0, il = attribute.count; i3 < il; i3++) {
      v.fromBufferAttribute(attribute, i3);
      if (v.x === 0 && v.y === 0 && v.z === 0) {
        v.setX(1);
      } else {
        v.normalize();
      }
      attribute.setXYZ(i3, v.x, v.y, v.z);
    }
    cache.attributesNormalized.set(normal, attribute);
    return attribute;
  }
  /**
   * Applies a texture transform, if present, to the map definition. Requires
   * the KHR_texture_transform extension.
   *
   * @param {Object} mapDef
   * @param {THREE.Texture} texture
   */
  applyTextureTransform(mapDef, texture) {
    let didTransform = false;
    const transformDef = {};
    if (texture.offset.x !== 0 || texture.offset.y !== 0) {
      transformDef.offset = texture.offset.toArray();
      didTransform = true;
    }
    if (texture.rotation !== 0) {
      transformDef.rotation = texture.rotation;
      didTransform = true;
    }
    if (texture.repeat.x !== 1 || texture.repeat.y !== 1) {
      transformDef.scale = texture.repeat.toArray();
      didTransform = true;
    }
    if (didTransform) {
      mapDef.extensions = mapDef.extensions || {};
      mapDef.extensions["KHR_texture_transform"] = transformDef;
      this.extensionsUsed["KHR_texture_transform"] = true;
    }
  }
  buildMetalRoughTexture(metalnessMap, roughnessMap) {
    if (metalnessMap === roughnessMap)
      return metalnessMap;
    function getEncodingConversion(map2) {
      if ("colorSpace" in map2 ? map2.colorSpace === "srgb" : map2.encoding === 3001) {
        return function SRGBToLinear(c3) {
          return c3 < 0.04045 ? c3 * 0.0773993808 : Math.pow(c3 * 0.9478672986 + 0.0521327014, 2.4);
        };
      }
      return function LinearToLinear(c3) {
        return c3;
      };
    }
    console.warn("THREE.GLTFExporter: Merged metalnessMap and roughnessMap textures.");
    if (metalnessMap instanceof CompressedTexture) {
      metalnessMap = decompress(metalnessMap);
    }
    if (roughnessMap instanceof CompressedTexture) {
      roughnessMap = decompress(roughnessMap);
    }
    const metalness = metalnessMap ? metalnessMap.image : null;
    const roughness = roughnessMap ? roughnessMap.image : null;
    const width = Math.max(metalness ? metalness.width : 0, roughness ? roughness.width : 0);
    const height = Math.max(metalness ? metalness.height : 0, roughness ? roughness.height : 0);
    const canvas = getCanvas();
    canvas.width = width;
    canvas.height = height;
    const context3 = canvas.getContext("2d");
    context3.fillStyle = "#00ffff";
    context3.fillRect(0, 0, width, height);
    const composite = context3.getImageData(0, 0, width, height);
    if (metalness) {
      context3.drawImage(metalness, 0, 0, width, height);
      const convert = getEncodingConversion(metalnessMap);
      const data = context3.getImageData(0, 0, width, height).data;
      for (let i3 = 2; i3 < data.length; i3 += 4) {
        composite.data[i3] = convert(data[i3] / 256) * 256;
      }
    }
    if (roughness) {
      context3.drawImage(roughness, 0, 0, width, height);
      const convert = getEncodingConversion(roughnessMap);
      const data = context3.getImageData(0, 0, width, height).data;
      for (let i3 = 1; i3 < data.length; i3 += 4) {
        composite.data[i3] = convert(data[i3] / 256) * 256;
      }
    }
    context3.putImageData(composite, 0, 0);
    const reference = metalnessMap || roughnessMap;
    const texture = reference.clone();
    texture.source = new Texture(canvas).source;
    if ("colorSpace" in texture)
      texture.colorSpace = "";
    else
      texture.encoding = 3e3;
    texture.channel = (metalnessMap || roughnessMap).channel;
    if (metalnessMap && roughnessMap && metalnessMap.channel !== roughnessMap.channel) {
      console.warn("THREE.GLTFExporter: UV channels for metalnessMap and roughnessMap textures must match.");
    }
    return texture;
  }
  /**
   * Process a buffer to append to the default one.
   * @param  {ArrayBuffer} buffer
   * @return {Integer}
   */
  processBuffer(buffer) {
    const json = this.json;
    const buffers = this.buffers;
    if (!json.buffers)
      json.buffers = [{ byteLength: 0 }];
    buffers.push(buffer);
    return 0;
  }
  /**
   * Process and generate a BufferView
   * @param  {BufferAttribute} attribute
   * @param  {number} componentType
   * @param  {number} start
   * @param  {number} count
   * @param  {number} target (Optional) Target usage of the BufferView
   * @return {Object}
   */
  processBufferView(attribute, componentType, start, count, target) {
    const json = this.json;
    if (!json.bufferViews)
      json.bufferViews = [];
    let componentSize;
    switch (componentType) {
      case WEBGL_CONSTANTS.BYTE:
      case WEBGL_CONSTANTS.UNSIGNED_BYTE:
        componentSize = 1;
        break;
      case WEBGL_CONSTANTS.SHORT:
      case WEBGL_CONSTANTS.UNSIGNED_SHORT:
        componentSize = 2;
        break;
      default:
        componentSize = 4;
    }
    const byteLength = getPaddedBufferSize(count * attribute.itemSize * componentSize);
    const dataView = new DataView(new ArrayBuffer(byteLength));
    let offset = 0;
    for (let i3 = start; i3 < start + count; i3++) {
      for (let a4 = 0; a4 < attribute.itemSize; a4++) {
        let value;
        if (attribute.itemSize > 4) {
          value = attribute.array[i3 * attribute.itemSize + a4];
        } else {
          if (a4 === 0)
            value = attribute.getX(i3);
          else if (a4 === 1)
            value = attribute.getY(i3);
          else if (a4 === 2)
            value = attribute.getZ(i3);
          else if (a4 === 3)
            value = attribute.getW(i3);
          if (attribute.normalized === true) {
            value = MathUtils.normalize(value, attribute.array);
          }
        }
        if (componentType === WEBGL_CONSTANTS.FLOAT) {
          dataView.setFloat32(offset, value, true);
        } else if (componentType === WEBGL_CONSTANTS.INT) {
          dataView.setInt32(offset, value, true);
        } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_INT) {
          dataView.setUint32(offset, value, true);
        } else if (componentType === WEBGL_CONSTANTS.SHORT) {
          dataView.setInt16(offset, value, true);
        } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_SHORT) {
          dataView.setUint16(offset, value, true);
        } else if (componentType === WEBGL_CONSTANTS.BYTE) {
          dataView.setInt8(offset, value);
        } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_BYTE) {
          dataView.setUint8(offset, value);
        }
        offset += componentSize;
      }
    }
    const bufferViewDef = {
      buffer: this.processBuffer(dataView.buffer),
      byteOffset: this.byteOffset,
      byteLength
    };
    if (target !== void 0)
      bufferViewDef.target = target;
    if (target === WEBGL_CONSTANTS.ARRAY_BUFFER) {
      bufferViewDef.byteStride = attribute.itemSize * componentSize;
    }
    this.byteOffset += byteLength;
    json.bufferViews.push(bufferViewDef);
    const output = {
      id: json.bufferViews.length - 1,
      byteLength: 0
    };
    return output;
  }
  /**
   * Process and generate a BufferView from an image Blob.
   * @param {Blob} blob
   * @return {Promise<Integer>}
   */
  processBufferViewImage(blob) {
    const writer = this;
    const json = writer.json;
    if (!json.bufferViews)
      json.bufferViews = [];
    return new Promise(function(resolve) {
      const reader = new FileReader();
      reader.readAsArrayBuffer(blob);
      reader.onloadend = function() {
        const buffer = getPaddedArrayBuffer(reader.result);
        const bufferViewDef = {
          buffer: writer.processBuffer(buffer),
          byteOffset: writer.byteOffset,
          byteLength: buffer.byteLength
        };
        writer.byteOffset += buffer.byteLength;
        resolve(json.bufferViews.push(bufferViewDef) - 1);
      };
    });
  }
  /**
   * Process attribute to generate an accessor
   * @param  {BufferAttribute} attribute Attribute to process
   * @param  {THREE.BufferGeometry} geometry (Optional) Geometry used for truncated draw range
   * @param  {Integer} start (Optional)
   * @param  {Integer} count (Optional)
   * @return {Integer|null} Index of the processed accessor on the "accessors" array
   */
  processAccessor(attribute, geometry2, start, count) {
    const json = this.json;
    const types = {
      1: "SCALAR",
      2: "VEC2",
      3: "VEC3",
      4: "VEC4",
      9: "MAT3",
      16: "MAT4"
    };
    let componentType;
    if (attribute.array.constructor === Float32Array) {
      componentType = WEBGL_CONSTANTS.FLOAT;
    } else if (attribute.array.constructor === Int32Array) {
      componentType = WEBGL_CONSTANTS.INT;
    } else if (attribute.array.constructor === Uint32Array) {
      componentType = WEBGL_CONSTANTS.UNSIGNED_INT;
    } else if (attribute.array.constructor === Int16Array) {
      componentType = WEBGL_CONSTANTS.SHORT;
    } else if (attribute.array.constructor === Uint16Array) {
      componentType = WEBGL_CONSTANTS.UNSIGNED_SHORT;
    } else if (attribute.array.constructor === Int8Array) {
      componentType = WEBGL_CONSTANTS.BYTE;
    } else if (attribute.array.constructor === Uint8Array) {
      componentType = WEBGL_CONSTANTS.UNSIGNED_BYTE;
    } else {
      throw new Error(
        "THREE.GLTFExporter: Unsupported bufferAttribute component type: " + attribute.array.constructor.name
      );
    }
    if (start === void 0)
      start = 0;
    if (count === void 0)
      count = attribute.count;
    if (count === 0)
      return null;
    const minMax = getMinMax(attribute, start, count);
    let bufferViewTarget;
    if (geometry2 !== void 0) {
      bufferViewTarget = attribute === geometry2.index ? WEBGL_CONSTANTS.ELEMENT_ARRAY_BUFFER : WEBGL_CONSTANTS.ARRAY_BUFFER;
    }
    const bufferView = this.processBufferView(attribute, componentType, start, count, bufferViewTarget);
    const accessorDef = {
      bufferView: bufferView.id,
      byteOffset: bufferView.byteOffset,
      componentType,
      count,
      max: minMax.max,
      min: minMax.min,
      type: types[attribute.itemSize]
    };
    if (attribute.normalized === true)
      accessorDef.normalized = true;
    if (!json.accessors)
      json.accessors = [];
    return json.accessors.push(accessorDef) - 1;
  }
  /**
   * Process image
   * @param  {Image} image to process
   * @param  {Integer} format of the image (RGBAFormat)
   * @param  {Boolean} flipY before writing out the image
   * @param  {String} mimeType export format
   * @return {Integer}     Index of the processed texture in the "images" array
   */
  processImage(image, format, flipY, mimeType = "image/png") {
    if (image !== null) {
      const writer = this;
      const cache = writer.cache;
      const json = writer.json;
      const options = writer.options;
      const pending = writer.pending;
      if (!cache.images.has(image))
        cache.images.set(image, {});
      const cachedImages = cache.images.get(image);
      const key = mimeType + ":flipY/" + flipY.toString();
      if (cachedImages[key] !== void 0)
        return cachedImages[key];
      if (!json.images)
        json.images = [];
      const imageDef = { mimeType };
      const canvas = getCanvas();
      canvas.width = Math.min(image.width, options.maxTextureSize);
      canvas.height = Math.min(image.height, options.maxTextureSize);
      const ctx = canvas.getContext("2d");
      if (flipY === true) {
        ctx.translate(0, canvas.height);
        ctx.scale(1, -1);
      }
      if (image.data !== void 0) {
        if (format !== RGBAFormat) {
          console.error("GLTFExporter: Only RGBAFormat is supported.", format);
        }
        if (image.width > options.maxTextureSize || image.height > options.maxTextureSize) {
          console.warn("GLTFExporter: Image size is bigger than maxTextureSize", image);
        }
        const data = new Uint8ClampedArray(image.height * image.width * 4);
        for (let i3 = 0; i3 < data.length; i3 += 4) {
          data[i3 + 0] = image.data[i3 + 0];
          data[i3 + 1] = image.data[i3 + 1];
          data[i3 + 2] = image.data[i3 + 2];
          data[i3 + 3] = image.data[i3 + 3];
        }
        ctx.putImageData(new ImageData(data, image.width, image.height), 0, 0);
      } else {
        ctx.drawImage(image, 0, 0, canvas.width, canvas.height);
      }
      if (options.binary === true) {
        pending.push(
          getToBlobPromise(canvas, mimeType).then((blob) => writer.processBufferViewImage(blob)).then((bufferViewIndex) => {
            imageDef.bufferView = bufferViewIndex;
          })
        );
      } else {
        if (canvas.toDataURL !== void 0) {
          imageDef.uri = canvas.toDataURL(mimeType);
        } else {
          pending.push(
            getToBlobPromise(canvas, mimeType).then((blob) => new FileReader().readAsDataURL(blob)).then((dataURL) => {
              imageDef.uri = dataURL;
            })
          );
        }
      }
      const index = json.images.push(imageDef) - 1;
      cachedImages[key] = index;
      return index;
    } else {
      throw new Error("THREE.GLTFExporter: No valid image data found. Unable to process texture.");
    }
  }
  /**
   * Process sampler
   * @param  {Texture} map Texture to process
   * @return {Integer}     Index of the processed texture in the "samplers" array
   */
  processSampler(map2) {
    const json = this.json;
    if (!json.samplers)
      json.samplers = [];
    const samplerDef = {
      magFilter: THREE_TO_WEBGL[map2.magFilter],
      minFilter: THREE_TO_WEBGL[map2.minFilter],
      wrapS: THREE_TO_WEBGL[map2.wrapS],
      wrapT: THREE_TO_WEBGL[map2.wrapT]
    };
    return json.samplers.push(samplerDef) - 1;
  }
  /**
   * Process texture
   * @param  {Texture} map Map to process
   * @return {Integer} Index of the processed texture in the "textures" array
   */
  processTexture(map2) {
    const writer = this;
    const options = writer.options;
    const cache = this.cache;
    const json = this.json;
    if (cache.textures.has(map2))
      return cache.textures.get(map2);
    if (!json.textures)
      json.textures = [];
    if (map2 instanceof CompressedTexture) {
      map2 = decompress(map2, options.maxTextureSize);
    }
    let mimeType = map2.userData.mimeType;
    if (mimeType === "image/webp")
      mimeType = "image/png";
    const textureDef = {
      sampler: this.processSampler(map2),
      source: this.processImage(map2.image, map2.format, map2.flipY, mimeType)
    };
    if (map2.name)
      textureDef.name = map2.name;
    this._invokeAll(function(ext) {
      ext.writeTexture && ext.writeTexture(map2, textureDef);
    });
    const index = json.textures.push(textureDef) - 1;
    cache.textures.set(map2, index);
    return index;
  }
  /**
   * Process material
   * @param  {THREE.Material} material Material to process
   * @return {Integer|null} Index of the processed material in the "materials" array
   */
  processMaterial(material2) {
    const cache = this.cache;
    const json = this.json;
    if (cache.materials.has(material2))
      return cache.materials.get(material2);
    if (material2.isShaderMaterial) {
      console.warn("GLTFExporter: THREE.ShaderMaterial not supported.");
      return null;
    }
    if (!json.materials)
      json.materials = [];
    const materialDef = { pbrMetallicRoughness: {} };
    if (material2.isMeshStandardMaterial !== true && material2.isMeshBasicMaterial !== true) {
      console.warn("GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.");
    }
    const color = material2.color.toArray().concat([material2.opacity]);
    if (!equalArray(color, [1, 1, 1, 1])) {
      materialDef.pbrMetallicRoughness.baseColorFactor = color;
    }
    if (material2.isMeshStandardMaterial) {
      materialDef.pbrMetallicRoughness.metallicFactor = material2.metalness;
      materialDef.pbrMetallicRoughness.roughnessFactor = material2.roughness;
    } else {
      materialDef.pbrMetallicRoughness.metallicFactor = 0.5;
      materialDef.pbrMetallicRoughness.roughnessFactor = 0.5;
    }
    if (material2.metalnessMap || material2.roughnessMap) {
      const metalRoughTexture = this.buildMetalRoughTexture(material2.metalnessMap, material2.roughnessMap);
      const metalRoughMapDef = {
        index: this.processTexture(metalRoughTexture),
        channel: metalRoughTexture.channel
      };
      this.applyTextureTransform(metalRoughMapDef, metalRoughTexture);
      materialDef.pbrMetallicRoughness.metallicRoughnessTexture = metalRoughMapDef;
    }
    if (material2.map) {
      const baseColorMapDef = {
        index: this.processTexture(material2.map),
        texCoord: material2.map.channel
      };
      this.applyTextureTransform(baseColorMapDef, material2.map);
      materialDef.pbrMetallicRoughness.baseColorTexture = baseColorMapDef;
    }
    if (material2.emissive) {
      const emissive = material2.emissive;
      const maxEmissiveComponent = Math.max(emissive.r, emissive.g, emissive.b);
      if (maxEmissiveComponent > 0) {
        materialDef.emissiveFactor = material2.emissive.toArray();
      }
      if (material2.emissiveMap) {
        const emissiveMapDef = {
          index: this.processTexture(material2.emissiveMap),
          texCoord: material2.emissiveMap.channel
        };
        this.applyTextureTransform(emissiveMapDef, material2.emissiveMap);
        materialDef.emissiveTexture = emissiveMapDef;
      }
    }
    if (material2.normalMap) {
      const normalMapDef = {
        index: this.processTexture(material2.normalMap),
        texCoord: material2.normalMap.channel
      };
      if (material2.normalScale && material2.normalScale.x !== 1) {
        normalMapDef.scale = material2.normalScale.x;
      }
      this.applyTextureTransform(normalMapDef, material2.normalMap);
      materialDef.normalTexture = normalMapDef;
    }
    if (material2.aoMap) {
      const occlusionMapDef = {
        index: this.processTexture(material2.aoMap),
        texCoord: material2.aoMap.channel
      };
      if (material2.aoMapIntensity !== 1) {
        occlusionMapDef.strength = material2.aoMapIntensity;
      }
      this.applyTextureTransform(occlusionMapDef, material2.aoMap);
      materialDef.occlusionTexture = occlusionMapDef;
    }
    if (material2.transparent) {
      materialDef.alphaMode = "BLEND";
    } else {
      if (material2.alphaTest > 0) {
        materialDef.alphaMode = "MASK";
        materialDef.alphaCutoff = material2.alphaTest;
      }
    }
    if (material2.side === DoubleSide)
      materialDef.doubleSided = true;
    if (material2.name !== "")
      materialDef.name = material2.name;
    this.serializeUserData(material2, materialDef);
    this._invokeAll(function(ext) {
      ext.writeMaterial && ext.writeMaterial(material2, materialDef);
    });
    const index = json.materials.push(materialDef) - 1;
    cache.materials.set(material2, index);
    return index;
  }
  /**
   * Process mesh
   * @param  {THREE.Mesh} mesh Mesh to process
   * @return {Integer|null} Index of the processed mesh in the "meshes" array
   */
  processMesh(mesh) {
    const cache = this.cache;
    const json = this.json;
    const meshCacheKeyParts = [mesh.geometry.uuid];
    if (Array.isArray(mesh.material)) {
      for (let i3 = 0, l = mesh.material.length; i3 < l; i3++) {
        meshCacheKeyParts.push(mesh.material[i3].uuid);
      }
    } else {
      meshCacheKeyParts.push(mesh.material.uuid);
    }
    const meshCacheKey = meshCacheKeyParts.join(":");
    if (cache.meshes.has(meshCacheKey))
      return cache.meshes.get(meshCacheKey);
    const geometry2 = mesh.geometry;
    let mode;
    if (mesh.isLineSegments) {
      mode = WEBGL_CONSTANTS.LINES;
    } else if (mesh.isLineLoop) {
      mode = WEBGL_CONSTANTS.LINE_LOOP;
    } else if (mesh.isLine) {
      mode = WEBGL_CONSTANTS.LINE_STRIP;
    } else if (mesh.isPoints) {
      mode = WEBGL_CONSTANTS.POINTS;
    } else {
      mode = mesh.material.wireframe ? WEBGL_CONSTANTS.LINES : WEBGL_CONSTANTS.TRIANGLES;
    }
    const meshDef = {};
    const attributes = {};
    const primitives = [];
    const targets = [];
    const nameConversion = {
      uv: "TEXCOORD_0",
      [REVISION.replace(/\D+/g, "") >= 152 ? "uv1" : "uv2"]: "TEXCOORD_1",
      color: "COLOR_0",
      skinWeight: "WEIGHTS_0",
      skinIndex: "JOINTS_0"
    };
    const originalNormal = geometry2.getAttribute("normal");
    if (originalNormal !== void 0 && !this.isNormalizedNormalAttribute(originalNormal)) {
      console.warn("THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one.");
      geometry2.setAttribute("normal", this.createNormalizedNormalAttribute(originalNormal));
    }
    let modifiedAttribute = null;
    for (let attributeName in geometry2.attributes) {
      if (attributeName.slice(0, 5) === "morph")
        continue;
      const attribute = geometry2.attributes[attributeName];
      attributeName = nameConversion[attributeName] || attributeName.toUpperCase();
      const validVertexAttributes = /^(POSITION|NORMAL|TANGENT|TEXCOORD_\d+|COLOR_\d+|JOINTS_\d+|WEIGHTS_\d+)$/;
      if (!validVertexAttributes.test(attributeName))
        attributeName = "_" + attributeName;
      if (cache.attributes.has(this.getUID(attribute))) {
        attributes[attributeName] = cache.attributes.get(this.getUID(attribute));
        continue;
      }
      modifiedAttribute = null;
      const array = attribute.array;
      if (attributeName === "JOINTS_0" && !(array instanceof Uint16Array) && !(array instanceof Uint8Array)) {
        console.warn('GLTFExporter: Attribute "skinIndex" converted to type UNSIGNED_SHORT.');
        modifiedAttribute = new BufferAttribute(new Uint16Array(array), attribute.itemSize, attribute.normalized);
      }
      const accessor = this.processAccessor(modifiedAttribute || attribute, geometry2);
      if (accessor !== null) {
        if (!attributeName.startsWith("_")) {
          this.detectMeshQuantization(attributeName, attribute);
        }
        attributes[attributeName] = accessor;
        cache.attributes.set(this.getUID(attribute), accessor);
      }
    }
    if (originalNormal !== void 0)
      geometry2.setAttribute("normal", originalNormal);
    if (Object.keys(attributes).length === 0)
      return null;
    if (mesh.morphTargetInfluences !== void 0 && mesh.morphTargetInfluences.length > 0) {
      const weights = [];
      const targetNames = [];
      const reverseDictionary = {};
      if (mesh.morphTargetDictionary !== void 0) {
        for (const key in mesh.morphTargetDictionary) {
          reverseDictionary[mesh.morphTargetDictionary[key]] = key;
        }
      }
      for (let i3 = 0; i3 < mesh.morphTargetInfluences.length; ++i3) {
        const target = {};
        let warned2 = false;
        for (const attributeName in geometry2.morphAttributes) {
          if (attributeName !== "position" && attributeName !== "normal") {
            if (!warned2) {
              console.warn("GLTFExporter: Only POSITION and NORMAL morph are supported.");
              warned2 = true;
            }
            continue;
          }
          const attribute = geometry2.morphAttributes[attributeName][i3];
          const gltfAttributeName = attributeName.toUpperCase();
          const baseAttribute = geometry2.attributes[attributeName];
          if (cache.attributes.has(this.getUID(attribute, true))) {
            target[gltfAttributeName] = cache.attributes.get(this.getUID(attribute, true));
            continue;
          }
          const relativeAttribute = attribute.clone();
          if (!geometry2.morphTargetsRelative) {
            for (let j = 0, jl = attribute.count; j < jl; j++) {
              for (let a4 = 0; a4 < attribute.itemSize; a4++) {
                if (a4 === 0)
                  relativeAttribute.setX(j, attribute.getX(j) - baseAttribute.getX(j));
                if (a4 === 1)
                  relativeAttribute.setY(j, attribute.getY(j) - baseAttribute.getY(j));
                if (a4 === 2)
                  relativeAttribute.setZ(j, attribute.getZ(j) - baseAttribute.getZ(j));
                if (a4 === 3)
                  relativeAttribute.setW(j, attribute.getW(j) - baseAttribute.getW(j));
              }
            }
          }
          target[gltfAttributeName] = this.processAccessor(relativeAttribute, geometry2);
          cache.attributes.set(this.getUID(baseAttribute, true), target[gltfAttributeName]);
        }
        targets.push(target);
        weights.push(mesh.morphTargetInfluences[i3]);
        if (mesh.morphTargetDictionary !== void 0)
          targetNames.push(reverseDictionary[i3]);
      }
      meshDef.weights = weights;
      if (targetNames.length > 0) {
        meshDef.extras = {};
        meshDef.extras.targetNames = targetNames;
      }
    }
    const isMultiMaterial = Array.isArray(mesh.material);
    if (isMultiMaterial && geometry2.groups.length === 0)
      return null;
    const materials = isMultiMaterial ? mesh.material : [mesh.material];
    const groups = isMultiMaterial ? geometry2.groups : [{ materialIndex: 0, start: void 0, count: void 0 }];
    for (let i3 = 0, il = groups.length; i3 < il; i3++) {
      const primitive = {
        mode,
        attributes
      };
      this.serializeUserData(geometry2, primitive);
      if (targets.length > 0)
        primitive.targets = targets;
      if (geometry2.index !== null) {
        let cacheKey = this.getUID(geometry2.index);
        if (groups[i3].start !== void 0 || groups[i3].count !== void 0) {
          cacheKey += ":" + groups[i3].start + ":" + groups[i3].count;
        }
        if (cache.attributes.has(cacheKey)) {
          primitive.indices = cache.attributes.get(cacheKey);
        } else {
          primitive.indices = this.processAccessor(geometry2.index, geometry2, groups[i3].start, groups[i3].count);
          cache.attributes.set(cacheKey, primitive.indices);
        }
        if (primitive.indices === null)
          delete primitive.indices;
      }
      const material2 = this.processMaterial(materials[groups[i3].materialIndex]);
      if (material2 !== null)
        primitive.material = material2;
      primitives.push(primitive);
    }
    meshDef.primitives = primitives;
    if (!json.meshes)
      json.meshes = [];
    this._invokeAll(function(ext) {
      ext.writeMesh && ext.writeMesh(mesh, meshDef);
    });
    const index = json.meshes.push(meshDef) - 1;
    cache.meshes.set(meshCacheKey, index);
    return index;
  }
  /**
   * If a vertex attribute with a
   * [non-standard data type](https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#meshes-overview)
   * is used, it is checked whether it is a valid data type according to the
   * [KHR_mesh_quantization](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_mesh_quantization/README.md)
   * extension.
   * In this case the extension is automatically added to the list of used extensions.
   *
   * @param {string} attributeName
   * @param {THREE.BufferAttribute} attribute
   */
  detectMeshQuantization(attributeName, attribute) {
    if (this.extensionsUsed[KHR_MESH_QUANTIZATION])
      return;
    let attrType = void 0;
    switch (attribute.array.constructor) {
      case Int8Array:
        attrType = "byte";
        break;
      case Uint8Array:
        attrType = "unsigned byte";
        break;
      case Int16Array:
        attrType = "short";
        break;
      case Uint16Array:
        attrType = "unsigned short";
        break;
      default:
        return;
    }
    if (attribute.normalized)
      attrType += " normalized";
    const attrNamePrefix = attributeName.split("_", 1)[0];
    if (KHR_mesh_quantization_ExtraAttrTypes[attrNamePrefix] && KHR_mesh_quantization_ExtraAttrTypes[attrNamePrefix].includes(attrType)) {
      this.extensionsUsed[KHR_MESH_QUANTIZATION] = true;
      this.extensionsRequired[KHR_MESH_QUANTIZATION] = true;
    }
  }
  /**
   * Process camera
   * @param  {THREE.Camera} camera Camera to process
   * @return {Integer}      Index of the processed mesh in the "camera" array
   */
  processCamera(camera) {
    const json = this.json;
    if (!json.cameras)
      json.cameras = [];
    const isOrtho = camera.isOrthographicCamera;
    const cameraDef = {
      type: isOrtho ? "orthographic" : "perspective"
    };
    if (isOrtho) {
      cameraDef.orthographic = {
        xmag: camera.right * 2,
        ymag: camera.top * 2,
        zfar: camera.far <= 0 ? 1e-3 : camera.far,
        znear: camera.near < 0 ? 0 : camera.near
      };
    } else {
      cameraDef.perspective = {
        aspectRatio: camera.aspect,
        yfov: MathUtils.degToRad(camera.fov),
        zfar: camera.far <= 0 ? 1e-3 : camera.far,
        znear: camera.near < 0 ? 0 : camera.near
      };
    }
    if (camera.name !== "")
      cameraDef.name = camera.type;
    return json.cameras.push(cameraDef) - 1;
  }
  /**
   * Creates glTF animation entry from AnimationClip object.
   *
   * Status:
   * - Only properties listed in PATH_PROPERTIES may be animated.
   *
   * @param {THREE.AnimationClip} clip
   * @param {THREE.Object3D} root
   * @return {number|null}
   */
  processAnimation(clip, root) {
    const json = this.json;
    const nodeMap = this.nodeMap;
    if (!json.animations)
      json.animations = [];
    clip = GLTFExporter.Utils.mergeMorphTargetTracks(clip.clone(), root);
    const tracks = clip.tracks;
    const channels = [];
    const samplers = [];
    for (let i3 = 0; i3 < tracks.length; ++i3) {
      const track = tracks[i3];
      const trackBinding = PropertyBinding.parseTrackName(track.name);
      let trackNode = PropertyBinding.findNode(root, trackBinding.nodeName);
      const trackProperty = PATH_PROPERTIES[trackBinding.propertyName];
      if (trackBinding.objectName === "bones") {
        if (trackNode.isSkinnedMesh === true) {
          trackNode = trackNode.skeleton.getBoneByName(trackBinding.objectIndex);
        } else {
          trackNode = void 0;
        }
      }
      if (!trackNode || !trackProperty) {
        console.warn('THREE.GLTFExporter: Could not export animation track "%s".', track.name);
        return null;
      }
      const inputItemSize = 1;
      let outputItemSize = track.values.length / track.times.length;
      if (trackProperty === PATH_PROPERTIES.morphTargetInfluences) {
        outputItemSize /= trackNode.morphTargetInfluences.length;
      }
      let interpolation;
      if (track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline === true) {
        interpolation = "CUBICSPLINE";
        outputItemSize /= 3;
      } else if (track.getInterpolation() === InterpolateDiscrete) {
        interpolation = "STEP";
      } else {
        interpolation = "LINEAR";
      }
      samplers.push({
        input: this.processAccessor(new BufferAttribute(track.times, inputItemSize)),
        output: this.processAccessor(new BufferAttribute(track.values, outputItemSize)),
        interpolation
      });
      channels.push({
        sampler: samplers.length - 1,
        target: {
          node: nodeMap.get(trackNode),
          path: trackProperty
        }
      });
    }
    json.animations.push({
      name: clip.name || "clip_" + json.animations.length,
      samplers,
      channels
    });
    return json.animations.length - 1;
  }
  /**
   * @param {THREE.Object3D} object
   * @return {number|null}
   */
  processSkin(object) {
    const json = this.json;
    const nodeMap = this.nodeMap;
    const node = json.nodes[nodeMap.get(object)];
    const skeleton = object.skeleton;
    if (skeleton === void 0)
      return null;
    const rootJoint = object.skeleton.bones[0];
    if (rootJoint === void 0)
      return null;
    const joints = [];
    const inverseBindMatrices = new Float32Array(skeleton.bones.length * 16);
    const temporaryBoneInverse = new Matrix4();
    for (let i3 = 0; i3 < skeleton.bones.length; ++i3) {
      joints.push(nodeMap.get(skeleton.bones[i3]));
      temporaryBoneInverse.copy(skeleton.boneInverses[i3]);
      temporaryBoneInverse.multiply(object.bindMatrix).toArray(inverseBindMatrices, i3 * 16);
    }
    if (json.skins === void 0)
      json.skins = [];
    json.skins.push({
      inverseBindMatrices: this.processAccessor(new BufferAttribute(inverseBindMatrices, 16)),
      joints,
      skeleton: nodeMap.get(rootJoint)
    });
    const skinIndex = node.skin = json.skins.length - 1;
    return skinIndex;
  }
  /**
   * Process Object3D node
   * @param  {THREE.Object3D} node Object3D to processNode
   * @return {Integer} Index of the node in the nodes list
   */
  processNode(object) {
    const json = this.json;
    const options = this.options;
    const nodeMap = this.nodeMap;
    if (!json.nodes)
      json.nodes = [];
    const nodeDef = {};
    if (options.trs) {
      const rotation = object.quaternion.toArray();
      const position = object.position.toArray();
      const scale = object.scale.toArray();
      if (!equalArray(rotation, [0, 0, 0, 1])) {
        nodeDef.rotation = rotation;
      }
      if (!equalArray(position, [0, 0, 0])) {
        nodeDef.translation = position;
      }
      if (!equalArray(scale, [1, 1, 1])) {
        nodeDef.scale = scale;
      }
    } else {
      if (object.matrixAutoUpdate) {
        object.updateMatrix();
      }
      if (isIdentityMatrix(object.matrix) === false) {
        nodeDef.matrix = object.matrix.elements;
      }
    }
    if (object.name !== "")
      nodeDef.name = String(object.name);
    this.serializeUserData(object, nodeDef);
    if (object.isMesh || object.isLine || object.isPoints) {
      const meshIndex = this.processMesh(object);
      if (meshIndex !== null)
        nodeDef.mesh = meshIndex;
    } else if (object.isCamera) {
      nodeDef.camera = this.processCamera(object);
    }
    if (object.isSkinnedMesh)
      this.skins.push(object);
    if (object.children.length > 0) {
      const children = [];
      for (let i3 = 0, l = object.children.length; i3 < l; i3++) {
        const child = object.children[i3];
        if (child.visible || options.onlyVisible === false) {
          const nodeIndex2 = this.processNode(child);
          if (nodeIndex2 !== null)
            children.push(nodeIndex2);
        }
      }
      if (children.length > 0)
        nodeDef.children = children;
    }
    this._invokeAll(function(ext) {
      ext.writeNode && ext.writeNode(object, nodeDef);
    });
    const nodeIndex = json.nodes.push(nodeDef) - 1;
    nodeMap.set(object, nodeIndex);
    return nodeIndex;
  }
  /**
   * Process Scene
   * @param  {Scene} node Scene to process
   */
  processScene(scene) {
    const json = this.json;
    const options = this.options;
    if (!json.scenes) {
      json.scenes = [];
      json.scene = 0;
    }
    const sceneDef = {};
    if (scene.name !== "")
      sceneDef.name = scene.name;
    json.scenes.push(sceneDef);
    const nodes = [];
    for (let i3 = 0, l = scene.children.length; i3 < l; i3++) {
      const child = scene.children[i3];
      if (child.visible || options.onlyVisible === false) {
        const nodeIndex = this.processNode(child);
        if (nodeIndex !== null)
          nodes.push(nodeIndex);
      }
    }
    if (nodes.length > 0)
      sceneDef.nodes = nodes;
    this.serializeUserData(scene, sceneDef);
  }
  /**
   * Creates a Scene to hold a list of objects and parse it
   * @param  {Array} objects List of objects to process
   */
  processObjects(objects) {
    const scene = new Scene();
    scene.name = "AuxScene";
    for (let i3 = 0; i3 < objects.length; i3++) {
      scene.children.push(objects[i3]);
    }
    this.processScene(scene);
  }
  /**
   * @param {THREE.Object3D|Array<THREE.Object3D>} input
   */
  processInput(input) {
    const options = this.options;
    input = input instanceof Array ? input : [input];
    this._invokeAll(function(ext) {
      ext.beforeParse && ext.beforeParse(input);
    });
    const objectsWithoutScene = [];
    for (let i3 = 0; i3 < input.length; i3++) {
      if (input[i3] instanceof Scene) {
        this.processScene(input[i3]);
      } else {
        objectsWithoutScene.push(input[i3]);
      }
    }
    if (objectsWithoutScene.length > 0)
      this.processObjects(objectsWithoutScene);
    for (let i3 = 0; i3 < this.skins.length; ++i3) {
      this.processSkin(this.skins[i3]);
    }
    for (let i3 = 0; i3 < options.animations.length; ++i3) {
      this.processAnimation(options.animations[i3], input[0]);
    }
    this._invokeAll(function(ext) {
      ext.afterParse && ext.afterParse(input);
    });
  }
  _invokeAll(func) {
    for (let i3 = 0, il = this.plugins.length; i3 < il; i3++) {
      func(this.plugins[i3]);
    }
  }
};
var GLTFLightExtension = class {
  constructor(writer) {
    this.writer = writer;
    this.name = "KHR_lights_punctual";
  }
  writeNode(light, nodeDef) {
    if (!light.isLight)
      return;
    if (!light.isDirectionalLight && !light.isPointLight && !light.isSpotLight) {
      console.warn("THREE.GLTFExporter: Only directional, point, and spot lights are supported.", light);
      return;
    }
    const writer = this.writer;
    const json = writer.json;
    const extensionsUsed = writer.extensionsUsed;
    const lightDef = {};
    if (light.name)
      lightDef.name = light.name;
    lightDef.color = light.color.toArray();
    lightDef.intensity = light.intensity;
    if (light.isDirectionalLight) {
      lightDef.type = "directional";
    } else if (light.isPointLight) {
      lightDef.type = "point";
      if (light.distance > 0)
        lightDef.range = light.distance;
    } else if (light.isSpotLight) {
      lightDef.type = "spot";
      if (light.distance > 0)
        lightDef.range = light.distance;
      lightDef.spot = {};
      lightDef.spot.innerConeAngle = (light.penumbra - 1) * light.angle * -1;
      lightDef.spot.outerConeAngle = light.angle;
    }
    if (light.decay !== void 0 && light.decay !== 2) {
      console.warn(
        "THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, and expects light.decay=2."
      );
    }
    if (light.target && (light.target.parent !== light || light.target.position.x !== 0 || light.target.position.y !== 0 || light.target.position.z !== -1)) {
      console.warn(
        "THREE.GLTFExporter: Light direction may be lost. For best results, make light.target a child of the light with position 0,0,-1."
      );
    }
    if (!extensionsUsed[this.name]) {
      json.extensions = json.extensions || {};
      json.extensions[this.name] = { lights: [] };
      extensionsUsed[this.name] = true;
    }
    const lights = json.extensions[this.name].lights;
    lights.push(lightDef);
    nodeDef.extensions = nodeDef.extensions || {};
    nodeDef.extensions[this.name] = { light: lights.length - 1 };
  }
};
var GLTFMaterialsUnlitExtension = class {
  constructor(writer) {
    this.writer = writer;
    this.name = "KHR_materials_unlit";
  }
  writeMaterial(material2, materialDef) {
    if (!material2.isMeshBasicMaterial)
      return;
    const writer = this.writer;
    const extensionsUsed = writer.extensionsUsed;
    materialDef.extensions = materialDef.extensions || {};
    materialDef.extensions[this.name] = {};
    extensionsUsed[this.name] = true;
    materialDef.pbrMetallicRoughness.metallicFactor = 0;
    materialDef.pbrMetallicRoughness.roughnessFactor = 0.9;
  }
};
var GLTFMaterialsClearcoatExtension = class {
  constructor(writer) {
    this.writer = writer;
    this.name = "KHR_materials_clearcoat";
  }
  writeMaterial(material2, materialDef) {
    if (!material2.isMeshPhysicalMaterial || material2.clearcoat === 0)
      return;
    const writer = this.writer;
    const extensionsUsed = writer.extensionsUsed;
    const extensionDef = {};
    extensionDef.clearcoatFactor = material2.clearcoat;
    if (material2.clearcoatMap) {
      const clearcoatMapDef = {
        index: writer.processTexture(material2.clearcoatMap),
        texCoord: material2.clearcoatMap.channel
      };
      writer.applyTextureTransform(clearcoatMapDef, material2.clearcoatMap);
      extensionDef.clearcoatTexture = clearcoatMapDef;
    }
    extensionDef.clearcoatRoughnessFactor = material2.clearcoatRoughness;
    if (material2.clearcoatRoughnessMap) {
      const clearcoatRoughnessMapDef = {
        index: writer.processTexture(material2.clearcoatRoughnessMap),
        texCoord: material2.clearcoatRoughnessMap.channel
      };
      writer.applyTextureTransform(clearcoatRoughnessMapDef, material2.clearcoatRoughnessMap);
      extensionDef.clearcoatRoughnessTexture = clearcoatRoughnessMapDef;
    }
    if (material2.clearcoatNormalMap) {
      const clearcoatNormalMapDef = {
        index: writer.processTexture(material2.clearcoatNormalMap),
        texCoord: material2.clearcoatNormalMap.channel
      };
      writer.applyTextureTransform(clearcoatNormalMapDef, material2.clearcoatNormalMap);
      extensionDef.clearcoatNormalTexture = clearcoatNormalMapDef;
    }
    materialDef.extensions = materialDef.extensions || {};
    materialDef.extensions[this.name] = extensionDef;
    extensionsUsed[this.name] = true;
  }
};
var GLTFMaterialsIridescenceExtension = class {
  constructor(writer) {
    this.writer = writer;
    this.name = "KHR_materials_iridescence";
  }
  writeMaterial(material2, materialDef) {
    if (!material2.isMeshPhysicalMaterial || material2.iridescence === 0)
      return;
    const writer = this.writer;
    const extensionsUsed = writer.extensionsUsed;
    const extensionDef = {};
    extensionDef.iridescenceFactor = material2.iridescence;
    if (material2.iridescenceMap) {
      const iridescenceMapDef = {
        index: writer.processTexture(material2.iridescenceMap),
        texCoord: material2.iridescenceMap.channel
      };
      writer.applyTextureTransform(iridescenceMapDef, material2.iridescenceMap);
      extensionDef.iridescenceTexture = iridescenceMapDef;
    }
    extensionDef.iridescenceIor = material2.iridescenceIOR;
    extensionDef.iridescenceThicknessMinimum = material2.iridescenceThicknessRange[0];
    extensionDef.iridescenceThicknessMaximum = material2.iridescenceThicknessRange[1];
    if (material2.iridescenceThicknessMap) {
      const iridescenceThicknessMapDef = {
        index: writer.processTexture(material2.iridescenceThicknessMap),
        texCoord: material2.iridescenceThicknessMap.channel
      };
      writer.applyTextureTransform(iridescenceThicknessMapDef, material2.iridescenceThicknessMap);
      extensionDef.iridescenceThicknessTexture = iridescenceThicknessMapDef;
    }
    materialDef.extensions = materialDef.extensions || {};
    materialDef.extensions[this.name] = extensionDef;
    extensionsUsed[this.name] = true;
  }
};
var GLTFMaterialsTransmissionExtension = class {
  constructor(writer) {
    this.writer = writer;
    this.name = "KHR_materials_transmission";
  }
  writeMaterial(material2, materialDef) {
    if (!material2.isMeshPhysicalMaterial || material2.transmission === 0)
      return;
    const writer = this.writer;
    const extensionsUsed = writer.extensionsUsed;
    const extensionDef = {};
    extensionDef.transmissionFactor = material2.transmission;
    if (material2.transmissionMap) {
      const transmissionMapDef = {
        index: writer.processTexture(material2.transmissionMap),
        texCoord: material2.transmissionMap.channel
      };
      writer.applyTextureTransform(transmissionMapDef, material2.transmissionMap);
      extensionDef.transmissionTexture = transmissionMapDef;
    }
    materialDef.extensions = materialDef.extensions || {};
    materialDef.extensions[this.name] = extensionDef;
    extensionsUsed[this.name] = true;
  }
};
var GLTFMaterialsVolumeExtension = class {
  constructor(writer) {
    this.writer = writer;
    this.name = "KHR_materials_volume";
  }
  writeMaterial(material2, materialDef) {
    if (!material2.isMeshPhysicalMaterial || material2.transmission === 0)
      return;
    const writer = this.writer;
    const extensionsUsed = writer.extensionsUsed;
    const extensionDef = {};
    extensionDef.thicknessFactor = material2.thickness;
    if (material2.thicknessMap) {
      const thicknessMapDef = {
        index: writer.processTexture(material2.thicknessMap),
        texCoord: material2.thicknessMap.channel
      };
      writer.applyTextureTransform(thicknessMapDef, material2.thicknessMap);
      extensionDef.thicknessTexture = thicknessMapDef;
    }
    extensionDef.attenuationDistance = material2.attenuationDistance;
    extensionDef.attenuationColor = material2.attenuationColor.toArray();
    materialDef.extensions = materialDef.extensions || {};
    materialDef.extensions[this.name] = extensionDef;
    extensionsUsed[this.name] = true;
  }
};
var GLTFMaterialsIorExtension = class {
  constructor(writer) {
    this.writer = writer;
    this.name = "KHR_materials_ior";
  }
  writeMaterial(material2, materialDef) {
    if (!material2.isMeshPhysicalMaterial || material2.ior === 1.5)
      return;
    const writer = this.writer;
    const extensionsUsed = writer.extensionsUsed;
    const extensionDef = {};
    extensionDef.ior = material2.ior;
    materialDef.extensions = materialDef.extensions || {};
    materialDef.extensions[this.name] = extensionDef;
    extensionsUsed[this.name] = true;
  }
};
var GLTFMaterialsSpecularExtension = class {
  constructor(writer) {
    this.writer = writer;
    this.name = "KHR_materials_specular";
  }
  writeMaterial(material2, materialDef) {
    if (!material2.isMeshPhysicalMaterial || material2.specularIntensity === 1 && material2.specularColor.equals(DEFAULT_SPECULAR_COLOR) && !material2.specularIntensityMap && !material2.specularColorTexture)
      return;
    const writer = this.writer;
    const extensionsUsed = writer.extensionsUsed;
    const extensionDef = {};
    if (material2.specularIntensityMap) {
      const specularIntensityMapDef = {
        index: writer.processTexture(material2.specularIntensityMap),
        texCoord: material2.specularIntensityMap.channel
      };
      writer.applyTextureTransform(specularIntensityMapDef, material2.specularIntensityMap);
      extensionDef.specularTexture = specularIntensityMapDef;
    }
    if (material2.specularColorMap) {
      const specularColorMapDef = {
        index: writer.processTexture(material2.specularColorMap),
        texCoord: material2.specularColorMap.channel
      };
      writer.applyTextureTransform(specularColorMapDef, material2.specularColorMap);
      extensionDef.specularColorTexture = specularColorMapDef;
    }
    extensionDef.specularFactor = material2.specularIntensity;
    extensionDef.specularColorFactor = material2.specularColor.toArray();
    materialDef.extensions = materialDef.extensions || {};
    materialDef.extensions[this.name] = extensionDef;
    extensionsUsed[this.name] = true;
  }
};
var GLTFMaterialsSheenExtension = class {
  constructor(writer) {
    this.writer = writer;
    this.name = "KHR_materials_sheen";
  }
  writeMaterial(material2, materialDef) {
    if (!material2.isMeshPhysicalMaterial || material2.sheen == 0)
      return;
    const writer = this.writer;
    const extensionsUsed = writer.extensionsUsed;
    const extensionDef = {};
    if (material2.sheenRoughnessMap) {
      const sheenRoughnessMapDef = {
        index: writer.processTexture(material2.sheenRoughnessMap),
        texCoord: material2.sheenRoughnessMap.channel
      };
      writer.applyTextureTransform(sheenRoughnessMapDef, material2.sheenRoughnessMap);
      extensionDef.sheenRoughnessTexture = sheenRoughnessMapDef;
    }
    if (material2.sheenColorMap) {
      const sheenColorMapDef = {
        index: writer.processTexture(material2.sheenColorMap),
        texCoord: material2.sheenColorMap.channel
      };
      writer.applyTextureTransform(sheenColorMapDef, material2.sheenColorMap);
      extensionDef.sheenColorTexture = sheenColorMapDef;
    }
    extensionDef.sheenRoughnessFactor = material2.sheenRoughness;
    extensionDef.sheenColorFactor = material2.sheenColor.toArray();
    materialDef.extensions = materialDef.extensions || {};
    materialDef.extensions[this.name] = extensionDef;
    extensionsUsed[this.name] = true;
  }
};
var GLTFMaterialsAnisotropyExtension = class {
  constructor(writer) {
    this.writer = writer;
    this.name = "KHR_materials_anisotropy";
  }
  writeMaterial(material2, materialDef) {
    if (!material2.isMeshPhysicalMaterial || material2.anisotropy == 0)
      return;
    const writer = this.writer;
    const extensionsUsed = writer.extensionsUsed;
    const extensionDef = {};
    if (material2.anisotropyMap) {
      const anisotropyMapDef = { index: writer.processTexture(material2.anisotropyMap) };
      writer.applyTextureTransform(anisotropyMapDef, material2.anisotropyMap);
      extensionDef.anisotropyTexture = anisotropyMapDef;
    }
    extensionDef.anisotropyStrength = material2.anisotropy;
    extensionDef.anisotropyRotation = material2.anisotropyRotation;
    materialDef.extensions = materialDef.extensions || {};
    materialDef.extensions[this.name] = extensionDef;
    extensionsUsed[this.name] = true;
  }
};
var GLTFMaterialsEmissiveStrengthExtension = class {
  constructor(writer) {
    this.writer = writer;
    this.name = "KHR_materials_emissive_strength";
  }
  writeMaterial(material2, materialDef) {
    if (!material2.isMeshStandardMaterial || material2.emissiveIntensity === 1)
      return;
    const writer = this.writer;
    const extensionsUsed = writer.extensionsUsed;
    const extensionDef = {};
    extensionDef.emissiveStrength = material2.emissiveIntensity;
    materialDef.extensions = materialDef.extensions || {};
    materialDef.extensions[this.name] = extensionDef;
    extensionsUsed[this.name] = true;
  }
};
GLTFExporter.Utils = {
  insertKeyframe: function(track, time) {
    const tolerance = 1e-3;
    const valueSize = track.getValueSize();
    const times = new track.TimeBufferType(track.times.length + 1);
    const values = new track.ValueBufferType(track.values.length + valueSize);
    const interpolant = track.createInterpolant(new track.ValueBufferType(valueSize));
    let index;
    if (track.times.length === 0) {
      times[0] = time;
      for (let i3 = 0; i3 < valueSize; i3++) {
        values[i3] = 0;
      }
      index = 0;
    } else if (time < track.times[0]) {
      if (Math.abs(track.times[0] - time) < tolerance)
        return 0;
      times[0] = time;
      times.set(track.times, 1);
      values.set(interpolant.evaluate(time), 0);
      values.set(track.values, valueSize);
      index = 0;
    } else if (time > track.times[track.times.length - 1]) {
      if (Math.abs(track.times[track.times.length - 1] - time) < tolerance) {
        return track.times.length - 1;
      }
      times[times.length - 1] = time;
      times.set(track.times, 0);
      values.set(track.values, 0);
      values.set(interpolant.evaluate(time), track.values.length);
      index = times.length - 1;
    } else {
      for (let i3 = 0; i3 < track.times.length; i3++) {
        if (Math.abs(track.times[i3] - time) < tolerance)
          return i3;
        if (track.times[i3] < time && track.times[i3 + 1] > time) {
          times.set(track.times.slice(0, i3 + 1), 0);
          times[i3 + 1] = time;
          times.set(track.times.slice(i3 + 1), i3 + 2);
          values.set(track.values.slice(0, (i3 + 1) * valueSize), 0);
          values.set(interpolant.evaluate(time), (i3 + 1) * valueSize);
          values.set(track.values.slice((i3 + 1) * valueSize), (i3 + 2) * valueSize);
          index = i3 + 1;
          break;
        }
      }
    }
    track.times = times;
    track.values = values;
    return index;
  },
  mergeMorphTargetTracks: function(clip, root) {
    const tracks = [];
    const mergedTracks = {};
    const sourceTracks = clip.tracks;
    for (let i3 = 0; i3 < sourceTracks.length; ++i3) {
      let sourceTrack = sourceTracks[i3];
      const sourceTrackBinding = PropertyBinding.parseTrackName(sourceTrack.name);
      const sourceTrackNode = PropertyBinding.findNode(root, sourceTrackBinding.nodeName);
      if (sourceTrackBinding.propertyName !== "morphTargetInfluences" || sourceTrackBinding.propertyIndex === void 0) {
        tracks.push(sourceTrack);
        continue;
      }
      if (sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodDiscrete && sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodLinear) {
        if (sourceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {
          throw new Error("THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.");
        }
        console.warn("THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead.");
        sourceTrack = sourceTrack.clone();
        sourceTrack.setInterpolation(InterpolateLinear);
      }
      const targetCount = sourceTrackNode.morphTargetInfluences.length;
      const targetIndex = sourceTrackNode.morphTargetDictionary[sourceTrackBinding.propertyIndex];
      if (targetIndex === void 0) {
        throw new Error("THREE.GLTFExporter: Morph target name not found: " + sourceTrackBinding.propertyIndex);
      }
      let mergedTrack;
      if (mergedTracks[sourceTrackNode.uuid] === void 0) {
        mergedTrack = sourceTrack.clone();
        const values = new mergedTrack.ValueBufferType(targetCount * mergedTrack.times.length);
        for (let j = 0; j < mergedTrack.times.length; j++) {
          values[j * targetCount + targetIndex] = mergedTrack.values[j];
        }
        mergedTrack.name = (sourceTrackBinding.nodeName || "") + ".morphTargetInfluences";
        mergedTrack.values = values;
        mergedTracks[sourceTrackNode.uuid] = mergedTrack;
        tracks.push(mergedTrack);
        continue;
      }
      const sourceInterpolant = sourceTrack.createInterpolant(new sourceTrack.ValueBufferType(1));
      mergedTrack = mergedTracks[sourceTrackNode.uuid];
      for (let j = 0; j < mergedTrack.times.length; j++) {
        mergedTrack.values[j * targetCount + targetIndex] = sourceInterpolant.evaluate(mergedTrack.times[j]);
      }
      for (let j = 0; j < sourceTrack.times.length; j++) {
        const keyframeIndex = this.insertKeyframe(mergedTrack, sourceTrack.times[j]);
        mergedTrack.values[keyframeIndex * targetCount + targetIndex] = sourceTrack.values[j];
      }
    }
    clip.tracks = tracks;
    return clip;
  }
};

// node_modules/fflate/esm/browser.js
var ch2 = {};
var wk = function(c3, id, msg, transfer, cb3) {
  var w = new Worker(ch2[id] || (ch2[id] = URL.createObjectURL(new Blob([c3], { type: "text/javascript" }))));
  w.onerror = function(e) {
    return cb3(e.error, null);
  };
  w.onmessage = function(e) {
    return cb3(null, e.data);
  };
  w.postMessage(msg, transfer);
  return w;
};
var u8 = Uint8Array;
var u16 = Uint16Array;
var u32 = Uint32Array;
var fleb = new u8([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  2,
  2,
  2,
  2,
  3,
  3,
  3,
  3,
  4,
  4,
  4,
  4,
  5,
  5,
  5,
  5,
  0,
  /* unused */
  0,
  0,
  /* impossible */
  0
]);
var fdeb = new u8([
  0,
  0,
  0,
  0,
  1,
  1,
  2,
  2,
  3,
  3,
  4,
  4,
  5,
  5,
  6,
  6,
  7,
  7,
  8,
  8,
  9,
  9,
  10,
  10,
  11,
  11,
  12,
  12,
  13,
  13,
  /* unused */
  0,
  0
]);
var clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
var freb = function(eb, start) {
  var b5 = new u16(31);
  for (var i3 = 0; i3 < 31; ++i3) {
    b5[i3] = start += 1 << eb[i3 - 1];
  }
  var r = new u32(b5[30]);
  for (var i3 = 1; i3 < 30; ++i3) {
    for (var j = b5[i3]; j < b5[i3 + 1]; ++j) {
      r[j] = j - b5[i3] << 5 | i3;
    }
  }
  return [b5, r];
};
var _a2 = freb(fleb, 2);
var fl = _a2[0];
var revfl = _a2[1];
fl[28] = 258, revfl[258] = 28;
var _b2 = freb(fdeb, 0);
var fd = _b2[0];
var revfd = _b2[1];
var rev = new u16(32768);
for (i3 = 0; i3 < 32768; ++i3) {
  x = (i3 & 43690) >>> 1 | (i3 & 21845) << 1;
  x = (x & 52428) >>> 2 | (x & 13107) << 2;
  x = (x & 61680) >>> 4 | (x & 3855) << 4;
  rev[i3] = ((x & 65280) >>> 8 | (x & 255) << 8) >>> 1;
}
var x;
var i3;
var hMap = function(cd, mb, r) {
  var s = cd.length;
  var i3 = 0;
  var l = new u16(mb);
  for (; i3 < s; ++i3)
    ++l[cd[i3] - 1];
  var le = new u16(mb);
  for (i3 = 0; i3 < mb; ++i3) {
    le[i3] = le[i3 - 1] + l[i3 - 1] << 1;
  }
  var co;
  if (r) {
    co = new u16(1 << mb);
    var rvb = 15 - mb;
    for (i3 = 0; i3 < s; ++i3) {
      if (cd[i3]) {
        var sv = i3 << 4 | cd[i3];
        var r_1 = mb - cd[i3];
        var v = le[cd[i3] - 1]++ << r_1;
        for (var m = v | (1 << r_1) - 1; v <= m; ++v) {
          co[rev[v] >>> rvb] = sv;
        }
      }
    }
  } else {
    co = new u16(s);
    for (i3 = 0; i3 < s; ++i3) {
      if (cd[i3]) {
        co[i3] = rev[le[cd[i3] - 1]++] >>> 15 - cd[i3];
      }
    }
  }
  return co;
};
var flt = new u8(288);
for (i3 = 0; i3 < 144; ++i3)
  flt[i3] = 8;
var i3;
for (i3 = 144; i3 < 256; ++i3)
  flt[i3] = 9;
var i3;
for (i3 = 256; i3 < 280; ++i3)
  flt[i3] = 7;
var i3;
for (i3 = 280; i3 < 288; ++i3)
  flt[i3] = 8;
var i3;
var fdt = new u8(32);
for (i3 = 0; i3 < 32; ++i3)
  fdt[i3] = 5;
var i3;
var flm = hMap(flt, 9, 0);
var flrm = hMap(flt, 9, 1);
var fdm = hMap(fdt, 5, 0);
var fdrm = hMap(fdt, 5, 1);
var max = function(a4) {
  var m = a4[0];
  for (var i3 = 1; i3 < a4.length; ++i3) {
    if (a4[i3] > m)
      m = a4[i3];
  }
  return m;
};
var bits = function(d, p, m) {
  var o = p / 8 | 0;
  return (d[o] | d[o + 1] << 8) >> (p & 7) & m;
};
var bits16 = function(d, p) {
  var o = p / 8 | 0;
  return (d[o] | d[o + 1] << 8 | d[o + 2] << 16) >> (p & 7);
};
var shft = function(p) {
  return (p / 8 | 0) + (p & 7 && 1);
};
var slc = function(v, s, e) {
  if (s == null || s < 0)
    s = 0;
  if (e == null || e > v.length)
    e = v.length;
  var n = new (v instanceof u16 ? u16 : v instanceof u32 ? u32 : u8)(e - s);
  n.set(v.subarray(s, e));
  return n;
};
var inflt = function(dat, buf, st) {
  var sl = dat.length;
  if (!sl || st && !st.l && sl < 5)
    return buf || new u8(0);
  var noBuf = !buf || st;
  var noSt = !st || st.i;
  if (!st)
    st = {};
  if (!buf)
    buf = new u8(sl * 3);
  var cbuf = function(l2) {
    var bl = buf.length;
    if (l2 > bl) {
      var nbuf = new u8(Math.max(bl * 2, l2));
      nbuf.set(buf);
      buf = nbuf;
    }
  };
  var final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;
  var tbts = sl * 8;
  do {
    if (!lm) {
      st.f = final = bits(dat, pos, 1);
      var type = bits(dat, pos + 1, 3);
      pos += 3;
      if (!type) {
        var s = shft(pos) + 4, l = dat[s - 4] | dat[s - 3] << 8, t2 = s + l;
        if (t2 > sl) {
          if (noSt)
            throw "unexpected EOF";
          break;
        }
        if (noBuf)
          cbuf(bt + l);
        buf.set(dat.subarray(s, t2), bt);
        st.b = bt += l, st.p = pos = t2 * 8;
        continue;
      } else if (type == 1)
        lm = flrm, dm = fdrm, lbt = 9, dbt = 5;
      else if (type == 2) {
        var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;
        var tl = hLit + bits(dat, pos + 5, 31) + 1;
        pos += 14;
        var ldt = new u8(tl);
        var clt = new u8(19);
        for (var i3 = 0; i3 < hcLen; ++i3) {
          clt[clim[i3]] = bits(dat, pos + i3 * 3, 7);
        }
        pos += hcLen * 3;
        var clb = max(clt), clbmsk = (1 << clb) - 1;
        var clm = hMap(clt, clb, 1);
        for (var i3 = 0; i3 < tl; ) {
          var r = clm[bits(dat, pos, clbmsk)];
          pos += r & 15;
          var s = r >>> 4;
          if (s < 16) {
            ldt[i3++] = s;
          } else {
            var c3 = 0, n = 0;
            if (s == 16)
              n = 3 + bits(dat, pos, 3), pos += 2, c3 = ldt[i3 - 1];
            else if (s == 17)
              n = 3 + bits(dat, pos, 7), pos += 3;
            else if (s == 18)
              n = 11 + bits(dat, pos, 127), pos += 7;
            while (n--)
              ldt[i3++] = c3;
          }
        }
        var lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);
        lbt = max(lt);
        dbt = max(dt);
        lm = hMap(lt, lbt, 1);
        dm = hMap(dt, dbt, 1);
      } else
        throw "invalid block type";
      if (pos > tbts) {
        if (noSt)
          throw "unexpected EOF";
        break;
      }
    }
    if (noBuf)
      cbuf(bt + 131072);
    var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;
    var lpos = pos;
    for (; ; lpos = pos) {
      var c3 = lm[bits16(dat, pos) & lms], sym = c3 >>> 4;
      pos += c3 & 15;
      if (pos > tbts) {
        if (noSt)
          throw "unexpected EOF";
        break;
      }
      if (!c3)
        throw "invalid length/literal";
      if (sym < 256)
        buf[bt++] = sym;
      else if (sym == 256) {
        lpos = pos, lm = null;
        break;
      } else {
        var add = sym - 254;
        if (sym > 264) {
          var i3 = sym - 257, b5 = fleb[i3];
          add = bits(dat, pos, (1 << b5) - 1) + fl[i3];
          pos += b5;
        }
        var d = dm[bits16(dat, pos) & dms], dsym = d >>> 4;
        if (!d)
          throw "invalid distance";
        pos += d & 15;
        var dt = fd[dsym];
        if (dsym > 3) {
          var b5 = fdeb[dsym];
          dt += bits16(dat, pos) & (1 << b5) - 1, pos += b5;
        }
        if (pos > tbts) {
          if (noSt)
            throw "unexpected EOF";
          break;
        }
        if (noBuf)
          cbuf(bt + 131072);
        var end = bt + add;
        for (; bt < end; bt += 4) {
          buf[bt] = buf[bt - dt];
          buf[bt + 1] = buf[bt + 1 - dt];
          buf[bt + 2] = buf[bt + 2 - dt];
          buf[bt + 3] = buf[bt + 3 - dt];
        }
        bt = end;
      }
    }
    st.l = lm, st.p = lpos, st.b = bt;
    if (lm)
      final = 1, st.m = lbt, st.d = dm, st.n = dbt;
  } while (!final);
  return bt == buf.length ? buf : slc(buf, 0, bt);
};
var wbits = function(d, p, v) {
  v <<= p & 7;
  var o = p / 8 | 0;
  d[o] |= v;
  d[o + 1] |= v >>> 8;
};
var wbits16 = function(d, p, v) {
  v <<= p & 7;
  var o = p / 8 | 0;
  d[o] |= v;
  d[o + 1] |= v >>> 8;
  d[o + 2] |= v >>> 16;
};
var hTree = function(d, mb) {
  var t2 = [];
  for (var i3 = 0; i3 < d.length; ++i3) {
    if (d[i3])
      t2.push({ s: i3, f: d[i3] });
  }
  var s = t2.length;
  var t22 = t2.slice();
  if (!s)
    return [et, 0];
  if (s == 1) {
    var v = new u8(t2[0].s + 1);
    v[t2[0].s] = 1;
    return [v, 1];
  }
  t2.sort(function(a4, b5) {
    return a4.f - b5.f;
  });
  t2.push({ s: -1, f: 25001 });
  var l = t2[0], r = t2[1], i0 = 0, i1 = 1, i22 = 2;
  t2[0] = { s: -1, f: l.f + r.f, l, r };
  while (i1 != s - 1) {
    l = t2[t2[i0].f < t2[i22].f ? i0++ : i22++];
    r = t2[i0 != i1 && t2[i0].f < t2[i22].f ? i0++ : i22++];
    t2[i1++] = { s: -1, f: l.f + r.f, l, r };
  }
  var maxSym = t22[0].s;
  for (var i3 = 1; i3 < s; ++i3) {
    if (t22[i3].s > maxSym)
      maxSym = t22[i3].s;
  }
  var tr = new u16(maxSym + 1);
  var mbt = ln(t2[i1 - 1], tr, 0);
  if (mbt > mb) {
    var i3 = 0, dt = 0;
    var lft = mbt - mb, cst = 1 << lft;
    t22.sort(function(a4, b5) {
      return tr[b5.s] - tr[a4.s] || a4.f - b5.f;
    });
    for (; i3 < s; ++i3) {
      var i2_1 = t22[i3].s;
      if (tr[i2_1] > mb) {
        dt += cst - (1 << mbt - tr[i2_1]);
        tr[i2_1] = mb;
      } else
        break;
    }
    dt >>>= lft;
    while (dt > 0) {
      var i2_2 = t22[i3].s;
      if (tr[i2_2] < mb)
        dt -= 1 << mb - tr[i2_2]++ - 1;
      else
        ++i3;
    }
    for (; i3 >= 0 && dt; --i3) {
      var i2_3 = t22[i3].s;
      if (tr[i2_3] == mb) {
        --tr[i2_3];
        ++dt;
      }
    }
    mbt = mb;
  }
  return [new u8(tr), mbt];
};
var ln = function(n, l, d) {
  return n.s == -1 ? Math.max(ln(n.l, l, d + 1), ln(n.r, l, d + 1)) : l[n.s] = d;
};
var lc = function(c3) {
  var s = c3.length;
  while (s && !c3[--s])
    ;
  var cl = new u16(++s);
  var cli = 0, cln = c3[0], cls = 1;
  var w = function(v) {
    cl[cli++] = v;
  };
  for (var i3 = 1; i3 <= s; ++i3) {
    if (c3[i3] == cln && i3 != s)
      ++cls;
    else {
      if (!cln && cls > 2) {
        for (; cls > 138; cls -= 138)
          w(32754);
        if (cls > 2) {
          w(cls > 10 ? cls - 11 << 5 | 28690 : cls - 3 << 5 | 12305);
          cls = 0;
        }
      } else if (cls > 3) {
        w(cln), --cls;
        for (; cls > 6; cls -= 6)
          w(8304);
        if (cls > 2)
          w(cls - 3 << 5 | 8208), cls = 0;
      }
      while (cls--)
        w(cln);
      cls = 1;
      cln = c3[i3];
    }
  }
  return [cl.subarray(0, cli), s];
};
var clen = function(cf, cl) {
  var l = 0;
  for (var i3 = 0; i3 < cl.length; ++i3)
    l += cf[i3] * cl[i3];
  return l;
};
var wfblk = function(out, pos, dat) {
  var s = dat.length;
  var o = shft(pos + 2);
  out[o] = s & 255;
  out[o + 1] = s >>> 8;
  out[o + 2] = out[o] ^ 255;
  out[o + 3] = out[o + 1] ^ 255;
  for (var i3 = 0; i3 < s; ++i3)
    out[o + i3 + 4] = dat[i3];
  return (o + 4 + s) * 8;
};
var wblk = function(dat, out, final, syms, lf, df, eb, li, bs, bl, p) {
  wbits(out, p++, final);
  ++lf[256];
  var _a4 = hTree(lf, 15), dlt = _a4[0], mlb = _a4[1];
  var _b4 = hTree(df, 15), ddt = _b4[0], mdb = _b4[1];
  var _c = lc(dlt), lclt = _c[0], nlc = _c[1];
  var _d = lc(ddt), lcdt = _d[0], ndc = _d[1];
  var lcfreq = new u16(19);
  for (var i3 = 0; i3 < lclt.length; ++i3)
    lcfreq[lclt[i3] & 31]++;
  for (var i3 = 0; i3 < lcdt.length; ++i3)
    lcfreq[lcdt[i3] & 31]++;
  var _e = hTree(lcfreq, 7), lct = _e[0], mlcb = _e[1];
  var nlcc = 19;
  for (; nlcc > 4 && !lct[clim[nlcc - 1]]; --nlcc)
    ;
  var flen = bl + 5 << 3;
  var ftlen = clen(lf, flt) + clen(df, fdt) + eb;
  var dtlen = clen(lf, dlt) + clen(df, ddt) + eb + 14 + 3 * nlcc + clen(lcfreq, lct) + (2 * lcfreq[16] + 3 * lcfreq[17] + 7 * lcfreq[18]);
  if (flen <= ftlen && flen <= dtlen)
    return wfblk(out, p, dat.subarray(bs, bs + bl));
  var lm, ll, dm, dl;
  wbits(out, p, 1 + (dtlen < ftlen)), p += 2;
  if (dtlen < ftlen) {
    lm = hMap(dlt, mlb, 0), ll = dlt, dm = hMap(ddt, mdb, 0), dl = ddt;
    var llm = hMap(lct, mlcb, 0);
    wbits(out, p, nlc - 257);
    wbits(out, p + 5, ndc - 1);
    wbits(out, p + 10, nlcc - 4);
    p += 14;
    for (var i3 = 0; i3 < nlcc; ++i3)
      wbits(out, p + 3 * i3, lct[clim[i3]]);
    p += 3 * nlcc;
    var lcts = [lclt, lcdt];
    for (var it = 0; it < 2; ++it) {
      var clct = lcts[it];
      for (var i3 = 0; i3 < clct.length; ++i3) {
        var len = clct[i3] & 31;
        wbits(out, p, llm[len]), p += lct[len];
        if (len > 15)
          wbits(out, p, clct[i3] >>> 5 & 127), p += clct[i3] >>> 12;
      }
    }
  } else {
    lm = flm, ll = flt, dm = fdm, dl = fdt;
  }
  for (var i3 = 0; i3 < li; ++i3) {
    if (syms[i3] > 255) {
      var len = syms[i3] >>> 18 & 31;
      wbits16(out, p, lm[len + 257]), p += ll[len + 257];
      if (len > 7)
        wbits(out, p, syms[i3] >>> 23 & 31), p += fleb[len];
      var dst = syms[i3] & 31;
      wbits16(out, p, dm[dst]), p += dl[dst];
      if (dst > 3)
        wbits16(out, p, syms[i3] >>> 5 & 8191), p += fdeb[dst];
    } else {
      wbits16(out, p, lm[syms[i3]]), p += ll[syms[i3]];
    }
  }
  wbits16(out, p, lm[256]);
  return p + ll[256];
};
var deo = new u32([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]);
var et = new u8(0);
var dflt = function(dat, lvl, plvl, pre, post2, lst) {
  var s = dat.length;
  var o = new u8(pre + s + 5 * (1 + Math.ceil(s / 7e3)) + post2);
  var w = o.subarray(pre, o.length - post2);
  var pos = 0;
  if (!lvl || s < 8) {
    for (var i3 = 0; i3 <= s; i3 += 65535) {
      var e = i3 + 65535;
      if (e < s) {
        pos = wfblk(w, pos, dat.subarray(i3, e));
      } else {
        w[i3] = lst;
        pos = wfblk(w, pos, dat.subarray(i3, s));
      }
    }
  } else {
    var opt = deo[lvl - 1];
    var n = opt >>> 13, c3 = opt & 8191;
    var msk_1 = (1 << plvl) - 1;
    var prev = new u16(32768), head2 = new u16(msk_1 + 1);
    var bs1_1 = Math.ceil(plvl / 3), bs2_1 = 2 * bs1_1;
    var hsh = function(i4) {
      return (dat[i4] ^ dat[i4 + 1] << bs1_1 ^ dat[i4 + 2] << bs2_1) & msk_1;
    };
    var syms = new u32(25e3);
    var lf = new u16(288), df = new u16(32);
    var lc_1 = 0, eb = 0, i3 = 0, li = 0, wi = 0, bs = 0;
    for (; i3 < s; ++i3) {
      var hv = hsh(i3);
      var imod = i3 & 32767, pimod = head2[hv];
      prev[imod] = pimod;
      head2[hv] = imod;
      if (wi <= i3) {
        var rem = s - i3;
        if ((lc_1 > 7e3 || li > 24576) && rem > 423) {
          pos = wblk(dat, w, 0, syms, lf, df, eb, li, bs, i3 - bs, pos);
          li = lc_1 = eb = 0, bs = i3;
          for (var j = 0; j < 286; ++j)
            lf[j] = 0;
          for (var j = 0; j < 30; ++j)
            df[j] = 0;
        }
        var l = 2, d = 0, ch_1 = c3, dif = imod - pimod & 32767;
        if (rem > 2 && hv == hsh(i3 - dif)) {
          var maxn = Math.min(n, rem) - 1;
          var maxd = Math.min(32767, i3);
          var ml = Math.min(258, rem);
          while (dif <= maxd && --ch_1 && imod != pimod) {
            if (dat[i3 + l] == dat[i3 + l - dif]) {
              var nl = 0;
              for (; nl < ml && dat[i3 + nl] == dat[i3 + nl - dif]; ++nl)
                ;
              if (nl > l) {
                l = nl, d = dif;
                if (nl > maxn)
                  break;
                var mmd = Math.min(dif, nl - 2);
                var md = 0;
                for (var j = 0; j < mmd; ++j) {
                  var ti = i3 - dif + j + 32768 & 32767;
                  var pti = prev[ti];
                  var cd = ti - pti + 32768 & 32767;
                  if (cd > md)
                    md = cd, pimod = ti;
                }
              }
            }
            imod = pimod, pimod = prev[imod];
            dif += imod - pimod + 32768 & 32767;
          }
        }
        if (d) {
          syms[li++] = 268435456 | revfl[l] << 18 | revfd[d];
          var lin = revfl[l] & 31, din = revfd[d] & 31;
          eb += fleb[lin] + fdeb[din];
          ++lf[257 + lin];
          ++df[din];
          wi = i3 + l;
          ++lc_1;
        } else {
          syms[li++] = dat[i3];
          ++lf[dat[i3]];
        }
      }
    }
    pos = wblk(dat, w, lst, syms, lf, df, eb, li, bs, i3 - bs, pos);
    if (!lst && pos & 7)
      pos = wfblk(w, pos + 1, et);
  }
  return slc(o, 0, pre + shft(pos) + post2);
};
var crct = function() {
  var t2 = new Int32Array(256);
  for (var i3 = 0; i3 < 256; ++i3) {
    var c3 = i3, k = 9;
    while (--k)
      c3 = (c3 & 1 && -306674912) ^ c3 >>> 1;
    t2[i3] = c3;
  }
  return t2;
}();
var crc = function() {
  var c3 = -1;
  return {
    p: function(d) {
      var cr = c3;
      for (var i3 = 0; i3 < d.length; ++i3)
        cr = crct[cr & 255 ^ d[i3]] ^ cr >>> 8;
      c3 = cr;
    },
    d: function() {
      return ~c3;
    }
  };
};
var adler = function() {
  var a4 = 1, b5 = 0;
  return {
    p: function(d) {
      var n = a4, m = b5;
      var l = d.length;
      for (var i3 = 0; i3 != l; ) {
        var e = Math.min(i3 + 2655, l);
        for (; i3 < e; ++i3)
          m += n += d[i3];
        n = (n & 65535) + 15 * (n >> 16), m = (m & 65535) + 15 * (m >> 16);
      }
      a4 = n, b5 = m;
    },
    d: function() {
      a4 %= 65521, b5 %= 65521;
      return (a4 & 255) << 24 | a4 >>> 8 << 16 | (b5 & 255) << 8 | b5 >>> 8;
    }
  };
};
var dopt = function(dat, opt, pre, post2, st) {
  return dflt(dat, opt.level == null ? 6 : opt.level, opt.mem == null ? Math.ceil(Math.max(8, Math.min(13, Math.log(dat.length))) * 1.5) : 12 + opt.mem, pre, post2, !st);
};
var mrg = function(a4, b5) {
  var o = {};
  for (var k in a4)
    o[k] = a4[k];
  for (var k in b5)
    o[k] = b5[k];
  return o;
};
var wcln = function(fn, fnStr, td3) {
  var dt = fn();
  var st = fn.toString();
  var ks = st.slice(st.indexOf("[") + 1, st.lastIndexOf("]")).replace(/ /g, "").split(",");
  for (var i3 = 0; i3 < dt.length; ++i3) {
    var v = dt[i3], k = ks[i3];
    if (typeof v == "function") {
      fnStr += ";" + k + "=";
      var st_1 = v.toString();
      if (v.prototype) {
        if (st_1.indexOf("[native code]") != -1) {
          var spInd = st_1.indexOf(" ", 8) + 1;
          fnStr += st_1.slice(spInd, st_1.indexOf("(", spInd));
        } else {
          fnStr += st_1;
          for (var t2 in v.prototype)
            fnStr += ";" + k + ".prototype." + t2 + "=" + v.prototype[t2].toString();
        }
      } else
        fnStr += st_1;
    } else
      td3[k] = v;
  }
  return [fnStr, td3];
};
var ch = [];
var cbfs = function(v) {
  var tl = [];
  for (var k in v) {
    if (v[k] instanceof u8 || v[k] instanceof u16 || v[k] instanceof u32)
      tl.push((v[k] = new v[k].constructor(v[k])).buffer);
  }
  return tl;
};
var wrkr = function(fns, init5, id, cb3) {
  var _a4;
  if (!ch[id]) {
    var fnStr = "", td_1 = {}, m = fns.length - 1;
    for (var i3 = 0; i3 < m; ++i3)
      _a4 = wcln(fns[i3], fnStr, td_1), fnStr = _a4[0], td_1 = _a4[1];
    ch[id] = wcln(fns[m], fnStr, td_1);
  }
  var td3 = mrg({}, ch[id][1]);
  return wk(ch[id][0] + ";onmessage=function(e){for(var k in e.data)self[k]=e.data[k];onmessage=" + init5.toString() + "}", id, td3, cbfs(td3), cb3);
};
var bInflt = function() {
  return [u8, u16, u32, fleb, fdeb, clim, fl, fd, flrm, fdrm, rev, hMap, max, bits, bits16, shft, slc, inflt, inflateSync, pbf, gu8];
};
var bDflt = function() {
  return [u8, u16, u32, fleb, fdeb, clim, revfl, revfd, flm, flt, fdm, fdt, rev, deo, et, hMap, wbits, wbits16, hTree, ln, lc, clen, wfblk, wblk, shft, slc, dflt, dopt, deflateSync, pbf];
};
var gze = function() {
  return [gzh, gzhl, wbytes, crc, crct];
};
var guze = function() {
  return [gzs, gzl];
};
var zle = function() {
  return [zlh, wbytes, adler];
};
var zule = function() {
  return [zlv];
};
var pbf = function(msg) {
  return postMessage(msg, [msg.buffer]);
};
var gu8 = function(o) {
  return o && o.size && new u8(o.size);
};
var astrm = function(strm) {
  strm.ondata = function(dat, final) {
    return postMessage([dat, final], [dat.buffer]);
  };
  return function(ev) {
    return strm.push(ev.data[0], ev.data[1]);
  };
};
var astrmify = function(fns, strm, opts, init5, id) {
  var t2;
  var w = wrkr(fns, init5, id, function(err, dat) {
    if (err)
      w.terminate(), strm.ondata.call(strm, err);
    else {
      if (dat[1])
        w.terminate();
      strm.ondata.call(strm, err, dat[0], dat[1]);
    }
  });
  w.postMessage(opts);
  strm.push = function(d, f) {
    if (t2)
      throw "stream finished";
    if (!strm.ondata)
      throw "no stream handler";
    w.postMessage([d, t2 = f], [d.buffer]);
  };
  strm.terminate = function() {
    w.terminate();
  };
};
var b2 = function(d, b5) {
  return d[b5] | d[b5 + 1] << 8;
};
var b4 = function(d, b5) {
  return (d[b5] | d[b5 + 1] << 8 | d[b5 + 2] << 16 | d[b5 + 3] << 24) >>> 0;
};
var b8 = function(d, b5) {
  return b4(d, b5) + b4(d, b5 + 4) * 4294967296;
};
var wbytes = function(d, b5, v) {
  for (; v; ++b5)
    d[b5] = v, v >>>= 8;
};
var gzh = function(c3, o) {
  var fn = o.filename;
  c3[0] = 31, c3[1] = 139, c3[2] = 8, c3[8] = o.level < 2 ? 4 : o.level == 9 ? 2 : 0, c3[9] = 3;
  if (o.mtime != 0)
    wbytes(c3, 4, Math.floor(new Date(o.mtime || Date.now()) / 1e3));
  if (fn) {
    c3[3] = 8;
    for (var i3 = 0; i3 <= fn.length; ++i3)
      c3[i3 + 10] = fn.charCodeAt(i3);
  }
};
var gzs = function(d) {
  if (d[0] != 31 || d[1] != 139 || d[2] != 8)
    throw "invalid gzip data";
  var flg = d[3];
  var st = 10;
  if (flg & 4)
    st += d[10] | (d[11] << 8) + 2;
  for (var zs = (flg >> 3 & 1) + (flg >> 4 & 1); zs > 0; zs -= !d[st++])
    ;
  return st + (flg & 2);
};
var gzl = function(d) {
  var l = d.length;
  return (d[l - 4] | d[l - 3] << 8 | d[l - 2] << 16 | d[l - 1] << 24) >>> 0;
};
var gzhl = function(o) {
  return 10 + (o.filename && o.filename.length + 1 || 0);
};
var zlh = function(c3, o) {
  var lv = o.level, fl3 = lv == 0 ? 0 : lv < 6 ? 1 : lv == 9 ? 3 : 2;
  c3[0] = 120, c3[1] = fl3 << 6 | (fl3 ? 32 - 2 * fl3 : 1);
};
var zlv = function(d) {
  if ((d[0] & 15) != 8 || d[0] >>> 4 > 7 || (d[0] << 8 | d[1]) % 31)
    throw "invalid zlib data";
  if (d[1] & 32)
    throw "invalid zlib data: preset dictionaries not supported";
};
function AsyncCmpStrm(opts, cb3) {
  if (!cb3 && typeof opts == "function")
    cb3 = opts, opts = {};
  this.ondata = cb3;
  return opts;
}
var Deflate = function() {
  function Deflate3(opts, cb3) {
    if (!cb3 && typeof opts == "function")
      cb3 = opts, opts = {};
    this.ondata = cb3;
    this.o = opts || {};
  }
  Deflate3.prototype.p = function(c3, f) {
    this.ondata(dopt(c3, this.o, 0, 0, !f), f);
  };
  Deflate3.prototype.push = function(chunk, final) {
    if (this.d)
      throw "stream finished";
    if (!this.ondata)
      throw "no stream handler";
    this.d = final;
    this.p(chunk, final || false);
  };
  return Deflate3;
}();
var AsyncDeflate = function() {
  function AsyncDeflate3(opts, cb3) {
    astrmify([
      bDflt,
      function() {
        return [astrm, Deflate];
      }
    ], this, AsyncCmpStrm.call(this, opts, cb3), function(ev) {
      var strm = new Deflate(ev.data);
      onmessage = astrm(strm);
    }, 6);
  }
  return AsyncDeflate3;
}();
function deflateSync(data, opts) {
  return dopt(data, opts || {}, 0, 0);
}
var Inflate = function() {
  function Inflate3(cb3) {
    this.s = {};
    this.p = new u8(0);
    this.ondata = cb3;
  }
  Inflate3.prototype.e = function(c3) {
    if (this.d)
      throw "stream finished";
    if (!this.ondata)
      throw "no stream handler";
    var l = this.p.length;
    var n = new u8(l + c3.length);
    n.set(this.p), n.set(c3, l), this.p = n;
  };
  Inflate3.prototype.c = function(final) {
    this.d = this.s.i = final || false;
    var bts = this.s.b;
    var dt = inflt(this.p, this.o, this.s);
    this.ondata(slc(dt, bts, this.s.b), this.d);
    this.o = slc(dt, this.s.b - 32768), this.s.b = this.o.length;
    this.p = slc(this.p, this.s.p / 8 | 0), this.s.p &= 7;
  };
  Inflate3.prototype.push = function(chunk, final) {
    this.e(chunk), this.c(final);
  };
  return Inflate3;
}();
var AsyncInflate = function() {
  function AsyncInflate3(cb3) {
    this.ondata = cb3;
    astrmify([
      bInflt,
      function() {
        return [astrm, Inflate];
      }
    ], this, 0, function() {
      var strm = new Inflate();
      onmessage = astrm(strm);
    }, 7);
  }
  return AsyncInflate3;
}();
function inflateSync(data, out) {
  return inflt(data, out);
}
var Gzip = function() {
  function Gzip3(opts, cb3) {
    this.c = crc();
    this.l = 0;
    this.v = 1;
    Deflate.call(this, opts, cb3);
  }
  Gzip3.prototype.push = function(chunk, final) {
    Deflate.prototype.push.call(this, chunk, final);
  };
  Gzip3.prototype.p = function(c3, f) {
    this.c.p(c3);
    this.l += c3.length;
    var raw = dopt(c3, this.o, this.v && gzhl(this.o), f && 8, !f);
    if (this.v)
      gzh(raw, this.o), this.v = 0;
    if (f)
      wbytes(raw, raw.length - 8, this.c.d()), wbytes(raw, raw.length - 4, this.l);
    this.ondata(raw, f);
  };
  return Gzip3;
}();
var AsyncGzip = function() {
  function AsyncGzip3(opts, cb3) {
    astrmify([
      bDflt,
      gze,
      function() {
        return [astrm, Deflate, Gzip];
      }
    ], this, AsyncCmpStrm.call(this, opts, cb3), function(ev) {
      var strm = new Gzip(ev.data);
      onmessage = astrm(strm);
    }, 8);
  }
  return AsyncGzip3;
}();
var Gunzip = function() {
  function Gunzip3(cb3) {
    this.v = 1;
    Inflate.call(this, cb3);
  }
  Gunzip3.prototype.push = function(chunk, final) {
    Inflate.prototype.e.call(this, chunk);
    if (this.v) {
      var s = this.p.length > 3 ? gzs(this.p) : 4;
      if (s >= this.p.length && !final)
        return;
      this.p = this.p.subarray(s), this.v = 0;
    }
    if (final) {
      if (this.p.length < 8)
        throw "invalid gzip stream";
      this.p = this.p.subarray(0, -8);
    }
    Inflate.prototype.c.call(this, final);
  };
  return Gunzip3;
}();
var AsyncGunzip = function() {
  function AsyncGunzip3(cb3) {
    this.ondata = cb3;
    astrmify([
      bInflt,
      guze,
      function() {
        return [astrm, Inflate, Gunzip];
      }
    ], this, 0, function() {
      var strm = new Gunzip();
      onmessage = astrm(strm);
    }, 9);
  }
  return AsyncGunzip3;
}();
var Zlib = function() {
  function Zlib3(opts, cb3) {
    this.c = adler();
    this.v = 1;
    Deflate.call(this, opts, cb3);
  }
  Zlib3.prototype.push = function(chunk, final) {
    Deflate.prototype.push.call(this, chunk, final);
  };
  Zlib3.prototype.p = function(c3, f) {
    this.c.p(c3);
    var raw = dopt(c3, this.o, this.v && 2, f && 4, !f);
    if (this.v)
      zlh(raw, this.o), this.v = 0;
    if (f)
      wbytes(raw, raw.length - 4, this.c.d());
    this.ondata(raw, f);
  };
  return Zlib3;
}();
var AsyncZlib = function() {
  function AsyncZlib3(opts, cb3) {
    astrmify([
      bDflt,
      zle,
      function() {
        return [astrm, Deflate, Zlib];
      }
    ], this, AsyncCmpStrm.call(this, opts, cb3), function(ev) {
      var strm = new Zlib(ev.data);
      onmessage = astrm(strm);
    }, 10);
  }
  return AsyncZlib3;
}();
var Unzlib = function() {
  function Unzlib3(cb3) {
    this.v = 1;
    Inflate.call(this, cb3);
  }
  Unzlib3.prototype.push = function(chunk, final) {
    Inflate.prototype.e.call(this, chunk);
    if (this.v) {
      if (this.p.length < 2 && !final)
        return;
      this.p = this.p.subarray(2), this.v = 0;
    }
    if (final) {
      if (this.p.length < 4)
        throw "invalid zlib stream";
      this.p = this.p.subarray(0, -4);
    }
    Inflate.prototype.c.call(this, final);
  };
  return Unzlib3;
}();
var AsyncUnzlib = function() {
  function AsyncUnzlib3(cb3) {
    this.ondata = cb3;
    astrmify([
      bInflt,
      zule,
      function() {
        return [astrm, Inflate, Unzlib];
      }
    ], this, 0, function() {
      var strm = new Unzlib();
      onmessage = astrm(strm);
    }, 11);
  }
  return AsyncUnzlib3;
}();
function unzlibSync(data, out) {
  return inflt((zlv(data), data.subarray(2, -4)), out);
}
var Decompress = function() {
  function Decompress3(cb3) {
    this.G = Gunzip;
    this.I = Inflate;
    this.Z = Unzlib;
    this.ondata = cb3;
  }
  Decompress3.prototype.push = function(chunk, final) {
    if (!this.ondata)
      throw "no stream handler";
    if (!this.s) {
      if (this.p && this.p.length) {
        var n = new u8(this.p.length + chunk.length);
        n.set(this.p), n.set(chunk, this.p.length);
      } else
        this.p = chunk;
      if (this.p.length > 2) {
        var _this_1 = this;
        var cb3 = function() {
          _this_1.ondata.apply(_this_1, arguments);
        };
        this.s = this.p[0] == 31 && this.p[1] == 139 && this.p[2] == 8 ? new this.G(cb3) : (this.p[0] & 15) != 8 || this.p[0] >> 4 > 7 || (this.p[0] << 8 | this.p[1]) % 31 ? new this.I(cb3) : new this.Z(cb3);
        this.s.push(this.p, final);
        this.p = null;
      }
    } else
      this.s.push(chunk, final);
  };
  return Decompress3;
}();
var AsyncDecompress = function() {
  function AsyncDecompress3(cb3) {
    this.G = AsyncGunzip;
    this.I = AsyncInflate;
    this.Z = AsyncUnzlib;
    this.ondata = cb3;
  }
  AsyncDecompress3.prototype.push = function(chunk, final) {
    Decompress.prototype.push.call(this, chunk, final);
  };
  return AsyncDecompress3;
}();
var te = typeof TextEncoder != "undefined" && new TextEncoder();
var td = typeof TextDecoder != "undefined" && new TextDecoder();
var tds = 0;
try {
  td.decode(et, { stream: true });
  tds = 1;
} catch (e) {
}
var dutf8 = function(d) {
  for (var r = "", i3 = 0; ; ) {
    var c3 = d[i3++];
    var eb = (c3 > 127) + (c3 > 223) + (c3 > 239);
    if (i3 + eb > d.length)
      return [r, slc(d, i3 - 1)];
    if (!eb)
      r += String.fromCharCode(c3);
    else if (eb == 3) {
      c3 = ((c3 & 15) << 18 | (d[i3++] & 63) << 12 | (d[i3++] & 63) << 6 | d[i3++] & 63) - 65536, r += String.fromCharCode(55296 | c3 >> 10, 56320 | c3 & 1023);
    } else if (eb & 1)
      r += String.fromCharCode((c3 & 31) << 6 | d[i3++] & 63);
    else
      r += String.fromCharCode((c3 & 15) << 12 | (d[i3++] & 63) << 6 | d[i3++] & 63);
  }
};
var DecodeUTF8 = function() {
  function DecodeUTF83(cb3) {
    this.ondata = cb3;
    if (tds)
      this.t = new TextDecoder();
    else
      this.p = et;
  }
  DecodeUTF83.prototype.push = function(chunk, final) {
    if (!this.ondata)
      throw "no callback";
    final = !!final;
    if (this.t) {
      this.ondata(this.t.decode(chunk, { stream: true }), final);
      if (final) {
        if (this.t.decode().length)
          throw "invalid utf-8 data";
        this.t = null;
      }
      return;
    }
    if (!this.p)
      throw "stream finished";
    var dat = new u8(this.p.length + chunk.length);
    dat.set(this.p);
    dat.set(chunk, this.p.length);
    var _a4 = dutf8(dat), ch4 = _a4[0], np = _a4[1];
    if (final) {
      if (np.length)
        throw "invalid utf-8 data";
      this.p = null;
    } else
      this.p = np;
    this.ondata(ch4, final);
  };
  return DecodeUTF83;
}();
var EncodeUTF8 = function() {
  function EncodeUTF83(cb3) {
    this.ondata = cb3;
  }
  EncodeUTF83.prototype.push = function(chunk, final) {
    if (!this.ondata)
      throw "no callback";
    if (this.d)
      throw "stream finished";
    this.ondata(strToU8(chunk), this.d = final || false);
  };
  return EncodeUTF83;
}();
function strToU8(str, latin1) {
  if (latin1) {
    var ar_1 = new u8(str.length);
    for (var i3 = 0; i3 < str.length; ++i3)
      ar_1[i3] = str.charCodeAt(i3);
    return ar_1;
  }
  if (te)
    return te.encode(str);
  var l = str.length;
  var ar = new u8(str.length + (str.length >> 1));
  var ai = 0;
  var w = function(v) {
    ar[ai++] = v;
  };
  for (var i3 = 0; i3 < l; ++i3) {
    if (ai + 5 > ar.length) {
      var n = new u8(ai + 8 + (l - i3 << 1));
      n.set(ar);
      ar = n;
    }
    var c3 = str.charCodeAt(i3);
    if (c3 < 128 || latin1)
      w(c3);
    else if (c3 < 2048)
      w(192 | c3 >> 6), w(128 | c3 & 63);
    else if (c3 > 55295 && c3 < 57344)
      c3 = 65536 + (c3 & 1023 << 10) | str.charCodeAt(++i3) & 1023, w(240 | c3 >> 18), w(128 | c3 >> 12 & 63), w(128 | c3 >> 6 & 63), w(128 | c3 & 63);
    else
      w(224 | c3 >> 12), w(128 | c3 >> 6 & 63), w(128 | c3 & 63);
  }
  return slc(ar, 0, ai);
}
function strFromU8(dat, latin1) {
  if (latin1) {
    var r = "";
    for (var i3 = 0; i3 < dat.length; i3 += 16384)
      r += String.fromCharCode.apply(null, dat.subarray(i3, i3 + 16384));
    return r;
  } else if (td)
    return td.decode(dat);
  else {
    var _a4 = dutf8(dat), out = _a4[0], ext = _a4[1];
    if (ext.length)
      throw "invalid utf-8 data";
    return out;
  }
}
var dbf = function(l) {
  return l == 1 ? 3 : l < 6 ? 2 : l == 9 ? 1 : 0;
};
var z64e = function(d, b5) {
  for (; b2(d, b5) != 1; b5 += 4 + b2(d, b5 + 2))
    ;
  return [b8(d, b5 + 12), b8(d, b5 + 4), b8(d, b5 + 20)];
};
var exfl = function(ex) {
  var le = 0;
  if (ex) {
    for (var k in ex) {
      var l = ex[k].length;
      if (l > 65535)
        throw "extra field too long";
      le += l + 4;
    }
  }
  return le;
};
var wzh = function(d, b5, f, fn, u, c3, ce, co) {
  var fl3 = fn.length, ex = f.extra, col = co && co.length;
  var exl = exfl(ex);
  wbytes(d, b5, ce != null ? 33639248 : 67324752), b5 += 4;
  if (ce != null)
    d[b5++] = 20, d[b5++] = f.os;
  d[b5] = 20, b5 += 2;
  d[b5++] = f.flag << 1 | (c3 == null && 8), d[b5++] = u && 8;
  d[b5++] = f.compression & 255, d[b5++] = f.compression >> 8;
  var dt = new Date(f.mtime == null ? Date.now() : f.mtime), y = dt.getFullYear() - 1980;
  if (y < 0 || y > 119)
    throw "date not in range 1980-2099";
  wbytes(d, b5, y << 25 | dt.getMonth() + 1 << 21 | dt.getDate() << 16 | dt.getHours() << 11 | dt.getMinutes() << 5 | dt.getSeconds() >>> 1), b5 += 4;
  if (c3 != null) {
    wbytes(d, b5, f.crc);
    wbytes(d, b5 + 4, c3);
    wbytes(d, b5 + 8, f.size);
  }
  wbytes(d, b5 + 12, fl3);
  wbytes(d, b5 + 14, exl), b5 += 16;
  if (ce != null) {
    wbytes(d, b5, col);
    wbytes(d, b5 + 6, f.attrs);
    wbytes(d, b5 + 10, ce), b5 += 14;
  }
  d.set(fn, b5);
  b5 += fl3;
  if (exl) {
    for (var k in ex) {
      var exf = ex[k], l = exf.length;
      wbytes(d, b5, +k);
      wbytes(d, b5 + 2, l);
      d.set(exf, b5 + 4), b5 += 4 + l;
    }
  }
  if (col)
    d.set(co, b5), b5 += col;
  return b5;
};
var wzf = function(o, b5, c3, d, e) {
  wbytes(o, b5, 101010256);
  wbytes(o, b5 + 8, c3);
  wbytes(o, b5 + 10, c3);
  wbytes(o, b5 + 12, d);
  wbytes(o, b5 + 16, e);
};
var ZipPassThrough = function() {
  function ZipPassThrough3(filename) {
    this.filename = filename;
    this.c = crc();
    this.size = 0;
    this.compression = 0;
  }
  ZipPassThrough3.prototype.process = function(chunk, final) {
    this.ondata(null, chunk, final);
  };
  ZipPassThrough3.prototype.push = function(chunk, final) {
    if (!this.ondata)
      throw "no callback - add to ZIP archive before pushing";
    this.c.p(chunk);
    this.size += chunk.length;
    if (final)
      this.crc = this.c.d();
    this.process(chunk, final || false);
  };
  return ZipPassThrough3;
}();
var ZipDeflate = function() {
  function ZipDeflate3(filename, opts) {
    var _this_1 = this;
    if (!opts)
      opts = {};
    ZipPassThrough.call(this, filename);
    this.d = new Deflate(opts, function(dat, final) {
      _this_1.ondata(null, dat, final);
    });
    this.compression = 8;
    this.flag = dbf(opts.level);
  }
  ZipDeflate3.prototype.process = function(chunk, final) {
    try {
      this.d.push(chunk, final);
    } catch (e) {
      this.ondata(e, null, final);
    }
  };
  ZipDeflate3.prototype.push = function(chunk, final) {
    ZipPassThrough.prototype.push.call(this, chunk, final);
  };
  return ZipDeflate3;
}();
var AsyncZipDeflate = function() {
  function AsyncZipDeflate3(filename, opts) {
    var _this_1 = this;
    if (!opts)
      opts = {};
    ZipPassThrough.call(this, filename);
    this.d = new AsyncDeflate(opts, function(err, dat, final) {
      _this_1.ondata(err, dat, final);
    });
    this.compression = 8;
    this.flag = dbf(opts.level);
    this.terminate = this.d.terminate;
  }
  AsyncZipDeflate3.prototype.process = function(chunk, final) {
    this.d.push(chunk, final);
  };
  AsyncZipDeflate3.prototype.push = function(chunk, final) {
    ZipPassThrough.prototype.push.call(this, chunk, final);
  };
  return AsyncZipDeflate3;
}();
var Zip = function() {
  function Zip3(cb3) {
    this.ondata = cb3;
    this.u = [];
    this.d = 1;
  }
  Zip3.prototype.add = function(file) {
    var _this_1 = this;
    if (this.d & 2)
      throw "stream finished";
    var f = strToU8(file.filename), fl3 = f.length;
    var com = file.comment, o = com && strToU8(com);
    var u = fl3 != file.filename.length || o && com.length != o.length;
    var hl = fl3 + exfl(file.extra) + 30;
    if (fl3 > 65535)
      throw "filename too long";
    var header = new u8(hl);
    wzh(header, 0, file, f, u);
    var chks = [header];
    var pAll = function() {
      for (var _i = 0, chks_1 = chks; _i < chks_1.length; _i++) {
        var chk = chks_1[_i];
        _this_1.ondata(null, chk, false);
      }
      chks = [];
    };
    var tr = this.d;
    this.d = 0;
    var ind = this.u.length;
    var uf = mrg(file, {
      f,
      u,
      o,
      t: function() {
        if (file.terminate)
          file.terminate();
      },
      r: function() {
        pAll();
        if (tr) {
          var nxt = _this_1.u[ind + 1];
          if (nxt)
            nxt.r();
          else
            _this_1.d = 1;
        }
        tr = 1;
      }
    });
    var cl = 0;
    file.ondata = function(err, dat, final) {
      if (err) {
        _this_1.ondata(err, dat, final);
        _this_1.terminate();
      } else {
        cl += dat.length;
        chks.push(dat);
        if (final) {
          var dd = new u8(16);
          wbytes(dd, 0, 134695760);
          wbytes(dd, 4, file.crc);
          wbytes(dd, 8, cl);
          wbytes(dd, 12, file.size);
          chks.push(dd);
          uf.c = cl, uf.b = hl + cl + 16, uf.crc = file.crc, uf.size = file.size;
          if (tr)
            uf.r();
          tr = 1;
        } else if (tr)
          pAll();
      }
    };
    this.u.push(uf);
  };
  Zip3.prototype.end = function() {
    var _this_1 = this;
    if (this.d & 2) {
      if (this.d & 1)
        throw "stream finishing";
      throw "stream finished";
    }
    if (this.d)
      this.e();
    else
      this.u.push({
        r: function() {
          if (!(_this_1.d & 1))
            return;
          _this_1.u.splice(-1, 1);
          _this_1.e();
        },
        t: function() {
        }
      });
    this.d = 3;
  };
  Zip3.prototype.e = function() {
    var bt = 0, l = 0, tl = 0;
    for (var _i = 0, _a4 = this.u; _i < _a4.length; _i++) {
      var f = _a4[_i];
      tl += 46 + f.f.length + exfl(f.extra) + (f.o ? f.o.length : 0);
    }
    var out = new u8(tl + 22);
    for (var _b4 = 0, _c = this.u; _b4 < _c.length; _b4++) {
      var f = _c[_b4];
      wzh(out, bt, f, f.f, f.u, f.c, l, f.o);
      bt += 46 + f.f.length + exfl(f.extra) + (f.o ? f.o.length : 0), l += f.b;
    }
    wzf(out, bt, this.u.length, tl, l);
    this.ondata(null, out, true);
    this.d = 2;
  };
  Zip3.prototype.terminate = function() {
    for (var _i = 0, _a4 = this.u; _i < _a4.length; _i++) {
      var f = _a4[_i];
      f.t();
    }
    this.d = 2;
  };
  return Zip3;
}();
var UnzipPassThrough = function() {
  function UnzipPassThrough3() {
  }
  UnzipPassThrough3.prototype.push = function(data, final) {
    this.ondata(null, data, final);
  };
  UnzipPassThrough3.compression = 0;
  return UnzipPassThrough3;
}();
var UnzipInflate = function() {
  function UnzipInflate3() {
    var _this_1 = this;
    this.i = new Inflate(function(dat, final) {
      _this_1.ondata(null, dat, final);
    });
  }
  UnzipInflate3.prototype.push = function(data, final) {
    try {
      this.i.push(data, final);
    } catch (e) {
      this.ondata(e, data, final);
    }
  };
  UnzipInflate3.compression = 8;
  return UnzipInflate3;
}();
var AsyncUnzipInflate = function() {
  function AsyncUnzipInflate3(_, sz) {
    var _this_1 = this;
    if (sz < 32e4) {
      this.i = new Inflate(function(dat, final) {
        _this_1.ondata(null, dat, final);
      });
    } else {
      this.i = new AsyncInflate(function(err, dat, final) {
        _this_1.ondata(err, dat, final);
      });
      this.terminate = this.i.terminate;
    }
  }
  AsyncUnzipInflate3.prototype.push = function(data, final) {
    if (this.i.terminate)
      data = slc(data, 0);
    this.i.push(data, final);
  };
  AsyncUnzipInflate3.compression = 8;
  return AsyncUnzipInflate3;
}();
var Unzip = function() {
  function Unzip3(cb3) {
    this.onfile = cb3;
    this.k = [];
    this.o = {
      0: UnzipPassThrough
    };
    this.p = et;
  }
  Unzip3.prototype.push = function(chunk, final) {
    var _this_1 = this;
    if (!this.onfile)
      throw "no callback";
    if (!this.p)
      throw "stream finished";
    if (this.c > 0) {
      var len = Math.min(this.c, chunk.length);
      var toAdd = chunk.subarray(0, len);
      this.c -= len;
      if (this.d)
        this.d.push(toAdd, !this.c);
      else
        this.k[0].push(toAdd);
      chunk = chunk.subarray(len);
      if (chunk.length)
        return this.push(chunk, final);
    } else {
      var f = 0, i3 = 0, is = void 0, buf = void 0;
      if (!this.p.length)
        buf = chunk;
      else if (!chunk.length)
        buf = this.p;
      else {
        buf = new u8(this.p.length + chunk.length);
        buf.set(this.p), buf.set(chunk, this.p.length);
      }
      var l = buf.length, oc = this.c, add = oc && this.d;
      var _loop_2 = function() {
        var _a4;
        var sig = b4(buf, i3);
        if (sig == 67324752) {
          f = 1, is = i3;
          this_1.d = null;
          this_1.c = 0;
          var bf = b2(buf, i3 + 6), cmp_1 = b2(buf, i3 + 8), u = bf & 2048, dd = bf & 8, fnl = b2(buf, i3 + 26), es = b2(buf, i3 + 28);
          if (l > i3 + 30 + fnl + es) {
            var chks_2 = [];
            this_1.k.unshift(chks_2);
            f = 2;
            var sc_1 = b4(buf, i3 + 18), su_1 = b4(buf, i3 + 22);
            var fn_1 = strFromU8(buf.subarray(i3 + 30, i3 += 30 + fnl), !u);
            if (sc_1 == 4294967295) {
              _a4 = dd ? [-2] : z64e(buf, i3), sc_1 = _a4[0], su_1 = _a4[1];
            } else if (dd)
              sc_1 = -1;
            i3 += es;
            this_1.c = sc_1;
            var d_1;
            var file_1 = {
              name: fn_1,
              compression: cmp_1,
              start: function() {
                if (!file_1.ondata)
                  throw "no callback";
                if (!sc_1)
                  file_1.ondata(null, et, true);
                else {
                  var ctr = _this_1.o[cmp_1];
                  if (!ctr)
                    throw "unknown compression type " + cmp_1;
                  d_1 = sc_1 < 0 ? new ctr(fn_1) : new ctr(fn_1, sc_1, su_1);
                  d_1.ondata = function(err, dat3, final2) {
                    file_1.ondata(err, dat3, final2);
                  };
                  for (var _i = 0, chks_3 = chks_2; _i < chks_3.length; _i++) {
                    var dat2 = chks_3[_i];
                    d_1.push(dat2, false);
                  }
                  if (_this_1.k[0] == chks_2 && _this_1.c)
                    _this_1.d = d_1;
                  else
                    d_1.push(et, true);
                }
              },
              terminate: function() {
                if (d_1 && d_1.terminate)
                  d_1.terminate();
              }
            };
            if (sc_1 >= 0)
              file_1.size = sc_1, file_1.originalSize = su_1;
            this_1.onfile(file_1);
          }
          return "break";
        } else if (oc) {
          if (sig == 134695760) {
            is = i3 += 12 + (oc == -2 && 8), f = 3, this_1.c = 0;
            return "break";
          } else if (sig == 33639248) {
            is = i3 -= 4, f = 3, this_1.c = 0;
            return "break";
          }
        }
      };
      var this_1 = this;
      for (; i3 < l - 4; ++i3) {
        var state_1 = _loop_2();
        if (state_1 === "break")
          break;
      }
      this.p = et;
      if (oc < 0) {
        var dat = f ? buf.subarray(0, is - 12 - (oc == -2 && 8) - (b4(buf, is - 16) == 134695760 && 4)) : buf.subarray(0, i3);
        if (add)
          add.push(dat, !!f);
        else
          this.k[+(f == 2)].push(dat);
      }
      if (f & 2)
        return this.push(buf.subarray(i3), final);
      this.p = buf.subarray(i3);
    }
    if (final) {
      if (this.c)
        throw "invalid zip file";
      this.p = null;
    }
  };
  Unzip3.prototype.register = function(decoder) {
    this.o[decoder.compression] = decoder;
  };
  return Unzip3;
}();

// node_modules/three-stdlib/exporters/DRACOExporter.js
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField2 = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var _DRACOExporter = class {
  parse(object, options = {
    decodeSpeed: 5,
    encodeSpeed: 5,
    encoderMethod: _DRACOExporter.MESH_EDGEBREAKER_ENCODING,
    quantization: [16, 8, 8, 8, 8],
    exportUvs: true,
    exportNormals: true,
    exportColor: false
  }) {
    if (object instanceof BufferGeometry && object.isBufferGeometry) {
      throw new Error("DRACOExporter: The first parameter of parse() is now an instance of Mesh or Points.");
    }
    if (DracoEncoderModule === void 0) {
      throw new Error("THREE.DRACOExporter: required the draco_encoder to work.");
    }
    const geometry2 = object.geometry;
    const dracoEncoder = DracoEncoderModule();
    const encoder = new dracoEncoder.Encoder();
    let builder;
    let dracoObject;
    if (!geometry2.isBufferGeometry) {
      throw new Error("THREE.DRACOExporter.parse(geometry, options): geometry is not a THREE.BufferGeometry instance.");
    }
    if (object instanceof Mesh && object.isMesh) {
      builder = new dracoEncoder.MeshBuilder();
      dracoObject = new dracoEncoder.Mesh();
      const vertices = geometry2.getAttribute("position");
      builder.AddFloatAttributeToMesh(
        dracoObject,
        dracoEncoder.POSITION,
        vertices.count,
        vertices.itemSize,
        vertices.array
      );
      const faces = geometry2.getIndex();
      if (faces !== null) {
        builder.AddFacesToMesh(dracoObject, faces.count / 3, faces.array);
      } else {
        const faces2 = new (vertices.count > 65535 ? Uint32Array : Uint16Array)(vertices.count);
        for (let i3 = 0; i3 < faces2.length; i3++) {
          faces2[i3] = i3;
        }
        builder.AddFacesToMesh(dracoObject, vertices.count, faces2);
      }
      if (options.exportNormals) {
        const normals = geometry2.getAttribute("normal");
        if (normals !== void 0) {
          builder.AddFloatAttributeToMesh(
            dracoObject,
            dracoEncoder.NORMAL,
            normals.count,
            normals.itemSize,
            normals.array
          );
        }
      }
      if (options.exportUvs) {
        const uvs = geometry2.getAttribute("uv");
        if (uvs !== void 0) {
          builder.AddFloatAttributeToMesh(dracoObject, dracoEncoder.TEX_COORD, uvs.count, uvs.itemSize, uvs.array);
        }
      }
      if (options.exportColor) {
        const colors = geometry2.getAttribute("color");
        if (colors !== void 0) {
          builder.AddFloatAttributeToMesh(dracoObject, dracoEncoder.COLOR, colors.count, colors.itemSize, colors.array);
        }
      }
    } else if (object instanceof Points && object.isPoints) {
      builder = new dracoEncoder.PointCloudBuilder();
      dracoObject = new dracoEncoder.PointCloud();
      const vertices = geometry2.getAttribute("position");
      builder.AddFloatAttribute(dracoObject, dracoEncoder.POSITION, vertices.count, vertices.itemSize, vertices.array);
      if (options.exportColor) {
        const colors = geometry2.getAttribute("color");
        if (colors !== void 0) {
          builder.AddFloatAttribute(dracoObject, dracoEncoder.COLOR, colors.count, colors.itemSize, colors.array);
        }
      }
    } else {
      throw new Error("DRACOExporter: Unsupported object type.");
    }
    const encodedData = new dracoEncoder.DracoInt8Array();
    const encodeSpeed = options.encodeSpeed !== void 0 ? options.encodeSpeed : 5;
    const decodeSpeed = options.decodeSpeed !== void 0 ? options.decodeSpeed : 5;
    encoder.SetSpeedOptions(encodeSpeed, decodeSpeed);
    if (options.encoderMethod !== void 0) {
      encoder.SetEncodingMethod(options.encoderMethod);
    }
    if (options.quantization !== void 0) {
      for (let i3 = 0; i3 < 5; i3++) {
        if (options.quantization[i3] !== void 0) {
          encoder.SetAttributeQuantization(i3, options.quantization[i3]);
        }
      }
    }
    let length;
    if (object instanceof Mesh && object.isMesh) {
      length = encoder.EncodeMeshToDracoBuffer(dracoObject, encodedData);
    } else {
      length = encoder.EncodePointCloudToDracoBuffer(dracoObject, true, encodedData);
    }
    dracoEncoder.destroy(dracoObject);
    if (length === 0) {
      throw new Error("THREE.DRACOExporter: Draco encoding failed.");
    }
    const outputData = new Int8Array(new ArrayBuffer(length));
    for (let i3 = 0; i3 < length; i3++) {
      outputData[i3] = encodedData.GetValue(i3);
    }
    dracoEncoder.destroy(encodedData);
    dracoEncoder.destroy(encoder);
    dracoEncoder.destroy(builder);
    return outputData;
  }
};
var DRACOExporter = _DRACOExporter;
__publicField2(DRACOExporter, "MESH_EDGEBREAKER_ENCODING", 1);
__publicField2(DRACOExporter, "MESH_SEQUENTIAL_ENCODING", 0);
__publicField2(DRACOExporter, "POINT_CLOUD", 0);
__publicField2(DRACOExporter, "TRIANGULAR_MESH", 1);
__publicField2(DRACOExporter, "INVALID", -1);
__publicField2(DRACOExporter, "POSITION", 0);
__publicField2(DRACOExporter, "NORMAL", 1);
__publicField2(DRACOExporter, "COLOR", 2);
__publicField2(DRACOExporter, "TEX_COORD", 3);
__publicField2(DRACOExporter, "GENERIC", 4);

// node_modules/mmd-parser/build/mmdparser.module.js
function CharsetEncoder() {
}
CharsetEncoder.prototype.s2u = function(uint8Array) {
  var t2 = this.s2uTable;
  var str = "";
  var p = 0;
  while (p < uint8Array.length) {
    var key = uint8Array[p++];
    if (!(key >= 0 && key <= 126 || key >= 161 && key <= 223) && p < uint8Array.length) {
      key = key << 8 | uint8Array[p++];
    }
    if (t2[key] === void 0) {
      console.error("unknown char code " + key + ".");
      return str;
    }
    str += String.fromCharCode(t2[key]);
  }
  return str;
};
CharsetEncoder.prototype.s2uTable = {
  0: 0,
  1: 1,
  2: 2,
  3: 3,
  4: 4,
  5: 5,
  6: 6,
  7: 7,
  8: 8,
  9: 9,
  10: 10,
  11: 11,
  12: 12,
  13: 13,
  14: 14,
  15: 15,
  16: 16,
  17: 17,
  18: 18,
  19: 19,
  20: 20,
  21: 21,
  22: 22,
  23: 23,
  24: 24,
  25: 25,
  26: 26,
  27: 27,
  28: 28,
  29: 29,
  30: 30,
  31: 31,
  32: 32,
  33: 33,
  34: 34,
  35: 35,
  36: 36,
  37: 37,
  38: 38,
  39: 39,
  40: 40,
  41: 41,
  42: 42,
  43: 43,
  44: 44,
  45: 45,
  46: 46,
  47: 47,
  48: 48,
  49: 49,
  50: 50,
  51: 51,
  52: 52,
  53: 53,
  54: 54,
  55: 55,
  56: 56,
  57: 57,
  58: 58,
  59: 59,
  60: 60,
  61: 61,
  62: 62,
  63: 63,
  64: 64,
  65: 65,
  66: 66,
  67: 67,
  68: 68,
  69: 69,
  70: 70,
  71: 71,
  72: 72,
  73: 73,
  74: 74,
  75: 75,
  76: 76,
  77: 77,
  78: 78,
  79: 79,
  80: 80,
  81: 81,
  82: 82,
  83: 83,
  84: 84,
  85: 85,
  86: 86,
  87: 87,
  88: 88,
  89: 89,
  90: 90,
  91: 91,
  92: 92,
  93: 93,
  94: 94,
  95: 95,
  96: 96,
  97: 97,
  98: 98,
  99: 99,
  100: 100,
  101: 101,
  102: 102,
  103: 103,
  104: 104,
  105: 105,
  106: 106,
  107: 107,
  108: 108,
  109: 109,
  110: 110,
  111: 111,
  112: 112,
  113: 113,
  114: 114,
  115: 115,
  116: 116,
  117: 117,
  118: 118,
  119: 119,
  120: 120,
  121: 121,
  122: 122,
  123: 123,
  124: 124,
  125: 125,
  126: 126,
  161: 65377,
  162: 65378,
  163: 65379,
  164: 65380,
  165: 65381,
  166: 65382,
  167: 65383,
  168: 65384,
  169: 65385,
  170: 65386,
  171: 65387,
  172: 65388,
  173: 65389,
  174: 65390,
  175: 65391,
  176: 65392,
  177: 65393,
  178: 65394,
  179: 65395,
  180: 65396,
  181: 65397,
  182: 65398,
  183: 65399,
  184: 65400,
  185: 65401,
  186: 65402,
  187: 65403,
  188: 65404,
  189: 65405,
  190: 65406,
  191: 65407,
  192: 65408,
  193: 65409,
  194: 65410,
  195: 65411,
  196: 65412,
  197: 65413,
  198: 65414,
  199: 65415,
  200: 65416,
  201: 65417,
  202: 65418,
  203: 65419,
  204: 65420,
  205: 65421,
  206: 65422,
  207: 65423,
  208: 65424,
  209: 65425,
  210: 65426,
  211: 65427,
  212: 65428,
  213: 65429,
  214: 65430,
  215: 65431,
  216: 65432,
  217: 65433,
  218: 65434,
  219: 65435,
  220: 65436,
  221: 65437,
  222: 65438,
  223: 65439,
  33088: 12288,
  33089: 12289,
  33090: 12290,
  33091: 65292,
  33092: 65294,
  33093: 12539,
  33094: 65306,
  33095: 65307,
  33096: 65311,
  33097: 65281,
  33098: 12443,
  33099: 12444,
  33100: 180,
  33101: 65344,
  33102: 168,
  33103: 65342,
  33104: 65507,
  33105: 65343,
  33106: 12541,
  33107: 12542,
  33108: 12445,
  33109: 12446,
  33110: 12291,
  33111: 20189,
  33112: 12293,
  33113: 12294,
  33114: 12295,
  33115: 12540,
  33116: 8213,
  33117: 8208,
  33118: 65295,
  33119: 65340,
  33120: 65374,
  33121: 8741,
  33122: 65372,
  33123: 8230,
  33124: 8229,
  33125: 8216,
  33126: 8217,
  33127: 8220,
  33128: 8221,
  33129: 65288,
  33130: 65289,
  33131: 12308,
  33132: 12309,
  33133: 65339,
  33134: 65341,
  33135: 65371,
  33136: 65373,
  33137: 12296,
  33138: 12297,
  33139: 12298,
  33140: 12299,
  33141: 12300,
  33142: 12301,
  33143: 12302,
  33144: 12303,
  33145: 12304,
  33146: 12305,
  33147: 65291,
  33148: 65293,
  33149: 177,
  33150: 215,
  33152: 247,
  33153: 65309,
  33154: 8800,
  33155: 65308,
  33156: 65310,
  33157: 8806,
  33158: 8807,
  33159: 8734,
  33160: 8756,
  33161: 9794,
  33162: 9792,
  33163: 176,
  33164: 8242,
  33165: 8243,
  33166: 8451,
  33167: 65509,
  33168: 65284,
  33169: 65504,
  33170: 65505,
  33171: 65285,
  33172: 65283,
  33173: 65286,
  33174: 65290,
  33175: 65312,
  33176: 167,
  33177: 9734,
  33178: 9733,
  33179: 9675,
  33180: 9679,
  33181: 9678,
  33182: 9671,
  33183: 9670,
  33184: 9633,
  33185: 9632,
  33186: 9651,
  33187: 9650,
  33188: 9661,
  33189: 9660,
  33190: 8251,
  33191: 12306,
  33192: 8594,
  33193: 8592,
  33194: 8593,
  33195: 8595,
  33196: 12307,
  33208: 8712,
  33209: 8715,
  33210: 8838,
  33211: 8839,
  33212: 8834,
  33213: 8835,
  33214: 8746,
  33215: 8745,
  33224: 8743,
  33225: 8744,
  33226: 65506,
  33227: 8658,
  33228: 8660,
  33229: 8704,
  33230: 8707,
  33242: 8736,
  33243: 8869,
  33244: 8978,
  33245: 8706,
  33246: 8711,
  33247: 8801,
  33248: 8786,
  33249: 8810,
  33250: 8811,
  33251: 8730,
  33252: 8765,
  33253: 8733,
  33254: 8757,
  33255: 8747,
  33256: 8748,
  33264: 8491,
  33265: 8240,
  33266: 9839,
  33267: 9837,
  33268: 9834,
  33269: 8224,
  33270: 8225,
  33271: 182,
  33276: 9711,
  33359: 65296,
  33360: 65297,
  33361: 65298,
  33362: 65299,
  33363: 65300,
  33364: 65301,
  33365: 65302,
  33366: 65303,
  33367: 65304,
  33368: 65305,
  33376: 65313,
  33377: 65314,
  33378: 65315,
  33379: 65316,
  33380: 65317,
  33381: 65318,
  33382: 65319,
  33383: 65320,
  33384: 65321,
  33385: 65322,
  33386: 65323,
  33387: 65324,
  33388: 65325,
  33389: 65326,
  33390: 65327,
  33391: 65328,
  33392: 65329,
  33393: 65330,
  33394: 65331,
  33395: 65332,
  33396: 65333,
  33397: 65334,
  33398: 65335,
  33399: 65336,
  33400: 65337,
  33401: 65338,
  33409: 65345,
  33410: 65346,
  33411: 65347,
  33412: 65348,
  33413: 65349,
  33414: 65350,
  33415: 65351,
  33416: 65352,
  33417: 65353,
  33418: 65354,
  33419: 65355,
  33420: 65356,
  33421: 65357,
  33422: 65358,
  33423: 65359,
  33424: 65360,
  33425: 65361,
  33426: 65362,
  33427: 65363,
  33428: 65364,
  33429: 65365,
  33430: 65366,
  33431: 65367,
  33432: 65368,
  33433: 65369,
  33434: 65370,
  33439: 12353,
  33440: 12354,
  33441: 12355,
  33442: 12356,
  33443: 12357,
  33444: 12358,
  33445: 12359,
  33446: 12360,
  33447: 12361,
  33448: 12362,
  33449: 12363,
  33450: 12364,
  33451: 12365,
  33452: 12366,
  33453: 12367,
  33454: 12368,
  33455: 12369,
  33456: 12370,
  33457: 12371,
  33458: 12372,
  33459: 12373,
  33460: 12374,
  33461: 12375,
  33462: 12376,
  33463: 12377,
  33464: 12378,
  33465: 12379,
  33466: 12380,
  33467: 12381,
  33468: 12382,
  33469: 12383,
  33470: 12384,
  33471: 12385,
  33472: 12386,
  33473: 12387,
  33474: 12388,
  33475: 12389,
  33476: 12390,
  33477: 12391,
  33478: 12392,
  33479: 12393,
  33480: 12394,
  33481: 12395,
  33482: 12396,
  33483: 12397,
  33484: 12398,
  33485: 12399,
  33486: 12400,
  33487: 12401,
  33488: 12402,
  33489: 12403,
  33490: 12404,
  33491: 12405,
  33492: 12406,
  33493: 12407,
  33494: 12408,
  33495: 12409,
  33496: 12410,
  33497: 12411,
  33498: 12412,
  33499: 12413,
  33500: 12414,
  33501: 12415,
  33502: 12416,
  33503: 12417,
  33504: 12418,
  33505: 12419,
  33506: 12420,
  33507: 12421,
  33508: 12422,
  33509: 12423,
  33510: 12424,
  33511: 12425,
  33512: 12426,
  33513: 12427,
  33514: 12428,
  33515: 12429,
  33516: 12430,
  33517: 12431,
  33518: 12432,
  33519: 12433,
  33520: 12434,
  33521: 12435,
  33600: 12449,
  33601: 12450,
  33602: 12451,
  33603: 12452,
  33604: 12453,
  33605: 12454,
  33606: 12455,
  33607: 12456,
  33608: 12457,
  33609: 12458,
  33610: 12459,
  33611: 12460,
  33612: 12461,
  33613: 12462,
  33614: 12463,
  33615: 12464,
  33616: 12465,
  33617: 12466,
  33618: 12467,
  33619: 12468,
  33620: 12469,
  33621: 12470,
  33622: 12471,
  33623: 12472,
  33624: 12473,
  33625: 12474,
  33626: 12475,
  33627: 12476,
  33628: 12477,
  33629: 12478,
  33630: 12479,
  33631: 12480,
  33632: 12481,
  33633: 12482,
  33634: 12483,
  33635: 12484,
  33636: 12485,
  33637: 12486,
  33638: 12487,
  33639: 12488,
  33640: 12489,
  33641: 12490,
  33642: 12491,
  33643: 12492,
  33644: 12493,
  33645: 12494,
  33646: 12495,
  33647: 12496,
  33648: 12497,
  33649: 12498,
  33650: 12499,
  33651: 12500,
  33652: 12501,
  33653: 12502,
  33654: 12503,
  33655: 12504,
  33656: 12505,
  33657: 12506,
  33658: 12507,
  33659: 12508,
  33660: 12509,
  33661: 12510,
  33662: 12511,
  33664: 12512,
  33665: 12513,
  33666: 12514,
  33667: 12515,
  33668: 12516,
  33669: 12517,
  33670: 12518,
  33671: 12519,
  33672: 12520,
  33673: 12521,
  33674: 12522,
  33675: 12523,
  33676: 12524,
  33677: 12525,
  33678: 12526,
  33679: 12527,
  33680: 12528,
  33681: 12529,
  33682: 12530,
  33683: 12531,
  33684: 12532,
  33685: 12533,
  33686: 12534,
  33695: 913,
  33696: 914,
  33697: 915,
  33698: 916,
  33699: 917,
  33700: 918,
  33701: 919,
  33702: 920,
  33703: 921,
  33704: 922,
  33705: 923,
  33706: 924,
  33707: 925,
  33708: 926,
  33709: 927,
  33710: 928,
  33711: 929,
  33712: 931,
  33713: 932,
  33714: 933,
  33715: 934,
  33716: 935,
  33717: 936,
  33718: 937,
  33727: 945,
  33728: 946,
  33729: 947,
  33730: 948,
  33731: 949,
  33732: 950,
  33733: 951,
  33734: 952,
  33735: 953,
  33736: 954,
  33737: 955,
  33738: 956,
  33739: 957,
  33740: 958,
  33741: 959,
  33742: 960,
  33743: 961,
  33744: 963,
  33745: 964,
  33746: 965,
  33747: 966,
  33748: 967,
  33749: 968,
  33750: 969,
  33856: 1040,
  33857: 1041,
  33858: 1042,
  33859: 1043,
  33860: 1044,
  33861: 1045,
  33862: 1025,
  33863: 1046,
  33864: 1047,
  33865: 1048,
  33866: 1049,
  33867: 1050,
  33868: 1051,
  33869: 1052,
  33870: 1053,
  33871: 1054,
  33872: 1055,
  33873: 1056,
  33874: 1057,
  33875: 1058,
  33876: 1059,
  33877: 1060,
  33878: 1061,
  33879: 1062,
  33880: 1063,
  33881: 1064,
  33882: 1065,
  33883: 1066,
  33884: 1067,
  33885: 1068,
  33886: 1069,
  33887: 1070,
  33888: 1071,
  33904: 1072,
  33905: 1073,
  33906: 1074,
  33907: 1075,
  33908: 1076,
  33909: 1077,
  33910: 1105,
  33911: 1078,
  33912: 1079,
  33913: 1080,
  33914: 1081,
  33915: 1082,
  33916: 1083,
  33917: 1084,
  33918: 1085,
  33920: 1086,
  33921: 1087,
  33922: 1088,
  33923: 1089,
  33924: 1090,
  33925: 1091,
  33926: 1092,
  33927: 1093,
  33928: 1094,
  33929: 1095,
  33930: 1096,
  33931: 1097,
  33932: 1098,
  33933: 1099,
  33934: 1100,
  33935: 1101,
  33936: 1102,
  33937: 1103,
  33951: 9472,
  33952: 9474,
  33953: 9484,
  33954: 9488,
  33955: 9496,
  33956: 9492,
  33957: 9500,
  33958: 9516,
  33959: 9508,
  33960: 9524,
  33961: 9532,
  33962: 9473,
  33963: 9475,
  33964: 9487,
  33965: 9491,
  33966: 9499,
  33967: 9495,
  33968: 9507,
  33969: 9523,
  33970: 9515,
  33971: 9531,
  33972: 9547,
  33973: 9504,
  33974: 9519,
  33975: 9512,
  33976: 9527,
  33977: 9535,
  33978: 9501,
  33979: 9520,
  33980: 9509,
  33981: 9528,
  33982: 9538,
  34624: 9312,
  34625: 9313,
  34626: 9314,
  34627: 9315,
  34628: 9316,
  34629: 9317,
  34630: 9318,
  34631: 9319,
  34632: 9320,
  34633: 9321,
  34634: 9322,
  34635: 9323,
  34636: 9324,
  34637: 9325,
  34638: 9326,
  34639: 9327,
  34640: 9328,
  34641: 9329,
  34642: 9330,
  34643: 9331,
  34644: 8544,
  34645: 8545,
  34646: 8546,
  34647: 8547,
  34648: 8548,
  34649: 8549,
  34650: 8550,
  34651: 8551,
  34652: 8552,
  34653: 8553,
  34655: 13129,
  34656: 13076,
  34657: 13090,
  34658: 13133,
  34659: 13080,
  34660: 13095,
  34661: 13059,
  34662: 13110,
  34663: 13137,
  34664: 13143,
  34665: 13069,
  34666: 13094,
  34667: 13091,
  34668: 13099,
  34669: 13130,
  34670: 13115,
  34671: 13212,
  34672: 13213,
  34673: 13214,
  34674: 13198,
  34675: 13199,
  34676: 13252,
  34677: 13217,
  34686: 13179,
  34688: 12317,
  34689: 12319,
  34690: 8470,
  34691: 13261,
  34692: 8481,
  34693: 12964,
  34694: 12965,
  34695: 12966,
  34696: 12967,
  34697: 12968,
  34698: 12849,
  34699: 12850,
  34700: 12857,
  34701: 13182,
  34702: 13181,
  34703: 13180,
  34704: 8786,
  34705: 8801,
  34706: 8747,
  34707: 8750,
  34708: 8721,
  34709: 8730,
  34710: 8869,
  34711: 8736,
  34712: 8735,
  34713: 8895,
  34714: 8757,
  34715: 8745,
  34716: 8746,
  34975: 20124,
  34976: 21782,
  34977: 23043,
  34978: 38463,
  34979: 21696,
  34980: 24859,
  34981: 25384,
  34982: 23030,
  34983: 36898,
  34984: 33909,
  34985: 33564,
  34986: 31312,
  34987: 24746,
  34988: 25569,
  34989: 28197,
  34990: 26093,
  34991: 33894,
  34992: 33446,
  34993: 39925,
  34994: 26771,
  34995: 22311,
  34996: 26017,
  34997: 25201,
  34998: 23451,
  34999: 22992,
  35e3: 34427,
  35001: 39156,
  35002: 32098,
  35003: 32190,
  35004: 39822,
  35005: 25110,
  35006: 31903,
  35007: 34999,
  35008: 23433,
  35009: 24245,
  35010: 25353,
  35011: 26263,
  35012: 26696,
  35013: 38343,
  35014: 38797,
  35015: 26447,
  35016: 20197,
  35017: 20234,
  35018: 20301,
  35019: 20381,
  35020: 20553,
  35021: 22258,
  35022: 22839,
  35023: 22996,
  35024: 23041,
  35025: 23561,
  35026: 24799,
  35027: 24847,
  35028: 24944,
  35029: 26131,
  35030: 26885,
  35031: 28858,
  35032: 30031,
  35033: 30064,
  35034: 31227,
  35035: 32173,
  35036: 32239,
  35037: 32963,
  35038: 33806,
  35039: 34915,
  35040: 35586,
  35041: 36949,
  35042: 36986,
  35043: 21307,
  35044: 20117,
  35045: 20133,
  35046: 22495,
  35047: 32946,
  35048: 37057,
  35049: 30959,
  35050: 19968,
  35051: 22769,
  35052: 28322,
  35053: 36920,
  35054: 31282,
  35055: 33576,
  35056: 33419,
  35057: 39983,
  35058: 20801,
  35059: 21360,
  35060: 21693,
  35061: 21729,
  35062: 22240,
  35063: 23035,
  35064: 24341,
  35065: 39154,
  35066: 28139,
  35067: 32996,
  35068: 34093,
  35136: 38498,
  35137: 38512,
  35138: 38560,
  35139: 38907,
  35140: 21515,
  35141: 21491,
  35142: 23431,
  35143: 28879,
  35144: 32701,
  35145: 36802,
  35146: 38632,
  35147: 21359,
  35148: 40284,
  35149: 31418,
  35150: 19985,
  35151: 30867,
  35152: 33276,
  35153: 28198,
  35154: 22040,
  35155: 21764,
  35156: 27421,
  35157: 34074,
  35158: 39995,
  35159: 23013,
  35160: 21417,
  35161: 28006,
  35162: 29916,
  35163: 38287,
  35164: 22082,
  35165: 20113,
  35166: 36939,
  35167: 38642,
  35168: 33615,
  35169: 39180,
  35170: 21473,
  35171: 21942,
  35172: 23344,
  35173: 24433,
  35174: 26144,
  35175: 26355,
  35176: 26628,
  35177: 27704,
  35178: 27891,
  35179: 27945,
  35180: 29787,
  35181: 30408,
  35182: 31310,
  35183: 38964,
  35184: 33521,
  35185: 34907,
  35186: 35424,
  35187: 37613,
  35188: 28082,
  35189: 30123,
  35190: 30410,
  35191: 39365,
  35192: 24742,
  35193: 35585,
  35194: 36234,
  35195: 38322,
  35196: 27022,
  35197: 21421,
  35198: 20870,
  35200: 22290,
  35201: 22576,
  35202: 22852,
  35203: 23476,
  35204: 24310,
  35205: 24616,
  35206: 25513,
  35207: 25588,
  35208: 27839,
  35209: 28436,
  35210: 28814,
  35211: 28948,
  35212: 29017,
  35213: 29141,
  35214: 29503,
  35215: 32257,
  35216: 33398,
  35217: 33489,
  35218: 34199,
  35219: 36960,
  35220: 37467,
  35221: 40219,
  35222: 22633,
  35223: 26044,
  35224: 27738,
  35225: 29989,
  35226: 20985,
  35227: 22830,
  35228: 22885,
  35229: 24448,
  35230: 24540,
  35231: 25276,
  35232: 26106,
  35233: 27178,
  35234: 27431,
  35235: 27572,
  35236: 29579,
  35237: 32705,
  35238: 35158,
  35239: 40236,
  35240: 40206,
  35241: 40644,
  35242: 23713,
  35243: 27798,
  35244: 33659,
  35245: 20740,
  35246: 23627,
  35247: 25014,
  35248: 33222,
  35249: 26742,
  35250: 29281,
  35251: 20057,
  35252: 20474,
  35253: 21368,
  35254: 24681,
  35255: 28201,
  35256: 31311,
  35257: 38899,
  35258: 19979,
  35259: 21270,
  35260: 20206,
  35261: 20309,
  35262: 20285,
  35263: 20385,
  35264: 20339,
  35265: 21152,
  35266: 21487,
  35267: 22025,
  35268: 22799,
  35269: 23233,
  35270: 23478,
  35271: 23521,
  35272: 31185,
  35273: 26247,
  35274: 26524,
  35275: 26550,
  35276: 27468,
  35277: 27827,
  35278: 28779,
  35279: 29634,
  35280: 31117,
  35281: 31166,
  35282: 31292,
  35283: 31623,
  35284: 33457,
  35285: 33499,
  35286: 33540,
  35287: 33655,
  35288: 33775,
  35289: 33747,
  35290: 34662,
  35291: 35506,
  35292: 22057,
  35293: 36008,
  35294: 36838,
  35295: 36942,
  35296: 38686,
  35297: 34442,
  35298: 20420,
  35299: 23784,
  35300: 25105,
  35301: 29273,
  35302: 30011,
  35303: 33253,
  35304: 33469,
  35305: 34558,
  35306: 36032,
  35307: 38597,
  35308: 39187,
  35309: 39381,
  35310: 20171,
  35311: 20250,
  35312: 35299,
  35313: 22238,
  35314: 22602,
  35315: 22730,
  35316: 24315,
  35317: 24555,
  35318: 24618,
  35319: 24724,
  35320: 24674,
  35321: 25040,
  35322: 25106,
  35323: 25296,
  35324: 25913,
  35392: 39745,
  35393: 26214,
  35394: 26800,
  35395: 28023,
  35396: 28784,
  35397: 30028,
  35398: 30342,
  35399: 32117,
  35400: 33445,
  35401: 34809,
  35402: 38283,
  35403: 38542,
  35404: 35997,
  35405: 20977,
  35406: 21182,
  35407: 22806,
  35408: 21683,
  35409: 23475,
  35410: 23830,
  35411: 24936,
  35412: 27010,
  35413: 28079,
  35414: 30861,
  35415: 33995,
  35416: 34903,
  35417: 35442,
  35418: 37799,
  35419: 39608,
  35420: 28012,
  35421: 39336,
  35422: 34521,
  35423: 22435,
  35424: 26623,
  35425: 34510,
  35426: 37390,
  35427: 21123,
  35428: 22151,
  35429: 21508,
  35430: 24275,
  35431: 25313,
  35432: 25785,
  35433: 26684,
  35434: 26680,
  35435: 27579,
  35436: 29554,
  35437: 30906,
  35438: 31339,
  35439: 35226,
  35440: 35282,
  35441: 36203,
  35442: 36611,
  35443: 37101,
  35444: 38307,
  35445: 38548,
  35446: 38761,
  35447: 23398,
  35448: 23731,
  35449: 27005,
  35450: 38989,
  35451: 38990,
  35452: 25499,
  35453: 31520,
  35454: 27179,
  35456: 27263,
  35457: 26806,
  35458: 39949,
  35459: 28511,
  35460: 21106,
  35461: 21917,
  35462: 24688,
  35463: 25324,
  35464: 27963,
  35465: 28167,
  35466: 28369,
  35467: 33883,
  35468: 35088,
  35469: 36676,
  35470: 19988,
  35471: 39993,
  35472: 21494,
  35473: 26907,
  35474: 27194,
  35475: 38788,
  35476: 26666,
  35477: 20828,
  35478: 31427,
  35479: 33970,
  35480: 37340,
  35481: 37772,
  35482: 22107,
  35483: 40232,
  35484: 26658,
  35485: 33541,
  35486: 33841,
  35487: 31909,
  35488: 21e3,
  35489: 33477,
  35490: 29926,
  35491: 20094,
  35492: 20355,
  35493: 20896,
  35494: 23506,
  35495: 21002,
  35496: 21208,
  35497: 21223,
  35498: 24059,
  35499: 21914,
  35500: 22570,
  35501: 23014,
  35502: 23436,
  35503: 23448,
  35504: 23515,
  35505: 24178,
  35506: 24185,
  35507: 24739,
  35508: 24863,
  35509: 24931,
  35510: 25022,
  35511: 25563,
  35512: 25954,
  35513: 26577,
  35514: 26707,
  35515: 26874,
  35516: 27454,
  35517: 27475,
  35518: 27735,
  35519: 28450,
  35520: 28567,
  35521: 28485,
  35522: 29872,
  35523: 29976,
  35524: 30435,
  35525: 30475,
  35526: 31487,
  35527: 31649,
  35528: 31777,
  35529: 32233,
  35530: 32566,
  35531: 32752,
  35532: 32925,
  35533: 33382,
  35534: 33694,
  35535: 35251,
  35536: 35532,
  35537: 36011,
  35538: 36996,
  35539: 37969,
  35540: 38291,
  35541: 38289,
  35542: 38306,
  35543: 38501,
  35544: 38867,
  35545: 39208,
  35546: 33304,
  35547: 20024,
  35548: 21547,
  35549: 23736,
  35550: 24012,
  35551: 29609,
  35552: 30284,
  35553: 30524,
  35554: 23721,
  35555: 32747,
  35556: 36107,
  35557: 38593,
  35558: 38929,
  35559: 38996,
  35560: 39e3,
  35561: 20225,
  35562: 20238,
  35563: 21361,
  35564: 21916,
  35565: 22120,
  35566: 22522,
  35567: 22855,
  35568: 23305,
  35569: 23492,
  35570: 23696,
  35571: 24076,
  35572: 24190,
  35573: 24524,
  35574: 25582,
  35575: 26426,
  35576: 26071,
  35577: 26082,
  35578: 26399,
  35579: 26827,
  35580: 26820,
  35648: 27231,
  35649: 24112,
  35650: 27589,
  35651: 27671,
  35652: 27773,
  35653: 30079,
  35654: 31048,
  35655: 23395,
  35656: 31232,
  35657: 32e3,
  35658: 24509,
  35659: 35215,
  35660: 35352,
  35661: 36020,
  35662: 36215,
  35663: 36556,
  35664: 36637,
  35665: 39138,
  35666: 39438,
  35667: 39740,
  35668: 20096,
  35669: 20605,
  35670: 20736,
  35671: 22931,
  35672: 23452,
  35673: 25135,
  35674: 25216,
  35675: 25836,
  35676: 27450,
  35677: 29344,
  35678: 30097,
  35679: 31047,
  35680: 32681,
  35681: 34811,
  35682: 35516,
  35683: 35696,
  35684: 25516,
  35685: 33738,
  35686: 38816,
  35687: 21513,
  35688: 21507,
  35689: 21931,
  35690: 26708,
  35691: 27224,
  35692: 35440,
  35693: 30759,
  35694: 26485,
  35695: 40653,
  35696: 21364,
  35697: 23458,
  35698: 33050,
  35699: 34384,
  35700: 36870,
  35701: 19992,
  35702: 20037,
  35703: 20167,
  35704: 20241,
  35705: 21450,
  35706: 21560,
  35707: 23470,
  35708: 24339,
  35709: 24613,
  35710: 25937,
  35712: 26429,
  35713: 27714,
  35714: 27762,
  35715: 27875,
  35716: 28792,
  35717: 29699,
  35718: 31350,
  35719: 31406,
  35720: 31496,
  35721: 32026,
  35722: 31998,
  35723: 32102,
  35724: 26087,
  35725: 29275,
  35726: 21435,
  35727: 23621,
  35728: 24040,
  35729: 25298,
  35730: 25312,
  35731: 25369,
  35732: 28192,
  35733: 34394,
  35734: 35377,
  35735: 36317,
  35736: 37624,
  35737: 28417,
  35738: 31142,
  35739: 39770,
  35740: 20136,
  35741: 20139,
  35742: 20140,
  35743: 20379,
  35744: 20384,
  35745: 20689,
  35746: 20807,
  35747: 31478,
  35748: 20849,
  35749: 20982,
  35750: 21332,
  35751: 21281,
  35752: 21375,
  35753: 21483,
  35754: 21932,
  35755: 22659,
  35756: 23777,
  35757: 24375,
  35758: 24394,
  35759: 24623,
  35760: 24656,
  35761: 24685,
  35762: 25375,
  35763: 25945,
  35764: 27211,
  35765: 27841,
  35766: 29378,
  35767: 29421,
  35768: 30703,
  35769: 33016,
  35770: 33029,
  35771: 33288,
  35772: 34126,
  35773: 37111,
  35774: 37857,
  35775: 38911,
  35776: 39255,
  35777: 39514,
  35778: 20208,
  35779: 20957,
  35780: 23597,
  35781: 26241,
  35782: 26989,
  35783: 23616,
  35784: 26354,
  35785: 26997,
  35786: 29577,
  35787: 26704,
  35788: 31873,
  35789: 20677,
  35790: 21220,
  35791: 22343,
  35792: 24062,
  35793: 37670,
  35794: 26020,
  35795: 27427,
  35796: 27453,
  35797: 29748,
  35798: 31105,
  35799: 31165,
  35800: 31563,
  35801: 32202,
  35802: 33465,
  35803: 33740,
  35804: 34943,
  35805: 35167,
  35806: 35641,
  35807: 36817,
  35808: 37329,
  35809: 21535,
  35810: 37504,
  35811: 20061,
  35812: 20534,
  35813: 21477,
  35814: 21306,
  35815: 29399,
  35816: 29590,
  35817: 30697,
  35818: 33510,
  35819: 36527,
  35820: 39366,
  35821: 39368,
  35822: 39378,
  35823: 20855,
  35824: 24858,
  35825: 34398,
  35826: 21936,
  35827: 31354,
  35828: 20598,
  35829: 23507,
  35830: 36935,
  35831: 38533,
  35832: 20018,
  35833: 27355,
  35834: 37351,
  35835: 23633,
  35836: 23624,
  35904: 25496,
  35905: 31391,
  35906: 27795,
  35907: 38772,
  35908: 36705,
  35909: 31402,
  35910: 29066,
  35911: 38536,
  35912: 31874,
  35913: 26647,
  35914: 32368,
  35915: 26705,
  35916: 37740,
  35917: 21234,
  35918: 21531,
  35919: 34219,
  35920: 35347,
  35921: 32676,
  35922: 36557,
  35923: 37089,
  35924: 21350,
  35925: 34952,
  35926: 31041,
  35927: 20418,
  35928: 20670,
  35929: 21009,
  35930: 20804,
  35931: 21843,
  35932: 22317,
  35933: 29674,
  35934: 22411,
  35935: 22865,
  35936: 24418,
  35937: 24452,
  35938: 24693,
  35939: 24950,
  35940: 24935,
  35941: 25001,
  35942: 25522,
  35943: 25658,
  35944: 25964,
  35945: 26223,
  35946: 26690,
  35947: 28179,
  35948: 30054,
  35949: 31293,
  35950: 31995,
  35951: 32076,
  35952: 32153,
  35953: 32331,
  35954: 32619,
  35955: 33550,
  35956: 33610,
  35957: 34509,
  35958: 35336,
  35959: 35427,
  35960: 35686,
  35961: 36605,
  35962: 38938,
  35963: 40335,
  35964: 33464,
  35965: 36814,
  35966: 39912,
  35968: 21127,
  35969: 25119,
  35970: 25731,
  35971: 28608,
  35972: 38553,
  35973: 26689,
  35974: 20625,
  35975: 27424,
  35976: 27770,
  35977: 28500,
  35978: 31348,
  35979: 32080,
  35980: 34880,
  35981: 35363,
  35982: 26376,
  35983: 20214,
  35984: 20537,
  35985: 20518,
  35986: 20581,
  35987: 20860,
  35988: 21048,
  35989: 21091,
  35990: 21927,
  35991: 22287,
  35992: 22533,
  35993: 23244,
  35994: 24314,
  35995: 25010,
  35996: 25080,
  35997: 25331,
  35998: 25458,
  35999: 26908,
  36e3: 27177,
  36001: 29309,
  36002: 29356,
  36003: 29486,
  36004: 30740,
  36005: 30831,
  36006: 32121,
  36007: 30476,
  36008: 32937,
  36009: 35211,
  36010: 35609,
  36011: 36066,
  36012: 36562,
  36013: 36963,
  36014: 37749,
  36015: 38522,
  36016: 38997,
  36017: 39443,
  36018: 40568,
  36019: 20803,
  36020: 21407,
  36021: 21427,
  36022: 24187,
  36023: 24358,
  36024: 28187,
  36025: 28304,
  36026: 29572,
  36027: 29694,
  36028: 32067,
  36029: 33335,
  36030: 35328,
  36031: 35578,
  36032: 38480,
  36033: 20046,
  36034: 20491,
  36035: 21476,
  36036: 21628,
  36037: 22266,
  36038: 22993,
  36039: 23396,
  36040: 24049,
  36041: 24235,
  36042: 24359,
  36043: 25144,
  36044: 25925,
  36045: 26543,
  36046: 28246,
  36047: 29392,
  36048: 31946,
  36049: 34996,
  36050: 32929,
  36051: 32993,
  36052: 33776,
  36053: 34382,
  36054: 35463,
  36055: 36328,
  36056: 37431,
  36057: 38599,
  36058: 39015,
  36059: 40723,
  36060: 20116,
  36061: 20114,
  36062: 20237,
  36063: 21320,
  36064: 21577,
  36065: 21566,
  36066: 23087,
  36067: 24460,
  36068: 24481,
  36069: 24735,
  36070: 26791,
  36071: 27278,
  36072: 29786,
  36073: 30849,
  36074: 35486,
  36075: 35492,
  36076: 35703,
  36077: 37264,
  36078: 20062,
  36079: 39881,
  36080: 20132,
  36081: 20348,
  36082: 20399,
  36083: 20505,
  36084: 20502,
  36085: 20809,
  36086: 20844,
  36087: 21151,
  36088: 21177,
  36089: 21246,
  36090: 21402,
  36091: 21475,
  36092: 21521,
  36160: 21518,
  36161: 21897,
  36162: 22353,
  36163: 22434,
  36164: 22909,
  36165: 23380,
  36166: 23389,
  36167: 23439,
  36168: 24037,
  36169: 24039,
  36170: 24055,
  36171: 24184,
  36172: 24195,
  36173: 24218,
  36174: 24247,
  36175: 24344,
  36176: 24658,
  36177: 24908,
  36178: 25239,
  36179: 25304,
  36180: 25511,
  36181: 25915,
  36182: 26114,
  36183: 26179,
  36184: 26356,
  36185: 26477,
  36186: 26657,
  36187: 26775,
  36188: 27083,
  36189: 27743,
  36190: 27946,
  36191: 28009,
  36192: 28207,
  36193: 28317,
  36194: 30002,
  36195: 30343,
  36196: 30828,
  36197: 31295,
  36198: 31968,
  36199: 32005,
  36200: 32024,
  36201: 32094,
  36202: 32177,
  36203: 32789,
  36204: 32771,
  36205: 32943,
  36206: 32945,
  36207: 33108,
  36208: 33167,
  36209: 33322,
  36210: 33618,
  36211: 34892,
  36212: 34913,
  36213: 35611,
  36214: 36002,
  36215: 36092,
  36216: 37066,
  36217: 37237,
  36218: 37489,
  36219: 30783,
  36220: 37628,
  36221: 38308,
  36222: 38477,
  36224: 38917,
  36225: 39321,
  36226: 39640,
  36227: 40251,
  36228: 21083,
  36229: 21163,
  36230: 21495,
  36231: 21512,
  36232: 22741,
  36233: 25335,
  36234: 28640,
  36235: 35946,
  36236: 36703,
  36237: 40633,
  36238: 20811,
  36239: 21051,
  36240: 21578,
  36241: 22269,
  36242: 31296,
  36243: 37239,
  36244: 40288,
  36245: 40658,
  36246: 29508,
  36247: 28425,
  36248: 33136,
  36249: 29969,
  36250: 24573,
  36251: 24794,
  36252: 39592,
  36253: 29403,
  36254: 36796,
  36255: 27492,
  36256: 38915,
  36257: 20170,
  36258: 22256,
  36259: 22372,
  36260: 22718,
  36261: 23130,
  36262: 24680,
  36263: 25031,
  36264: 26127,
  36265: 26118,
  36266: 26681,
  36267: 26801,
  36268: 28151,
  36269: 30165,
  36270: 32058,
  36271: 33390,
  36272: 39746,
  36273: 20123,
  36274: 20304,
  36275: 21449,
  36276: 21766,
  36277: 23919,
  36278: 24038,
  36279: 24046,
  36280: 26619,
  36281: 27801,
  36282: 29811,
  36283: 30722,
  36284: 35408,
  36285: 37782,
  36286: 35039,
  36287: 22352,
  36288: 24231,
  36289: 25387,
  36290: 20661,
  36291: 20652,
  36292: 20877,
  36293: 26368,
  36294: 21705,
  36295: 22622,
  36296: 22971,
  36297: 23472,
  36298: 24425,
  36299: 25165,
  36300: 25505,
  36301: 26685,
  36302: 27507,
  36303: 28168,
  36304: 28797,
  36305: 37319,
  36306: 29312,
  36307: 30741,
  36308: 30758,
  36309: 31085,
  36310: 25998,
  36311: 32048,
  36312: 33756,
  36313: 35009,
  36314: 36617,
  36315: 38555,
  36316: 21092,
  36317: 22312,
  36318: 26448,
  36319: 32618,
  36320: 36001,
  36321: 20916,
  36322: 22338,
  36323: 38442,
  36324: 22586,
  36325: 27018,
  36326: 32948,
  36327: 21682,
  36328: 23822,
  36329: 22524,
  36330: 30869,
  36331: 40442,
  36332: 20316,
  36333: 21066,
  36334: 21643,
  36335: 25662,
  36336: 26152,
  36337: 26388,
  36338: 26613,
  36339: 31364,
  36340: 31574,
  36341: 32034,
  36342: 37679,
  36343: 26716,
  36344: 39853,
  36345: 31545,
  36346: 21273,
  36347: 20874,
  36348: 21047,
  36416: 23519,
  36417: 25334,
  36418: 25774,
  36419: 25830,
  36420: 26413,
  36421: 27578,
  36422: 34217,
  36423: 38609,
  36424: 30352,
  36425: 39894,
  36426: 25420,
  36427: 37638,
  36428: 39851,
  36429: 30399,
  36430: 26194,
  36431: 19977,
  36432: 20632,
  36433: 21442,
  36434: 23665,
  36435: 24808,
  36436: 25746,
  36437: 25955,
  36438: 26719,
  36439: 29158,
  36440: 29642,
  36441: 29987,
  36442: 31639,
  36443: 32386,
  36444: 34453,
  36445: 35715,
  36446: 36059,
  36447: 37240,
  36448: 39184,
  36449: 26028,
  36450: 26283,
  36451: 27531,
  36452: 20181,
  36453: 20180,
  36454: 20282,
  36455: 20351,
  36456: 21050,
  36457: 21496,
  36458: 21490,
  36459: 21987,
  36460: 22235,
  36461: 22763,
  36462: 22987,
  36463: 22985,
  36464: 23039,
  36465: 23376,
  36466: 23629,
  36467: 24066,
  36468: 24107,
  36469: 24535,
  36470: 24605,
  36471: 25351,
  36472: 25903,
  36473: 23388,
  36474: 26031,
  36475: 26045,
  36476: 26088,
  36477: 26525,
  36478: 27490,
  36480: 27515,
  36481: 27663,
  36482: 29509,
  36483: 31049,
  36484: 31169,
  36485: 31992,
  36486: 32025,
  36487: 32043,
  36488: 32930,
  36489: 33026,
  36490: 33267,
  36491: 35222,
  36492: 35422,
  36493: 35433,
  36494: 35430,
  36495: 35468,
  36496: 35566,
  36497: 36039,
  36498: 36060,
  36499: 38604,
  36500: 39164,
  36501: 27503,
  36502: 20107,
  36503: 20284,
  36504: 20365,
  36505: 20816,
  36506: 23383,
  36507: 23546,
  36508: 24904,
  36509: 25345,
  36510: 26178,
  36511: 27425,
  36512: 28363,
  36513: 27835,
  36514: 29246,
  36515: 29885,
  36516: 30164,
  36517: 30913,
  36518: 31034,
  36519: 32780,
  36520: 32819,
  36521: 33258,
  36522: 33940,
  36523: 36766,
  36524: 27728,
  36525: 40575,
  36526: 24335,
  36527: 35672,
  36528: 40235,
  36529: 31482,
  36530: 36600,
  36531: 23437,
  36532: 38635,
  36533: 19971,
  36534: 21489,
  36535: 22519,
  36536: 22833,
  36537: 23241,
  36538: 23460,
  36539: 24713,
  36540: 28287,
  36541: 28422,
  36542: 30142,
  36543: 36074,
  36544: 23455,
  36545: 34048,
  36546: 31712,
  36547: 20594,
  36548: 26612,
  36549: 33437,
  36550: 23649,
  36551: 34122,
  36552: 32286,
  36553: 33294,
  36554: 20889,
  36555: 23556,
  36556: 25448,
  36557: 36198,
  36558: 26012,
  36559: 29038,
  36560: 31038,
  36561: 32023,
  36562: 32773,
  36563: 35613,
  36564: 36554,
  36565: 36974,
  36566: 34503,
  36567: 37034,
  36568: 20511,
  36569: 21242,
  36570: 23610,
  36571: 26451,
  36572: 28796,
  36573: 29237,
  36574: 37196,
  36575: 37320,
  36576: 37675,
  36577: 33509,
  36578: 23490,
  36579: 24369,
  36580: 24825,
  36581: 20027,
  36582: 21462,
  36583: 23432,
  36584: 25163,
  36585: 26417,
  36586: 27530,
  36587: 29417,
  36588: 29664,
  36589: 31278,
  36590: 33131,
  36591: 36259,
  36592: 37202,
  36593: 39318,
  36594: 20754,
  36595: 21463,
  36596: 21610,
  36597: 23551,
  36598: 25480,
  36599: 27193,
  36600: 32172,
  36601: 38656,
  36602: 22234,
  36603: 21454,
  36604: 21608,
  36672: 23447,
  36673: 23601,
  36674: 24030,
  36675: 20462,
  36676: 24833,
  36677: 25342,
  36678: 27954,
  36679: 31168,
  36680: 31179,
  36681: 32066,
  36682: 32333,
  36683: 32722,
  36684: 33261,
  36685: 33311,
  36686: 33936,
  36687: 34886,
  36688: 35186,
  36689: 35728,
  36690: 36468,
  36691: 36655,
  36692: 36913,
  36693: 37195,
  36694: 37228,
  36695: 38598,
  36696: 37276,
  36697: 20160,
  36698: 20303,
  36699: 20805,
  36700: 21313,
  36701: 24467,
  36702: 25102,
  36703: 26580,
  36704: 27713,
  36705: 28171,
  36706: 29539,
  36707: 32294,
  36708: 37325,
  36709: 37507,
  36710: 21460,
  36711: 22809,
  36712: 23487,
  36713: 28113,
  36714: 31069,
  36715: 32302,
  36716: 31899,
  36717: 22654,
  36718: 29087,
  36719: 20986,
  36720: 34899,
  36721: 36848,
  36722: 20426,
  36723: 23803,
  36724: 26149,
  36725: 30636,
  36726: 31459,
  36727: 33308,
  36728: 39423,
  36729: 20934,
  36730: 24490,
  36731: 26092,
  36732: 26991,
  36733: 27529,
  36734: 28147,
  36736: 28310,
  36737: 28516,
  36738: 30462,
  36739: 32020,
  36740: 24033,
  36741: 36981,
  36742: 37255,
  36743: 38918,
  36744: 20966,
  36745: 21021,
  36746: 25152,
  36747: 26257,
  36748: 26329,
  36749: 28186,
  36750: 24246,
  36751: 32210,
  36752: 32626,
  36753: 26360,
  36754: 34223,
  36755: 34295,
  36756: 35576,
  36757: 21161,
  36758: 21465,
  36759: 22899,
  36760: 24207,
  36761: 24464,
  36762: 24661,
  36763: 37604,
  36764: 38500,
  36765: 20663,
  36766: 20767,
  36767: 21213,
  36768: 21280,
  36769: 21319,
  36770: 21484,
  36771: 21736,
  36772: 21830,
  36773: 21809,
  36774: 22039,
  36775: 22888,
  36776: 22974,
  36777: 23100,
  36778: 23477,
  36779: 23558,
  36780: 23567,
  36781: 23569,
  36782: 23578,
  36783: 24196,
  36784: 24202,
  36785: 24288,
  36786: 24432,
  36787: 25215,
  36788: 25220,
  36789: 25307,
  36790: 25484,
  36791: 25463,
  36792: 26119,
  36793: 26124,
  36794: 26157,
  36795: 26230,
  36796: 26494,
  36797: 26786,
  36798: 27167,
  36799: 27189,
  36800: 27836,
  36801: 28040,
  36802: 28169,
  36803: 28248,
  36804: 28988,
  36805: 28966,
  36806: 29031,
  36807: 30151,
  36808: 30465,
  36809: 30813,
  36810: 30977,
  36811: 31077,
  36812: 31216,
  36813: 31456,
  36814: 31505,
  36815: 31911,
  36816: 32057,
  36817: 32918,
  36818: 33750,
  36819: 33931,
  36820: 34121,
  36821: 34909,
  36822: 35059,
  36823: 35359,
  36824: 35388,
  36825: 35412,
  36826: 35443,
  36827: 35937,
  36828: 36062,
  36829: 37284,
  36830: 37478,
  36831: 37758,
  36832: 37912,
  36833: 38556,
  36834: 38808,
  36835: 19978,
  36836: 19976,
  36837: 19998,
  36838: 20055,
  36839: 20887,
  36840: 21104,
  36841: 22478,
  36842: 22580,
  36843: 22732,
  36844: 23330,
  36845: 24120,
  36846: 24773,
  36847: 25854,
  36848: 26465,
  36849: 26454,
  36850: 27972,
  36851: 29366,
  36852: 30067,
  36853: 31331,
  36854: 33976,
  36855: 35698,
  36856: 37304,
  36857: 37664,
  36858: 22065,
  36859: 22516,
  36860: 39166,
  36928: 25325,
  36929: 26893,
  36930: 27542,
  36931: 29165,
  36932: 32340,
  36933: 32887,
  36934: 33394,
  36935: 35302,
  36936: 39135,
  36937: 34645,
  36938: 36785,
  36939: 23611,
  36940: 20280,
  36941: 20449,
  36942: 20405,
  36943: 21767,
  36944: 23072,
  36945: 23517,
  36946: 23529,
  36947: 24515,
  36948: 24910,
  36949: 25391,
  36950: 26032,
  36951: 26187,
  36952: 26862,
  36953: 27035,
  36954: 28024,
  36955: 28145,
  36956: 30003,
  36957: 30137,
  36958: 30495,
  36959: 31070,
  36960: 31206,
  36961: 32051,
  36962: 33251,
  36963: 33455,
  36964: 34218,
  36965: 35242,
  36966: 35386,
  36967: 36523,
  36968: 36763,
  36969: 36914,
  36970: 37341,
  36971: 38663,
  36972: 20154,
  36973: 20161,
  36974: 20995,
  36975: 22645,
  36976: 22764,
  36977: 23563,
  36978: 29978,
  36979: 23613,
  36980: 33102,
  36981: 35338,
  36982: 36805,
  36983: 38499,
  36984: 38765,
  36985: 31525,
  36986: 35535,
  36987: 38920,
  36988: 37218,
  36989: 22259,
  36990: 21416,
  36992: 36887,
  36993: 21561,
  36994: 22402,
  36995: 24101,
  36996: 25512,
  36997: 27700,
  36998: 28810,
  36999: 30561,
  37e3: 31883,
  37001: 32736,
  37002: 34928,
  37003: 36930,
  37004: 37204,
  37005: 37648,
  37006: 37656,
  37007: 38543,
  37008: 29790,
  37009: 39620,
  37010: 23815,
  37011: 23913,
  37012: 25968,
  37013: 26530,
  37014: 36264,
  37015: 38619,
  37016: 25454,
  37017: 26441,
  37018: 26905,
  37019: 33733,
  37020: 38935,
  37021: 38592,
  37022: 35070,
  37023: 28548,
  37024: 25722,
  37025: 23544,
  37026: 19990,
  37027: 28716,
  37028: 30045,
  37029: 26159,
  37030: 20932,
  37031: 21046,
  37032: 21218,
  37033: 22995,
  37034: 24449,
  37035: 24615,
  37036: 25104,
  37037: 25919,
  37038: 25972,
  37039: 26143,
  37040: 26228,
  37041: 26866,
  37042: 26646,
  37043: 27491,
  37044: 28165,
  37045: 29298,
  37046: 29983,
  37047: 30427,
  37048: 31934,
  37049: 32854,
  37050: 22768,
  37051: 35069,
  37052: 35199,
  37053: 35488,
  37054: 35475,
  37055: 35531,
  37056: 36893,
  37057: 37266,
  37058: 38738,
  37059: 38745,
  37060: 25993,
  37061: 31246,
  37062: 33030,
  37063: 38587,
  37064: 24109,
  37065: 24796,
  37066: 25114,
  37067: 26021,
  37068: 26132,
  37069: 26512,
  37070: 30707,
  37071: 31309,
  37072: 31821,
  37073: 32318,
  37074: 33034,
  37075: 36012,
  37076: 36196,
  37077: 36321,
  37078: 36447,
  37079: 30889,
  37080: 20999,
  37081: 25305,
  37082: 25509,
  37083: 25666,
  37084: 25240,
  37085: 35373,
  37086: 31363,
  37087: 31680,
  37088: 35500,
  37089: 38634,
  37090: 32118,
  37091: 33292,
  37092: 34633,
  37093: 20185,
  37094: 20808,
  37095: 21315,
  37096: 21344,
  37097: 23459,
  37098: 23554,
  37099: 23574,
  37100: 24029,
  37101: 25126,
  37102: 25159,
  37103: 25776,
  37104: 26643,
  37105: 26676,
  37106: 27849,
  37107: 27973,
  37108: 27927,
  37109: 26579,
  37110: 28508,
  37111: 29006,
  37112: 29053,
  37113: 26059,
  37114: 31359,
  37115: 31661,
  37116: 32218,
  37184: 32330,
  37185: 32680,
  37186: 33146,
  37187: 33307,
  37188: 33337,
  37189: 34214,
  37190: 35438,
  37191: 36046,
  37192: 36341,
  37193: 36984,
  37194: 36983,
  37195: 37549,
  37196: 37521,
  37197: 38275,
  37198: 39854,
  37199: 21069,
  37200: 21892,
  37201: 28472,
  37202: 28982,
  37203: 20840,
  37204: 31109,
  37205: 32341,
  37206: 33203,
  37207: 31950,
  37208: 22092,
  37209: 22609,
  37210: 23720,
  37211: 25514,
  37212: 26366,
  37213: 26365,
  37214: 26970,
  37215: 29401,
  37216: 30095,
  37217: 30094,
  37218: 30990,
  37219: 31062,
  37220: 31199,
  37221: 31895,
  37222: 32032,
  37223: 32068,
  37224: 34311,
  37225: 35380,
  37226: 38459,
  37227: 36961,
  37228: 40736,
  37229: 20711,
  37230: 21109,
  37231: 21452,
  37232: 21474,
  37233: 20489,
  37234: 21930,
  37235: 22766,
  37236: 22863,
  37237: 29245,
  37238: 23435,
  37239: 23652,
  37240: 21277,
  37241: 24803,
  37242: 24819,
  37243: 25436,
  37244: 25475,
  37245: 25407,
  37246: 25531,
  37248: 25805,
  37249: 26089,
  37250: 26361,
  37251: 24035,
  37252: 27085,
  37253: 27133,
  37254: 28437,
  37255: 29157,
  37256: 20105,
  37257: 30185,
  37258: 30456,
  37259: 31379,
  37260: 31967,
  37261: 32207,
  37262: 32156,
  37263: 32865,
  37264: 33609,
  37265: 33624,
  37266: 33900,
  37267: 33980,
  37268: 34299,
  37269: 35013,
  37270: 36208,
  37271: 36865,
  37272: 36973,
  37273: 37783,
  37274: 38684,
  37275: 39442,
  37276: 20687,
  37277: 22679,
  37278: 24974,
  37279: 33235,
  37280: 34101,
  37281: 36104,
  37282: 36896,
  37283: 20419,
  37284: 20596,
  37285: 21063,
  37286: 21363,
  37287: 24687,
  37288: 25417,
  37289: 26463,
  37290: 28204,
  37291: 36275,
  37292: 36895,
  37293: 20439,
  37294: 23646,
  37295: 36042,
  37296: 26063,
  37297: 32154,
  37298: 21330,
  37299: 34966,
  37300: 20854,
  37301: 25539,
  37302: 23384,
  37303: 23403,
  37304: 23562,
  37305: 25613,
  37306: 26449,
  37307: 36956,
  37308: 20182,
  37309: 22810,
  37310: 22826,
  37311: 27760,
  37312: 35409,
  37313: 21822,
  37314: 22549,
  37315: 22949,
  37316: 24816,
  37317: 25171,
  37318: 26561,
  37319: 33333,
  37320: 26965,
  37321: 38464,
  37322: 39364,
  37323: 39464,
  37324: 20307,
  37325: 22534,
  37326: 23550,
  37327: 32784,
  37328: 23729,
  37329: 24111,
  37330: 24453,
  37331: 24608,
  37332: 24907,
  37333: 25140,
  37334: 26367,
  37335: 27888,
  37336: 28382,
  37337: 32974,
  37338: 33151,
  37339: 33492,
  37340: 34955,
  37341: 36024,
  37342: 36864,
  37343: 36910,
  37344: 38538,
  37345: 40667,
  37346: 39899,
  37347: 20195,
  37348: 21488,
  37349: 22823,
  37350: 31532,
  37351: 37261,
  37352: 38988,
  37353: 40441,
  37354: 28381,
  37355: 28711,
  37356: 21331,
  37357: 21828,
  37358: 23429,
  37359: 25176,
  37360: 25246,
  37361: 25299,
  37362: 27810,
  37363: 28655,
  37364: 29730,
  37365: 35351,
  37366: 37944,
  37367: 28609,
  37368: 35582,
  37369: 33592,
  37370: 20967,
  37371: 34552,
  37372: 21482,
  37440: 21481,
  37441: 20294,
  37442: 36948,
  37443: 36784,
  37444: 22890,
  37445: 33073,
  37446: 24061,
  37447: 31466,
  37448: 36799,
  37449: 26842,
  37450: 35895,
  37451: 29432,
  37452: 40008,
  37453: 27197,
  37454: 35504,
  37455: 20025,
  37456: 21336,
  37457: 22022,
  37458: 22374,
  37459: 25285,
  37460: 25506,
  37461: 26086,
  37462: 27470,
  37463: 28129,
  37464: 28251,
  37465: 28845,
  37466: 30701,
  37467: 31471,
  37468: 31658,
  37469: 32187,
  37470: 32829,
  37471: 32966,
  37472: 34507,
  37473: 35477,
  37474: 37723,
  37475: 22243,
  37476: 22727,
  37477: 24382,
  37478: 26029,
  37479: 26262,
  37480: 27264,
  37481: 27573,
  37482: 30007,
  37483: 35527,
  37484: 20516,
  37485: 30693,
  37486: 22320,
  37487: 24347,
  37488: 24677,
  37489: 26234,
  37490: 27744,
  37491: 30196,
  37492: 31258,
  37493: 32622,
  37494: 33268,
  37495: 34584,
  37496: 36933,
  37497: 39347,
  37498: 31689,
  37499: 30044,
  37500: 31481,
  37501: 31569,
  37502: 33988,
  37504: 36880,
  37505: 31209,
  37506: 31378,
  37507: 33590,
  37508: 23265,
  37509: 30528,
  37510: 20013,
  37511: 20210,
  37512: 23449,
  37513: 24544,
  37514: 25277,
  37515: 26172,
  37516: 26609,
  37517: 27880,
  37518: 34411,
  37519: 34935,
  37520: 35387,
  37521: 37198,
  37522: 37619,
  37523: 39376,
  37524: 27159,
  37525: 28710,
  37526: 29482,
  37527: 33511,
  37528: 33879,
  37529: 36015,
  37530: 19969,
  37531: 20806,
  37532: 20939,
  37533: 21899,
  37534: 23541,
  37535: 24086,
  37536: 24115,
  37537: 24193,
  37538: 24340,
  37539: 24373,
  37540: 24427,
  37541: 24500,
  37542: 25074,
  37543: 25361,
  37544: 26274,
  37545: 26397,
  37546: 28526,
  37547: 29266,
  37548: 30010,
  37549: 30522,
  37550: 32884,
  37551: 33081,
  37552: 33144,
  37553: 34678,
  37554: 35519,
  37555: 35548,
  37556: 36229,
  37557: 36339,
  37558: 37530,
  37559: 38263,
  37560: 38914,
  37561: 40165,
  37562: 21189,
  37563: 25431,
  37564: 30452,
  37565: 26389,
  37566: 27784,
  37567: 29645,
  37568: 36035,
  37569: 37806,
  37570: 38515,
  37571: 27941,
  37572: 22684,
  37573: 26894,
  37574: 27084,
  37575: 36861,
  37576: 37786,
  37577: 30171,
  37578: 36890,
  37579: 22618,
  37580: 26626,
  37581: 25524,
  37582: 27131,
  37583: 20291,
  37584: 28460,
  37585: 26584,
  37586: 36795,
  37587: 34086,
  37588: 32180,
  37589: 37716,
  37590: 26943,
  37591: 28528,
  37592: 22378,
  37593: 22775,
  37594: 23340,
  37595: 32044,
  37596: 29226,
  37597: 21514,
  37598: 37347,
  37599: 40372,
  37600: 20141,
  37601: 20302,
  37602: 20572,
  37603: 20597,
  37604: 21059,
  37605: 35998,
  37606: 21576,
  37607: 22564,
  37608: 23450,
  37609: 24093,
  37610: 24213,
  37611: 24237,
  37612: 24311,
  37613: 24351,
  37614: 24716,
  37615: 25269,
  37616: 25402,
  37617: 25552,
  37618: 26799,
  37619: 27712,
  37620: 30855,
  37621: 31118,
  37622: 31243,
  37623: 32224,
  37624: 33351,
  37625: 35330,
  37626: 35558,
  37627: 36420,
  37628: 36883,
  37696: 37048,
  37697: 37165,
  37698: 37336,
  37699: 40718,
  37700: 27877,
  37701: 25688,
  37702: 25826,
  37703: 25973,
  37704: 28404,
  37705: 30340,
  37706: 31515,
  37707: 36969,
  37708: 37841,
  37709: 28346,
  37710: 21746,
  37711: 24505,
  37712: 25764,
  37713: 36685,
  37714: 36845,
  37715: 37444,
  37716: 20856,
  37717: 22635,
  37718: 22825,
  37719: 23637,
  37720: 24215,
  37721: 28155,
  37722: 32399,
  37723: 29980,
  37724: 36028,
  37725: 36578,
  37726: 39003,
  37727: 28857,
  37728: 20253,
  37729: 27583,
  37730: 28593,
  37731: 3e4,
  37732: 38651,
  37733: 20814,
  37734: 21520,
  37735: 22581,
  37736: 22615,
  37737: 22956,
  37738: 23648,
  37739: 24466,
  37740: 26007,
  37741: 26460,
  37742: 28193,
  37743: 30331,
  37744: 33759,
  37745: 36077,
  37746: 36884,
  37747: 37117,
  37748: 37709,
  37749: 30757,
  37750: 30778,
  37751: 21162,
  37752: 24230,
  37753: 22303,
  37754: 22900,
  37755: 24594,
  37756: 20498,
  37757: 20826,
  37758: 20908,
  37760: 20941,
  37761: 20992,
  37762: 21776,
  37763: 22612,
  37764: 22616,
  37765: 22871,
  37766: 23445,
  37767: 23798,
  37768: 23947,
  37769: 24764,
  37770: 25237,
  37771: 25645,
  37772: 26481,
  37773: 26691,
  37774: 26812,
  37775: 26847,
  37776: 30423,
  37777: 28120,
  37778: 28271,
  37779: 28059,
  37780: 28783,
  37781: 29128,
  37782: 24403,
  37783: 30168,
  37784: 31095,
  37785: 31561,
  37786: 31572,
  37787: 31570,
  37788: 31958,
  37789: 32113,
  37790: 21040,
  37791: 33891,
  37792: 34153,
  37793: 34276,
  37794: 35342,
  37795: 35588,
  37796: 35910,
  37797: 36367,
  37798: 36867,
  37799: 36879,
  37800: 37913,
  37801: 38518,
  37802: 38957,
  37803: 39472,
  37804: 38360,
  37805: 20685,
  37806: 21205,
  37807: 21516,
  37808: 22530,
  37809: 23566,
  37810: 24999,
  37811: 25758,
  37812: 27934,
  37813: 30643,
  37814: 31461,
  37815: 33012,
  37816: 33796,
  37817: 36947,
  37818: 37509,
  37819: 23776,
  37820: 40199,
  37821: 21311,
  37822: 24471,
  37823: 24499,
  37824: 28060,
  37825: 29305,
  37826: 30563,
  37827: 31167,
  37828: 31716,
  37829: 27602,
  37830: 29420,
  37831: 35501,
  37832: 26627,
  37833: 27233,
  37834: 20984,
  37835: 31361,
  37836: 26932,
  37837: 23626,
  37838: 40182,
  37839: 33515,
  37840: 23493,
  37841: 37193,
  37842: 28702,
  37843: 22136,
  37844: 23663,
  37845: 24775,
  37846: 25958,
  37847: 27788,
  37848: 35930,
  37849: 36929,
  37850: 38931,
  37851: 21585,
  37852: 26311,
  37853: 37389,
  37854: 22856,
  37855: 37027,
  37856: 20869,
  37857: 20045,
  37858: 20970,
  37859: 34201,
  37860: 35598,
  37861: 28760,
  37862: 25466,
  37863: 37707,
  37864: 26978,
  37865: 39348,
  37866: 32260,
  37867: 30071,
  37868: 21335,
  37869: 26976,
  37870: 36575,
  37871: 38627,
  37872: 27741,
  37873: 20108,
  37874: 23612,
  37875: 24336,
  37876: 36841,
  37877: 21250,
  37878: 36049,
  37879: 32905,
  37880: 34425,
  37881: 24319,
  37882: 26085,
  37883: 20083,
  37884: 20837,
  37952: 22914,
  37953: 23615,
  37954: 38894,
  37955: 20219,
  37956: 22922,
  37957: 24525,
  37958: 35469,
  37959: 28641,
  37960: 31152,
  37961: 31074,
  37962: 23527,
  37963: 33905,
  37964: 29483,
  37965: 29105,
  37966: 24180,
  37967: 24565,
  37968: 25467,
  37969: 25754,
  37970: 29123,
  37971: 31896,
  37972: 20035,
  37973: 24316,
  37974: 20043,
  37975: 22492,
  37976: 22178,
  37977: 24745,
  37978: 28611,
  37979: 32013,
  37980: 33021,
  37981: 33075,
  37982: 33215,
  37983: 36786,
  37984: 35223,
  37985: 34468,
  37986: 24052,
  37987: 25226,
  37988: 25773,
  37989: 35207,
  37990: 26487,
  37991: 27874,
  37992: 27966,
  37993: 29750,
  37994: 30772,
  37995: 23110,
  37996: 32629,
  37997: 33453,
  37998: 39340,
  37999: 20467,
  38e3: 24259,
  38001: 25309,
  38002: 25490,
  38003: 25943,
  38004: 26479,
  38005: 30403,
  38006: 29260,
  38007: 32972,
  38008: 32954,
  38009: 36649,
  38010: 37197,
  38011: 20493,
  38012: 22521,
  38013: 23186,
  38014: 26757,
  38016: 26995,
  38017: 29028,
  38018: 29437,
  38019: 36023,
  38020: 22770,
  38021: 36064,
  38022: 38506,
  38023: 36889,
  38024: 34687,
  38025: 31204,
  38026: 30695,
  38027: 33833,
  38028: 20271,
  38029: 21093,
  38030: 21338,
  38031: 25293,
  38032: 26575,
  38033: 27850,
  38034: 30333,
  38035: 31636,
  38036: 31893,
  38037: 33334,
  38038: 34180,
  38039: 36843,
  38040: 26333,
  38041: 28448,
  38042: 29190,
  38043: 32283,
  38044: 33707,
  38045: 39361,
  38046: 40614,
  38047: 20989,
  38048: 31665,
  38049: 30834,
  38050: 31672,
  38051: 32903,
  38052: 31560,
  38053: 27368,
  38054: 24161,
  38055: 32908,
  38056: 30033,
  38057: 30048,
  38058: 20843,
  38059: 37474,
  38060: 28300,
  38061: 30330,
  38062: 37271,
  38063: 39658,
  38064: 20240,
  38065: 32624,
  38066: 25244,
  38067: 31567,
  38068: 38309,
  38069: 40169,
  38070: 22138,
  38071: 22617,
  38072: 34532,
  38073: 38588,
  38074: 20276,
  38075: 21028,
  38076: 21322,
  38077: 21453,
  38078: 21467,
  38079: 24070,
  38080: 25644,
  38081: 26001,
  38082: 26495,
  38083: 27710,
  38084: 27726,
  38085: 29256,
  38086: 29359,
  38087: 29677,
  38088: 30036,
  38089: 32321,
  38090: 33324,
  38091: 34281,
  38092: 36009,
  38093: 31684,
  38094: 37318,
  38095: 29033,
  38096: 38930,
  38097: 39151,
  38098: 25405,
  38099: 26217,
  38100: 30058,
  38101: 30436,
  38102: 30928,
  38103: 34115,
  38104: 34542,
  38105: 21290,
  38106: 21329,
  38107: 21542,
  38108: 22915,
  38109: 24199,
  38110: 24444,
  38111: 24754,
  38112: 25161,
  38113: 25209,
  38114: 25259,
  38115: 26e3,
  38116: 27604,
  38117: 27852,
  38118: 30130,
  38119: 30382,
  38120: 30865,
  38121: 31192,
  38122: 32203,
  38123: 32631,
  38124: 32933,
  38125: 34987,
  38126: 35513,
  38127: 36027,
  38128: 36991,
  38129: 38750,
  38130: 39131,
  38131: 27147,
  38132: 31800,
  38133: 20633,
  38134: 23614,
  38135: 24494,
  38136: 26503,
  38137: 27608,
  38138: 29749,
  38139: 30473,
  38140: 32654,
  38208: 40763,
  38209: 26570,
  38210: 31255,
  38211: 21305,
  38212: 30091,
  38213: 39661,
  38214: 24422,
  38215: 33181,
  38216: 33777,
  38217: 32920,
  38218: 24380,
  38219: 24517,
  38220: 30050,
  38221: 31558,
  38222: 36924,
  38223: 26727,
  38224: 23019,
  38225: 23195,
  38226: 32016,
  38227: 30334,
  38228: 35628,
  38229: 20469,
  38230: 24426,
  38231: 27161,
  38232: 27703,
  38233: 28418,
  38234: 29922,
  38235: 31080,
  38236: 34920,
  38237: 35413,
  38238: 35961,
  38239: 24287,
  38240: 25551,
  38241: 30149,
  38242: 31186,
  38243: 33495,
  38244: 37672,
  38245: 37618,
  38246: 33948,
  38247: 34541,
  38248: 39981,
  38249: 21697,
  38250: 24428,
  38251: 25996,
  38252: 27996,
  38253: 28693,
  38254: 36007,
  38255: 36051,
  38256: 38971,
  38257: 25935,
  38258: 29942,
  38259: 19981,
  38260: 20184,
  38261: 22496,
  38262: 22827,
  38263: 23142,
  38264: 23500,
  38265: 20904,
  38266: 24067,
  38267: 24220,
  38268: 24598,
  38269: 25206,
  38270: 25975,
  38272: 26023,
  38273: 26222,
  38274: 28014,
  38275: 29238,
  38276: 31526,
  38277: 33104,
  38278: 33178,
  38279: 33433,
  38280: 35676,
  38281: 36e3,
  38282: 36070,
  38283: 36212,
  38284: 38428,
  38285: 38468,
  38286: 20398,
  38287: 25771,
  38288: 27494,
  38289: 33310,
  38290: 33889,
  38291: 34154,
  38292: 37096,
  38293: 23553,
  38294: 26963,
  38295: 39080,
  38296: 33914,
  38297: 34135,
  38298: 20239,
  38299: 21103,
  38300: 24489,
  38301: 24133,
  38302: 26381,
  38303: 31119,
  38304: 33145,
  38305: 35079,
  38306: 35206,
  38307: 28149,
  38308: 24343,
  38309: 25173,
  38310: 27832,
  38311: 20175,
  38312: 29289,
  38313: 39826,
  38314: 20998,
  38315: 21563,
  38316: 22132,
  38317: 22707,
  38318: 24996,
  38319: 25198,
  38320: 28954,
  38321: 22894,
  38322: 31881,
  38323: 31966,
  38324: 32027,
  38325: 38640,
  38326: 25991,
  38327: 32862,
  38328: 19993,
  38329: 20341,
  38330: 20853,
  38331: 22592,
  38332: 24163,
  38333: 24179,
  38334: 24330,
  38335: 26564,
  38336: 20006,
  38337: 34109,
  38338: 38281,
  38339: 38491,
  38340: 31859,
  38341: 38913,
  38342: 20731,
  38343: 22721,
  38344: 30294,
  38345: 30887,
  38346: 21029,
  38347: 30629,
  38348: 34065,
  38349: 31622,
  38350: 20559,
  38351: 22793,
  38352: 29255,
  38353: 31687,
  38354: 32232,
  38355: 36794,
  38356: 36820,
  38357: 36941,
  38358: 20415,
  38359: 21193,
  38360: 23081,
  38361: 24321,
  38362: 38829,
  38363: 20445,
  38364: 33303,
  38365: 37610,
  38366: 22275,
  38367: 25429,
  38368: 27497,
  38369: 29995,
  38370: 35036,
  38371: 36628,
  38372: 31298,
  38373: 21215,
  38374: 22675,
  38375: 24917,
  38376: 25098,
  38377: 26286,
  38378: 27597,
  38379: 31807,
  38380: 33769,
  38381: 20515,
  38382: 20472,
  38383: 21253,
  38384: 21574,
  38385: 22577,
  38386: 22857,
  38387: 23453,
  38388: 23792,
  38389: 23791,
  38390: 23849,
  38391: 24214,
  38392: 25265,
  38393: 25447,
  38394: 25918,
  38395: 26041,
  38396: 26379,
  38464: 27861,
  38465: 27873,
  38466: 28921,
  38467: 30770,
  38468: 32299,
  38469: 32990,
  38470: 33459,
  38471: 33804,
  38472: 34028,
  38473: 34562,
  38474: 35090,
  38475: 35370,
  38476: 35914,
  38477: 37030,
  38478: 37586,
  38479: 39165,
  38480: 40179,
  38481: 40300,
  38482: 20047,
  38483: 20129,
  38484: 20621,
  38485: 21078,
  38486: 22346,
  38487: 22952,
  38488: 24125,
  38489: 24536,
  38490: 24537,
  38491: 25151,
  38492: 26292,
  38493: 26395,
  38494: 26576,
  38495: 26834,
  38496: 20882,
  38497: 32033,
  38498: 32938,
  38499: 33192,
  38500: 35584,
  38501: 35980,
  38502: 36031,
  38503: 37502,
  38504: 38450,
  38505: 21536,
  38506: 38956,
  38507: 21271,
  38508: 20693,
  38509: 21340,
  38510: 22696,
  38511: 25778,
  38512: 26420,
  38513: 29287,
  38514: 30566,
  38515: 31302,
  38516: 37350,
  38517: 21187,
  38518: 27809,
  38519: 27526,
  38520: 22528,
  38521: 24140,
  38522: 22868,
  38523: 26412,
  38524: 32763,
  38525: 20961,
  38526: 30406,
  38528: 25705,
  38529: 30952,
  38530: 39764,
  38531: 40635,
  38532: 22475,
  38533: 22969,
  38534: 26151,
  38535: 26522,
  38536: 27598,
  38537: 21737,
  38538: 27097,
  38539: 24149,
  38540: 33180,
  38541: 26517,
  38542: 39850,
  38543: 26622,
  38544: 40018,
  38545: 26717,
  38546: 20134,
  38547: 20451,
  38548: 21448,
  38549: 25273,
  38550: 26411,
  38551: 27819,
  38552: 36804,
  38553: 20397,
  38554: 32365,
  38555: 40639,
  38556: 19975,
  38557: 24930,
  38558: 28288,
  38559: 28459,
  38560: 34067,
  38561: 21619,
  38562: 26410,
  38563: 39749,
  38564: 24051,
  38565: 31637,
  38566: 23724,
  38567: 23494,
  38568: 34588,
  38569: 28234,
  38570: 34001,
  38571: 31252,
  38572: 33032,
  38573: 22937,
  38574: 31885,
  38575: 27665,
  38576: 30496,
  38577: 21209,
  38578: 22818,
  38579: 28961,
  38580: 29279,
  38581: 30683,
  38582: 38695,
  38583: 40289,
  38584: 26891,
  38585: 23167,
  38586: 23064,
  38587: 20901,
  38588: 21517,
  38589: 21629,
  38590: 26126,
  38591: 30431,
  38592: 36855,
  38593: 37528,
  38594: 40180,
  38595: 23018,
  38596: 29277,
  38597: 28357,
  38598: 20813,
  38599: 26825,
  38600: 32191,
  38601: 32236,
  38602: 38754,
  38603: 40634,
  38604: 25720,
  38605: 27169,
  38606: 33538,
  38607: 22916,
  38608: 23391,
  38609: 27611,
  38610: 29467,
  38611: 30450,
  38612: 32178,
  38613: 32791,
  38614: 33945,
  38615: 20786,
  38616: 26408,
  38617: 40665,
  38618: 30446,
  38619: 26466,
  38620: 21247,
  38621: 39173,
  38622: 23588,
  38623: 25147,
  38624: 31870,
  38625: 36016,
  38626: 21839,
  38627: 24758,
  38628: 32011,
  38629: 38272,
  38630: 21249,
  38631: 20063,
  38632: 20918,
  38633: 22812,
  38634: 29242,
  38635: 32822,
  38636: 37326,
  38637: 24357,
  38638: 30690,
  38639: 21380,
  38640: 24441,
  38641: 32004,
  38642: 34220,
  38643: 35379,
  38644: 36493,
  38645: 38742,
  38646: 26611,
  38647: 34222,
  38648: 37971,
  38649: 24841,
  38650: 24840,
  38651: 27833,
  38652: 30290,
  38720: 35565,
  38721: 36664,
  38722: 21807,
  38723: 20305,
  38724: 20778,
  38725: 21191,
  38726: 21451,
  38727: 23461,
  38728: 24189,
  38729: 24736,
  38730: 24962,
  38731: 25558,
  38732: 26377,
  38733: 26586,
  38734: 28263,
  38735: 28044,
  38736: 29494,
  38737: 29495,
  38738: 30001,
  38739: 31056,
  38740: 35029,
  38741: 35480,
  38742: 36938,
  38743: 37009,
  38744: 37109,
  38745: 38596,
  38746: 34701,
  38747: 22805,
  38748: 20104,
  38749: 20313,
  38750: 19982,
  38751: 35465,
  38752: 36671,
  38753: 38928,
  38754: 20653,
  38755: 24188,
  38756: 22934,
  38757: 23481,
  38758: 24248,
  38759: 25562,
  38760: 25594,
  38761: 25793,
  38762: 26332,
  38763: 26954,
  38764: 27096,
  38765: 27915,
  38766: 28342,
  38767: 29076,
  38768: 29992,
  38769: 31407,
  38770: 32650,
  38771: 32768,
  38772: 33865,
  38773: 33993,
  38774: 35201,
  38775: 35617,
  38776: 36362,
  38777: 36965,
  38778: 38525,
  38779: 39178,
  38780: 24958,
  38781: 25233,
  38782: 27442,
  38784: 27779,
  38785: 28020,
  38786: 32716,
  38787: 32764,
  38788: 28096,
  38789: 32645,
  38790: 34746,
  38791: 35064,
  38792: 26469,
  38793: 33713,
  38794: 38972,
  38795: 38647,
  38796: 27931,
  38797: 32097,
  38798: 33853,
  38799: 37226,
  38800: 20081,
  38801: 21365,
  38802: 23888,
  38803: 27396,
  38804: 28651,
  38805: 34253,
  38806: 34349,
  38807: 35239,
  38808: 21033,
  38809: 21519,
  38810: 23653,
  38811: 26446,
  38812: 26792,
  38813: 29702,
  38814: 29827,
  38815: 30178,
  38816: 35023,
  38817: 35041,
  38818: 37324,
  38819: 38626,
  38820: 38520,
  38821: 24459,
  38822: 29575,
  38823: 31435,
  38824: 33870,
  38825: 25504,
  38826: 30053,
  38827: 21129,
  38828: 27969,
  38829: 28316,
  38830: 29705,
  38831: 30041,
  38832: 30827,
  38833: 31890,
  38834: 38534,
  38835: 31452,
  38836: 40845,
  38837: 20406,
  38838: 24942,
  38839: 26053,
  38840: 34396,
  38841: 20102,
  38842: 20142,
  38843: 20698,
  38844: 20001,
  38845: 20940,
  38846: 23534,
  38847: 26009,
  38848: 26753,
  38849: 28092,
  38850: 29471,
  38851: 30274,
  38852: 30637,
  38853: 31260,
  38854: 31975,
  38855: 33391,
  38856: 35538,
  38857: 36988,
  38858: 37327,
  38859: 38517,
  38860: 38936,
  38861: 21147,
  38862: 32209,
  38863: 20523,
  38864: 21400,
  38865: 26519,
  38866: 28107,
  38867: 29136,
  38868: 29747,
  38869: 33256,
  38870: 36650,
  38871: 38563,
  38872: 40023,
  38873: 40607,
  38874: 29792,
  38875: 22593,
  38876: 28057,
  38877: 32047,
  38878: 39006,
  38879: 20196,
  38880: 20278,
  38881: 20363,
  38882: 20919,
  38883: 21169,
  38884: 23994,
  38885: 24604,
  38886: 29618,
  38887: 31036,
  38888: 33491,
  38889: 37428,
  38890: 38583,
  38891: 38646,
  38892: 38666,
  38893: 40599,
  38894: 40802,
  38895: 26278,
  38896: 27508,
  38897: 21015,
  38898: 21155,
  38899: 28872,
  38900: 35010,
  38901: 24265,
  38902: 24651,
  38903: 24976,
  38904: 28451,
  38905: 29001,
  38906: 31806,
  38907: 32244,
  38908: 32879,
  38976: 34030,
  38977: 36899,
  38978: 37676,
  38979: 21570,
  38980: 39791,
  38981: 27347,
  38982: 28809,
  38983: 36034,
  38984: 36335,
  38985: 38706,
  38986: 21172,
  38987: 23105,
  38988: 24266,
  38989: 24324,
  38990: 26391,
  38991: 27004,
  38992: 27028,
  38993: 28010,
  38994: 28431,
  38995: 29282,
  38996: 29436,
  38997: 31725,
  38998: 32769,
  38999: 32894,
  39e3: 34635,
  39001: 37070,
  39002: 20845,
  39003: 40595,
  39004: 31108,
  39005: 32907,
  39006: 37682,
  39007: 35542,
  39008: 20525,
  39009: 21644,
  39010: 35441,
  39011: 27498,
  39012: 36036,
  39013: 33031,
  39014: 24785,
  39015: 26528,
  39016: 40434,
  39017: 20121,
  39018: 20120,
  39019: 39952,
  39020: 35435,
  39021: 34241,
  39022: 34152,
  39023: 26880,
  39024: 28286,
  39025: 30871,
  39026: 33109,
  39071: 24332,
  39072: 19984,
  39073: 19989,
  39074: 20010,
  39075: 20017,
  39076: 20022,
  39077: 20028,
  39078: 20031,
  39079: 20034,
  39080: 20054,
  39081: 20056,
  39082: 20098,
  39083: 20101,
  39084: 35947,
  39085: 20106,
  39086: 33298,
  39087: 24333,
  39088: 20110,
  39089: 20126,
  39090: 20127,
  39091: 20128,
  39092: 20130,
  39093: 20144,
  39094: 20147,
  39095: 20150,
  39096: 20174,
  39097: 20173,
  39098: 20164,
  39099: 20166,
  39100: 20162,
  39101: 20183,
  39102: 20190,
  39103: 20205,
  39104: 20191,
  39105: 20215,
  39106: 20233,
  39107: 20314,
  39108: 20272,
  39109: 20315,
  39110: 20317,
  39111: 20311,
  39112: 20295,
  39113: 20342,
  39114: 20360,
  39115: 20367,
  39116: 20376,
  39117: 20347,
  39118: 20329,
  39119: 20336,
  39120: 20369,
  39121: 20335,
  39122: 20358,
  39123: 20374,
  39124: 20760,
  39125: 20436,
  39126: 20447,
  39127: 20430,
  39128: 20440,
  39129: 20443,
  39130: 20433,
  39131: 20442,
  39132: 20432,
  39133: 20452,
  39134: 20453,
  39135: 20506,
  39136: 20520,
  39137: 20500,
  39138: 20522,
  39139: 20517,
  39140: 20485,
  39141: 20252,
  39142: 20470,
  39143: 20513,
  39144: 20521,
  39145: 20524,
  39146: 20478,
  39147: 20463,
  39148: 20497,
  39149: 20486,
  39150: 20547,
  39151: 20551,
  39152: 26371,
  39153: 20565,
  39154: 20560,
  39155: 20552,
  39156: 20570,
  39157: 20566,
  39158: 20588,
  39159: 20600,
  39160: 20608,
  39161: 20634,
  39162: 20613,
  39163: 20660,
  39164: 20658,
  39232: 20681,
  39233: 20682,
  39234: 20659,
  39235: 20674,
  39236: 20694,
  39237: 20702,
  39238: 20709,
  39239: 20717,
  39240: 20707,
  39241: 20718,
  39242: 20729,
  39243: 20725,
  39244: 20745,
  39245: 20737,
  39246: 20738,
  39247: 20758,
  39248: 20757,
  39249: 20756,
  39250: 20762,
  39251: 20769,
  39252: 20794,
  39253: 20791,
  39254: 20796,
  39255: 20795,
  39256: 20799,
  39257: 20800,
  39258: 20818,
  39259: 20812,
  39260: 20820,
  39261: 20834,
  39262: 31480,
  39263: 20841,
  39264: 20842,
  39265: 20846,
  39266: 20864,
  39267: 20866,
  39268: 22232,
  39269: 20876,
  39270: 20873,
  39271: 20879,
  39272: 20881,
  39273: 20883,
  39274: 20885,
  39275: 20886,
  39276: 20900,
  39277: 20902,
  39278: 20898,
  39279: 20905,
  39280: 20906,
  39281: 20907,
  39282: 20915,
  39283: 20913,
  39284: 20914,
  39285: 20912,
  39286: 20917,
  39287: 20925,
  39288: 20933,
  39289: 20937,
  39290: 20955,
  39291: 20960,
  39292: 34389,
  39293: 20969,
  39294: 20973,
  39296: 20976,
  39297: 20981,
  39298: 20990,
  39299: 20996,
  39300: 21003,
  39301: 21012,
  39302: 21006,
  39303: 21031,
  39304: 21034,
  39305: 21038,
  39306: 21043,
  39307: 21049,
  39308: 21071,
  39309: 21060,
  39310: 21067,
  39311: 21068,
  39312: 21086,
  39313: 21076,
  39314: 21098,
  39315: 21108,
  39316: 21097,
  39317: 21107,
  39318: 21119,
  39319: 21117,
  39320: 21133,
  39321: 21140,
  39322: 21138,
  39323: 21105,
  39324: 21128,
  39325: 21137,
  39326: 36776,
  39327: 36775,
  39328: 21164,
  39329: 21165,
  39330: 21180,
  39331: 21173,
  39332: 21185,
  39333: 21197,
  39334: 21207,
  39335: 21214,
  39336: 21219,
  39337: 21222,
  39338: 39149,
  39339: 21216,
  39340: 21235,
  39341: 21237,
  39342: 21240,
  39343: 21241,
  39344: 21254,
  39345: 21256,
  39346: 30008,
  39347: 21261,
  39348: 21264,
  39349: 21263,
  39350: 21269,
  39351: 21274,
  39352: 21283,
  39353: 21295,
  39354: 21297,
  39355: 21299,
  39356: 21304,
  39357: 21312,
  39358: 21318,
  39359: 21317,
  39360: 19991,
  39361: 21321,
  39362: 21325,
  39363: 20950,
  39364: 21342,
  39365: 21353,
  39366: 21358,
  39367: 22808,
  39368: 21371,
  39369: 21367,
  39370: 21378,
  39371: 21398,
  39372: 21408,
  39373: 21414,
  39374: 21413,
  39375: 21422,
  39376: 21424,
  39377: 21430,
  39378: 21443,
  39379: 31762,
  39380: 38617,
  39381: 21471,
  39382: 26364,
  39383: 29166,
  39384: 21486,
  39385: 21480,
  39386: 21485,
  39387: 21498,
  39388: 21505,
  39389: 21565,
  39390: 21568,
  39391: 21548,
  39392: 21549,
  39393: 21564,
  39394: 21550,
  39395: 21558,
  39396: 21545,
  39397: 21533,
  39398: 21582,
  39399: 21647,
  39400: 21621,
  39401: 21646,
  39402: 21599,
  39403: 21617,
  39404: 21623,
  39405: 21616,
  39406: 21650,
  39407: 21627,
  39408: 21632,
  39409: 21622,
  39410: 21636,
  39411: 21648,
  39412: 21638,
  39413: 21703,
  39414: 21666,
  39415: 21688,
  39416: 21669,
  39417: 21676,
  39418: 21700,
  39419: 21704,
  39420: 21672,
  39488: 21675,
  39489: 21698,
  39490: 21668,
  39491: 21694,
  39492: 21692,
  39493: 21720,
  39494: 21733,
  39495: 21734,
  39496: 21775,
  39497: 21780,
  39498: 21757,
  39499: 21742,
  39500: 21741,
  39501: 21754,
  39502: 21730,
  39503: 21817,
  39504: 21824,
  39505: 21859,
  39506: 21836,
  39507: 21806,
  39508: 21852,
  39509: 21829,
  39510: 21846,
  39511: 21847,
  39512: 21816,
  39513: 21811,
  39514: 21853,
  39515: 21913,
  39516: 21888,
  39517: 21679,
  39518: 21898,
  39519: 21919,
  39520: 21883,
  39521: 21886,
  39522: 21912,
  39523: 21918,
  39524: 21934,
  39525: 21884,
  39526: 21891,
  39527: 21929,
  39528: 21895,
  39529: 21928,
  39530: 21978,
  39531: 21957,
  39532: 21983,
  39533: 21956,
  39534: 21980,
  39535: 21988,
  39536: 21972,
  39537: 22036,
  39538: 22007,
  39539: 22038,
  39540: 22014,
  39541: 22013,
  39542: 22043,
  39543: 22009,
  39544: 22094,
  39545: 22096,
  39546: 29151,
  39547: 22068,
  39548: 22070,
  39549: 22066,
  39550: 22072,
  39552: 22123,
  39553: 22116,
  39554: 22063,
  39555: 22124,
  39556: 22122,
  39557: 22150,
  39558: 22144,
  39559: 22154,
  39560: 22176,
  39561: 22164,
  39562: 22159,
  39563: 22181,
  39564: 22190,
  39565: 22198,
  39566: 22196,
  39567: 22210,
  39568: 22204,
  39569: 22209,
  39570: 22211,
  39571: 22208,
  39572: 22216,
  39573: 22222,
  39574: 22225,
  39575: 22227,
  39576: 22231,
  39577: 22254,
  39578: 22265,
  39579: 22272,
  39580: 22271,
  39581: 22276,
  39582: 22281,
  39583: 22280,
  39584: 22283,
  39585: 22285,
  39586: 22291,
  39587: 22296,
  39588: 22294,
  39589: 21959,
  39590: 22300,
  39591: 22310,
  39592: 22327,
  39593: 22328,
  39594: 22350,
  39595: 22331,
  39596: 22336,
  39597: 22351,
  39598: 22377,
  39599: 22464,
  39600: 22408,
  39601: 22369,
  39602: 22399,
  39603: 22409,
  39604: 22419,
  39605: 22432,
  39606: 22451,
  39607: 22436,
  39608: 22442,
  39609: 22448,
  39610: 22467,
  39611: 22470,
  39612: 22484,
  39613: 22482,
  39614: 22483,
  39615: 22538,
  39616: 22486,
  39617: 22499,
  39618: 22539,
  39619: 22553,
  39620: 22557,
  39621: 22642,
  39622: 22561,
  39623: 22626,
  39624: 22603,
  39625: 22640,
  39626: 27584,
  39627: 22610,
  39628: 22589,
  39629: 22649,
  39630: 22661,
  39631: 22713,
  39632: 22687,
  39633: 22699,
  39634: 22714,
  39635: 22750,
  39636: 22715,
  39637: 22712,
  39638: 22702,
  39639: 22725,
  39640: 22739,
  39641: 22737,
  39642: 22743,
  39643: 22745,
  39644: 22744,
  39645: 22757,
  39646: 22748,
  39647: 22756,
  39648: 22751,
  39649: 22767,
  39650: 22778,
  39651: 22777,
  39652: 22779,
  39653: 22780,
  39654: 22781,
  39655: 22786,
  39656: 22794,
  39657: 22800,
  39658: 22811,
  39659: 26790,
  39660: 22821,
  39661: 22828,
  39662: 22829,
  39663: 22834,
  39664: 22840,
  39665: 22846,
  39666: 31442,
  39667: 22869,
  39668: 22864,
  39669: 22862,
  39670: 22874,
  39671: 22872,
  39672: 22882,
  39673: 22880,
  39674: 22887,
  39675: 22892,
  39676: 22889,
  39744: 22904,
  39745: 22913,
  39746: 22941,
  39747: 20318,
  39748: 20395,
  39749: 22947,
  39750: 22962,
  39751: 22982,
  39752: 23016,
  39753: 23004,
  39754: 22925,
  39755: 23001,
  39756: 23002,
  39757: 23077,
  39758: 23071,
  39759: 23057,
  39760: 23068,
  39761: 23049,
  39762: 23066,
  39763: 23104,
  39764: 23148,
  39765: 23113,
  39766: 23093,
  39767: 23094,
  39768: 23138,
  39769: 23146,
  39770: 23194,
  39771: 23228,
  39772: 23230,
  39773: 23243,
  39774: 23234,
  39775: 23229,
  39776: 23267,
  39777: 23255,
  39778: 23270,
  39779: 23273,
  39780: 23254,
  39781: 23290,
  39782: 23291,
  39783: 23308,
  39784: 23307,
  39785: 23318,
  39786: 23346,
  39787: 23248,
  39788: 23338,
  39789: 23350,
  39790: 23358,
  39791: 23363,
  39792: 23365,
  39793: 23360,
  39794: 23377,
  39795: 23381,
  39796: 23386,
  39797: 23387,
  39798: 23397,
  39799: 23401,
  39800: 23408,
  39801: 23411,
  39802: 23413,
  39803: 23416,
  39804: 25992,
  39805: 23418,
  39806: 23424,
  39808: 23427,
  39809: 23462,
  39810: 23480,
  39811: 23491,
  39812: 23495,
  39813: 23497,
  39814: 23508,
  39815: 23504,
  39816: 23524,
  39817: 23526,
  39818: 23522,
  39819: 23518,
  39820: 23525,
  39821: 23531,
  39822: 23536,
  39823: 23542,
  39824: 23539,
  39825: 23557,
  39826: 23559,
  39827: 23560,
  39828: 23565,
  39829: 23571,
  39830: 23584,
  39831: 23586,
  39832: 23592,
  39833: 23608,
  39834: 23609,
  39835: 23617,
  39836: 23622,
  39837: 23630,
  39838: 23635,
  39839: 23632,
  39840: 23631,
  39841: 23409,
  39842: 23660,
  39843: 23662,
  39844: 20066,
  39845: 23670,
  39846: 23673,
  39847: 23692,
  39848: 23697,
  39849: 23700,
  39850: 22939,
  39851: 23723,
  39852: 23739,
  39853: 23734,
  39854: 23740,
  39855: 23735,
  39856: 23749,
  39857: 23742,
  39858: 23751,
  39859: 23769,
  39860: 23785,
  39861: 23805,
  39862: 23802,
  39863: 23789,
  39864: 23948,
  39865: 23786,
  39866: 23819,
  39867: 23829,
  39868: 23831,
  39869: 23900,
  39870: 23839,
  39871: 23835,
  39872: 23825,
  39873: 23828,
  39874: 23842,
  39875: 23834,
  39876: 23833,
  39877: 23832,
  39878: 23884,
  39879: 23890,
  39880: 23886,
  39881: 23883,
  39882: 23916,
  39883: 23923,
  39884: 23926,
  39885: 23943,
  39886: 23940,
  39887: 23938,
  39888: 23970,
  39889: 23965,
  39890: 23980,
  39891: 23982,
  39892: 23997,
  39893: 23952,
  39894: 23991,
  39895: 23996,
  39896: 24009,
  39897: 24013,
  39898: 24019,
  39899: 24018,
  39900: 24022,
  39901: 24027,
  39902: 24043,
  39903: 24050,
  39904: 24053,
  39905: 24075,
  39906: 24090,
  39907: 24089,
  39908: 24081,
  39909: 24091,
  39910: 24118,
  39911: 24119,
  39912: 24132,
  39913: 24131,
  39914: 24128,
  39915: 24142,
  39916: 24151,
  39917: 24148,
  39918: 24159,
  39919: 24162,
  39920: 24164,
  39921: 24135,
  39922: 24181,
  39923: 24182,
  39924: 24186,
  39925: 40636,
  39926: 24191,
  39927: 24224,
  39928: 24257,
  39929: 24258,
  39930: 24264,
  39931: 24272,
  39932: 24271,
  4e4: 24278,
  40001: 24291,
  40002: 24285,
  40003: 24282,
  40004: 24283,
  40005: 24290,
  40006: 24289,
  40007: 24296,
  40008: 24297,
  40009: 24300,
  40010: 24305,
  40011: 24307,
  40012: 24304,
  40013: 24308,
  40014: 24312,
  40015: 24318,
  40016: 24323,
  40017: 24329,
  40018: 24413,
  40019: 24412,
  40020: 24331,
  40021: 24337,
  40022: 24342,
  40023: 24361,
  40024: 24365,
  40025: 24376,
  40026: 24385,
  40027: 24392,
  40028: 24396,
  40029: 24398,
  40030: 24367,
  40031: 24401,
  40032: 24406,
  40033: 24407,
  40034: 24409,
  40035: 24417,
  40036: 24429,
  40037: 24435,
  40038: 24439,
  40039: 24451,
  40040: 24450,
  40041: 24447,
  40042: 24458,
  40043: 24456,
  40044: 24465,
  40045: 24455,
  40046: 24478,
  40047: 24473,
  40048: 24472,
  40049: 24480,
  40050: 24488,
  40051: 24493,
  40052: 24508,
  40053: 24534,
  40054: 24571,
  40055: 24548,
  40056: 24568,
  40057: 24561,
  40058: 24541,
  40059: 24755,
  40060: 24575,
  40061: 24609,
  40062: 24672,
  40064: 24601,
  40065: 24592,
  40066: 24617,
  40067: 24590,
  40068: 24625,
  40069: 24603,
  40070: 24597,
  40071: 24619,
  40072: 24614,
  40073: 24591,
  40074: 24634,
  40075: 24666,
  40076: 24641,
  40077: 24682,
  40078: 24695,
  40079: 24671,
  40080: 24650,
  40081: 24646,
  40082: 24653,
  40083: 24675,
  40084: 24643,
  40085: 24676,
  40086: 24642,
  40087: 24684,
  40088: 24683,
  40089: 24665,
  40090: 24705,
  40091: 24717,
  40092: 24807,
  40093: 24707,
  40094: 24730,
  40095: 24708,
  40096: 24731,
  40097: 24726,
  40098: 24727,
  40099: 24722,
  40100: 24743,
  40101: 24715,
  40102: 24801,
  40103: 24760,
  40104: 24800,
  40105: 24787,
  40106: 24756,
  40107: 24560,
  40108: 24765,
  40109: 24774,
  40110: 24757,
  40111: 24792,
  40112: 24909,
  40113: 24853,
  40114: 24838,
  40115: 24822,
  40116: 24823,
  40117: 24832,
  40118: 24820,
  40119: 24826,
  40120: 24835,
  40121: 24865,
  40122: 24827,
  40123: 24817,
  40124: 24845,
  40125: 24846,
  40126: 24903,
  40127: 24894,
  40128: 24872,
  40129: 24871,
  40130: 24906,
  40131: 24895,
  40132: 24892,
  40133: 24876,
  40134: 24884,
  40135: 24893,
  40136: 24898,
  40137: 24900,
  40138: 24947,
  40139: 24951,
  40140: 24920,
  40141: 24921,
  40142: 24922,
  40143: 24939,
  40144: 24948,
  40145: 24943,
  40146: 24933,
  40147: 24945,
  40148: 24927,
  40149: 24925,
  40150: 24915,
  40151: 24949,
  40152: 24985,
  40153: 24982,
  40154: 24967,
  40155: 25004,
  40156: 24980,
  40157: 24986,
  40158: 24970,
  40159: 24977,
  40160: 25003,
  40161: 25006,
  40162: 25036,
  40163: 25034,
  40164: 25033,
  40165: 25079,
  40166: 25032,
  40167: 25027,
  40168: 25030,
  40169: 25018,
  40170: 25035,
  40171: 32633,
  40172: 25037,
  40173: 25062,
  40174: 25059,
  40175: 25078,
  40176: 25082,
  40177: 25076,
  40178: 25087,
  40179: 25085,
  40180: 25084,
  40181: 25086,
  40182: 25088,
  40183: 25096,
  40184: 25097,
  40185: 25101,
  40186: 25100,
  40187: 25108,
  40188: 25115,
  40256: 25118,
  40257: 25121,
  40258: 25130,
  40259: 25134,
  40260: 25136,
  40261: 25138,
  40262: 25139,
  40263: 25153,
  40264: 25166,
  40265: 25182,
  40266: 25187,
  40267: 25179,
  40268: 25184,
  40269: 25192,
  40270: 25212,
  40271: 25218,
  40272: 25225,
  40273: 25214,
  40274: 25234,
  40275: 25235,
  40276: 25238,
  40277: 25300,
  40278: 25219,
  40279: 25236,
  40280: 25303,
  40281: 25297,
  40282: 25275,
  40283: 25295,
  40284: 25343,
  40285: 25286,
  40286: 25812,
  40287: 25288,
  40288: 25308,
  40289: 25292,
  40290: 25290,
  40291: 25282,
  40292: 25287,
  40293: 25243,
  40294: 25289,
  40295: 25356,
  40296: 25326,
  40297: 25329,
  40298: 25383,
  40299: 25346,
  40300: 25352,
  40301: 25327,
  40302: 25333,
  40303: 25424,
  40304: 25406,
  40305: 25421,
  40306: 25628,
  40307: 25423,
  40308: 25494,
  40309: 25486,
  40310: 25472,
  40311: 25515,
  40312: 25462,
  40313: 25507,
  40314: 25487,
  40315: 25481,
  40316: 25503,
  40317: 25525,
  40318: 25451,
  40320: 25449,
  40321: 25534,
  40322: 25577,
  40323: 25536,
  40324: 25542,
  40325: 25571,
  40326: 25545,
  40327: 25554,
  40328: 25590,
  40329: 25540,
  40330: 25622,
  40331: 25652,
  40332: 25606,
  40333: 25619,
  40334: 25638,
  40335: 25654,
  40336: 25885,
  40337: 25623,
  40338: 25640,
  40339: 25615,
  40340: 25703,
  40341: 25711,
  40342: 25718,
  40343: 25678,
  40344: 25898,
  40345: 25749,
  40346: 25747,
  40347: 25765,
  40348: 25769,
  40349: 25736,
  40350: 25788,
  40351: 25818,
  40352: 25810,
  40353: 25797,
  40354: 25799,
  40355: 25787,
  40356: 25816,
  40357: 25794,
  40358: 25841,
  40359: 25831,
  40360: 33289,
  40361: 25824,
  40362: 25825,
  40363: 25260,
  40364: 25827,
  40365: 25839,
  40366: 25900,
  40367: 25846,
  40368: 25844,
  40369: 25842,
  40370: 25850,
  40371: 25856,
  40372: 25853,
  40373: 25880,
  40374: 25884,
  40375: 25861,
  40376: 25892,
  40377: 25891,
  40378: 25899,
  40379: 25908,
  40380: 25909,
  40381: 25911,
  40382: 25910,
  40383: 25912,
  40384: 30027,
  40385: 25928,
  40386: 25942,
  40387: 25941,
  40388: 25933,
  40389: 25944,
  40390: 25950,
  40391: 25949,
  40392: 25970,
  40393: 25976,
  40394: 25986,
  40395: 25987,
  40396: 35722,
  40397: 26011,
  40398: 26015,
  40399: 26027,
  40400: 26039,
  40401: 26051,
  40402: 26054,
  40403: 26049,
  40404: 26052,
  40405: 26060,
  40406: 26066,
  40407: 26075,
  40408: 26073,
  40409: 26080,
  40410: 26081,
  40411: 26097,
  40412: 26482,
  40413: 26122,
  40414: 26115,
  40415: 26107,
  40416: 26483,
  40417: 26165,
  40418: 26166,
  40419: 26164,
  40420: 26140,
  40421: 26191,
  40422: 26180,
  40423: 26185,
  40424: 26177,
  40425: 26206,
  40426: 26205,
  40427: 26212,
  40428: 26215,
  40429: 26216,
  40430: 26207,
  40431: 26210,
  40432: 26224,
  40433: 26243,
  40434: 26248,
  40435: 26254,
  40436: 26249,
  40437: 26244,
  40438: 26264,
  40439: 26269,
  40440: 26305,
  40441: 26297,
  40442: 26313,
  40443: 26302,
  40444: 26300,
  40512: 26308,
  40513: 26296,
  40514: 26326,
  40515: 26330,
  40516: 26336,
  40517: 26175,
  40518: 26342,
  40519: 26345,
  40520: 26352,
  40521: 26357,
  40522: 26359,
  40523: 26383,
  40524: 26390,
  40525: 26398,
  40526: 26406,
  40527: 26407,
  40528: 38712,
  40529: 26414,
  40530: 26431,
  40531: 26422,
  40532: 26433,
  40533: 26424,
  40534: 26423,
  40535: 26438,
  40536: 26462,
  40537: 26464,
  40538: 26457,
  40539: 26467,
  40540: 26468,
  40541: 26505,
  40542: 26480,
  40543: 26537,
  40544: 26492,
  40545: 26474,
  40546: 26508,
  40547: 26507,
  40548: 26534,
  40549: 26529,
  40550: 26501,
  40551: 26551,
  40552: 26607,
  40553: 26548,
  40554: 26604,
  40555: 26547,
  40556: 26601,
  40557: 26552,
  40558: 26596,
  40559: 26590,
  40560: 26589,
  40561: 26594,
  40562: 26606,
  40563: 26553,
  40564: 26574,
  40565: 26566,
  40566: 26599,
  40567: 27292,
  40568: 26654,
  40569: 26694,
  40570: 26665,
  40571: 26688,
  40572: 26701,
  40573: 26674,
  40574: 26702,
  40576: 26803,
  40577: 26667,
  40578: 26713,
  40579: 26723,
  40580: 26743,
  40581: 26751,
  40582: 26783,
  40583: 26767,
  40584: 26797,
  40585: 26772,
  40586: 26781,
  40587: 26779,
  40588: 26755,
  40589: 27310,
  40590: 26809,
  40591: 26740,
  40592: 26805,
  40593: 26784,
  40594: 26810,
  40595: 26895,
  40596: 26765,
  40597: 26750,
  40598: 26881,
  40599: 26826,
  40600: 26888,
  40601: 26840,
  40602: 26914,
  40603: 26918,
  40604: 26849,
  40605: 26892,
  40606: 26829,
  40607: 26836,
  40608: 26855,
  40609: 26837,
  40610: 26934,
  40611: 26898,
  40612: 26884,
  40613: 26839,
  40614: 26851,
  40615: 26917,
  40616: 26873,
  40617: 26848,
  40618: 26863,
  40619: 26920,
  40620: 26922,
  40621: 26906,
  40622: 26915,
  40623: 26913,
  40624: 26822,
  40625: 27001,
  40626: 26999,
  40627: 26972,
  40628: 27e3,
  40629: 26987,
  40630: 26964,
  40631: 27006,
  40632: 26990,
  40633: 26937,
  40634: 26996,
  40635: 26941,
  40636: 26969,
  40637: 26928,
  40638: 26977,
  40639: 26974,
  40640: 26973,
  40641: 27009,
  40642: 26986,
  40643: 27058,
  40644: 27054,
  40645: 27088,
  40646: 27071,
  40647: 27073,
  40648: 27091,
  40649: 27070,
  40650: 27086,
  40651: 23528,
  40652: 27082,
  40653: 27101,
  40654: 27067,
  40655: 27075,
  40656: 27047,
  40657: 27182,
  40658: 27025,
  40659: 27040,
  40660: 27036,
  40661: 27029,
  40662: 27060,
  40663: 27102,
  40664: 27112,
  40665: 27138,
  40666: 27163,
  40667: 27135,
  40668: 27402,
  40669: 27129,
  40670: 27122,
  40671: 27111,
  40672: 27141,
  40673: 27057,
  40674: 27166,
  40675: 27117,
  40676: 27156,
  40677: 27115,
  40678: 27146,
  40679: 27154,
  40680: 27329,
  40681: 27171,
  40682: 27155,
  40683: 27204,
  40684: 27148,
  40685: 27250,
  40686: 27190,
  40687: 27256,
  40688: 27207,
  40689: 27234,
  40690: 27225,
  40691: 27238,
  40692: 27208,
  40693: 27192,
  40694: 27170,
  40695: 27280,
  40696: 27277,
  40697: 27296,
  40698: 27268,
  40699: 27298,
  40700: 27299,
  40768: 27287,
  40769: 34327,
  40770: 27323,
  40771: 27331,
  40772: 27330,
  40773: 27320,
  40774: 27315,
  40775: 27308,
  40776: 27358,
  40777: 27345,
  40778: 27359,
  40779: 27306,
  40780: 27354,
  40781: 27370,
  40782: 27387,
  40783: 27397,
  40784: 34326,
  40785: 27386,
  40786: 27410,
  40787: 27414,
  40788: 39729,
  40789: 27423,
  40790: 27448,
  40791: 27447,
  40792: 30428,
  40793: 27449,
  40794: 39150,
  40795: 27463,
  40796: 27459,
  40797: 27465,
  40798: 27472,
  40799: 27481,
  40800: 27476,
  40801: 27483,
  40802: 27487,
  40803: 27489,
  40804: 27512,
  40805: 27513,
  40806: 27519,
  40807: 27520,
  40808: 27524,
  40809: 27523,
  40810: 27533,
  40811: 27544,
  40812: 27541,
  40813: 27550,
  40814: 27556,
  40815: 27562,
  40816: 27563,
  40817: 27567,
  40818: 27570,
  40819: 27569,
  40820: 27571,
  40821: 27575,
  40822: 27580,
  40823: 27590,
  40824: 27595,
  40825: 27603,
  40826: 27615,
  40827: 27628,
  40828: 27627,
  40829: 27635,
  40830: 27631,
  40832: 40638,
  40833: 27656,
  40834: 27667,
  40835: 27668,
  40836: 27675,
  40837: 27684,
  40838: 27683,
  40839: 27742,
  40840: 27733,
  40841: 27746,
  40842: 27754,
  40843: 27778,
  40844: 27789,
  40845: 27802,
  40846: 27777,
  40847: 27803,
  40848: 27774,
  40849: 27752,
  40850: 27763,
  40851: 27794,
  40852: 27792,
  40853: 27844,
  40854: 27889,
  40855: 27859,
  40856: 27837,
  40857: 27863,
  40858: 27845,
  40859: 27869,
  40860: 27822,
  40861: 27825,
  40862: 27838,
  40863: 27834,
  40864: 27867,
  40865: 27887,
  40866: 27865,
  40867: 27882,
  40868: 27935,
  40869: 34893,
  40870: 27958,
  40871: 27947,
  40872: 27965,
  40873: 27960,
  40874: 27929,
  40875: 27957,
  40876: 27955,
  40877: 27922,
  40878: 27916,
  40879: 28003,
  40880: 28051,
  40881: 28004,
  40882: 27994,
  40883: 28025,
  40884: 27993,
  40885: 28046,
  40886: 28053,
  40887: 28644,
  40888: 28037,
  40889: 28153,
  40890: 28181,
  40891: 28170,
  40892: 28085,
  40893: 28103,
  40894: 28134,
  40895: 28088,
  40896: 28102,
  40897: 28140,
  40898: 28126,
  40899: 28108,
  40900: 28136,
  40901: 28114,
  40902: 28101,
  40903: 28154,
  40904: 28121,
  40905: 28132,
  40906: 28117,
  40907: 28138,
  40908: 28142,
  40909: 28205,
  40910: 28270,
  40911: 28206,
  40912: 28185,
  40913: 28274,
  40914: 28255,
  40915: 28222,
  40916: 28195,
  40917: 28267,
  40918: 28203,
  40919: 28278,
  40920: 28237,
  40921: 28191,
  40922: 28227,
  40923: 28218,
  40924: 28238,
  40925: 28196,
  40926: 28415,
  40927: 28189,
  40928: 28216,
  40929: 28290,
  40930: 28330,
  40931: 28312,
  40932: 28361,
  40933: 28343,
  40934: 28371,
  40935: 28349,
  40936: 28335,
  40937: 28356,
  40938: 28338,
  40939: 28372,
  40940: 28373,
  40941: 28303,
  40942: 28325,
  40943: 28354,
  40944: 28319,
  40945: 28481,
  40946: 28433,
  40947: 28748,
  40948: 28396,
  40949: 28408,
  40950: 28414,
  40951: 28479,
  40952: 28402,
  40953: 28465,
  40954: 28399,
  40955: 28466,
  40956: 28364,
  57408: 28478,
  57409: 28435,
  57410: 28407,
  57411: 28550,
  57412: 28538,
  57413: 28536,
  57414: 28545,
  57415: 28544,
  57416: 28527,
  57417: 28507,
  57418: 28659,
  57419: 28525,
  57420: 28546,
  57421: 28540,
  57422: 28504,
  57423: 28558,
  57424: 28561,
  57425: 28610,
  57426: 28518,
  57427: 28595,
  57428: 28579,
  57429: 28577,
  57430: 28580,
  57431: 28601,
  57432: 28614,
  57433: 28586,
  57434: 28639,
  57435: 28629,
  57436: 28652,
  57437: 28628,
  57438: 28632,
  57439: 28657,
  57440: 28654,
  57441: 28635,
  57442: 28681,
  57443: 28683,
  57444: 28666,
  57445: 28689,
  57446: 28673,
  57447: 28687,
  57448: 28670,
  57449: 28699,
  57450: 28698,
  57451: 28532,
  57452: 28701,
  57453: 28696,
  57454: 28703,
  57455: 28720,
  57456: 28734,
  57457: 28722,
  57458: 28753,
  57459: 28771,
  57460: 28825,
  57461: 28818,
  57462: 28847,
  57463: 28913,
  57464: 28844,
  57465: 28856,
  57466: 28851,
  57467: 28846,
  57468: 28895,
  57469: 28875,
  57470: 28893,
  57472: 28889,
  57473: 28937,
  57474: 28925,
  57475: 28956,
  57476: 28953,
  57477: 29029,
  57478: 29013,
  57479: 29064,
  57480: 29030,
  57481: 29026,
  57482: 29004,
  57483: 29014,
  57484: 29036,
  57485: 29071,
  57486: 29179,
  57487: 29060,
  57488: 29077,
  57489: 29096,
  57490: 29100,
  57491: 29143,
  57492: 29113,
  57493: 29118,
  57494: 29138,
  57495: 29129,
  57496: 29140,
  57497: 29134,
  57498: 29152,
  57499: 29164,
  57500: 29159,
  57501: 29173,
  57502: 29180,
  57503: 29177,
  57504: 29183,
  57505: 29197,
  57506: 29200,
  57507: 29211,
  57508: 29224,
  57509: 29229,
  57510: 29228,
  57511: 29232,
  57512: 29234,
  57513: 29243,
  57514: 29244,
  57515: 29247,
  57516: 29248,
  57517: 29254,
  57518: 29259,
  57519: 29272,
  57520: 29300,
  57521: 29310,
  57522: 29314,
  57523: 29313,
  57524: 29319,
  57525: 29330,
  57526: 29334,
  57527: 29346,
  57528: 29351,
  57529: 29369,
  57530: 29362,
  57531: 29379,
  57532: 29382,
  57533: 29380,
  57534: 29390,
  57535: 29394,
  57536: 29410,
  57537: 29408,
  57538: 29409,
  57539: 29433,
  57540: 29431,
  57541: 20495,
  57542: 29463,
  57543: 29450,
  57544: 29468,
  57545: 29462,
  57546: 29469,
  57547: 29492,
  57548: 29487,
  57549: 29481,
  57550: 29477,
  57551: 29502,
  57552: 29518,
  57553: 29519,
  57554: 40664,
  57555: 29527,
  57556: 29546,
  57557: 29544,
  57558: 29552,
  57559: 29560,
  57560: 29557,
  57561: 29563,
  57562: 29562,
  57563: 29640,
  57564: 29619,
  57565: 29646,
  57566: 29627,
  57567: 29632,
  57568: 29669,
  57569: 29678,
  57570: 29662,
  57571: 29858,
  57572: 29701,
  57573: 29807,
  57574: 29733,
  57575: 29688,
  57576: 29746,
  57577: 29754,
  57578: 29781,
  57579: 29759,
  57580: 29791,
  57581: 29785,
  57582: 29761,
  57583: 29788,
  57584: 29801,
  57585: 29808,
  57586: 29795,
  57587: 29802,
  57588: 29814,
  57589: 29822,
  57590: 29835,
  57591: 29854,
  57592: 29863,
  57593: 29898,
  57594: 29903,
  57595: 29908,
  57596: 29681,
  57664: 29920,
  57665: 29923,
  57666: 29927,
  57667: 29929,
  57668: 29934,
  57669: 29938,
  57670: 29936,
  57671: 29937,
  57672: 29944,
  57673: 29943,
  57674: 29956,
  57675: 29955,
  57676: 29957,
  57677: 29964,
  57678: 29966,
  57679: 29965,
  57680: 29973,
  57681: 29971,
  57682: 29982,
  57683: 29990,
  57684: 29996,
  57685: 30012,
  57686: 30020,
  57687: 30029,
  57688: 30026,
  57689: 30025,
  57690: 30043,
  57691: 30022,
  57692: 30042,
  57693: 30057,
  57694: 30052,
  57695: 30055,
  57696: 30059,
  57697: 30061,
  57698: 30072,
  57699: 30070,
  57700: 30086,
  57701: 30087,
  57702: 30068,
  57703: 30090,
  57704: 30089,
  57705: 30082,
  57706: 30100,
  57707: 30106,
  57708: 30109,
  57709: 30117,
  57710: 30115,
  57711: 30146,
  57712: 30131,
  57713: 30147,
  57714: 30133,
  57715: 30141,
  57716: 30136,
  57717: 30140,
  57718: 30129,
  57719: 30157,
  57720: 30154,
  57721: 30162,
  57722: 30169,
  57723: 30179,
  57724: 30174,
  57725: 30206,
  57726: 30207,
  57728: 30204,
  57729: 30209,
  57730: 30192,
  57731: 30202,
  57732: 30194,
  57733: 30195,
  57734: 30219,
  57735: 30221,
  57736: 30217,
  57737: 30239,
  57738: 30247,
  57739: 30240,
  57740: 30241,
  57741: 30242,
  57742: 30244,
  57743: 30260,
  57744: 30256,
  57745: 30267,
  57746: 30279,
  57747: 30280,
  57748: 30278,
  57749: 30300,
  57750: 30296,
  57751: 30305,
  57752: 30306,
  57753: 30312,
  57754: 30313,
  57755: 30314,
  57756: 30311,
  57757: 30316,
  57758: 30320,
  57759: 30322,
  57760: 30326,
  57761: 30328,
  57762: 30332,
  57763: 30336,
  57764: 30339,
  57765: 30344,
  57766: 30347,
  57767: 30350,
  57768: 30358,
  57769: 30355,
  57770: 30361,
  57771: 30362,
  57772: 30384,
  57773: 30388,
  57774: 30392,
  57775: 30393,
  57776: 30394,
  57777: 30402,
  57778: 30413,
  57779: 30422,
  57780: 30418,
  57781: 30430,
  57782: 30433,
  57783: 30437,
  57784: 30439,
  57785: 30442,
  57786: 34351,
  57787: 30459,
  57788: 30472,
  57789: 30471,
  57790: 30468,
  57791: 30505,
  57792: 30500,
  57793: 30494,
  57794: 30501,
  57795: 30502,
  57796: 30491,
  57797: 30519,
  57798: 30520,
  57799: 30535,
  57800: 30554,
  57801: 30568,
  57802: 30571,
  57803: 30555,
  57804: 30565,
  57805: 30591,
  57806: 30590,
  57807: 30585,
  57808: 30606,
  57809: 30603,
  57810: 30609,
  57811: 30624,
  57812: 30622,
  57813: 30640,
  57814: 30646,
  57815: 30649,
  57816: 30655,
  57817: 30652,
  57818: 30653,
  57819: 30651,
  57820: 30663,
  57821: 30669,
  57822: 30679,
  57823: 30682,
  57824: 30684,
  57825: 30691,
  57826: 30702,
  57827: 30716,
  57828: 30732,
  57829: 30738,
  57830: 31014,
  57831: 30752,
  57832: 31018,
  57833: 30789,
  57834: 30862,
  57835: 30836,
  57836: 30854,
  57837: 30844,
  57838: 30874,
  57839: 30860,
  57840: 30883,
  57841: 30901,
  57842: 30890,
  57843: 30895,
  57844: 30929,
  57845: 30918,
  57846: 30923,
  57847: 30932,
  57848: 30910,
  57849: 30908,
  57850: 30917,
  57851: 30922,
  57852: 30956,
  57920: 30951,
  57921: 30938,
  57922: 30973,
  57923: 30964,
  57924: 30983,
  57925: 30994,
  57926: 30993,
  57927: 31001,
  57928: 31020,
  57929: 31019,
  57930: 31040,
  57931: 31072,
  57932: 31063,
  57933: 31071,
  57934: 31066,
  57935: 31061,
  57936: 31059,
  57937: 31098,
  57938: 31103,
  57939: 31114,
  57940: 31133,
  57941: 31143,
  57942: 40779,
  57943: 31146,
  57944: 31150,
  57945: 31155,
  57946: 31161,
  57947: 31162,
  57948: 31177,
  57949: 31189,
  57950: 31207,
  57951: 31212,
  57952: 31201,
  57953: 31203,
  57954: 31240,
  57955: 31245,
  57956: 31256,
  57957: 31257,
  57958: 31264,
  57959: 31263,
  57960: 31104,
  57961: 31281,
  57962: 31291,
  57963: 31294,
  57964: 31287,
  57965: 31299,
  57966: 31319,
  57967: 31305,
  57968: 31329,
  57969: 31330,
  57970: 31337,
  57971: 40861,
  57972: 31344,
  57973: 31353,
  57974: 31357,
  57975: 31368,
  57976: 31383,
  57977: 31381,
  57978: 31384,
  57979: 31382,
  57980: 31401,
  57981: 31432,
  57982: 31408,
  57984: 31414,
  57985: 31429,
  57986: 31428,
  57987: 31423,
  57988: 36995,
  57989: 31431,
  57990: 31434,
  57991: 31437,
  57992: 31439,
  57993: 31445,
  57994: 31443,
  57995: 31449,
  57996: 31450,
  57997: 31453,
  57998: 31457,
  57999: 31458,
  58e3: 31462,
  58001: 31469,
  58002: 31472,
  58003: 31490,
  58004: 31503,
  58005: 31498,
  58006: 31494,
  58007: 31539,
  58008: 31512,
  58009: 31513,
  58010: 31518,
  58011: 31541,
  58012: 31528,
  58013: 31542,
  58014: 31568,
  58015: 31610,
  58016: 31492,
  58017: 31565,
  58018: 31499,
  58019: 31564,
  58020: 31557,
  58021: 31605,
  58022: 31589,
  58023: 31604,
  58024: 31591,
  58025: 31600,
  58026: 31601,
  58027: 31596,
  58028: 31598,
  58029: 31645,
  58030: 31640,
  58031: 31647,
  58032: 31629,
  58033: 31644,
  58034: 31642,
  58035: 31627,
  58036: 31634,
  58037: 31631,
  58038: 31581,
  58039: 31641,
  58040: 31691,
  58041: 31681,
  58042: 31692,
  58043: 31695,
  58044: 31668,
  58045: 31686,
  58046: 31709,
  58047: 31721,
  58048: 31761,
  58049: 31764,
  58050: 31718,
  58051: 31717,
  58052: 31840,
  58053: 31744,
  58054: 31751,
  58055: 31763,
  58056: 31731,
  58057: 31735,
  58058: 31767,
  58059: 31757,
  58060: 31734,
  58061: 31779,
  58062: 31783,
  58063: 31786,
  58064: 31775,
  58065: 31799,
  58066: 31787,
  58067: 31805,
  58068: 31820,
  58069: 31811,
  58070: 31828,
  58071: 31823,
  58072: 31808,
  58073: 31824,
  58074: 31832,
  58075: 31839,
  58076: 31844,
  58077: 31830,
  58078: 31845,
  58079: 31852,
  58080: 31861,
  58081: 31875,
  58082: 31888,
  58083: 31908,
  58084: 31917,
  58085: 31906,
  58086: 31915,
  58087: 31905,
  58088: 31912,
  58089: 31923,
  58090: 31922,
  58091: 31921,
  58092: 31918,
  58093: 31929,
  58094: 31933,
  58095: 31936,
  58096: 31941,
  58097: 31938,
  58098: 31960,
  58099: 31954,
  58100: 31964,
  58101: 31970,
  58102: 39739,
  58103: 31983,
  58104: 31986,
  58105: 31988,
  58106: 31990,
  58107: 31994,
  58108: 32006,
  58176: 32002,
  58177: 32028,
  58178: 32021,
  58179: 32010,
  58180: 32069,
  58181: 32075,
  58182: 32046,
  58183: 32050,
  58184: 32063,
  58185: 32053,
  58186: 32070,
  58187: 32115,
  58188: 32086,
  58189: 32078,
  58190: 32114,
  58191: 32104,
  58192: 32110,
  58193: 32079,
  58194: 32099,
  58195: 32147,
  58196: 32137,
  58197: 32091,
  58198: 32143,
  58199: 32125,
  58200: 32155,
  58201: 32186,
  58202: 32174,
  58203: 32163,
  58204: 32181,
  58205: 32199,
  58206: 32189,
  58207: 32171,
  58208: 32317,
  58209: 32162,
  58210: 32175,
  58211: 32220,
  58212: 32184,
  58213: 32159,
  58214: 32176,
  58215: 32216,
  58216: 32221,
  58217: 32228,
  58218: 32222,
  58219: 32251,
  58220: 32242,
  58221: 32225,
  58222: 32261,
  58223: 32266,
  58224: 32291,
  58225: 32289,
  58226: 32274,
  58227: 32305,
  58228: 32287,
  58229: 32265,
  58230: 32267,
  58231: 32290,
  58232: 32326,
  58233: 32358,
  58234: 32315,
  58235: 32309,
  58236: 32313,
  58237: 32323,
  58238: 32311,
  58240: 32306,
  58241: 32314,
  58242: 32359,
  58243: 32349,
  58244: 32342,
  58245: 32350,
  58246: 32345,
  58247: 32346,
  58248: 32377,
  58249: 32362,
  58250: 32361,
  58251: 32380,
  58252: 32379,
  58253: 32387,
  58254: 32213,
  58255: 32381,
  58256: 36782,
  58257: 32383,
  58258: 32392,
  58259: 32393,
  58260: 32396,
  58261: 32402,
  58262: 32400,
  58263: 32403,
  58264: 32404,
  58265: 32406,
  58266: 32398,
  58267: 32411,
  58268: 32412,
  58269: 32568,
  58270: 32570,
  58271: 32581,
  58272: 32588,
  58273: 32589,
  58274: 32590,
  58275: 32592,
  58276: 32593,
  58277: 32597,
  58278: 32596,
  58279: 32600,
  58280: 32607,
  58281: 32608,
  58282: 32616,
  58283: 32617,
  58284: 32615,
  58285: 32632,
  58286: 32642,
  58287: 32646,
  58288: 32643,
  58289: 32648,
  58290: 32647,
  58291: 32652,
  58292: 32660,
  58293: 32670,
  58294: 32669,
  58295: 32666,
  58296: 32675,
  58297: 32687,
  58298: 32690,
  58299: 32697,
  58300: 32686,
  58301: 32694,
  58302: 32696,
  58303: 35697,
  58304: 32709,
  58305: 32710,
  58306: 32714,
  58307: 32725,
  58308: 32724,
  58309: 32737,
  58310: 32742,
  58311: 32745,
  58312: 32755,
  58313: 32761,
  58314: 39132,
  58315: 32774,
  58316: 32772,
  58317: 32779,
  58318: 32786,
  58319: 32792,
  58320: 32793,
  58321: 32796,
  58322: 32801,
  58323: 32808,
  58324: 32831,
  58325: 32827,
  58326: 32842,
  58327: 32838,
  58328: 32850,
  58329: 32856,
  58330: 32858,
  58331: 32863,
  58332: 32866,
  58333: 32872,
  58334: 32883,
  58335: 32882,
  58336: 32880,
  58337: 32886,
  58338: 32889,
  58339: 32893,
  58340: 32895,
  58341: 32900,
  58342: 32902,
  58343: 32901,
  58344: 32923,
  58345: 32915,
  58346: 32922,
  58347: 32941,
  58348: 20880,
  58349: 32940,
  58350: 32987,
  58351: 32997,
  58352: 32985,
  58353: 32989,
  58354: 32964,
  58355: 32986,
  58356: 32982,
  58357: 33033,
  58358: 33007,
  58359: 33009,
  58360: 33051,
  58361: 33065,
  58362: 33059,
  58363: 33071,
  58364: 33099,
  58432: 38539,
  58433: 33094,
  58434: 33086,
  58435: 33107,
  58436: 33105,
  58437: 33020,
  58438: 33137,
  58439: 33134,
  58440: 33125,
  58441: 33126,
  58442: 33140,
  58443: 33155,
  58444: 33160,
  58445: 33162,
  58446: 33152,
  58447: 33154,
  58448: 33184,
  58449: 33173,
  58450: 33188,
  58451: 33187,
  58452: 33119,
  58453: 33171,
  58454: 33193,
  58455: 33200,
  58456: 33205,
  58457: 33214,
  58458: 33208,
  58459: 33213,
  58460: 33216,
  58461: 33218,
  58462: 33210,
  58463: 33225,
  58464: 33229,
  58465: 33233,
  58466: 33241,
  58467: 33240,
  58468: 33224,
  58469: 33242,
  58470: 33247,
  58471: 33248,
  58472: 33255,
  58473: 33274,
  58474: 33275,
  58475: 33278,
  58476: 33281,
  58477: 33282,
  58478: 33285,
  58479: 33287,
  58480: 33290,
  58481: 33293,
  58482: 33296,
  58483: 33302,
  58484: 33321,
  58485: 33323,
  58486: 33336,
  58487: 33331,
  58488: 33344,
  58489: 33369,
  58490: 33368,
  58491: 33373,
  58492: 33370,
  58493: 33375,
  58494: 33380,
  58496: 33378,
  58497: 33384,
  58498: 33386,
  58499: 33387,
  58500: 33326,
  58501: 33393,
  58502: 33399,
  58503: 33400,
  58504: 33406,
  58505: 33421,
  58506: 33426,
  58507: 33451,
  58508: 33439,
  58509: 33467,
  58510: 33452,
  58511: 33505,
  58512: 33507,
  58513: 33503,
  58514: 33490,
  58515: 33524,
  58516: 33523,
  58517: 33530,
  58518: 33683,
  58519: 33539,
  58520: 33531,
  58521: 33529,
  58522: 33502,
  58523: 33542,
  58524: 33500,
  58525: 33545,
  58526: 33497,
  58527: 33589,
  58528: 33588,
  58529: 33558,
  58530: 33586,
  58531: 33585,
  58532: 33600,
  58533: 33593,
  58534: 33616,
  58535: 33605,
  58536: 33583,
  58537: 33579,
  58538: 33559,
  58539: 33560,
  58540: 33669,
  58541: 33690,
  58542: 33706,
  58543: 33695,
  58544: 33698,
  58545: 33686,
  58546: 33571,
  58547: 33678,
  58548: 33671,
  58549: 33674,
  58550: 33660,
  58551: 33717,
  58552: 33651,
  58553: 33653,
  58554: 33696,
  58555: 33673,
  58556: 33704,
  58557: 33780,
  58558: 33811,
  58559: 33771,
  58560: 33742,
  58561: 33789,
  58562: 33795,
  58563: 33752,
  58564: 33803,
  58565: 33729,
  58566: 33783,
  58567: 33799,
  58568: 33760,
  58569: 33778,
  58570: 33805,
  58571: 33826,
  58572: 33824,
  58573: 33725,
  58574: 33848,
  58575: 34054,
  58576: 33787,
  58577: 33901,
  58578: 33834,
  58579: 33852,
  58580: 34138,
  58581: 33924,
  58582: 33911,
  58583: 33899,
  58584: 33965,
  58585: 33902,
  58586: 33922,
  58587: 33897,
  58588: 33862,
  58589: 33836,
  58590: 33903,
  58591: 33913,
  58592: 33845,
  58593: 33994,
  58594: 33890,
  58595: 33977,
  58596: 33983,
  58597: 33951,
  58598: 34009,
  58599: 33997,
  58600: 33979,
  58601: 34010,
  58602: 34e3,
  58603: 33985,
  58604: 33990,
  58605: 34006,
  58606: 33953,
  58607: 34081,
  58608: 34047,
  58609: 34036,
  58610: 34071,
  58611: 34072,
  58612: 34092,
  58613: 34079,
  58614: 34069,
  58615: 34068,
  58616: 34044,
  58617: 34112,
  58618: 34147,
  58619: 34136,
  58620: 34120,
  58688: 34113,
  58689: 34306,
  58690: 34123,
  58691: 34133,
  58692: 34176,
  58693: 34212,
  58694: 34184,
  58695: 34193,
  58696: 34186,
  58697: 34216,
  58698: 34157,
  58699: 34196,
  58700: 34203,
  58701: 34282,
  58702: 34183,
  58703: 34204,
  58704: 34167,
  58705: 34174,
  58706: 34192,
  58707: 34249,
  58708: 34234,
  58709: 34255,
  58710: 34233,
  58711: 34256,
  58712: 34261,
  58713: 34269,
  58714: 34277,
  58715: 34268,
  58716: 34297,
  58717: 34314,
  58718: 34323,
  58719: 34315,
  58720: 34302,
  58721: 34298,
  58722: 34310,
  58723: 34338,
  58724: 34330,
  58725: 34352,
  58726: 34367,
  58727: 34381,
  58728: 20053,
  58729: 34388,
  58730: 34399,
  58731: 34407,
  58732: 34417,
  58733: 34451,
  58734: 34467,
  58735: 34473,
  58736: 34474,
  58737: 34443,
  58738: 34444,
  58739: 34486,
  58740: 34479,
  58741: 34500,
  58742: 34502,
  58743: 34480,
  58744: 34505,
  58745: 34851,
  58746: 34475,
  58747: 34516,
  58748: 34526,
  58749: 34537,
  58750: 34540,
  58752: 34527,
  58753: 34523,
  58754: 34543,
  58755: 34578,
  58756: 34566,
  58757: 34568,
  58758: 34560,
  58759: 34563,
  58760: 34555,
  58761: 34577,
  58762: 34569,
  58763: 34573,
  58764: 34553,
  58765: 34570,
  58766: 34612,
  58767: 34623,
  58768: 34615,
  58769: 34619,
  58770: 34597,
  58771: 34601,
  58772: 34586,
  58773: 34656,
  58774: 34655,
  58775: 34680,
  58776: 34636,
  58777: 34638,
  58778: 34676,
  58779: 34647,
  58780: 34664,
  58781: 34670,
  58782: 34649,
  58783: 34643,
  58784: 34659,
  58785: 34666,
  58786: 34821,
  58787: 34722,
  58788: 34719,
  58789: 34690,
  58790: 34735,
  58791: 34763,
  58792: 34749,
  58793: 34752,
  58794: 34768,
  58795: 38614,
  58796: 34731,
  58797: 34756,
  58798: 34739,
  58799: 34759,
  58800: 34758,
  58801: 34747,
  58802: 34799,
  58803: 34802,
  58804: 34784,
  58805: 34831,
  58806: 34829,
  58807: 34814,
  58808: 34806,
  58809: 34807,
  58810: 34830,
  58811: 34770,
  58812: 34833,
  58813: 34838,
  58814: 34837,
  58815: 34850,
  58816: 34849,
  58817: 34865,
  58818: 34870,
  58819: 34873,
  58820: 34855,
  58821: 34875,
  58822: 34884,
  58823: 34882,
  58824: 34898,
  58825: 34905,
  58826: 34910,
  58827: 34914,
  58828: 34923,
  58829: 34945,
  58830: 34942,
  58831: 34974,
  58832: 34933,
  58833: 34941,
  58834: 34997,
  58835: 34930,
  58836: 34946,
  58837: 34967,
  58838: 34962,
  58839: 34990,
  58840: 34969,
  58841: 34978,
  58842: 34957,
  58843: 34980,
  58844: 34992,
  58845: 35007,
  58846: 34993,
  58847: 35011,
  58848: 35012,
  58849: 35028,
  58850: 35032,
  58851: 35033,
  58852: 35037,
  58853: 35065,
  58854: 35074,
  58855: 35068,
  58856: 35060,
  58857: 35048,
  58858: 35058,
  58859: 35076,
  58860: 35084,
  58861: 35082,
  58862: 35091,
  58863: 35139,
  58864: 35102,
  58865: 35109,
  58866: 35114,
  58867: 35115,
  58868: 35137,
  58869: 35140,
  58870: 35131,
  58871: 35126,
  58872: 35128,
  58873: 35148,
  58874: 35101,
  58875: 35168,
  58876: 35166,
  58944: 35174,
  58945: 35172,
  58946: 35181,
  58947: 35178,
  58948: 35183,
  58949: 35188,
  58950: 35191,
  58951: 35198,
  58952: 35203,
  58953: 35208,
  58954: 35210,
  58955: 35219,
  58956: 35224,
  58957: 35233,
  58958: 35241,
  58959: 35238,
  58960: 35244,
  58961: 35247,
  58962: 35250,
  58963: 35258,
  58964: 35261,
  58965: 35263,
  58966: 35264,
  58967: 35290,
  58968: 35292,
  58969: 35293,
  58970: 35303,
  58971: 35316,
  58972: 35320,
  58973: 35331,
  58974: 35350,
  58975: 35344,
  58976: 35340,
  58977: 35355,
  58978: 35357,
  58979: 35365,
  58980: 35382,
  58981: 35393,
  58982: 35419,
  58983: 35410,
  58984: 35398,
  58985: 35400,
  58986: 35452,
  58987: 35437,
  58988: 35436,
  58989: 35426,
  58990: 35461,
  58991: 35458,
  58992: 35460,
  58993: 35496,
  58994: 35489,
  58995: 35473,
  58996: 35493,
  58997: 35494,
  58998: 35482,
  58999: 35491,
  59e3: 35524,
  59001: 35533,
  59002: 35522,
  59003: 35546,
  59004: 35563,
  59005: 35571,
  59006: 35559,
  59008: 35556,
  59009: 35569,
  59010: 35604,
  59011: 35552,
  59012: 35554,
  59013: 35575,
  59014: 35550,
  59015: 35547,
  59016: 35596,
  59017: 35591,
  59018: 35610,
  59019: 35553,
  59020: 35606,
  59021: 35600,
  59022: 35607,
  59023: 35616,
  59024: 35635,
  59025: 38827,
  59026: 35622,
  59027: 35627,
  59028: 35646,
  59029: 35624,
  59030: 35649,
  59031: 35660,
  59032: 35663,
  59033: 35662,
  59034: 35657,
  59035: 35670,
  59036: 35675,
  59037: 35674,
  59038: 35691,
  59039: 35679,
  59040: 35692,
  59041: 35695,
  59042: 35700,
  59043: 35709,
  59044: 35712,
  59045: 35724,
  59046: 35726,
  59047: 35730,
  59048: 35731,
  59049: 35734,
  59050: 35737,
  59051: 35738,
  59052: 35898,
  59053: 35905,
  59054: 35903,
  59055: 35912,
  59056: 35916,
  59057: 35918,
  59058: 35920,
  59059: 35925,
  59060: 35938,
  59061: 35948,
  59062: 35960,
  59063: 35962,
  59064: 35970,
  59065: 35977,
  59066: 35973,
  59067: 35978,
  59068: 35981,
  59069: 35982,
  59070: 35988,
  59071: 35964,
  59072: 35992,
  59073: 25117,
  59074: 36013,
  59075: 36010,
  59076: 36029,
  59077: 36018,
  59078: 36019,
  59079: 36014,
  59080: 36022,
  59081: 36040,
  59082: 36033,
  59083: 36068,
  59084: 36067,
  59085: 36058,
  59086: 36093,
  59087: 36090,
  59088: 36091,
  59089: 36100,
  59090: 36101,
  59091: 36106,
  59092: 36103,
  59093: 36111,
  59094: 36109,
  59095: 36112,
  59096: 40782,
  59097: 36115,
  59098: 36045,
  59099: 36116,
  59100: 36118,
  59101: 36199,
  59102: 36205,
  59103: 36209,
  59104: 36211,
  59105: 36225,
  59106: 36249,
  59107: 36290,
  59108: 36286,
  59109: 36282,
  59110: 36303,
  59111: 36314,
  59112: 36310,
  59113: 36300,
  59114: 36315,
  59115: 36299,
  59116: 36330,
  59117: 36331,
  59118: 36319,
  59119: 36323,
  59120: 36348,
  59121: 36360,
  59122: 36361,
  59123: 36351,
  59124: 36381,
  59125: 36382,
  59126: 36368,
  59127: 36383,
  59128: 36418,
  59129: 36405,
  59130: 36400,
  59131: 36404,
  59132: 36426,
  59200: 36423,
  59201: 36425,
  59202: 36428,
  59203: 36432,
  59204: 36424,
  59205: 36441,
  59206: 36452,
  59207: 36448,
  59208: 36394,
  59209: 36451,
  59210: 36437,
  59211: 36470,
  59212: 36466,
  59213: 36476,
  59214: 36481,
  59215: 36487,
  59216: 36485,
  59217: 36484,
  59218: 36491,
  59219: 36490,
  59220: 36499,
  59221: 36497,
  59222: 36500,
  59223: 36505,
  59224: 36522,
  59225: 36513,
  59226: 36524,
  59227: 36528,
  59228: 36550,
  59229: 36529,
  59230: 36542,
  59231: 36549,
  59232: 36552,
  59233: 36555,
  59234: 36571,
  59235: 36579,
  59236: 36604,
  59237: 36603,
  59238: 36587,
  59239: 36606,
  59240: 36618,
  59241: 36613,
  59242: 36629,
  59243: 36626,
  59244: 36633,
  59245: 36627,
  59246: 36636,
  59247: 36639,
  59248: 36635,
  59249: 36620,
  59250: 36646,
  59251: 36659,
  59252: 36667,
  59253: 36665,
  59254: 36677,
  59255: 36674,
  59256: 36670,
  59257: 36684,
  59258: 36681,
  59259: 36678,
  59260: 36686,
  59261: 36695,
  59262: 36700,
  59264: 36706,
  59265: 36707,
  59266: 36708,
  59267: 36764,
  59268: 36767,
  59269: 36771,
  59270: 36781,
  59271: 36783,
  59272: 36791,
  59273: 36826,
  59274: 36837,
  59275: 36834,
  59276: 36842,
  59277: 36847,
  59278: 36999,
  59279: 36852,
  59280: 36869,
  59281: 36857,
  59282: 36858,
  59283: 36881,
  59284: 36885,
  59285: 36897,
  59286: 36877,
  59287: 36894,
  59288: 36886,
  59289: 36875,
  59290: 36903,
  59291: 36918,
  59292: 36917,
  59293: 36921,
  59294: 36856,
  59295: 36943,
  59296: 36944,
  59297: 36945,
  59298: 36946,
  59299: 36878,
  59300: 36937,
  59301: 36926,
  59302: 36950,
  59303: 36952,
  59304: 36958,
  59305: 36968,
  59306: 36975,
  59307: 36982,
  59308: 38568,
  59309: 36978,
  59310: 36994,
  59311: 36989,
  59312: 36993,
  59313: 36992,
  59314: 37002,
  59315: 37001,
  59316: 37007,
  59317: 37032,
  59318: 37039,
  59319: 37041,
  59320: 37045,
  59321: 37090,
  59322: 37092,
  59323: 25160,
  59324: 37083,
  59325: 37122,
  59326: 37138,
  59327: 37145,
  59328: 37170,
  59329: 37168,
  59330: 37194,
  59331: 37206,
  59332: 37208,
  59333: 37219,
  59334: 37221,
  59335: 37225,
  59336: 37235,
  59337: 37234,
  59338: 37259,
  59339: 37257,
  59340: 37250,
  59341: 37282,
  59342: 37291,
  59343: 37295,
  59344: 37290,
  59345: 37301,
  59346: 37300,
  59347: 37306,
  59348: 37312,
  59349: 37313,
  59350: 37321,
  59351: 37323,
  59352: 37328,
  59353: 37334,
  59354: 37343,
  59355: 37345,
  59356: 37339,
  59357: 37372,
  59358: 37365,
  59359: 37366,
  59360: 37406,
  59361: 37375,
  59362: 37396,
  59363: 37420,
  59364: 37397,
  59365: 37393,
  59366: 37470,
  59367: 37463,
  59368: 37445,
  59369: 37449,
  59370: 37476,
  59371: 37448,
  59372: 37525,
  59373: 37439,
  59374: 37451,
  59375: 37456,
  59376: 37532,
  59377: 37526,
  59378: 37523,
  59379: 37531,
  59380: 37466,
  59381: 37583,
  59382: 37561,
  59383: 37559,
  59384: 37609,
  59385: 37647,
  59386: 37626,
  59387: 37700,
  59388: 37678,
  59456: 37657,
  59457: 37666,
  59458: 37658,
  59459: 37667,
  59460: 37690,
  59461: 37685,
  59462: 37691,
  59463: 37724,
  59464: 37728,
  59465: 37756,
  59466: 37742,
  59467: 37718,
  59468: 37808,
  59469: 37804,
  59470: 37805,
  59471: 37780,
  59472: 37817,
  59473: 37846,
  59474: 37847,
  59475: 37864,
  59476: 37861,
  59477: 37848,
  59478: 37827,
  59479: 37853,
  59480: 37840,
  59481: 37832,
  59482: 37860,
  59483: 37914,
  59484: 37908,
  59485: 37907,
  59486: 37891,
  59487: 37895,
  59488: 37904,
  59489: 37942,
  59490: 37931,
  59491: 37941,
  59492: 37921,
  59493: 37946,
  59494: 37953,
  59495: 37970,
  59496: 37956,
  59497: 37979,
  59498: 37984,
  59499: 37986,
  59500: 37982,
  59501: 37994,
  59502: 37417,
  59503: 38e3,
  59504: 38005,
  59505: 38007,
  59506: 38013,
  59507: 37978,
  59508: 38012,
  59509: 38014,
  59510: 38017,
  59511: 38015,
  59512: 38274,
  59513: 38279,
  59514: 38282,
  59515: 38292,
  59516: 38294,
  59517: 38296,
  59518: 38297,
  59520: 38304,
  59521: 38312,
  59522: 38311,
  59523: 38317,
  59524: 38332,
  59525: 38331,
  59526: 38329,
  59527: 38334,
  59528: 38346,
  59529: 28662,
  59530: 38339,
  59531: 38349,
  59532: 38348,
  59533: 38357,
  59534: 38356,
  59535: 38358,
  59536: 38364,
  59537: 38369,
  59538: 38373,
  59539: 38370,
  59540: 38433,
  59541: 38440,
  59542: 38446,
  59543: 38447,
  59544: 38466,
  59545: 38476,
  59546: 38479,
  59547: 38475,
  59548: 38519,
  59549: 38492,
  59550: 38494,
  59551: 38493,
  59552: 38495,
  59553: 38502,
  59554: 38514,
  59555: 38508,
  59556: 38541,
  59557: 38552,
  59558: 38549,
  59559: 38551,
  59560: 38570,
  59561: 38567,
  59562: 38577,
  59563: 38578,
  59564: 38576,
  59565: 38580,
  59566: 38582,
  59567: 38584,
  59568: 38585,
  59569: 38606,
  59570: 38603,
  59571: 38601,
  59572: 38605,
  59573: 35149,
  59574: 38620,
  59575: 38669,
  59576: 38613,
  59577: 38649,
  59578: 38660,
  59579: 38662,
  59580: 38664,
  59581: 38675,
  59582: 38670,
  59583: 38673,
  59584: 38671,
  59585: 38678,
  59586: 38681,
  59587: 38692,
  59588: 38698,
  59589: 38704,
  59590: 38713,
  59591: 38717,
  59592: 38718,
  59593: 38724,
  59594: 38726,
  59595: 38728,
  59596: 38722,
  59597: 38729,
  59598: 38748,
  59599: 38752,
  59600: 38756,
  59601: 38758,
  59602: 38760,
  59603: 21202,
  59604: 38763,
  59605: 38769,
  59606: 38777,
  59607: 38789,
  59608: 38780,
  59609: 38785,
  59610: 38778,
  59611: 38790,
  59612: 38795,
  59613: 38799,
  59614: 38800,
  59615: 38812,
  59616: 38824,
  59617: 38822,
  59618: 38819,
  59619: 38835,
  59620: 38836,
  59621: 38851,
  59622: 38854,
  59623: 38856,
  59624: 38859,
  59625: 38876,
  59626: 38893,
  59627: 40783,
  59628: 38898,
  59629: 31455,
  59630: 38902,
  59631: 38901,
  59632: 38927,
  59633: 38924,
  59634: 38968,
  59635: 38948,
  59636: 38945,
  59637: 38967,
  59638: 38973,
  59639: 38982,
  59640: 38991,
  59641: 38987,
  59642: 39019,
  59643: 39023,
  59644: 39024,
  59712: 39025,
  59713: 39028,
  59714: 39027,
  59715: 39082,
  59716: 39087,
  59717: 39089,
  59718: 39094,
  59719: 39108,
  59720: 39107,
  59721: 39110,
  59722: 39145,
  59723: 39147,
  59724: 39171,
  59725: 39177,
  59726: 39186,
  59727: 39188,
  59728: 39192,
  59729: 39201,
  59730: 39197,
  59731: 39198,
  59732: 39204,
  59733: 39200,
  59734: 39212,
  59735: 39214,
  59736: 39229,
  59737: 39230,
  59738: 39234,
  59739: 39241,
  59740: 39237,
  59741: 39248,
  59742: 39243,
  59743: 39249,
  59744: 39250,
  59745: 39244,
  59746: 39253,
  59747: 39319,
  59748: 39320,
  59749: 39333,
  59750: 39341,
  59751: 39342,
  59752: 39356,
  59753: 39391,
  59754: 39387,
  59755: 39389,
  59756: 39384,
  59757: 39377,
  59758: 39405,
  59759: 39406,
  59760: 39409,
  59761: 39410,
  59762: 39419,
  59763: 39416,
  59764: 39425,
  59765: 39439,
  59766: 39429,
  59767: 39394,
  59768: 39449,
  59769: 39467,
  59770: 39479,
  59771: 39493,
  59772: 39490,
  59773: 39488,
  59774: 39491,
  59776: 39486,
  59777: 39509,
  59778: 39501,
  59779: 39515,
  59780: 39511,
  59781: 39519,
  59782: 39522,
  59783: 39525,
  59784: 39524,
  59785: 39529,
  59786: 39531,
  59787: 39530,
  59788: 39597,
  59789: 39600,
  59790: 39612,
  59791: 39616,
  59792: 39631,
  59793: 39633,
  59794: 39635,
  59795: 39636,
  59796: 39646,
  59797: 39647,
  59798: 39650,
  59799: 39651,
  59800: 39654,
  59801: 39663,
  59802: 39659,
  59803: 39662,
  59804: 39668,
  59805: 39665,
  59806: 39671,
  59807: 39675,
  59808: 39686,
  59809: 39704,
  59810: 39706,
  59811: 39711,
  59812: 39714,
  59813: 39715,
  59814: 39717,
  59815: 39719,
  59816: 39720,
  59817: 39721,
  59818: 39722,
  59819: 39726,
  59820: 39727,
  59821: 39730,
  59822: 39748,
  59823: 39747,
  59824: 39759,
  59825: 39757,
  59826: 39758,
  59827: 39761,
  59828: 39768,
  59829: 39796,
  59830: 39827,
  59831: 39811,
  59832: 39825,
  59833: 39830,
  59834: 39831,
  59835: 39839,
  59836: 39840,
  59837: 39848,
  59838: 39860,
  59839: 39872,
  59840: 39882,
  59841: 39865,
  59842: 39878,
  59843: 39887,
  59844: 39889,
  59845: 39890,
  59846: 39907,
  59847: 39906,
  59848: 39908,
  59849: 39892,
  59850: 39905,
  59851: 39994,
  59852: 39922,
  59853: 39921,
  59854: 39920,
  59855: 39957,
  59856: 39956,
  59857: 39945,
  59858: 39955,
  59859: 39948,
  59860: 39942,
  59861: 39944,
  59862: 39954,
  59863: 39946,
  59864: 39940,
  59865: 39982,
  59866: 39963,
  59867: 39973,
  59868: 39972,
  59869: 39969,
  59870: 39984,
  59871: 40007,
  59872: 39986,
  59873: 40006,
  59874: 39998,
  59875: 40026,
  59876: 40032,
  59877: 40039,
  59878: 40054,
  59879: 40056,
  59880: 40167,
  59881: 40172,
  59882: 40176,
  59883: 40201,
  59884: 40200,
  59885: 40171,
  59886: 40195,
  59887: 40198,
  59888: 40234,
  59889: 40230,
  59890: 40367,
  59891: 40227,
  59892: 40223,
  59893: 40260,
  59894: 40213,
  59895: 40210,
  59896: 40257,
  59897: 40255,
  59898: 40254,
  59899: 40262,
  59900: 40264,
  59968: 40285,
  59969: 40286,
  59970: 40292,
  59971: 40273,
  59972: 40272,
  59973: 40281,
  59974: 40306,
  59975: 40329,
  59976: 40327,
  59977: 40363,
  59978: 40303,
  59979: 40314,
  59980: 40346,
  59981: 40356,
  59982: 40361,
  59983: 40370,
  59984: 40388,
  59985: 40385,
  59986: 40379,
  59987: 40376,
  59988: 40378,
  59989: 40390,
  59990: 40399,
  59991: 40386,
  59992: 40409,
  59993: 40403,
  59994: 40440,
  59995: 40422,
  59996: 40429,
  59997: 40431,
  59998: 40445,
  59999: 40474,
  6e4: 40475,
  60001: 40478,
  60002: 40565,
  60003: 40569,
  60004: 40573,
  60005: 40577,
  60006: 40584,
  60007: 40587,
  60008: 40588,
  60009: 40594,
  60010: 40597,
  60011: 40593,
  60012: 40605,
  60013: 40613,
  60014: 40617,
  60015: 40632,
  60016: 40618,
  60017: 40621,
  60018: 38753,
  60019: 40652,
  60020: 40654,
  60021: 40655,
  60022: 40656,
  60023: 40660,
  60024: 40668,
  60025: 40670,
  60026: 40669,
  60027: 40672,
  60028: 40677,
  60029: 40680,
  60030: 40687,
  60032: 40692,
  60033: 40694,
  60034: 40695,
  60035: 40697,
  60036: 40699,
  60037: 40700,
  60038: 40701,
  60039: 40711,
  60040: 40712,
  60041: 30391,
  60042: 40725,
  60043: 40737,
  60044: 40748,
  60045: 40766,
  60046: 40778,
  60047: 40786,
  60048: 40788,
  60049: 40803,
  60050: 40799,
  60051: 40800,
  60052: 40801,
  60053: 40806,
  60054: 40807,
  60055: 40812,
  60056: 40810,
  60057: 40823,
  60058: 40818,
  60059: 40822,
  60060: 40853,
  60061: 40860,
  60062: 40864,
  60063: 22575,
  60064: 27079,
  60065: 36953,
  60066: 29796,
  60067: 20956,
  60068: 29081,
  60736: 32394,
  60737: 35100,
  60738: 37704,
  60739: 37512,
  60740: 34012,
  60741: 20425,
  60742: 28859,
  60743: 26161,
  60744: 26824,
  60745: 37625,
  60746: 26363,
  60747: 24389,
  60748: 20008,
  60749: 20193,
  60750: 20220,
  60751: 20224,
  60752: 20227,
  60753: 20281,
  60754: 20310,
  60755: 20370,
  60756: 20362,
  60757: 20378,
  60758: 20372,
  60759: 20429,
  60760: 20544,
  60761: 20514,
  60762: 20479,
  60763: 20510,
  60764: 20550,
  60765: 20592,
  60766: 20546,
  60767: 20628,
  60768: 20724,
  60769: 20696,
  60770: 20810,
  60771: 20836,
  60772: 20893,
  60773: 20926,
  60774: 20972,
  60775: 21013,
  60776: 21148,
  60777: 21158,
  60778: 21184,
  60779: 21211,
  60780: 21248,
  60781: 21255,
  60782: 21284,
  60783: 21362,
  60784: 21395,
  60785: 21426,
  60786: 21469,
  60787: 64014,
  60788: 21660,
  60789: 21642,
  60790: 21673,
  60791: 21759,
  60792: 21894,
  60793: 22361,
  60794: 22373,
  60795: 22444,
  60796: 22472,
  60797: 22471,
  60798: 64015,
  60800: 64016,
  60801: 22686,
  60802: 22706,
  60803: 22795,
  60804: 22867,
  60805: 22875,
  60806: 22877,
  60807: 22883,
  60808: 22948,
  60809: 22970,
  60810: 23382,
  60811: 23488,
  60812: 29999,
  60813: 23512,
  60814: 23532,
  60815: 23582,
  60816: 23718,
  60817: 23738,
  60818: 23797,
  60819: 23847,
  60820: 23891,
  60821: 64017,
  60822: 23874,
  60823: 23917,
  60824: 23992,
  60825: 23993,
  60826: 24016,
  60827: 24353,
  60828: 24372,
  60829: 24423,
  60830: 24503,
  60831: 24542,
  60832: 24669,
  60833: 24709,
  60834: 24714,
  60835: 24798,
  60836: 24789,
  60837: 24864,
  60838: 24818,
  60839: 24849,
  60840: 24887,
  60841: 24880,
  60842: 24984,
  60843: 25107,
  60844: 25254,
  60845: 25589,
  60846: 25696,
  60847: 25757,
  60848: 25806,
  60849: 25934,
  60850: 26112,
  60851: 26133,
  60852: 26171,
  60853: 26121,
  60854: 26158,
  60855: 26142,
  60856: 26148,
  60857: 26213,
  60858: 26199,
  60859: 26201,
  60860: 64018,
  60861: 26227,
  60862: 26265,
  60863: 26272,
  60864: 26290,
  60865: 26303,
  60866: 26362,
  60867: 26382,
  60868: 63785,
  60869: 26470,
  60870: 26555,
  60871: 26706,
  60872: 26560,
  60873: 26625,
  60874: 26692,
  60875: 26831,
  60876: 64019,
  60877: 26984,
  60878: 64020,
  60879: 27032,
  60880: 27106,
  60881: 27184,
  60882: 27243,
  60883: 27206,
  60884: 27251,
  60885: 27262,
  60886: 27362,
  60887: 27364,
  60888: 27606,
  60889: 27711,
  60890: 27740,
  60891: 27782,
  60892: 27759,
  60893: 27866,
  60894: 27908,
  60895: 28039,
  60896: 28015,
  60897: 28054,
  60898: 28076,
  60899: 28111,
  60900: 28152,
  60901: 28146,
  60902: 28156,
  60903: 28217,
  60904: 28252,
  60905: 28199,
  60906: 28220,
  60907: 28351,
  60908: 28552,
  60909: 28597,
  60910: 28661,
  60911: 28677,
  60912: 28679,
  60913: 28712,
  60914: 28805,
  60915: 28843,
  60916: 28943,
  60917: 28932,
  60918: 29020,
  60919: 28998,
  60920: 28999,
  60921: 64021,
  60922: 29121,
  60923: 29182,
  60924: 29361,
  60992: 29374,
  60993: 29476,
  60994: 64022,
  60995: 29559,
  60996: 29629,
  60997: 29641,
  60998: 29654,
  60999: 29667,
  61e3: 29650,
  61001: 29703,
  61002: 29685,
  61003: 29734,
  61004: 29738,
  61005: 29737,
  61006: 29742,
  61007: 29794,
  61008: 29833,
  61009: 29855,
  61010: 29953,
  61011: 30063,
  61012: 30338,
  61013: 30364,
  61014: 30366,
  61015: 30363,
  61016: 30374,
  61017: 64023,
  61018: 30534,
  61019: 21167,
  61020: 30753,
  61021: 30798,
  61022: 30820,
  61023: 30842,
  61024: 31024,
  61025: 64024,
  61026: 64025,
  61027: 64026,
  61028: 31124,
  61029: 64027,
  61030: 31131,
  61031: 31441,
  61032: 31463,
  61033: 64028,
  61034: 31467,
  61035: 31646,
  61036: 64029,
  61037: 32072,
  61038: 32092,
  61039: 32183,
  61040: 32160,
  61041: 32214,
  61042: 32338,
  61043: 32583,
  61044: 32673,
  61045: 64030,
  61046: 33537,
  61047: 33634,
  61048: 33663,
  61049: 33735,
  61050: 33782,
  61051: 33864,
  61052: 33972,
  61053: 34131,
  61054: 34137,
  61056: 34155,
  61057: 64031,
  61058: 34224,
  61059: 64032,
  61060: 64033,
  61061: 34823,
  61062: 35061,
  61063: 35346,
  61064: 35383,
  61065: 35449,
  61066: 35495,
  61067: 35518,
  61068: 35551,
  61069: 64034,
  61070: 35574,
  61071: 35667,
  61072: 35711,
  61073: 36080,
  61074: 36084,
  61075: 36114,
  61076: 36214,
  61077: 64035,
  61078: 36559,
  61079: 64036,
  61080: 64037,
  61081: 36967,
  61082: 37086,
  61083: 64038,
  61084: 37141,
  61085: 37159,
  61086: 37338,
  61087: 37335,
  61088: 37342,
  61089: 37357,
  61090: 37358,
  61091: 37348,
  61092: 37349,
  61093: 37382,
  61094: 37392,
  61095: 37386,
  61096: 37434,
  61097: 37440,
  61098: 37436,
  61099: 37454,
  61100: 37465,
  61101: 37457,
  61102: 37433,
  61103: 37479,
  61104: 37543,
  61105: 37495,
  61106: 37496,
  61107: 37607,
  61108: 37591,
  61109: 37593,
  61110: 37584,
  61111: 64039,
  61112: 37589,
  61113: 37600,
  61114: 37587,
  61115: 37669,
  61116: 37665,
  61117: 37627,
  61118: 64040,
  61119: 37662,
  61120: 37631,
  61121: 37661,
  61122: 37634,
  61123: 37744,
  61124: 37719,
  61125: 37796,
  61126: 37830,
  61127: 37854,
  61128: 37880,
  61129: 37937,
  61130: 37957,
  61131: 37960,
  61132: 38290,
  61133: 63964,
  61134: 64041,
  61135: 38557,
  61136: 38575,
  61137: 38707,
  61138: 38715,
  61139: 38723,
  61140: 38733,
  61141: 38735,
  61142: 38737,
  61143: 38741,
  61144: 38999,
  61145: 39013,
  61146: 64042,
  61147: 64043,
  61148: 39207,
  61149: 64044,
  61150: 39326,
  61151: 39502,
  61152: 39641,
  61153: 39644,
  61154: 39797,
  61155: 39794,
  61156: 39823,
  61157: 39857,
  61158: 39867,
  61159: 39936,
  61160: 40304,
  61161: 40299,
  61162: 64045,
  61163: 40473,
  61164: 40657,
  61167: 8560,
  61168: 8561,
  61169: 8562,
  61170: 8563,
  61171: 8564,
  61172: 8565,
  61173: 8566,
  61174: 8567,
  61175: 8568,
  61176: 8569,
  61177: 65506,
  61178: 65508,
  61179: 65287,
  61180: 65282,
  61504: 57344,
  61505: 57345,
  61506: 57346,
  61507: 57347,
  61508: 57348,
  61509: 57349,
  61510: 57350,
  61511: 57351,
  61512: 57352,
  61513: 57353,
  61514: 57354,
  61515: 57355,
  61516: 57356,
  61517: 57357,
  61518: 57358,
  61519: 57359,
  61520: 57360,
  61521: 57361,
  61522: 57362,
  61523: 57363,
  61524: 57364,
  61525: 57365,
  61526: 57366,
  61527: 57367,
  61528: 57368,
  61529: 57369,
  61530: 57370,
  61531: 57371,
  61532: 57372,
  61533: 57373,
  61534: 57374,
  61535: 57375,
  61536: 57376,
  61537: 57377,
  61538: 57378,
  61539: 57379,
  61540: 57380,
  61541: 57381,
  61542: 57382,
  61543: 57383,
  61544: 57384,
  61545: 57385,
  61546: 57386,
  61547: 57387,
  61548: 57388,
  61549: 57389,
  61550: 57390,
  61551: 57391,
  61552: 57392,
  61553: 57393,
  61554: 57394,
  61555: 57395,
  61556: 57396,
  61557: 57397,
  61558: 57398,
  61559: 57399,
  61560: 57400,
  61561: 57401,
  61562: 57402,
  61563: 57403,
  61564: 57404,
  61565: 57405,
  61566: 57406,
  61568: 57407,
  61569: 57408,
  61570: 57409,
  61571: 57410,
  61572: 57411,
  61573: 57412,
  61574: 57413,
  61575: 57414,
  61576: 57415,
  61577: 57416,
  61578: 57417,
  61579: 57418,
  61580: 57419,
  61581: 57420,
  61582: 57421,
  61583: 57422,
  61584: 57423,
  61585: 57424,
  61586: 57425,
  61587: 57426,
  61588: 57427,
  61589: 57428,
  61590: 57429,
  61591: 57430,
  61592: 57431,
  61593: 57432,
  61594: 57433,
  61595: 57434,
  61596: 57435,
  61597: 57436,
  61598: 57437,
  61599: 57438,
  61600: 57439,
  61601: 57440,
  61602: 57441,
  61603: 57442,
  61604: 57443,
  61605: 57444,
  61606: 57445,
  61607: 57446,
  61608: 57447,
  61609: 57448,
  61610: 57449,
  61611: 57450,
  61612: 57451,
  61613: 57452,
  61614: 57453,
  61615: 57454,
  61616: 57455,
  61617: 57456,
  61618: 57457,
  61619: 57458,
  61620: 57459,
  61621: 57460,
  61622: 57461,
  61623: 57462,
  61624: 57463,
  61625: 57464,
  61626: 57465,
  61627: 57466,
  61628: 57467,
  61629: 57468,
  61630: 57469,
  61631: 57470,
  61632: 57471,
  61633: 57472,
  61634: 57473,
  61635: 57474,
  61636: 57475,
  61637: 57476,
  61638: 57477,
  61639: 57478,
  61640: 57479,
  61641: 57480,
  61642: 57481,
  61643: 57482,
  61644: 57483,
  61645: 57484,
  61646: 57485,
  61647: 57486,
  61648: 57487,
  61649: 57488,
  61650: 57489,
  61651: 57490,
  61652: 57491,
  61653: 57492,
  61654: 57493,
  61655: 57494,
  61656: 57495,
  61657: 57496,
  61658: 57497,
  61659: 57498,
  61660: 57499,
  61661: 57500,
  61662: 57501,
  61663: 57502,
  61664: 57503,
  61665: 57504,
  61666: 57505,
  61667: 57506,
  61668: 57507,
  61669: 57508,
  61670: 57509,
  61671: 57510,
  61672: 57511,
  61673: 57512,
  61674: 57513,
  61675: 57514,
  61676: 57515,
  61677: 57516,
  61678: 57517,
  61679: 57518,
  61680: 57519,
  61681: 57520,
  61682: 57521,
  61683: 57522,
  61684: 57523,
  61685: 57524,
  61686: 57525,
  61687: 57526,
  61688: 57527,
  61689: 57528,
  61690: 57529,
  61691: 57530,
  61692: 57531,
  61760: 57532,
  61761: 57533,
  61762: 57534,
  61763: 57535,
  61764: 57536,
  61765: 57537,
  61766: 57538,
  61767: 57539,
  61768: 57540,
  61769: 57541,
  61770: 57542,
  61771: 57543,
  61772: 57544,
  61773: 57545,
  61774: 57546,
  61775: 57547,
  61776: 57548,
  61777: 57549,
  61778: 57550,
  61779: 57551,
  61780: 57552,
  61781: 57553,
  61782: 57554,
  61783: 57555,
  61784: 57556,
  61785: 57557,
  61786: 57558,
  61787: 57559,
  61788: 57560,
  61789: 57561,
  61790: 57562,
  61791: 57563,
  61792: 57564,
  61793: 57565,
  61794: 57566,
  61795: 57567,
  61796: 57568,
  61797: 57569,
  61798: 57570,
  61799: 57571,
  61800: 57572,
  61801: 57573,
  61802: 57574,
  61803: 57575,
  61804: 57576,
  61805: 57577,
  61806: 57578,
  61807: 57579,
  61808: 57580,
  61809: 57581,
  61810: 57582,
  61811: 57583,
  61812: 57584,
  61813: 57585,
  61814: 57586,
  61815: 57587,
  61816: 57588,
  61817: 57589,
  61818: 57590,
  61819: 57591,
  61820: 57592,
  61821: 57593,
  61822: 57594,
  61824: 57595,
  61825: 57596,
  61826: 57597,
  61827: 57598,
  61828: 57599,
  61829: 57600,
  61830: 57601,
  61831: 57602,
  61832: 57603,
  61833: 57604,
  61834: 57605,
  61835: 57606,
  61836: 57607,
  61837: 57608,
  61838: 57609,
  61839: 57610,
  61840: 57611,
  61841: 57612,
  61842: 57613,
  61843: 57614,
  61844: 57615,
  61845: 57616,
  61846: 57617,
  61847: 57618,
  61848: 57619,
  61849: 57620,
  61850: 57621,
  61851: 57622,
  61852: 57623,
  61853: 57624,
  61854: 57625,
  61855: 57626,
  61856: 57627,
  61857: 57628,
  61858: 57629,
  61859: 57630,
  61860: 57631,
  61861: 57632,
  61862: 57633,
  61863: 57634,
  61864: 57635,
  61865: 57636,
  61866: 57637,
  61867: 57638,
  61868: 57639,
  61869: 57640,
  61870: 57641,
  61871: 57642,
  61872: 57643,
  61873: 57644,
  61874: 57645,
  61875: 57646,
  61876: 57647,
  61877: 57648,
  61878: 57649,
  61879: 57650,
  61880: 57651,
  61881: 57652,
  61882: 57653,
  61883: 57654,
  61884: 57655,
  61885: 57656,
  61886: 57657,
  61887: 57658,
  61888: 57659,
  61889: 57660,
  61890: 57661,
  61891: 57662,
  61892: 57663,
  61893: 57664,
  61894: 57665,
  61895: 57666,
  61896: 57667,
  61897: 57668,
  61898: 57669,
  61899: 57670,
  61900: 57671,
  61901: 57672,
  61902: 57673,
  61903: 57674,
  61904: 57675,
  61905: 57676,
  61906: 57677,
  61907: 57678,
  61908: 57679,
  61909: 57680,
  61910: 57681,
  61911: 57682,
  61912: 57683,
  61913: 57684,
  61914: 57685,
  61915: 57686,
  61916: 57687,
  61917: 57688,
  61918: 57689,
  61919: 57690,
  61920: 57691,
  61921: 57692,
  61922: 57693,
  61923: 57694,
  61924: 57695,
  61925: 57696,
  61926: 57697,
  61927: 57698,
  61928: 57699,
  61929: 57700,
  61930: 57701,
  61931: 57702,
  61932: 57703,
  61933: 57704,
  61934: 57705,
  61935: 57706,
  61936: 57707,
  61937: 57708,
  61938: 57709,
  61939: 57710,
  61940: 57711,
  61941: 57712,
  61942: 57713,
  61943: 57714,
  61944: 57715,
  61945: 57716,
  61946: 57717,
  61947: 57718,
  61948: 57719,
  62016: 57720,
  62017: 57721,
  62018: 57722,
  62019: 57723,
  62020: 57724,
  62021: 57725,
  62022: 57726,
  62023: 57727,
  62024: 57728,
  62025: 57729,
  62026: 57730,
  62027: 57731,
  62028: 57732,
  62029: 57733,
  62030: 57734,
  62031: 57735,
  62032: 57736,
  62033: 57737,
  62034: 57738,
  62035: 57739,
  62036: 57740,
  62037: 57741,
  62038: 57742,
  62039: 57743,
  62040: 57744,
  62041: 57745,
  62042: 57746,
  62043: 57747,
  62044: 57748,
  62045: 57749,
  62046: 57750,
  62047: 57751,
  62048: 57752,
  62049: 57753,
  62050: 57754,
  62051: 57755,
  62052: 57756,
  62053: 57757,
  62054: 57758,
  62055: 57759,
  62056: 57760,
  62057: 57761,
  62058: 57762,
  62059: 57763,
  62060: 57764,
  62061: 57765,
  62062: 57766,
  62063: 57767,
  62064: 57768,
  62065: 57769,
  62066: 57770,
  62067: 57771,
  62068: 57772,
  62069: 57773,
  62070: 57774,
  62071: 57775,
  62072: 57776,
  62073: 57777,
  62074: 57778,
  62075: 57779,
  62076: 57780,
  62077: 57781,
  62078: 57782,
  62080: 57783,
  62081: 57784,
  62082: 57785,
  62083: 57786,
  62084: 57787,
  62085: 57788,
  62086: 57789,
  62087: 57790,
  62088: 57791,
  62089: 57792,
  62090: 57793,
  62091: 57794,
  62092: 57795,
  62093: 57796,
  62094: 57797,
  62095: 57798,
  62096: 57799,
  62097: 57800,
  62098: 57801,
  62099: 57802,
  62100: 57803,
  62101: 57804,
  62102: 57805,
  62103: 57806,
  62104: 57807,
  62105: 57808,
  62106: 57809,
  62107: 57810,
  62108: 57811,
  62109: 57812,
  62110: 57813,
  62111: 57814,
  62112: 57815,
  62113: 57816,
  62114: 57817,
  62115: 57818,
  62116: 57819,
  62117: 57820,
  62118: 57821,
  62119: 57822,
  62120: 57823,
  62121: 57824,
  62122: 57825,
  62123: 57826,
  62124: 57827,
  62125: 57828,
  62126: 57829,
  62127: 57830,
  62128: 57831,
  62129: 57832,
  62130: 57833,
  62131: 57834,
  62132: 57835,
  62133: 57836,
  62134: 57837,
  62135: 57838,
  62136: 57839,
  62137: 57840,
  62138: 57841,
  62139: 57842,
  62140: 57843,
  62141: 57844,
  62142: 57845,
  62143: 57846,
  62144: 57847,
  62145: 57848,
  62146: 57849,
  62147: 57850,
  62148: 57851,
  62149: 57852,
  62150: 57853,
  62151: 57854,
  62152: 57855,
  62153: 57856,
  62154: 57857,
  62155: 57858,
  62156: 57859,
  62157: 57860,
  62158: 57861,
  62159: 57862,
  62160: 57863,
  62161: 57864,
  62162: 57865,
  62163: 57866,
  62164: 57867,
  62165: 57868,
  62166: 57869,
  62167: 57870,
  62168: 57871,
  62169: 57872,
  62170: 57873,
  62171: 57874,
  62172: 57875,
  62173: 57876,
  62174: 57877,
  62175: 57878,
  62176: 57879,
  62177: 57880,
  62178: 57881,
  62179: 57882,
  62180: 57883,
  62181: 57884,
  62182: 57885,
  62183: 57886,
  62184: 57887,
  62185: 57888,
  62186: 57889,
  62187: 57890,
  62188: 57891,
  62189: 57892,
  62190: 57893,
  62191: 57894,
  62192: 57895,
  62193: 57896,
  62194: 57897,
  62195: 57898,
  62196: 57899,
  62197: 57900,
  62198: 57901,
  62199: 57902,
  62200: 57903,
  62201: 57904,
  62202: 57905,
  62203: 57906,
  62204: 57907,
  62272: 57908,
  62273: 57909,
  62274: 57910,
  62275: 57911,
  62276: 57912,
  62277: 57913,
  62278: 57914,
  62279: 57915,
  62280: 57916,
  62281: 57917,
  62282: 57918,
  62283: 57919,
  62284: 57920,
  62285: 57921,
  62286: 57922,
  62287: 57923,
  62288: 57924,
  62289: 57925,
  62290: 57926,
  62291: 57927,
  62292: 57928,
  62293: 57929,
  62294: 57930,
  62295: 57931,
  62296: 57932,
  62297: 57933,
  62298: 57934,
  62299: 57935,
  62300: 57936,
  62301: 57937,
  62302: 57938,
  62303: 57939,
  62304: 57940,
  62305: 57941,
  62306: 57942,
  62307: 57943,
  62308: 57944,
  62309: 57945,
  62310: 57946,
  62311: 57947,
  62312: 57948,
  62313: 57949,
  62314: 57950,
  62315: 57951,
  62316: 57952,
  62317: 57953,
  62318: 57954,
  62319: 57955,
  62320: 57956,
  62321: 57957,
  62322: 57958,
  62323: 57959,
  62324: 57960,
  62325: 57961,
  62326: 57962,
  62327: 57963,
  62328: 57964,
  62329: 57965,
  62330: 57966,
  62331: 57967,
  62332: 57968,
  62333: 57969,
  62334: 57970,
  62336: 57971,
  62337: 57972,
  62338: 57973,
  62339: 57974,
  62340: 57975,
  62341: 57976,
  62342: 57977,
  62343: 57978,
  62344: 57979,
  62345: 57980,
  62346: 57981,
  62347: 57982,
  62348: 57983,
  62349: 57984,
  62350: 57985,
  62351: 57986,
  62352: 57987,
  62353: 57988,
  62354: 57989,
  62355: 57990,
  62356: 57991,
  62357: 57992,
  62358: 57993,
  62359: 57994,
  62360: 57995,
  62361: 57996,
  62362: 57997,
  62363: 57998,
  62364: 57999,
  62365: 58e3,
  62366: 58001,
  62367: 58002,
  62368: 58003,
  62369: 58004,
  62370: 58005,
  62371: 58006,
  62372: 58007,
  62373: 58008,
  62374: 58009,
  62375: 58010,
  62376: 58011,
  62377: 58012,
  62378: 58013,
  62379: 58014,
  62380: 58015,
  62381: 58016,
  62382: 58017,
  62383: 58018,
  62384: 58019,
  62385: 58020,
  62386: 58021,
  62387: 58022,
  62388: 58023,
  62389: 58024,
  62390: 58025,
  62391: 58026,
  62392: 58027,
  62393: 58028,
  62394: 58029,
  62395: 58030,
  62396: 58031,
  62397: 58032,
  62398: 58033,
  62399: 58034,
  62400: 58035,
  62401: 58036,
  62402: 58037,
  62403: 58038,
  62404: 58039,
  62405: 58040,
  62406: 58041,
  62407: 58042,
  62408: 58043,
  62409: 58044,
  62410: 58045,
  62411: 58046,
  62412: 58047,
  62413: 58048,
  62414: 58049,
  62415: 58050,
  62416: 58051,
  62417: 58052,
  62418: 58053,
  62419: 58054,
  62420: 58055,
  62421: 58056,
  62422: 58057,
  62423: 58058,
  62424: 58059,
  62425: 58060,
  62426: 58061,
  62427: 58062,
  62428: 58063,
  62429: 58064,
  62430: 58065,
  62431: 58066,
  62432: 58067,
  62433: 58068,
  62434: 58069,
  62435: 58070,
  62436: 58071,
  62437: 58072,
  62438: 58073,
  62439: 58074,
  62440: 58075,
  62441: 58076,
  62442: 58077,
  62443: 58078,
  62444: 58079,
  62445: 58080,
  62446: 58081,
  62447: 58082,
  62448: 58083,
  62449: 58084,
  62450: 58085,
  62451: 58086,
  62452: 58087,
  62453: 58088,
  62454: 58089,
  62455: 58090,
  62456: 58091,
  62457: 58092,
  62458: 58093,
  62459: 58094,
  62460: 58095,
  62528: 58096,
  62529: 58097,
  62530: 58098,
  62531: 58099,
  62532: 58100,
  62533: 58101,
  62534: 58102,
  62535: 58103,
  62536: 58104,
  62537: 58105,
  62538: 58106,
  62539: 58107,
  62540: 58108,
  62541: 58109,
  62542: 58110,
  62543: 58111,
  62544: 58112,
  62545: 58113,
  62546: 58114,
  62547: 58115,
  62548: 58116,
  62549: 58117,
  62550: 58118,
  62551: 58119,
  62552: 58120,
  62553: 58121,
  62554: 58122,
  62555: 58123,
  62556: 58124,
  62557: 58125,
  62558: 58126,
  62559: 58127,
  62560: 58128,
  62561: 58129,
  62562: 58130,
  62563: 58131,
  62564: 58132,
  62565: 58133,
  62566: 58134,
  62567: 58135,
  62568: 58136,
  62569: 58137,
  62570: 58138,
  62571: 58139,
  62572: 58140,
  62573: 58141,
  62574: 58142,
  62575: 58143,
  62576: 58144,
  62577: 58145,
  62578: 58146,
  62579: 58147,
  62580: 58148,
  62581: 58149,
  62582: 58150,
  62583: 58151,
  62584: 58152,
  62585: 58153,
  62586: 58154,
  62587: 58155,
  62588: 58156,
  62589: 58157,
  62590: 58158,
  62592: 58159,
  62593: 58160,
  62594: 58161,
  62595: 58162,
  62596: 58163,
  62597: 58164,
  62598: 58165,
  62599: 58166,
  62600: 58167,
  62601: 58168,
  62602: 58169,
  62603: 58170,
  62604: 58171,
  62605: 58172,
  62606: 58173,
  62607: 58174,
  62608: 58175,
  62609: 58176,
  62610: 58177,
  62611: 58178,
  62612: 58179,
  62613: 58180,
  62614: 58181,
  62615: 58182,
  62616: 58183,
  62617: 58184,
  62618: 58185,
  62619: 58186,
  62620: 58187,
  62621: 58188,
  62622: 58189,
  62623: 58190,
  62624: 58191,
  62625: 58192,
  62626: 58193,
  62627: 58194,
  62628: 58195,
  62629: 58196,
  62630: 58197,
  62631: 58198,
  62632: 58199,
  62633: 58200,
  62634: 58201,
  62635: 58202,
  62636: 58203,
  62637: 58204,
  62638: 58205,
  62639: 58206,
  62640: 58207,
  62641: 58208,
  62642: 58209,
  62643: 58210,
  62644: 58211,
  62645: 58212,
  62646: 58213,
  62647: 58214,
  62648: 58215,
  62649: 58216,
  62650: 58217,
  62651: 58218,
  62652: 58219,
  62653: 58220,
  62654: 58221,
  62655: 58222,
  62656: 58223,
  62657: 58224,
  62658: 58225,
  62659: 58226,
  62660: 58227,
  62661: 58228,
  62662: 58229,
  62663: 58230,
  62664: 58231,
  62665: 58232,
  62666: 58233,
  62667: 58234,
  62668: 58235,
  62669: 58236,
  62670: 58237,
  62671: 58238,
  62672: 58239,
  62673: 58240,
  62674: 58241,
  62675: 58242,
  62676: 58243,
  62677: 58244,
  62678: 58245,
  62679: 58246,
  62680: 58247,
  62681: 58248,
  62682: 58249,
  62683: 58250,
  62684: 58251,
  62685: 58252,
  62686: 58253,
  62687: 58254,
  62688: 58255,
  62689: 58256,
  62690: 58257,
  62691: 58258,
  62692: 58259,
  62693: 58260,
  62694: 58261,
  62695: 58262,
  62696: 58263,
  62697: 58264,
  62698: 58265,
  62699: 58266,
  62700: 58267,
  62701: 58268,
  62702: 58269,
  62703: 58270,
  62704: 58271,
  62705: 58272,
  62706: 58273,
  62707: 58274,
  62708: 58275,
  62709: 58276,
  62710: 58277,
  62711: 58278,
  62712: 58279,
  62713: 58280,
  62714: 58281,
  62715: 58282,
  62716: 58283,
  62784: 58284,
  62785: 58285,
  62786: 58286,
  62787: 58287,
  62788: 58288,
  62789: 58289,
  62790: 58290,
  62791: 58291,
  62792: 58292,
  62793: 58293,
  62794: 58294,
  62795: 58295,
  62796: 58296,
  62797: 58297,
  62798: 58298,
  62799: 58299,
  62800: 58300,
  62801: 58301,
  62802: 58302,
  62803: 58303,
  62804: 58304,
  62805: 58305,
  62806: 58306,
  62807: 58307,
  62808: 58308,
  62809: 58309,
  62810: 58310,
  62811: 58311,
  62812: 58312,
  62813: 58313,
  62814: 58314,
  62815: 58315,
  62816: 58316,
  62817: 58317,
  62818: 58318,
  62819: 58319,
  62820: 58320,
  62821: 58321,
  62822: 58322,
  62823: 58323,
  62824: 58324,
  62825: 58325,
  62826: 58326,
  62827: 58327,
  62828: 58328,
  62829: 58329,
  62830: 58330,
  62831: 58331,
  62832: 58332,
  62833: 58333,
  62834: 58334,
  62835: 58335,
  62836: 58336,
  62837: 58337,
  62838: 58338,
  62839: 58339,
  62840: 58340,
  62841: 58341,
  62842: 58342,
  62843: 58343,
  62844: 58344,
  62845: 58345,
  62846: 58346,
  62848: 58347,
  62849: 58348,
  62850: 58349,
  62851: 58350,
  62852: 58351,
  62853: 58352,
  62854: 58353,
  62855: 58354,
  62856: 58355,
  62857: 58356,
  62858: 58357,
  62859: 58358,
  62860: 58359,
  62861: 58360,
  62862: 58361,
  62863: 58362,
  62864: 58363,
  62865: 58364,
  62866: 58365,
  62867: 58366,
  62868: 58367,
  62869: 58368,
  62870: 58369,
  62871: 58370,
  62872: 58371,
  62873: 58372,
  62874: 58373,
  62875: 58374,
  62876: 58375,
  62877: 58376,
  62878: 58377,
  62879: 58378,
  62880: 58379,
  62881: 58380,
  62882: 58381,
  62883: 58382,
  62884: 58383,
  62885: 58384,
  62886: 58385,
  62887: 58386,
  62888: 58387,
  62889: 58388,
  62890: 58389,
  62891: 58390,
  62892: 58391,
  62893: 58392,
  62894: 58393,
  62895: 58394,
  62896: 58395,
  62897: 58396,
  62898: 58397,
  62899: 58398,
  62900: 58399,
  62901: 58400,
  62902: 58401,
  62903: 58402,
  62904: 58403,
  62905: 58404,
  62906: 58405,
  62907: 58406,
  62908: 58407,
  62909: 58408,
  62910: 58409,
  62911: 58410,
  62912: 58411,
  62913: 58412,
  62914: 58413,
  62915: 58414,
  62916: 58415,
  62917: 58416,
  62918: 58417,
  62919: 58418,
  62920: 58419,
  62921: 58420,
  62922: 58421,
  62923: 58422,
  62924: 58423,
  62925: 58424,
  62926: 58425,
  62927: 58426,
  62928: 58427,
  62929: 58428,
  62930: 58429,
  62931: 58430,
  62932: 58431,
  62933: 58432,
  62934: 58433,
  62935: 58434,
  62936: 58435,
  62937: 58436,
  62938: 58437,
  62939: 58438,
  62940: 58439,
  62941: 58440,
  62942: 58441,
  62943: 58442,
  62944: 58443,
  62945: 58444,
  62946: 58445,
  62947: 58446,
  62948: 58447,
  62949: 58448,
  62950: 58449,
  62951: 58450,
  62952: 58451,
  62953: 58452,
  62954: 58453,
  62955: 58454,
  62956: 58455,
  62957: 58456,
  62958: 58457,
  62959: 58458,
  62960: 58459,
  62961: 58460,
  62962: 58461,
  62963: 58462,
  62964: 58463,
  62965: 58464,
  62966: 58465,
  62967: 58466,
  62968: 58467,
  62969: 58468,
  62970: 58469,
  62971: 58470,
  62972: 58471,
  63040: 58472,
  63041: 58473,
  63042: 58474,
  63043: 58475,
  63044: 58476,
  63045: 58477,
  63046: 58478,
  63047: 58479,
  63048: 58480,
  63049: 58481,
  63050: 58482,
  63051: 58483,
  63052: 58484,
  63053: 58485,
  63054: 58486,
  63055: 58487,
  63056: 58488,
  63057: 58489,
  63058: 58490,
  63059: 58491,
  63060: 58492,
  63061: 58493,
  63062: 58494,
  63063: 58495,
  63064: 58496,
  63065: 58497,
  63066: 58498,
  63067: 58499,
  63068: 58500,
  63069: 58501,
  63070: 58502,
  63071: 58503,
  63072: 58504,
  63073: 58505,
  63074: 58506,
  63075: 58507,
  63076: 58508,
  63077: 58509,
  63078: 58510,
  63079: 58511,
  63080: 58512,
  63081: 58513,
  63082: 58514,
  63083: 58515,
  63084: 58516,
  63085: 58517,
  63086: 58518,
  63087: 58519,
  63088: 58520,
  63089: 58521,
  63090: 58522,
  63091: 58523,
  63092: 58524,
  63093: 58525,
  63094: 58526,
  63095: 58527,
  63096: 58528,
  63097: 58529,
  63098: 58530,
  63099: 58531,
  63100: 58532,
  63101: 58533,
  63102: 58534,
  63104: 58535,
  63105: 58536,
  63106: 58537,
  63107: 58538,
  63108: 58539,
  63109: 58540,
  63110: 58541,
  63111: 58542,
  63112: 58543,
  63113: 58544,
  63114: 58545,
  63115: 58546,
  63116: 58547,
  63117: 58548,
  63118: 58549,
  63119: 58550,
  63120: 58551,
  63121: 58552,
  63122: 58553,
  63123: 58554,
  63124: 58555,
  63125: 58556,
  63126: 58557,
  63127: 58558,
  63128: 58559,
  63129: 58560,
  63130: 58561,
  63131: 58562,
  63132: 58563,
  63133: 58564,
  63134: 58565,
  63135: 58566,
  63136: 58567,
  63137: 58568,
  63138: 58569,
  63139: 58570,
  63140: 58571,
  63141: 58572,
  63142: 58573,
  63143: 58574,
  63144: 58575,
  63145: 58576,
  63146: 58577,
  63147: 58578,
  63148: 58579,
  63149: 58580,
  63150: 58581,
  63151: 58582,
  63152: 58583,
  63153: 58584,
  63154: 58585,
  63155: 58586,
  63156: 58587,
  63157: 58588,
  63158: 58589,
  63159: 58590,
  63160: 58591,
  63161: 58592,
  63162: 58593,
  63163: 58594,
  63164: 58595,
  63165: 58596,
  63166: 58597,
  63167: 58598,
  63168: 58599,
  63169: 58600,
  63170: 58601,
  63171: 58602,
  63172: 58603,
  63173: 58604,
  63174: 58605,
  63175: 58606,
  63176: 58607,
  63177: 58608,
  63178: 58609,
  63179: 58610,
  63180: 58611,
  63181: 58612,
  63182: 58613,
  63183: 58614,
  63184: 58615,
  63185: 58616,
  63186: 58617,
  63187: 58618,
  63188: 58619,
  63189: 58620,
  63190: 58621,
  63191: 58622,
  63192: 58623,
  63193: 58624,
  63194: 58625,
  63195: 58626,
  63196: 58627,
  63197: 58628,
  63198: 58629,
  63199: 58630,
  63200: 58631,
  63201: 58632,
  63202: 58633,
  63203: 58634,
  63204: 58635,
  63205: 58636,
  63206: 58637,
  63207: 58638,
  63208: 58639,
  63209: 58640,
  63210: 58641,
  63211: 58642,
  63212: 58643,
  63213: 58644,
  63214: 58645,
  63215: 58646,
  63216: 58647,
  63217: 58648,
  63218: 58649,
  63219: 58650,
  63220: 58651,
  63221: 58652,
  63222: 58653,
  63223: 58654,
  63224: 58655,
  63225: 58656,
  63226: 58657,
  63227: 58658,
  63228: 58659,
  63296: 58660,
  63297: 58661,
  63298: 58662,
  63299: 58663,
  63300: 58664,
  63301: 58665,
  63302: 58666,
  63303: 58667,
  63304: 58668,
  63305: 58669,
  63306: 58670,
  63307: 58671,
  63308: 58672,
  63309: 58673,
  63310: 58674,
  63311: 58675,
  63312: 58676,
  63313: 58677,
  63314: 58678,
  63315: 58679,
  63316: 58680,
  63317: 58681,
  63318: 58682,
  63319: 58683,
  63320: 58684,
  63321: 58685,
  63322: 58686,
  63323: 58687,
  63324: 58688,
  63325: 58689,
  63326: 58690,
  63327: 58691,
  63328: 58692,
  63329: 58693,
  63330: 58694,
  63331: 58695,
  63332: 58696,
  63333: 58697,
  63334: 58698,
  63335: 58699,
  63336: 58700,
  63337: 58701,
  63338: 58702,
  63339: 58703,
  63340: 58704,
  63341: 58705,
  63342: 58706,
  63343: 58707,
  63344: 58708,
  63345: 58709,
  63346: 58710,
  63347: 58711,
  63348: 58712,
  63349: 58713,
  63350: 58714,
  63351: 58715,
  63352: 58716,
  63353: 58717,
  63354: 58718,
  63355: 58719,
  63356: 58720,
  63357: 58721,
  63358: 58722,
  63360: 58723,
  63361: 58724,
  63362: 58725,
  63363: 58726,
  63364: 58727,
  63365: 58728,
  63366: 58729,
  63367: 58730,
  63368: 58731,
  63369: 58732,
  63370: 58733,
  63371: 58734,
  63372: 58735,
  63373: 58736,
  63374: 58737,
  63375: 58738,
  63376: 58739,
  63377: 58740,
  63378: 58741,
  63379: 58742,
  63380: 58743,
  63381: 58744,
  63382: 58745,
  63383: 58746,
  63384: 58747,
  63385: 58748,
  63386: 58749,
  63387: 58750,
  63388: 58751,
  63389: 58752,
  63390: 58753,
  63391: 58754,
  63392: 58755,
  63393: 58756,
  63394: 58757,
  63395: 58758,
  63396: 58759,
  63397: 58760,
  63398: 58761,
  63399: 58762,
  63400: 58763,
  63401: 58764,
  63402: 58765,
  63403: 58766,
  63404: 58767,
  63405: 58768,
  63406: 58769,
  63407: 58770,
  63408: 58771,
  63409: 58772,
  63410: 58773,
  63411: 58774,
  63412: 58775,
  63413: 58776,
  63414: 58777,
  63415: 58778,
  63416: 58779,
  63417: 58780,
  63418: 58781,
  63419: 58782,
  63420: 58783,
  63421: 58784,
  63422: 58785,
  63423: 58786,
  63424: 58787,
  63425: 58788,
  63426: 58789,
  63427: 58790,
  63428: 58791,
  63429: 58792,
  63430: 58793,
  63431: 58794,
  63432: 58795,
  63433: 58796,
  63434: 58797,
  63435: 58798,
  63436: 58799,
  63437: 58800,
  63438: 58801,
  63439: 58802,
  63440: 58803,
  63441: 58804,
  63442: 58805,
  63443: 58806,
  63444: 58807,
  63445: 58808,
  63446: 58809,
  63447: 58810,
  63448: 58811,
  63449: 58812,
  63450: 58813,
  63451: 58814,
  63452: 58815,
  63453: 58816,
  63454: 58817,
  63455: 58818,
  63456: 58819,
  63457: 58820,
  63458: 58821,
  63459: 58822,
  63460: 58823,
  63461: 58824,
  63462: 58825,
  63463: 58826,
  63464: 58827,
  63465: 58828,
  63466: 58829,
  63467: 58830,
  63468: 58831,
  63469: 58832,
  63470: 58833,
  63471: 58834,
  63472: 58835,
  63473: 58836,
  63474: 58837,
  63475: 58838,
  63476: 58839,
  63477: 58840,
  63478: 58841,
  63479: 58842,
  63480: 58843,
  63481: 58844,
  63482: 58845,
  63483: 58846,
  63484: 58847,
  63552: 58848,
  63553: 58849,
  63554: 58850,
  63555: 58851,
  63556: 58852,
  63557: 58853,
  63558: 58854,
  63559: 58855,
  63560: 58856,
  63561: 58857,
  63562: 58858,
  63563: 58859,
  63564: 58860,
  63565: 58861,
  63566: 58862,
  63567: 58863,
  63568: 58864,
  63569: 58865,
  63570: 58866,
  63571: 58867,
  63572: 58868,
  63573: 58869,
  63574: 58870,
  63575: 58871,
  63576: 58872,
  63577: 58873,
  63578: 58874,
  63579: 58875,
  63580: 58876,
  63581: 58877,
  63582: 58878,
  63583: 58879,
  63584: 58880,
  63585: 58881,
  63586: 58882,
  63587: 58883,
  63588: 58884,
  63589: 58885,
  63590: 58886,
  63591: 58887,
  63592: 58888,
  63593: 58889,
  63594: 58890,
  63595: 58891,
  63596: 58892,
  63597: 58893,
  63598: 58894,
  63599: 58895,
  63600: 58896,
  63601: 58897,
  63602: 58898,
  63603: 58899,
  63604: 58900,
  63605: 58901,
  63606: 58902,
  63607: 58903,
  63608: 58904,
  63609: 58905,
  63610: 58906,
  63611: 58907,
  63612: 58908,
  63613: 58909,
  63614: 58910,
  63616: 58911,
  63617: 58912,
  63618: 58913,
  63619: 58914,
  63620: 58915,
  63621: 58916,
  63622: 58917,
  63623: 58918,
  63624: 58919,
  63625: 58920,
  63626: 58921,
  63627: 58922,
  63628: 58923,
  63629: 58924,
  63630: 58925,
  63631: 58926,
  63632: 58927,
  63633: 58928,
  63634: 58929,
  63635: 58930,
  63636: 58931,
  63637: 58932,
  63638: 58933,
  63639: 58934,
  63640: 58935,
  63641: 58936,
  63642: 58937,
  63643: 58938,
  63644: 58939,
  63645: 58940,
  63646: 58941,
  63647: 58942,
  63648: 58943,
  63649: 58944,
  63650: 58945,
  63651: 58946,
  63652: 58947,
  63653: 58948,
  63654: 58949,
  63655: 58950,
  63656: 58951,
  63657: 58952,
  63658: 58953,
  63659: 58954,
  63660: 58955,
  63661: 58956,
  63662: 58957,
  63663: 58958,
  63664: 58959,
  63665: 58960,
  63666: 58961,
  63667: 58962,
  63668: 58963,
  63669: 58964,
  63670: 58965,
  63671: 58966,
  63672: 58967,
  63673: 58968,
  63674: 58969,
  63675: 58970,
  63676: 58971,
  63677: 58972,
  63678: 58973,
  63679: 58974,
  63680: 58975,
  63681: 58976,
  63682: 58977,
  63683: 58978,
  63684: 58979,
  63685: 58980,
  63686: 58981,
  63687: 58982,
  63688: 58983,
  63689: 58984,
  63690: 58985,
  63691: 58986,
  63692: 58987,
  63693: 58988,
  63694: 58989,
  63695: 58990,
  63696: 58991,
  63697: 58992,
  63698: 58993,
  63699: 58994,
  63700: 58995,
  63701: 58996,
  63702: 58997,
  63703: 58998,
  63704: 58999,
  63705: 59e3,
  63706: 59001,
  63707: 59002,
  63708: 59003,
  63709: 59004,
  63710: 59005,
  63711: 59006,
  63712: 59007,
  63713: 59008,
  63714: 59009,
  63715: 59010,
  63716: 59011,
  63717: 59012,
  63718: 59013,
  63719: 59014,
  63720: 59015,
  63721: 59016,
  63722: 59017,
  63723: 59018,
  63724: 59019,
  63725: 59020,
  63726: 59021,
  63727: 59022,
  63728: 59023,
  63729: 59024,
  63730: 59025,
  63731: 59026,
  63732: 59027,
  63733: 59028,
  63734: 59029,
  63735: 59030,
  63736: 59031,
  63737: 59032,
  63738: 59033,
  63739: 59034,
  63740: 59035,
  64064: 8560,
  64065: 8561,
  64066: 8562,
  64067: 8563,
  64068: 8564,
  64069: 8565,
  64070: 8566,
  64071: 8567,
  64072: 8568,
  64073: 8569,
  64074: 8544,
  64075: 8545,
  64076: 8546,
  64077: 8547,
  64078: 8548,
  64079: 8549,
  64080: 8550,
  64081: 8551,
  64082: 8552,
  64083: 8553,
  64084: 65506,
  64085: 65508,
  64086: 65287,
  64087: 65282,
  64088: 12849,
  64089: 8470,
  64090: 8481,
  64091: 8757,
  64092: 32394,
  64093: 35100,
  64094: 37704,
  64095: 37512,
  64096: 34012,
  64097: 20425,
  64098: 28859,
  64099: 26161,
  64100: 26824,
  64101: 37625,
  64102: 26363,
  64103: 24389,
  64104: 20008,
  64105: 20193,
  64106: 20220,
  64107: 20224,
  64108: 20227,
  64109: 20281,
  64110: 20310,
  64111: 20370,
  64112: 20362,
  64113: 20378,
  64114: 20372,
  64115: 20429,
  64116: 20544,
  64117: 20514,
  64118: 20479,
  64119: 20510,
  64120: 20550,
  64121: 20592,
  64122: 20546,
  64123: 20628,
  64124: 20724,
  64125: 20696,
  64126: 20810,
  64128: 20836,
  64129: 20893,
  64130: 20926,
  64131: 20972,
  64132: 21013,
  64133: 21148,
  64134: 21158,
  64135: 21184,
  64136: 21211,
  64137: 21248,
  64138: 21255,
  64139: 21284,
  64140: 21362,
  64141: 21395,
  64142: 21426,
  64143: 21469,
  64144: 64014,
  64145: 21660,
  64146: 21642,
  64147: 21673,
  64148: 21759,
  64149: 21894,
  64150: 22361,
  64151: 22373,
  64152: 22444,
  64153: 22472,
  64154: 22471,
  64155: 64015,
  64156: 64016,
  64157: 22686,
  64158: 22706,
  64159: 22795,
  64160: 22867,
  64161: 22875,
  64162: 22877,
  64163: 22883,
  64164: 22948,
  64165: 22970,
  64166: 23382,
  64167: 23488,
  64168: 29999,
  64169: 23512,
  64170: 23532,
  64171: 23582,
  64172: 23718,
  64173: 23738,
  64174: 23797,
  64175: 23847,
  64176: 23891,
  64177: 64017,
  64178: 23874,
  64179: 23917,
  64180: 23992,
  64181: 23993,
  64182: 24016,
  64183: 24353,
  64184: 24372,
  64185: 24423,
  64186: 24503,
  64187: 24542,
  64188: 24669,
  64189: 24709,
  64190: 24714,
  64191: 24798,
  64192: 24789,
  64193: 24864,
  64194: 24818,
  64195: 24849,
  64196: 24887,
  64197: 24880,
  64198: 24984,
  64199: 25107,
  64200: 25254,
  64201: 25589,
  64202: 25696,
  64203: 25757,
  64204: 25806,
  64205: 25934,
  64206: 26112,
  64207: 26133,
  64208: 26171,
  64209: 26121,
  64210: 26158,
  64211: 26142,
  64212: 26148,
  64213: 26213,
  64214: 26199,
  64215: 26201,
  64216: 64018,
  64217: 26227,
  64218: 26265,
  64219: 26272,
  64220: 26290,
  64221: 26303,
  64222: 26362,
  64223: 26382,
  64224: 63785,
  64225: 26470,
  64226: 26555,
  64227: 26706,
  64228: 26560,
  64229: 26625,
  64230: 26692,
  64231: 26831,
  64232: 64019,
  64233: 26984,
  64234: 64020,
  64235: 27032,
  64236: 27106,
  64237: 27184,
  64238: 27243,
  64239: 27206,
  64240: 27251,
  64241: 27262,
  64242: 27362,
  64243: 27364,
  64244: 27606,
  64245: 27711,
  64246: 27740,
  64247: 27782,
  64248: 27759,
  64249: 27866,
  64250: 27908,
  64251: 28039,
  64252: 28015,
  64320: 28054,
  64321: 28076,
  64322: 28111,
  64323: 28152,
  64324: 28146,
  64325: 28156,
  64326: 28217,
  64327: 28252,
  64328: 28199,
  64329: 28220,
  64330: 28351,
  64331: 28552,
  64332: 28597,
  64333: 28661,
  64334: 28677,
  64335: 28679,
  64336: 28712,
  64337: 28805,
  64338: 28843,
  64339: 28943,
  64340: 28932,
  64341: 29020,
  64342: 28998,
  64343: 28999,
  64344: 64021,
  64345: 29121,
  64346: 29182,
  64347: 29361,
  64348: 29374,
  64349: 29476,
  64350: 64022,
  64351: 29559,
  64352: 29629,
  64353: 29641,
  64354: 29654,
  64355: 29667,
  64356: 29650,
  64357: 29703,
  64358: 29685,
  64359: 29734,
  64360: 29738,
  64361: 29737,
  64362: 29742,
  64363: 29794,
  64364: 29833,
  64365: 29855,
  64366: 29953,
  64367: 30063,
  64368: 30338,
  64369: 30364,
  64370: 30366,
  64371: 30363,
  64372: 30374,
  64373: 64023,
  64374: 30534,
  64375: 21167,
  64376: 30753,
  64377: 30798,
  64378: 30820,
  64379: 30842,
  64380: 31024,
  64381: 64024,
  64382: 64025,
  64384: 64026,
  64385: 31124,
  64386: 64027,
  64387: 31131,
  64388: 31441,
  64389: 31463,
  64390: 64028,
  64391: 31467,
  64392: 31646,
  64393: 64029,
  64394: 32072,
  64395: 32092,
  64396: 32183,
  64397: 32160,
  64398: 32214,
  64399: 32338,
  64400: 32583,
  64401: 32673,
  64402: 64030,
  64403: 33537,
  64404: 33634,
  64405: 33663,
  64406: 33735,
  64407: 33782,
  64408: 33864,
  64409: 33972,
  64410: 34131,
  64411: 34137,
  64412: 34155,
  64413: 64031,
  64414: 34224,
  64415: 64032,
  64416: 64033,
  64417: 34823,
  64418: 35061,
  64419: 35346,
  64420: 35383,
  64421: 35449,
  64422: 35495,
  64423: 35518,
  64424: 35551,
  64425: 64034,
  64426: 35574,
  64427: 35667,
  64428: 35711,
  64429: 36080,
  64430: 36084,
  64431: 36114,
  64432: 36214,
  64433: 64035,
  64434: 36559,
  64435: 64036,
  64436: 64037,
  64437: 36967,
  64438: 37086,
  64439: 64038,
  64440: 37141,
  64441: 37159,
  64442: 37338,
  64443: 37335,
  64444: 37342,
  64445: 37357,
  64446: 37358,
  64447: 37348,
  64448: 37349,
  64449: 37382,
  64450: 37392,
  64451: 37386,
  64452: 37434,
  64453: 37440,
  64454: 37436,
  64455: 37454,
  64456: 37465,
  64457: 37457,
  64458: 37433,
  64459: 37479,
  64460: 37543,
  64461: 37495,
  64462: 37496,
  64463: 37607,
  64464: 37591,
  64465: 37593,
  64466: 37584,
  64467: 64039,
  64468: 37589,
  64469: 37600,
  64470: 37587,
  64471: 37669,
  64472: 37665,
  64473: 37627,
  64474: 64040,
  64475: 37662,
  64476: 37631,
  64477: 37661,
  64478: 37634,
  64479: 37744,
  64480: 37719,
  64481: 37796,
  64482: 37830,
  64483: 37854,
  64484: 37880,
  64485: 37937,
  64486: 37957,
  64487: 37960,
  64488: 38290,
  64489: 63964,
  64490: 64041,
  64491: 38557,
  64492: 38575,
  64493: 38707,
  64494: 38715,
  64495: 38723,
  64496: 38733,
  64497: 38735,
  64498: 38737,
  64499: 38741,
  64500: 38999,
  64501: 39013,
  64502: 64042,
  64503: 64043,
  64504: 39207,
  64505: 64044,
  64506: 39326,
  64507: 39502,
  64508: 39641,
  64576: 39644,
  64577: 39797,
  64578: 39794,
  64579: 39823,
  64580: 39857,
  64581: 39867,
  64582: 39936,
  64583: 40304,
  64584: 40299,
  64585: 64045,
  64586: 40473,
  64587: 40657
};
function DataViewEx(buffer, littleEndian) {
  this.dv = new DataView(buffer);
  this.offset = 0;
  this.littleEndian = littleEndian !== void 0 ? littleEndian : true;
  this.encoder = new CharsetEncoder();
}
DataViewEx.prototype = {
  constructor: DataViewEx,
  getInt8: function() {
    var value = this.dv.getInt8(this.offset);
    this.offset += 1;
    return value;
  },
  getInt8Array: function(size2) {
    var a4 = [];
    for (var i3 = 0; i3 < size2; i3++) {
      a4.push(this.getInt8());
    }
    return a4;
  },
  getUint8: function() {
    var value = this.dv.getUint8(this.offset);
    this.offset += 1;
    return value;
  },
  getUint8Array: function(size2) {
    var a4 = [];
    for (var i3 = 0; i3 < size2; i3++) {
      a4.push(this.getUint8());
    }
    return a4;
  },
  getInt16: function() {
    var value = this.dv.getInt16(this.offset, this.littleEndian);
    this.offset += 2;
    return value;
  },
  getInt16Array: function(size2) {
    var a4 = [];
    for (var i3 = 0; i3 < size2; i3++) {
      a4.push(this.getInt16());
    }
    return a4;
  },
  getUint16: function() {
    var value = this.dv.getUint16(this.offset, this.littleEndian);
    this.offset += 2;
    return value;
  },
  getUint16Array: function(size2) {
    var a4 = [];
    for (var i3 = 0; i3 < size2; i3++) {
      a4.push(this.getUint16());
    }
    return a4;
  },
  getInt32: function() {
    var value = this.dv.getInt32(this.offset, this.littleEndian);
    this.offset += 4;
    return value;
  },
  getInt32Array: function(size2) {
    var a4 = [];
    for (var i3 = 0; i3 < size2; i3++) {
      a4.push(this.getInt32());
    }
    return a4;
  },
  getUint32: function() {
    var value = this.dv.getUint32(this.offset, this.littleEndian);
    this.offset += 4;
    return value;
  },
  getUint32Array: function(size2) {
    var a4 = [];
    for (var i3 = 0; i3 < size2; i3++) {
      a4.push(this.getUint32());
    }
    return a4;
  },
  getFloat32: function() {
    var value = this.dv.getFloat32(this.offset, this.littleEndian);
    this.offset += 4;
    return value;
  },
  getFloat32Array: function(size2) {
    var a4 = [];
    for (var i3 = 0; i3 < size2; i3++) {
      a4.push(this.getFloat32());
    }
    return a4;
  },
  getFloat64: function() {
    var value = this.dv.getFloat64(this.offset, this.littleEndian);
    this.offset += 8;
    return value;
  },
  getFloat64Array: function(size2) {
    var a4 = [];
    for (var i3 = 0; i3 < size2; i3++) {
      a4.push(this.getFloat64());
    }
    return a4;
  },
  getIndex: function(type, isUnsigned) {
    switch (type) {
      case 1:
        return isUnsigned === true ? this.getUint8() : this.getInt8();
      case 2:
        return isUnsigned === true ? this.getUint16() : this.getInt16();
      case 4:
        return this.getInt32();
      default:
        throw "unknown number type " + type + " exception.";
    }
  },
  getIndexArray: function(type, size2, isUnsigned) {
    var a4 = [];
    for (var i3 = 0; i3 < size2; i3++) {
      a4.push(this.getIndex(type, isUnsigned));
    }
    return a4;
  },
  getChars: function(size2) {
    var str = "";
    while (size2 > 0) {
      var value = this.getUint8();
      size2--;
      if (value === 0) {
        break;
      }
      str += String.fromCharCode(value);
    }
    while (size2 > 0) {
      this.getUint8();
      size2--;
    }
    return str;
  },
  getSjisStringsAsUnicode: function(size2) {
    var a4 = [];
    while (size2 > 0) {
      var value = this.getUint8();
      size2--;
      if (value === 0) {
        break;
      }
      a4.push(value);
    }
    while (size2 > 0) {
      this.getUint8();
      size2--;
    }
    return this.encoder.s2u(new Uint8Array(a4));
  },
  getUnicodeStrings: function(size2) {
    var str = "";
    while (size2 > 0) {
      var value = this.getUint16();
      size2 -= 2;
      if (value === 0) {
        break;
      }
      str += String.fromCharCode(value);
    }
    while (size2 > 0) {
      this.getUint8();
      size2--;
    }
    return str;
  },
  getTextBuffer: function() {
    var size2 = this.getUint32();
    return this.getUnicodeStrings(size2);
  }
};
function DataCreationHelper() {
}
DataCreationHelper.prototype = {
  constructor: DataCreationHelper,
  leftToRightVector3: function(v) {
    v[2] = -v[2];
  },
  leftToRightQuaternion: function(q) {
    q[0] = -q[0];
    q[1] = -q[1];
  },
  leftToRightEuler: function(r) {
    r[0] = -r[0];
    r[1] = -r[1];
  },
  leftToRightIndexOrder: function(p) {
    var tmp2 = p[2];
    p[2] = p[0];
    p[0] = tmp2;
  },
  leftToRightVector3Range: function(v14, v23) {
    var tmp2 = -v23[2];
    v23[2] = -v14[2];
    v14[2] = tmp2;
  },
  leftToRightEulerRange: function(r1, r2) {
    var tmp1 = -r2[0];
    var tmp2 = -r2[1];
    r2[0] = -r1[0];
    r2[1] = -r1[1];
    r1[0] = tmp1;
    r1[1] = tmp2;
  }
};
function Parser() {
}
Parser.prototype.parsePmd = function(buffer, leftToRight) {
  var pmd = {};
  var dv = new DataViewEx(buffer);
  pmd.metadata = {};
  pmd.metadata.format = "pmd";
  pmd.metadata.coordinateSystem = "left";
  var parseHeader = function() {
    var metadata = pmd.metadata;
    metadata.magic = dv.getChars(3);
    if (metadata.magic !== "Pmd") {
      throw "PMD file magic is not Pmd, but " + metadata.magic;
    }
    metadata.version = dv.getFloat32();
    metadata.modelName = dv.getSjisStringsAsUnicode(20);
    metadata.comment = dv.getSjisStringsAsUnicode(256);
  };
  var parseVertices = function() {
    var parseVertex = function() {
      var p = {};
      p.position = dv.getFloat32Array(3);
      p.normal = dv.getFloat32Array(3);
      p.uv = dv.getFloat32Array(2);
      p.skinIndices = dv.getUint16Array(2);
      p.skinWeights = [dv.getUint8() / 100];
      p.skinWeights.push(1 - p.skinWeights[0]);
      p.edgeFlag = dv.getUint8();
      return p;
    };
    var metadata = pmd.metadata;
    metadata.vertexCount = dv.getUint32();
    pmd.vertices = [];
    for (var i3 = 0; i3 < metadata.vertexCount; i3++) {
      pmd.vertices.push(parseVertex());
    }
  };
  var parseFaces = function() {
    var parseFace = function() {
      var p = {};
      p.indices = dv.getUint16Array(3);
      return p;
    };
    var metadata = pmd.metadata;
    metadata.faceCount = dv.getUint32() / 3;
    pmd.faces = [];
    for (var i3 = 0; i3 < metadata.faceCount; i3++) {
      pmd.faces.push(parseFace());
    }
  };
  var parseMaterials = function() {
    var parseMaterial = function() {
      var p = {};
      p.diffuse = dv.getFloat32Array(4);
      p.shininess = dv.getFloat32();
      p.specular = dv.getFloat32Array(3);
      p.ambient = dv.getFloat32Array(3);
      p.toonIndex = dv.getInt8();
      p.edgeFlag = dv.getUint8();
      p.faceCount = dv.getUint32() / 3;
      p.fileName = dv.getSjisStringsAsUnicode(20);
      return p;
    };
    var metadata = pmd.metadata;
    metadata.materialCount = dv.getUint32();
    pmd.materials = [];
    for (var i3 = 0; i3 < metadata.materialCount; i3++) {
      pmd.materials.push(parseMaterial());
    }
  };
  var parseBones = function() {
    var parseBone = function() {
      var p = {};
      p.name = dv.getSjisStringsAsUnicode(20);
      p.parentIndex = dv.getInt16();
      p.tailIndex = dv.getInt16();
      p.type = dv.getUint8();
      p.ikIndex = dv.getInt16();
      p.position = dv.getFloat32Array(3);
      return p;
    };
    var metadata = pmd.metadata;
    metadata.boneCount = dv.getUint16();
    pmd.bones = [];
    for (var i3 = 0; i3 < metadata.boneCount; i3++) {
      pmd.bones.push(parseBone());
    }
  };
  var parseIks = function() {
    var parseIk = function() {
      var p = {};
      p.target = dv.getUint16();
      p.effector = dv.getUint16();
      p.linkCount = dv.getUint8();
      p.iteration = dv.getUint16();
      p.maxAngle = dv.getFloat32();
      p.links = [];
      for (var i4 = 0; i4 < p.linkCount; i4++) {
        var link = {};
        link.index = dv.getUint16();
        p.links.push(link);
      }
      return p;
    };
    var metadata = pmd.metadata;
    metadata.ikCount = dv.getUint16();
    pmd.iks = [];
    for (var i3 = 0; i3 < metadata.ikCount; i3++) {
      pmd.iks.push(parseIk());
    }
  };
  var parseMorphs = function() {
    var parseMorph = function() {
      var p = {};
      p.name = dv.getSjisStringsAsUnicode(20);
      p.elementCount = dv.getUint32();
      p.type = dv.getUint8();
      p.elements = [];
      for (var i4 = 0; i4 < p.elementCount; i4++) {
        p.elements.push({
          index: dv.getUint32(),
          position: dv.getFloat32Array(3)
        });
      }
      return p;
    };
    var metadata = pmd.metadata;
    metadata.morphCount = dv.getUint16();
    pmd.morphs = [];
    for (var i3 = 0; i3 < metadata.morphCount; i3++) {
      pmd.morphs.push(parseMorph());
    }
  };
  var parseMorphFrames = function() {
    var parseMorphFrame = function() {
      var p = {};
      p.index = dv.getUint16();
      return p;
    };
    var metadata = pmd.metadata;
    metadata.morphFrameCount = dv.getUint8();
    pmd.morphFrames = [];
    for (var i3 = 0; i3 < metadata.morphFrameCount; i3++) {
      pmd.morphFrames.push(parseMorphFrame());
    }
  };
  var parseBoneFrameNames = function() {
    var parseBoneFrameName = function() {
      var p = {};
      p.name = dv.getSjisStringsAsUnicode(50);
      return p;
    };
    var metadata = pmd.metadata;
    metadata.boneFrameNameCount = dv.getUint8();
    pmd.boneFrameNames = [];
    for (var i3 = 0; i3 < metadata.boneFrameNameCount; i3++) {
      pmd.boneFrameNames.push(parseBoneFrameName());
    }
  };
  var parseBoneFrames = function() {
    var parseBoneFrame = function() {
      var p = {};
      p.boneIndex = dv.getInt16();
      p.frameIndex = dv.getUint8();
      return p;
    };
    var metadata = pmd.metadata;
    metadata.boneFrameCount = dv.getUint32();
    pmd.boneFrames = [];
    for (var i3 = 0; i3 < metadata.boneFrameCount; i3++) {
      pmd.boneFrames.push(parseBoneFrame());
    }
  };
  var parseEnglishHeader = function() {
    var metadata = pmd.metadata;
    metadata.englishCompatibility = dv.getUint8();
    if (metadata.englishCompatibility > 0) {
      metadata.englishModelName = dv.getSjisStringsAsUnicode(20);
      metadata.englishComment = dv.getSjisStringsAsUnicode(256);
    }
  };
  var parseEnglishBoneNames = function() {
    var parseEnglishBoneName = function() {
      var p = {};
      p.name = dv.getSjisStringsAsUnicode(20);
      return p;
    };
    var metadata = pmd.metadata;
    if (metadata.englishCompatibility === 0) {
      return;
    }
    pmd.englishBoneNames = [];
    for (var i3 = 0; i3 < metadata.boneCount; i3++) {
      pmd.englishBoneNames.push(parseEnglishBoneName());
    }
  };
  var parseEnglishMorphNames = function() {
    var parseEnglishMorphName = function() {
      var p = {};
      p.name = dv.getSjisStringsAsUnicode(20);
      return p;
    };
    var metadata = pmd.metadata;
    if (metadata.englishCompatibility === 0) {
      return;
    }
    pmd.englishMorphNames = [];
    for (var i3 = 0; i3 < metadata.morphCount - 1; i3++) {
      pmd.englishMorphNames.push(parseEnglishMorphName());
    }
  };
  var parseEnglishBoneFrameNames = function() {
    var parseEnglishBoneFrameName = function() {
      var p = {};
      p.name = dv.getSjisStringsAsUnicode(50);
      return p;
    };
    var metadata = pmd.metadata;
    if (metadata.englishCompatibility === 0) {
      return;
    }
    pmd.englishBoneFrameNames = [];
    for (var i3 = 0; i3 < metadata.boneFrameNameCount; i3++) {
      pmd.englishBoneFrameNames.push(parseEnglishBoneFrameName());
    }
  };
  var parseToonTextures = function() {
    var parseToonTexture = function() {
      var p = {};
      p.fileName = dv.getSjisStringsAsUnicode(100);
      return p;
    };
    pmd.toonTextures = [];
    for (var i3 = 0; i3 < 10; i3++) {
      pmd.toonTextures.push(parseToonTexture());
    }
  };
  var parseRigidBodies = function() {
    var parseRigidBody = function() {
      var p = {};
      p.name = dv.getSjisStringsAsUnicode(20);
      p.boneIndex = dv.getInt16();
      p.groupIndex = dv.getUint8();
      p.groupTarget = dv.getUint16();
      p.shapeType = dv.getUint8();
      p.width = dv.getFloat32();
      p.height = dv.getFloat32();
      p.depth = dv.getFloat32();
      p.position = dv.getFloat32Array(3);
      p.rotation = dv.getFloat32Array(3);
      p.weight = dv.getFloat32();
      p.positionDamping = dv.getFloat32();
      p.rotationDamping = dv.getFloat32();
      p.restitution = dv.getFloat32();
      p.friction = dv.getFloat32();
      p.type = dv.getUint8();
      return p;
    };
    var metadata = pmd.metadata;
    metadata.rigidBodyCount = dv.getUint32();
    pmd.rigidBodies = [];
    for (var i3 = 0; i3 < metadata.rigidBodyCount; i3++) {
      pmd.rigidBodies.push(parseRigidBody());
    }
  };
  var parseConstraints = function() {
    var parseConstraint = function() {
      var p = {};
      p.name = dv.getSjisStringsAsUnicode(20);
      p.rigidBodyIndex1 = dv.getUint32();
      p.rigidBodyIndex2 = dv.getUint32();
      p.position = dv.getFloat32Array(3);
      p.rotation = dv.getFloat32Array(3);
      p.translationLimitation1 = dv.getFloat32Array(3);
      p.translationLimitation2 = dv.getFloat32Array(3);
      p.rotationLimitation1 = dv.getFloat32Array(3);
      p.rotationLimitation2 = dv.getFloat32Array(3);
      p.springPosition = dv.getFloat32Array(3);
      p.springRotation = dv.getFloat32Array(3);
      return p;
    };
    var metadata = pmd.metadata;
    metadata.constraintCount = dv.getUint32();
    pmd.constraints = [];
    for (var i3 = 0; i3 < metadata.constraintCount; i3++) {
      pmd.constraints.push(parseConstraint());
    }
  };
  parseHeader();
  parseVertices();
  parseFaces();
  parseMaterials();
  parseBones();
  parseIks();
  parseMorphs();
  parseMorphFrames();
  parseBoneFrameNames();
  parseBoneFrames();
  parseEnglishHeader();
  parseEnglishBoneNames();
  parseEnglishMorphNames();
  parseEnglishBoneFrameNames();
  parseToonTextures();
  parseRigidBodies();
  parseConstraints();
  if (leftToRight === true)
    this.leftToRightModel(pmd);
  return pmd;
};
Parser.prototype.parsePmx = function(buffer, leftToRight) {
  var pmx = {};
  var dv = new DataViewEx(buffer);
  pmx.metadata = {};
  pmx.metadata.format = "pmx";
  pmx.metadata.coordinateSystem = "left";
  var parseHeader = function() {
    var metadata = pmx.metadata;
    metadata.magic = dv.getChars(4);
    if (metadata.magic !== "PMX ") {
      throw "PMX file magic is not PMX , but " + metadata.magic;
    }
    metadata.version = dv.getFloat32();
    if (metadata.version !== 2 && metadata.version !== 2.1) {
      throw "PMX version " + metadata.version + " is not supported.";
    }
    metadata.headerSize = dv.getUint8();
    metadata.encoding = dv.getUint8();
    metadata.additionalUvNum = dv.getUint8();
    metadata.vertexIndexSize = dv.getUint8();
    metadata.textureIndexSize = dv.getUint8();
    metadata.materialIndexSize = dv.getUint8();
    metadata.boneIndexSize = dv.getUint8();
    metadata.morphIndexSize = dv.getUint8();
    metadata.rigidBodyIndexSize = dv.getUint8();
    metadata.modelName = dv.getTextBuffer();
    metadata.englishModelName = dv.getTextBuffer();
    metadata.comment = dv.getTextBuffer();
    metadata.englishComment = dv.getTextBuffer();
  };
  var parseVertices = function() {
    var parseVertex = function() {
      var p = {};
      p.position = dv.getFloat32Array(3);
      p.normal = dv.getFloat32Array(3);
      p.uv = dv.getFloat32Array(2);
      p.auvs = [];
      for (var i4 = 0; i4 < pmx.metadata.additionalUvNum; i4++) {
        p.auvs.push(dv.getFloat32Array(4));
      }
      p.type = dv.getUint8();
      var indexSize = metadata.boneIndexSize;
      if (p.type === 0) {
        p.skinIndices = dv.getIndexArray(indexSize, 1);
        p.skinWeights = [1];
      } else if (p.type === 1) {
        p.skinIndices = dv.getIndexArray(indexSize, 2);
        p.skinWeights = dv.getFloat32Array(1);
        p.skinWeights.push(1 - p.skinWeights[0]);
      } else if (p.type === 2) {
        p.skinIndices = dv.getIndexArray(indexSize, 4);
        p.skinWeights = dv.getFloat32Array(4);
      } else if (p.type === 3) {
        p.skinIndices = dv.getIndexArray(indexSize, 2);
        p.skinWeights = dv.getFloat32Array(1);
        p.skinWeights.push(1 - p.skinWeights[0]);
        p.skinC = dv.getFloat32Array(3);
        p.skinR0 = dv.getFloat32Array(3);
        p.skinR1 = dv.getFloat32Array(3);
        p.type = 1;
      } else {
        throw "unsupport bone type " + p.type + " exception.";
      }
      p.edgeRatio = dv.getFloat32();
      return p;
    };
    var metadata = pmx.metadata;
    metadata.vertexCount = dv.getUint32();
    pmx.vertices = [];
    for (var i3 = 0; i3 < metadata.vertexCount; i3++) {
      pmx.vertices.push(parseVertex());
    }
  };
  var parseFaces = function() {
    var parseFace = function() {
      var p = {};
      p.indices = dv.getIndexArray(metadata.vertexIndexSize, 3, true);
      return p;
    };
    var metadata = pmx.metadata;
    metadata.faceCount = dv.getUint32() / 3;
    pmx.faces = [];
    for (var i3 = 0; i3 < metadata.faceCount; i3++) {
      pmx.faces.push(parseFace());
    }
  };
  var parseTextures = function() {
    var parseTexture = function() {
      return dv.getTextBuffer();
    };
    var metadata = pmx.metadata;
    metadata.textureCount = dv.getUint32();
    pmx.textures = [];
    for (var i3 = 0; i3 < metadata.textureCount; i3++) {
      pmx.textures.push(parseTexture());
    }
  };
  var parseMaterials = function() {
    var parseMaterial = function() {
      var p = {};
      p.name = dv.getTextBuffer();
      p.englishName = dv.getTextBuffer();
      p.diffuse = dv.getFloat32Array(4);
      p.specular = dv.getFloat32Array(3);
      p.shininess = dv.getFloat32();
      p.ambient = dv.getFloat32Array(3);
      p.flag = dv.getUint8();
      p.edgeColor = dv.getFloat32Array(4);
      p.edgeSize = dv.getFloat32();
      p.textureIndex = dv.getIndex(pmx.metadata.textureIndexSize);
      p.envTextureIndex = dv.getIndex(pmx.metadata.textureIndexSize);
      p.envFlag = dv.getUint8();
      p.toonFlag = dv.getUint8();
      if (p.toonFlag === 0) {
        p.toonIndex = dv.getIndex(pmx.metadata.textureIndexSize);
      } else if (p.toonFlag === 1) {
        p.toonIndex = dv.getInt8();
      } else {
        throw "unknown toon flag " + p.toonFlag + " exception.";
      }
      p.comment = dv.getTextBuffer();
      p.faceCount = dv.getUint32() / 3;
      return p;
    };
    var metadata = pmx.metadata;
    metadata.materialCount = dv.getUint32();
    pmx.materials = [];
    for (var i3 = 0; i3 < metadata.materialCount; i3++) {
      pmx.materials.push(parseMaterial());
    }
  };
  var parseBones = function() {
    var parseBone = function() {
      var p = {};
      p.name = dv.getTextBuffer();
      p.englishName = dv.getTextBuffer();
      p.position = dv.getFloat32Array(3);
      p.parentIndex = dv.getIndex(pmx.metadata.boneIndexSize);
      p.transformationClass = dv.getUint32();
      p.flag = dv.getUint16();
      if (p.flag & 1) {
        p.connectIndex = dv.getIndex(pmx.metadata.boneIndexSize);
      } else {
        p.offsetPosition = dv.getFloat32Array(3);
      }
      if (p.flag & 256 || p.flag & 512) {
        var grant = {};
        grant.isLocal = (p.flag & 128) !== 0 ? true : false;
        grant.affectRotation = (p.flag & 256) !== 0 ? true : false;
        grant.affectPosition = (p.flag & 512) !== 0 ? true : false;
        grant.parentIndex = dv.getIndex(pmx.metadata.boneIndexSize);
        grant.ratio = dv.getFloat32();
        p.grant = grant;
      }
      if (p.flag & 1024) {
        p.fixAxis = dv.getFloat32Array(3);
      }
      if (p.flag & 2048) {
        p.localXVector = dv.getFloat32Array(3);
        p.localZVector = dv.getFloat32Array(3);
      }
      if (p.flag & 8192) {
        p.key = dv.getUint32();
      }
      if (p.flag & 32) {
        var ik = {};
        ik.effector = dv.getIndex(pmx.metadata.boneIndexSize);
        ik.target = null;
        ik.iteration = dv.getUint32();
        ik.maxAngle = dv.getFloat32();
        ik.linkCount = dv.getUint32();
        ik.links = [];
        for (var i4 = 0; i4 < ik.linkCount; i4++) {
          var link = {};
          link.index = dv.getIndex(pmx.metadata.boneIndexSize);
          link.angleLimitation = dv.getUint8();
          if (link.angleLimitation === 1) {
            link.lowerLimitationAngle = dv.getFloat32Array(3);
            link.upperLimitationAngle = dv.getFloat32Array(3);
          }
          ik.links.push(link);
        }
        p.ik = ik;
      }
      return p;
    };
    var metadata = pmx.metadata;
    metadata.boneCount = dv.getUint32();
    pmx.bones = [];
    for (var i3 = 0; i3 < metadata.boneCount; i3++) {
      pmx.bones.push(parseBone());
    }
  };
  var parseMorphs = function() {
    var parseMorph = function() {
      var p = {};
      p.name = dv.getTextBuffer();
      p.englishName = dv.getTextBuffer();
      p.panel = dv.getUint8();
      p.type = dv.getUint8();
      p.elementCount = dv.getUint32();
      p.elements = [];
      for (var i4 = 0; i4 < p.elementCount; i4++) {
        if (p.type === 0) {
          var m = {};
          m.index = dv.getIndex(pmx.metadata.morphIndexSize);
          m.ratio = dv.getFloat32();
          p.elements.push(m);
        } else if (p.type === 1) {
          var m = {};
          m.index = dv.getIndex(pmx.metadata.vertexIndexSize, true);
          m.position = dv.getFloat32Array(3);
          p.elements.push(m);
        } else if (p.type === 2) {
          var m = {};
          m.index = dv.getIndex(pmx.metadata.boneIndexSize);
          m.position = dv.getFloat32Array(3);
          m.rotation = dv.getFloat32Array(4);
          p.elements.push(m);
        } else if (p.type === 3) {
          var m = {};
          m.index = dv.getIndex(pmx.metadata.vertexIndexSize, true);
          m.uv = dv.getFloat32Array(4);
          p.elements.push(m);
        } else if (p.type === 4) {
        } else if (p.type === 5) {
        } else if (p.type === 6) {
        } else if (p.type === 7) {
        } else if (p.type === 8) {
          var m = {};
          m.index = dv.getIndex(pmx.metadata.materialIndexSize);
          m.type = dv.getUint8();
          m.diffuse = dv.getFloat32Array(4);
          m.specular = dv.getFloat32Array(3);
          m.shininess = dv.getFloat32();
          m.ambient = dv.getFloat32Array(3);
          m.edgeColor = dv.getFloat32Array(4);
          m.edgeSize = dv.getFloat32();
          m.textureColor = dv.getFloat32Array(4);
          m.sphereTextureColor = dv.getFloat32Array(4);
          m.toonColor = dv.getFloat32Array(4);
          p.elements.push(m);
        }
      }
      return p;
    };
    var metadata = pmx.metadata;
    metadata.morphCount = dv.getUint32();
    pmx.morphs = [];
    for (var i3 = 0; i3 < metadata.morphCount; i3++) {
      pmx.morphs.push(parseMorph());
    }
  };
  var parseFrames = function() {
    var parseFrame = function() {
      var p = {};
      p.name = dv.getTextBuffer();
      p.englishName = dv.getTextBuffer();
      p.type = dv.getUint8();
      p.elementCount = dv.getUint32();
      p.elements = [];
      for (var i4 = 0; i4 < p.elementCount; i4++) {
        var e = {};
        e.target = dv.getUint8();
        e.index = e.target === 0 ? dv.getIndex(pmx.metadata.boneIndexSize) : dv.getIndex(pmx.metadata.morphIndexSize);
        p.elements.push(e);
      }
      return p;
    };
    var metadata = pmx.metadata;
    metadata.frameCount = dv.getUint32();
    pmx.frames = [];
    for (var i3 = 0; i3 < metadata.frameCount; i3++) {
      pmx.frames.push(parseFrame());
    }
  };
  var parseRigidBodies = function() {
    var parseRigidBody = function() {
      var p = {};
      p.name = dv.getTextBuffer();
      p.englishName = dv.getTextBuffer();
      p.boneIndex = dv.getIndex(pmx.metadata.boneIndexSize);
      p.groupIndex = dv.getUint8();
      p.groupTarget = dv.getUint16();
      p.shapeType = dv.getUint8();
      p.width = dv.getFloat32();
      p.height = dv.getFloat32();
      p.depth = dv.getFloat32();
      p.position = dv.getFloat32Array(3);
      p.rotation = dv.getFloat32Array(3);
      p.weight = dv.getFloat32();
      p.positionDamping = dv.getFloat32();
      p.rotationDamping = dv.getFloat32();
      p.restitution = dv.getFloat32();
      p.friction = dv.getFloat32();
      p.type = dv.getUint8();
      return p;
    };
    var metadata = pmx.metadata;
    metadata.rigidBodyCount = dv.getUint32();
    pmx.rigidBodies = [];
    for (var i3 = 0; i3 < metadata.rigidBodyCount; i3++) {
      pmx.rigidBodies.push(parseRigidBody());
    }
  };
  var parseConstraints = function() {
    var parseConstraint = function() {
      var p = {};
      p.name = dv.getTextBuffer();
      p.englishName = dv.getTextBuffer();
      p.type = dv.getUint8();
      p.rigidBodyIndex1 = dv.getIndex(pmx.metadata.rigidBodyIndexSize);
      p.rigidBodyIndex2 = dv.getIndex(pmx.metadata.rigidBodyIndexSize);
      p.position = dv.getFloat32Array(3);
      p.rotation = dv.getFloat32Array(3);
      p.translationLimitation1 = dv.getFloat32Array(3);
      p.translationLimitation2 = dv.getFloat32Array(3);
      p.rotationLimitation1 = dv.getFloat32Array(3);
      p.rotationLimitation2 = dv.getFloat32Array(3);
      p.springPosition = dv.getFloat32Array(3);
      p.springRotation = dv.getFloat32Array(3);
      return p;
    };
    var metadata = pmx.metadata;
    metadata.constraintCount = dv.getUint32();
    pmx.constraints = [];
    for (var i3 = 0; i3 < metadata.constraintCount; i3++) {
      pmx.constraints.push(parseConstraint());
    }
  };
  parseHeader();
  parseVertices();
  parseFaces();
  parseTextures();
  parseMaterials();
  parseBones();
  parseMorphs();
  parseFrames();
  parseRigidBodies();
  parseConstraints();
  if (leftToRight === true)
    this.leftToRightModel(pmx);
  return pmx;
};
Parser.prototype.parseVmd = function(buffer, leftToRight) {
  var vmd = {};
  var dv = new DataViewEx(buffer);
  vmd.metadata = {};
  vmd.metadata.coordinateSystem = "left";
  var parseHeader = function() {
    var metadata = vmd.metadata;
    metadata.magic = dv.getChars(30);
    if (metadata.magic !== "Vocaloid Motion Data 0002") {
      throw "VMD file magic is not Vocaloid Motion Data 0002, but " + metadata.magic;
    }
    metadata.name = dv.getSjisStringsAsUnicode(20);
  };
  var parseMotions = function() {
    var parseMotion = function() {
      var p = {};
      p.boneName = dv.getSjisStringsAsUnicode(15);
      p.frameNum = dv.getUint32();
      p.position = dv.getFloat32Array(3);
      p.rotation = dv.getFloat32Array(4);
      p.interpolation = dv.getUint8Array(64);
      return p;
    };
    var metadata = vmd.metadata;
    metadata.motionCount = dv.getUint32();
    vmd.motions = [];
    for (var i3 = 0; i3 < metadata.motionCount; i3++) {
      vmd.motions.push(parseMotion());
    }
  };
  var parseMorphs = function() {
    var parseMorph = function() {
      var p = {};
      p.morphName = dv.getSjisStringsAsUnicode(15);
      p.frameNum = dv.getUint32();
      p.weight = dv.getFloat32();
      return p;
    };
    var metadata = vmd.metadata;
    metadata.morphCount = dv.getUint32();
    vmd.morphs = [];
    for (var i3 = 0; i3 < metadata.morphCount; i3++) {
      vmd.morphs.push(parseMorph());
    }
  };
  var parseCameras = function() {
    var parseCamera = function() {
      var p = {};
      p.frameNum = dv.getUint32();
      p.distance = dv.getFloat32();
      p.position = dv.getFloat32Array(3);
      p.rotation = dv.getFloat32Array(3);
      p.interpolation = dv.getUint8Array(24);
      p.fov = dv.getUint32();
      p.perspective = dv.getUint8();
      return p;
    };
    var metadata = vmd.metadata;
    metadata.cameraCount = dv.getUint32();
    vmd.cameras = [];
    for (var i3 = 0; i3 < metadata.cameraCount; i3++) {
      vmd.cameras.push(parseCamera());
    }
  };
  parseHeader();
  parseMotions();
  parseMorphs();
  parseCameras();
  if (leftToRight === true)
    this.leftToRightVmd(vmd);
  return vmd;
};
Parser.prototype.parseVpd = function(text, leftToRight) {
  var vpd = {};
  vpd.metadata = {};
  vpd.metadata.coordinateSystem = "left";
  vpd.bones = [];
  var commentPatternG = /\/\/\w*(\r|\n|\r\n)/g;
  var newlinePattern = /\r|\n|\r\n/;
  var lines = text.replace(commentPatternG, "").split(newlinePattern);
  function throwError() {
    throw "the file seems not vpd file.";
  }
  function checkMagic() {
    if (lines[0] !== "Vocaloid Pose Data file") {
      throwError();
    }
  }
  function parseHeader() {
    if (lines.length < 4) {
      throwError();
    }
    vpd.metadata.parentFile = lines[2];
    vpd.metadata.boneCount = parseInt(lines[3]);
  }
  function parseBones() {
    var boneHeaderPattern = /^\s*(Bone[0-9]+)\s*\{\s*(.*)$/;
    var boneVectorPattern = /^\s*(-?[0-9]+\.[0-9]+)\s*,\s*(-?[0-9]+\.[0-9]+)\s*,\s*(-?[0-9]+\.[0-9]+)\s*;/;
    var boneQuaternionPattern = /^\s*(-?[0-9]+\.[0-9]+)\s*,\s*(-?[0-9]+\.[0-9]+)\s*,\s*(-?[0-9]+\.[0-9]+)\s*,\s*(-?[0-9]+\.[0-9]+)\s*;/;
    var boneFooterPattern = /^\s*}/;
    var bones = vpd.bones;
    var n = null;
    var v = null;
    var q = null;
    for (var i3 = 4; i3 < lines.length; i3++) {
      var line2 = lines[i3];
      var result;
      result = line2.match(boneHeaderPattern);
      if (result !== null) {
        if (n !== null) {
          throwError();
        }
        n = result[2];
      }
      result = line2.match(boneVectorPattern);
      if (result !== null) {
        if (v !== null) {
          throwError();
        }
        v = [
          parseFloat(result[1]),
          parseFloat(result[2]),
          parseFloat(result[3])
        ];
      }
      result = line2.match(boneQuaternionPattern);
      if (result !== null) {
        if (q !== null) {
          throwError();
        }
        q = [
          parseFloat(result[1]),
          parseFloat(result[2]),
          parseFloat(result[3]),
          parseFloat(result[4])
        ];
      }
      result = line2.match(boneFooterPattern);
      if (result !== null) {
        if (n === null || v === null || q === null) {
          throwError();
        }
        bones.push({
          name: n,
          translation: v,
          quaternion: q
        });
        n = null;
        v = null;
        q = null;
      }
    }
    if (n !== null || v !== null || q !== null) {
      throwError();
    }
  }
  checkMagic();
  parseHeader();
  parseBones();
  if (leftToRight === true)
    this.leftToRightVpd(vpd);
  return vpd;
};
Parser.prototype.mergeVmds = function(vmds) {
  var v = {};
  v.metadata = {};
  v.metadata.name = vmds[0].metadata.name;
  v.metadata.coordinateSystem = vmds[0].metadata.coordinateSystem;
  v.metadata.motionCount = 0;
  v.metadata.morphCount = 0;
  v.metadata.cameraCount = 0;
  v.motions = [];
  v.morphs = [];
  v.cameras = [];
  for (var i3 = 0; i3 < vmds.length; i3++) {
    var v23 = vmds[i3];
    v.metadata.motionCount += v23.metadata.motionCount;
    v.metadata.morphCount += v23.metadata.morphCount;
    v.metadata.cameraCount += v23.metadata.cameraCount;
    for (var j = 0; j < v23.metadata.motionCount; j++) {
      v.motions.push(v23.motions[j]);
    }
    for (var j = 0; j < v23.metadata.morphCount; j++) {
      v.morphs.push(v23.morphs[j]);
    }
    for (var j = 0; j < v23.metadata.cameraCount; j++) {
      v.cameras.push(v23.cameras[j]);
    }
  }
  return v;
};
Parser.prototype.leftToRightModel = function(model) {
  if (model.metadata.coordinateSystem === "right") {
    return;
  }
  model.metadata.coordinateSystem = "right";
  var helper = new DataCreationHelper();
  for (var i3 = 0; i3 < model.metadata.vertexCount; i3++) {
    helper.leftToRightVector3(model.vertices[i3].position);
    helper.leftToRightVector3(model.vertices[i3].normal);
  }
  for (var i3 = 0; i3 < model.metadata.faceCount; i3++) {
    helper.leftToRightIndexOrder(model.faces[i3].indices);
  }
  for (var i3 = 0; i3 < model.metadata.boneCount; i3++) {
    helper.leftToRightVector3(model.bones[i3].position);
  }
  for (var i3 = 0; i3 < model.metadata.morphCount; i3++) {
    var m = model.morphs[i3];
    if (model.metadata.format === "pmx" && m.type !== 1) {
      continue;
    }
    for (var j = 0; j < m.elements.length; j++) {
      helper.leftToRightVector3(m.elements[j].position);
    }
  }
  for (var i3 = 0; i3 < model.metadata.rigidBodyCount; i3++) {
    helper.leftToRightVector3(model.rigidBodies[i3].position);
    helper.leftToRightEuler(model.rigidBodies[i3].rotation);
  }
  for (var i3 = 0; i3 < model.metadata.constraintCount; i3++) {
    helper.leftToRightVector3(model.constraints[i3].position);
    helper.leftToRightEuler(model.constraints[i3].rotation);
    helper.leftToRightVector3Range(model.constraints[i3].translationLimitation1, model.constraints[i3].translationLimitation2);
    helper.leftToRightEulerRange(model.constraints[i3].rotationLimitation1, model.constraints[i3].rotationLimitation2);
  }
};
Parser.prototype.leftToRightVmd = function(vmd) {
  if (vmd.metadata.coordinateSystem === "right") {
    return;
  }
  vmd.metadata.coordinateSystem = "right";
  var helper = new DataCreationHelper();
  for (var i3 = 0; i3 < vmd.metadata.motionCount; i3++) {
    helper.leftToRightVector3(vmd.motions[i3].position);
    helper.leftToRightQuaternion(vmd.motions[i3].rotation);
  }
  for (var i3 = 0; i3 < vmd.metadata.cameraCount; i3++) {
    helper.leftToRightVector3(vmd.cameras[i3].position);
    helper.leftToRightEuler(vmd.cameras[i3].rotation);
  }
};
Parser.prototype.leftToRightVpd = function(vpd) {
  if (vpd.metadata.coordinateSystem === "right") {
    return;
  }
  vpd.metadata.coordinateSystem = "right";
  var helper = new DataCreationHelper();
  for (var i3 = 0; i3 < vpd.bones.length; i3++) {
    helper.leftToRightVector3(vpd.bones[i3].translation);
    helper.leftToRightQuaternion(vpd.bones[i3].quaternion);
  }
};

// node_modules/three-stdlib/animation/CCDIKSolver.js
var _q = new Quaternion();
var _targetPos = new Vector3();
var _targetVec = new Vector3();
var _effectorPos = new Vector3();
var _effectorVec = new Vector3();
var _linkPos = new Vector3();
var _invLinkQ = new Quaternion();
var _linkScale = new Vector3();
var _axis = new Vector3();
var _vector2 = new Vector3();
var _matrix3 = new Matrix4();

// node_modules/three-stdlib/animation/MMDPhysics.js
var _position2 = new Vector3();
var _quaternion2 = new Quaternion();
var _scale2 = new Vector3();
var _matrixWorldInv = new Matrix4();

// node_modules/three-stdlib/animation/MMDAnimationHelper.js
var _q2 = new Quaternion();

// node_modules/three-stdlib/objects/Reflector.js
var __defProp2 = Object.defineProperty;
var __defNormalProp2 = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField3 = (obj, key, value) => {
  __defNormalProp2(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var _Reflector = class extends Mesh {
  constructor(geometry2, options = {}) {
    super(geometry2);
    this.isReflector = true;
    this.type = "Reflector";
    this.camera = new PerspectiveCamera();
    const scope = this;
    const color = options.color !== void 0 ? new Color(options.color) : new Color(8355711);
    const textureWidth = options.textureWidth || 512;
    const textureHeight = options.textureHeight || 512;
    const clipBias = options.clipBias || 0;
    const shader = options.shader || _Reflector.ReflectorShader;
    const multisample = options.multisample !== void 0 ? options.multisample : 4;
    const reflectorPlane = new Plane();
    const normal = new Vector3();
    const reflectorWorldPosition = new Vector3();
    const cameraWorldPosition = new Vector3();
    const rotationMatrix2 = new Matrix4();
    const lookAtPosition = new Vector3(0, 0, -1);
    const clipPlane = new Vector4();
    const view = new Vector3();
    const target = new Vector3();
    const q = new Vector4();
    const textureMatrix = new Matrix4();
    const virtualCamera = this.camera;
    const renderTarget = new WebGLRenderTarget(textureWidth, textureHeight, {
      samples: multisample,
      type: HalfFloatType
    });
    const material2 = new ShaderMaterial({
      uniforms: UniformsUtils.clone(shader.uniforms),
      fragmentShader: shader.fragmentShader,
      vertexShader: shader.vertexShader
    });
    material2.uniforms["tDiffuse"].value = renderTarget.texture;
    material2.uniforms["color"].value = color;
    material2.uniforms["textureMatrix"].value = textureMatrix;
    this.material = material2;
    this.onBeforeRender = function(renderer, scene, camera) {
      reflectorWorldPosition.setFromMatrixPosition(scope.matrixWorld);
      cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);
      rotationMatrix2.extractRotation(scope.matrixWorld);
      normal.set(0, 0, 1);
      normal.applyMatrix4(rotationMatrix2);
      view.subVectors(reflectorWorldPosition, cameraWorldPosition);
      if (view.dot(normal) > 0)
        return;
      view.reflect(normal).negate();
      view.add(reflectorWorldPosition);
      rotationMatrix2.extractRotation(camera.matrixWorld);
      lookAtPosition.set(0, 0, -1);
      lookAtPosition.applyMatrix4(rotationMatrix2);
      lookAtPosition.add(cameraWorldPosition);
      target.subVectors(reflectorWorldPosition, lookAtPosition);
      target.reflect(normal).negate();
      target.add(reflectorWorldPosition);
      virtualCamera.position.copy(view);
      virtualCamera.up.set(0, 1, 0);
      virtualCamera.up.applyMatrix4(rotationMatrix2);
      virtualCamera.up.reflect(normal);
      virtualCamera.lookAt(target);
      virtualCamera.far = camera.far;
      virtualCamera.updateMatrixWorld();
      virtualCamera.projectionMatrix.copy(camera.projectionMatrix);
      textureMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);
      textureMatrix.multiply(virtualCamera.projectionMatrix);
      textureMatrix.multiply(virtualCamera.matrixWorldInverse);
      textureMatrix.multiply(scope.matrixWorld);
      reflectorPlane.setFromNormalAndCoplanarPoint(normal, reflectorWorldPosition);
      reflectorPlane.applyMatrix4(virtualCamera.matrixWorldInverse);
      clipPlane.set(reflectorPlane.normal.x, reflectorPlane.normal.y, reflectorPlane.normal.z, reflectorPlane.constant);
      const projectionMatrix = virtualCamera.projectionMatrix;
      q.x = (Math.sign(clipPlane.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];
      q.y = (Math.sign(clipPlane.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];
      q.z = -1;
      q.w = (1 + projectionMatrix.elements[10]) / projectionMatrix.elements[14];
      clipPlane.multiplyScalar(2 / clipPlane.dot(q));
      projectionMatrix.elements[2] = clipPlane.x;
      projectionMatrix.elements[6] = clipPlane.y;
      projectionMatrix.elements[10] = clipPlane.z + 1 - clipBias;
      projectionMatrix.elements[14] = clipPlane.w;
      scope.visible = false;
      const currentRenderTarget = renderer.getRenderTarget();
      const currentXrEnabled = renderer.xr.enabled;
      const currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;
      const currentToneMapping = renderer.toneMapping;
      let isSRGB = false;
      if ("outputColorSpace" in renderer)
        isSRGB = renderer.outputColorSpace === "srgb";
      else
        isSRGB = renderer.outputEncoding === 3001;
      renderer.xr.enabled = false;
      renderer.shadowMap.autoUpdate = false;
      if ("outputColorSpace" in renderer)
        renderer.outputColorSpace = "linear-srgb";
      else
        renderer.outputEncoding = 3e3;
      renderer.toneMapping = NoToneMapping;
      renderer.setRenderTarget(renderTarget);
      renderer.state.buffers.depth.setMask(true);
      if (renderer.autoClear === false)
        renderer.clear();
      renderer.render(scene, virtualCamera);
      renderer.xr.enabled = currentXrEnabled;
      renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;
      renderer.toneMapping = currentToneMapping;
      if ("outputColorSpace" in renderer)
        renderer.outputColorSpace = isSRGB ? "srgb" : "srgb-linear";
      else
        renderer.outputEncoding = isSRGB ? 3001 : 3e3;
      renderer.setRenderTarget(currentRenderTarget);
      const viewport = camera.viewport;
      if (viewport !== void 0) {
        renderer.state.viewport(viewport);
      }
      scope.visible = true;
    };
    this.getRenderTarget = function() {
      return renderTarget;
    };
    this.dispose = function() {
      renderTarget.dispose();
      scope.material.dispose();
    };
  }
};
var Reflector = _Reflector;
__publicField3(Reflector, "ReflectorShader", {
  uniforms: {
    color: {
      value: null
    },
    tDiffuse: {
      value: null
    },
    textureMatrix: {
      value: null
    }
  },
  vertexShader: (
    /* glsl */
    `
		uniform mat4 textureMatrix;
		varying vec4 vUv;

		#include <common>
		#include <logdepthbuf_pars_vertex>

		void main() {

			vUv = textureMatrix * vec4( position, 1.0 );

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

			#include <logdepthbuf_vertex>

		}`
  ),
  fragmentShader: (
    /* glsl */
    `
		uniform vec3 color;
		uniform sampler2D tDiffuse;
		varying vec4 vUv;

		#include <logdepthbuf_pars_fragment>

		float blendOverlay( float base, float blend ) {

			return( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );

		}

		vec3 blendOverlay( vec3 base, vec3 blend ) {

			return vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );

		}

		void main() {

			#include <logdepthbuf_fragment>

			vec4 base = texture2DProj( tDiffuse, vUv );
			gl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );

			#include <tonemapping_fragment>
			#include <encodings_fragment>

		}`
  )
});

// node_modules/three-stdlib/objects/Refractor.js
var __defProp3 = Object.defineProperty;
var __defNormalProp3 = (obj, key, value) => key in obj ? __defProp3(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField4 = (obj, key, value) => {
  __defNormalProp3(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var _Refractor = class extends Mesh {
  constructor(geometry2, options = {}) {
    super(geometry2);
    this.isRefractor = true;
    this.type = "Refractor";
    this.camera = new PerspectiveCamera();
    const scope = this;
    const color = options.color !== void 0 ? new Color(options.color) : new Color(8355711);
    const textureWidth = options.textureWidth || 512;
    const textureHeight = options.textureHeight || 512;
    const clipBias = options.clipBias || 0;
    const shader = options.shader || _Refractor.RefractorShader;
    const multisample = options.multisample !== void 0 ? options.multisample : 4;
    const virtualCamera = this.camera;
    virtualCamera.matrixAutoUpdate = false;
    virtualCamera.userData.refractor = true;
    const refractorPlane = new Plane();
    const textureMatrix = new Matrix4();
    const renderTarget = new WebGLRenderTarget(textureWidth, textureHeight, {
      samples: multisample,
      type: HalfFloatType
    });
    this.material = new ShaderMaterial({
      uniforms: UniformsUtils.clone(shader.uniforms),
      vertexShader: shader.vertexShader,
      fragmentShader: shader.fragmentShader,
      transparent: true
      // ensures, refractors are drawn from farthest to closest
    });
    this.material.uniforms["color"].value = color;
    this.material.uniforms["tDiffuse"].value = renderTarget.texture;
    this.material.uniforms["textureMatrix"].value = textureMatrix;
    const visible = function() {
      const refractorWorldPosition = new Vector3();
      const cameraWorldPosition = new Vector3();
      const rotationMatrix2 = new Matrix4();
      const view = new Vector3();
      const normal = new Vector3();
      return function visible2(camera) {
        refractorWorldPosition.setFromMatrixPosition(scope.matrixWorld);
        cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);
        view.subVectors(refractorWorldPosition, cameraWorldPosition);
        rotationMatrix2.extractRotation(scope.matrixWorld);
        normal.set(0, 0, 1);
        normal.applyMatrix4(rotationMatrix2);
        return view.dot(normal) < 0;
      };
    }();
    const updateRefractorPlane = function() {
      const normal = new Vector3();
      const position = new Vector3();
      const quaternion = new Quaternion();
      const scale = new Vector3();
      return function updateRefractorPlane2() {
        scope.matrixWorld.decompose(position, quaternion, scale);
        normal.set(0, 0, 1).applyQuaternion(quaternion).normalize();
        normal.negate();
        refractorPlane.setFromNormalAndCoplanarPoint(normal, position);
      };
    }();
    const updateVirtualCamera = function() {
      const clipPlane = new Plane();
      const clipVector = new Vector4();
      const q = new Vector4();
      return function updateVirtualCamera2(camera) {
        virtualCamera.matrixWorld.copy(camera.matrixWorld);
        virtualCamera.matrixWorldInverse.copy(virtualCamera.matrixWorld).invert();
        virtualCamera.projectionMatrix.copy(camera.projectionMatrix);
        virtualCamera.far = camera.far;
        clipPlane.copy(refractorPlane);
        clipPlane.applyMatrix4(virtualCamera.matrixWorldInverse);
        clipVector.set(clipPlane.normal.x, clipPlane.normal.y, clipPlane.normal.z, clipPlane.constant);
        const projectionMatrix = virtualCamera.projectionMatrix;
        q.x = (Math.sign(clipVector.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];
        q.y = (Math.sign(clipVector.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];
        q.z = -1;
        q.w = (1 + projectionMatrix.elements[10]) / projectionMatrix.elements[14];
        clipVector.multiplyScalar(2 / clipVector.dot(q));
        projectionMatrix.elements[2] = clipVector.x;
        projectionMatrix.elements[6] = clipVector.y;
        projectionMatrix.elements[10] = clipVector.z + 1 - clipBias;
        projectionMatrix.elements[14] = clipVector.w;
      };
    }();
    function updateTextureMatrix(camera) {
      textureMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);
      textureMatrix.multiply(camera.projectionMatrix);
      textureMatrix.multiply(camera.matrixWorldInverse);
      textureMatrix.multiply(scope.matrixWorld);
    }
    function render3(renderer, scene, camera) {
      scope.visible = false;
      const currentRenderTarget = renderer.getRenderTarget();
      const currentXrEnabled = renderer.xr.enabled;
      const currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;
      const currentToneMapping = renderer.toneMapping;
      let isSRGB = false;
      if ("outputColorSpace" in renderer)
        isSRGB = renderer.outputColorSpace === "srgb";
      else
        isSRGB = renderer.outputEncoding === 3001;
      renderer.xr.enabled = false;
      renderer.shadowMap.autoUpdate = false;
      if ("outputColorSpace" in renderer)
        renderer.outputColorSpace = "linear-srgb";
      else
        renderer.outputEncoding = 3e3;
      renderer.toneMapping = NoToneMapping;
      renderer.setRenderTarget(renderTarget);
      if (renderer.autoClear === false)
        renderer.clear();
      renderer.render(scene, virtualCamera);
      renderer.xr.enabled = currentXrEnabled;
      renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;
      renderer.toneMapping = currentToneMapping;
      renderer.setRenderTarget(currentRenderTarget);
      if ("outputColorSpace" in renderer)
        renderer.outputColorSpace = isSRGB ? "srgb" : "srgb-linear";
      else
        renderer.outputEncoding = isSRGB ? 3001 : 3e3;
      const viewport = camera.viewport;
      if (viewport !== void 0) {
        renderer.state.viewport(viewport);
      }
      scope.visible = true;
    }
    this.onBeforeRender = function(renderer, scene, camera) {
      if (camera.userData.refractor === true)
        return;
      if (!visible(camera) === true)
        return;
      updateRefractorPlane();
      updateTextureMatrix(camera);
      updateVirtualCamera(camera);
      render3(renderer, scene, camera);
    };
    this.getRenderTarget = function() {
      return renderTarget;
    };
    this.dispose = function() {
      renderTarget.dispose();
      scope.material.dispose();
    };
  }
};
var Refractor = _Refractor;
__publicField4(Refractor, "RefractorShader", {
  uniforms: {
    color: {
      value: null
    },
    tDiffuse: {
      value: null
    },
    textureMatrix: {
      value: null
    }
  },
  vertexShader: (
    /* glsl */
    `

		uniform mat4 textureMatrix;

		varying vec4 vUv;

		void main() {

			vUv = textureMatrix * vec4( position, 1.0 );
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`
  ),
  fragmentShader: (
    /* glsl */
    `

		uniform vec3 color;
		uniform sampler2D tDiffuse;

		varying vec4 vUv;

		float blendOverlay( float base, float blend ) {

			return( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );

		}

		vec3 blendOverlay( vec3 base, vec3 blend ) {

			return vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );

		}

		void main() {

			vec4 base = texture2DProj( tDiffuse, vUv );
			gl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );

			#include <tonemapping_fragment>
			#include <encodings_fragment>

		}`
  )
});

// node_modules/three-stdlib/objects/ShadowMesh.js
var _shadowMatrix = new Matrix4();

// node_modules/three-stdlib/objects/Lensflare.js
var __defProp4 = Object.defineProperty;
var __defNormalProp4 = (obj, key, value) => key in obj ? __defProp4(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField5 = (obj, key, value) => {
  __defNormalProp4(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var geometry = new BufferGeometry();
var float32Array = new Float32Array([-1, -1, 0, 0, 0, 1, -1, 0, 1, 0, 1, 1, 0, 1, 1, -1, 1, 0, 0, 1]);
var interleavedBuffer = new InterleavedBuffer(float32Array, 5);
geometry.setIndex([0, 1, 2, 0, 2, 3]);
geometry.setAttribute(
  "position",
  new InterleavedBufferAttribute(interleavedBuffer, 3, 0, false)
);
geometry.setAttribute(
  "uv",
  new InterleavedBufferAttribute(interleavedBuffer, 2, 3, false)
);
var _Lensflare = class extends Mesh {
  constructor() {
    super(_Lensflare.Geometry, new MeshBasicMaterial({ opacity: 0, transparent: true }));
    this.isLensflare = true;
    this.type = "Lensflare";
    this.frustumCulled = false;
    this.renderOrder = Infinity;
    const positionScreen = new Vector3();
    const positionView = new Vector3();
    const tempMap = new DataTexture(new Uint8Array(16 * 16 * 3), 16, 16, RGBAFormat);
    tempMap.minFilter = NearestFilter;
    tempMap.magFilter = NearestFilter;
    tempMap.wrapS = ClampToEdgeWrapping;
    tempMap.wrapT = ClampToEdgeWrapping;
    const occlusionMap = new DataTexture(new Uint8Array(16 * 16 * 3), 16, 16, RGBAFormat);
    occlusionMap.minFilter = NearestFilter;
    occlusionMap.magFilter = NearestFilter;
    occlusionMap.wrapS = ClampToEdgeWrapping;
    occlusionMap.wrapT = ClampToEdgeWrapping;
    const geometry2 = _Lensflare.Geometry;
    const material1a = new RawShaderMaterial({
      uniforms: {
        scale: { value: null },
        screenPosition: { value: null }
      },
      vertexShader: (
        /* glsl */
        `

				precision highp float;

				uniform vec3 screenPosition;
				uniform vec2 scale;

				attribute vec3 position;

				void main() {

					gl_Position = vec4( position.xy * scale + screenPosition.xy, screenPosition.z, 1.0 );

				}`
      ),
      fragmentShader: (
        /* glsl */
        `

				precision highp float;

				void main() {

					gl_FragColor = vec4( 1.0, 0.0, 1.0, 1.0 );

				}`
      ),
      depthTest: true,
      depthWrite: false,
      transparent: false
    });
    const material1b = new RawShaderMaterial({
      uniforms: {
        map: { value: tempMap },
        scale: { value: null },
        screenPosition: { value: null }
      },
      vertexShader: (
        /* glsl */
        `

				precision highp float;

				uniform vec3 screenPosition;
				uniform vec2 scale;

				attribute vec3 position;
				attribute vec2 uv;

				varying vec2 vUV;

				void main() {

					vUV = uv;

					gl_Position = vec4( position.xy * scale + screenPosition.xy, screenPosition.z, 1.0 );

				}`
      ),
      fragmentShader: (
        /* glsl */
        `

				precision highp float;

				uniform sampler2D map;

				varying vec2 vUV;

				void main() {

					gl_FragColor = texture2D( map, vUV );

				}`
      ),
      depthTest: false,
      depthWrite: false,
      transparent: false
    });
    const mesh1 = new Mesh(geometry2, material1a);
    const elements = [];
    const shader = LensflareElement.Shader;
    const material2 = new RawShaderMaterial({
      uniforms: {
        map: { value: null },
        occlusionMap: { value: occlusionMap },
        color: { value: new Color(16777215) },
        scale: { value: new Vector2() },
        screenPosition: { value: new Vector3() }
      },
      vertexShader: shader.vertexShader,
      fragmentShader: shader.fragmentShader,
      blending: AdditiveBlending,
      transparent: true,
      depthWrite: false
    });
    const mesh2 = new Mesh(geometry2, material2);
    this.addElement = function(element) {
      elements.push(element);
    };
    const scale = new Vector2();
    const screenPositionPixels = new Vector2();
    const validArea = new Box2();
    const viewport = new Vector4();
    this.onBeforeRender = function(renderer, scene, camera) {
      renderer.getCurrentViewport(viewport);
      const invAspect = viewport.w / viewport.z;
      const halfViewportWidth = viewport.z / 2;
      const halfViewportHeight = viewport.w / 2;
      let size2 = 16 / viewport.w;
      scale.set(size2 * invAspect, size2);
      validArea.min.set(viewport.x, viewport.y);
      validArea.max.set(viewport.x + (viewport.z - 16), viewport.y + (viewport.w - 16));
      positionView.setFromMatrixPosition(this.matrixWorld);
      positionView.applyMatrix4(camera.matrixWorldInverse);
      if (positionView.z > 0)
        return;
      positionScreen.copy(positionView).applyMatrix4(camera.projectionMatrix);
      screenPositionPixels.x = viewport.x + positionScreen.x * halfViewportWidth + halfViewportWidth - 8;
      screenPositionPixels.y = viewport.y + positionScreen.y * halfViewportHeight + halfViewportHeight - 8;
      if (validArea.containsPoint(screenPositionPixels)) {
        renderer.copyFramebufferToTexture(screenPositionPixels, tempMap);
        let uniforms = material1a.uniforms;
        uniforms["scale"].value = scale;
        uniforms["screenPosition"].value = positionScreen;
        renderer.renderBufferDirect(camera, null, geometry2, material1a, mesh1, null);
        renderer.copyFramebufferToTexture(screenPositionPixels, occlusionMap);
        uniforms = material1b.uniforms;
        uniforms["scale"].value = scale;
        uniforms["screenPosition"].value = positionScreen;
        renderer.renderBufferDirect(camera, null, geometry2, material1b, mesh1, null);
        const vecX = -positionScreen.x * 2;
        const vecY = -positionScreen.y * 2;
        for (let i3 = 0, l = elements.length; i3 < l; i3++) {
          const element = elements[i3];
          const uniforms2 = material2.uniforms;
          uniforms2["color"].value.copy(element.color);
          uniforms2["map"].value = element.texture;
          uniforms2["screenPosition"].value.x = positionScreen.x + vecX * element.distance;
          uniforms2["screenPosition"].value.y = positionScreen.y + vecY * element.distance;
          size2 = element.size / viewport.w;
          const invAspect2 = viewport.w / viewport.z;
          uniforms2["scale"].value.set(size2 * invAspect2, size2);
          material2.uniformsNeedUpdate = true;
          renderer.renderBufferDirect(camera, null, geometry2, material2, mesh2, null);
        }
      }
    };
    this.dispose = function() {
      material1a.dispose();
      material1b.dispose();
      material2.dispose();
      tempMap.dispose();
      occlusionMap.dispose();
      for (let i3 = 0, l = elements.length; i3 < l; i3++) {
        elements[i3].texture.dispose();
      }
    };
  }
};
var Lensflare = _Lensflare;
__publicField5(Lensflare, "Geometry", geometry);
var LensflareElement = class {
  constructor(texture, size2 = 1, distance2 = 0, color = new Color(16777215)) {
    this.texture = texture;
    this.size = size2;
    this.distance = distance2;
    this.color = color;
  }
};
__publicField5(LensflareElement, "Shader", {
  uniforms: {
    map: { value: null },
    occlusionMap: { value: null },
    color: { value: null },
    scale: { value: null },
    screenPosition: { value: null }
  },
  vertexShader: (
    /* glsl */
    `

		precision highp float;

		uniform vec3 screenPosition;
		uniform vec2 scale;

		uniform sampler2D occlusionMap;

		attribute vec3 position;
		attribute vec2 uv;

		varying vec2 vUV;
		varying float vVisibility;

		void main() {

			vUV = uv;

			vec2 pos = position.xy;

			vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );
			visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );
			visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );
			visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );
			visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );
			visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );
			visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );
			visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );
			visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );

			vVisibility =        visibility.r / 9.0;
			vVisibility *= 1.0 - visibility.g / 9.0;
			vVisibility *=       visibility.b / 9.0;

			gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );

		}`
  ),
  fragmentShader: (
    /* glsl */
    `

		precision highp float;

		uniform sampler2D map;
		uniform vec3 color;

		varying vec2 vUV;
		varying float vVisibility;

		void main() {

			vec4 texture = texture2D( map, vUV );
			texture.a *= vVisibility;
			gl_FragColor = texture;
			gl_FragColor.rgb *= color;

		}`
  )
});

// node_modules/three-stdlib/objects/MarchingCubes.js
var edgeTable = new Int32Array([
  0,
  265,
  515,
  778,
  1030,
  1295,
  1541,
  1804,
  2060,
  2309,
  2575,
  2822,
  3082,
  3331,
  3593,
  3840,
  400,
  153,
  915,
  666,
  1430,
  1183,
  1941,
  1692,
  2460,
  2197,
  2975,
  2710,
  3482,
  3219,
  3993,
  3728,
  560,
  825,
  51,
  314,
  1590,
  1855,
  1077,
  1340,
  2620,
  2869,
  2111,
  2358,
  3642,
  3891,
  3129,
  3376,
  928,
  681,
  419,
  170,
  1958,
  1711,
  1445,
  1196,
  2988,
  2725,
  2479,
  2214,
  4010,
  3747,
  3497,
  3232,
  1120,
  1385,
  1635,
  1898,
  102,
  367,
  613,
  876,
  3180,
  3429,
  3695,
  3942,
  2154,
  2403,
  2665,
  2912,
  1520,
  1273,
  2035,
  1786,
  502,
  255,
  1013,
  764,
  3580,
  3317,
  4095,
  3830,
  2554,
  2291,
  3065,
  2800,
  1616,
  1881,
  1107,
  1370,
  598,
  863,
  85,
  348,
  3676,
  3925,
  3167,
  3414,
  2650,
  2899,
  2137,
  2384,
  1984,
  1737,
  1475,
  1226,
  966,
  719,
  453,
  204,
  4044,
  3781,
  3535,
  3270,
  3018,
  2755,
  2505,
  2240,
  2240,
  2505,
  2755,
  3018,
  3270,
  3535,
  3781,
  4044,
  204,
  453,
  719,
  966,
  1226,
  1475,
  1737,
  1984,
  2384,
  2137,
  2899,
  2650,
  3414,
  3167,
  3925,
  3676,
  348,
  85,
  863,
  598,
  1370,
  1107,
  1881,
  1616,
  2800,
  3065,
  2291,
  2554,
  3830,
  4095,
  3317,
  3580,
  764,
  1013,
  255,
  502,
  1786,
  2035,
  1273,
  1520,
  2912,
  2665,
  2403,
  2154,
  3942,
  3695,
  3429,
  3180,
  876,
  613,
  367,
  102,
  1898,
  1635,
  1385,
  1120,
  3232,
  3497,
  3747,
  4010,
  2214,
  2479,
  2725,
  2988,
  1196,
  1445,
  1711,
  1958,
  170,
  419,
  681,
  928,
  3376,
  3129,
  3891,
  3642,
  2358,
  2111,
  2869,
  2620,
  1340,
  1077,
  1855,
  1590,
  314,
  51,
  825,
  560,
  3728,
  3993,
  3219,
  3482,
  2710,
  2975,
  2197,
  2460,
  1692,
  1941,
  1183,
  1430,
  666,
  915,
  153,
  400,
  3840,
  3593,
  3331,
  3082,
  2822,
  2575,
  2309,
  2060,
  1804,
  1541,
  1295,
  1030,
  778,
  515,
  265,
  0
]);
var triTable = new Int32Array([
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  0,
  8,
  3,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  0,
  1,
  9,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1,
  8,
  3,
  9,
  8,
  1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1,
  2,
  10,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  0,
  8,
  3,
  1,
  2,
  10,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  9,
  2,
  10,
  0,
  2,
  9,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  2,
  8,
  3,
  2,
  10,
  8,
  10,
  9,
  8,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  3,
  11,
  2,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  0,
  11,
  2,
  8,
  11,
  0,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1,
  9,
  0,
  2,
  3,
  11,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1,
  11,
  2,
  1,
  9,
  11,
  9,
  8,
  11,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  3,
  10,
  1,
  11,
  10,
  3,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  0,
  10,
  1,
  0,
  8,
  10,
  8,
  11,
  10,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  3,
  9,
  0,
  3,
  11,
  9,
  11,
  10,
  9,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  9,
  8,
  10,
  10,
  8,
  11,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  4,
  7,
  8,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  4,
  3,
  0,
  7,
  3,
  4,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  0,
  1,
  9,
  8,
  4,
  7,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  4,
  1,
  9,
  4,
  7,
  1,
  7,
  3,
  1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1,
  2,
  10,
  8,
  4,
  7,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  3,
  4,
  7,
  3,
  0,
  4,
  1,
  2,
  10,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  9,
  2,
  10,
  9,
  0,
  2,
  8,
  4,
  7,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  2,
  10,
  9,
  2,
  9,
  7,
  2,
  7,
  3,
  7,
  9,
  4,
  -1,
  -1,
  -1,
  -1,
  8,
  4,
  7,
  3,
  11,
  2,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  11,
  4,
  7,
  11,
  2,
  4,
  2,
  0,
  4,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  9,
  0,
  1,
  8,
  4,
  7,
  2,
  3,
  11,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  4,
  7,
  11,
  9,
  4,
  11,
  9,
  11,
  2,
  9,
  2,
  1,
  -1,
  -1,
  -1,
  -1,
  3,
  10,
  1,
  3,
  11,
  10,
  7,
  8,
  4,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1,
  11,
  10,
  1,
  4,
  11,
  1,
  0,
  4,
  7,
  11,
  4,
  -1,
  -1,
  -1,
  -1,
  4,
  7,
  8,
  9,
  0,
  11,
  9,
  11,
  10,
  11,
  0,
  3,
  -1,
  -1,
  -1,
  -1,
  4,
  7,
  11,
  4,
  11,
  9,
  9,
  11,
  10,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  9,
  5,
  4,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  9,
  5,
  4,
  0,
  8,
  3,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  0,
  5,
  4,
  1,
  5,
  0,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  8,
  5,
  4,
  8,
  3,
  5,
  3,
  1,
  5,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1,
  2,
  10,
  9,
  5,
  4,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  3,
  0,
  8,
  1,
  2,
  10,
  4,
  9,
  5,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  5,
  2,
  10,
  5,
  4,
  2,
  4,
  0,
  2,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  2,
  10,
  5,
  3,
  2,
  5,
  3,
  5,
  4,
  3,
  4,
  8,
  -1,
  -1,
  -1,
  -1,
  9,
  5,
  4,
  2,
  3,
  11,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  0,
  11,
  2,
  0,
  8,
  11,
  4,
  9,
  5,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  0,
  5,
  4,
  0,
  1,
  5,
  2,
  3,
  11,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  2,
  1,
  5,
  2,
  5,
  8,
  2,
  8,
  11,
  4,
  8,
  5,
  -1,
  -1,
  -1,
  -1,
  10,
  3,
  11,
  10,
  1,
  3,
  9,
  5,
  4,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  4,
  9,
  5,
  0,
  8,
  1,
  8,
  10,
  1,
  8,
  11,
  10,
  -1,
  -1,
  -1,
  -1,
  5,
  4,
  0,
  5,
  0,
  11,
  5,
  11,
  10,
  11,
  0,
  3,
  -1,
  -1,
  -1,
  -1,
  5,
  4,
  8,
  5,
  8,
  10,
  10,
  8,
  11,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  9,
  7,
  8,
  5,
  7,
  9,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  9,
  3,
  0,
  9,
  5,
  3,
  5,
  7,
  3,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  0,
  7,
  8,
  0,
  1,
  7,
  1,
  5,
  7,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1,
  5,
  3,
  3,
  5,
  7,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  9,
  7,
  8,
  9,
  5,
  7,
  10,
  1,
  2,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  10,
  1,
  2,
  9,
  5,
  0,
  5,
  3,
  0,
  5,
  7,
  3,
  -1,
  -1,
  -1,
  -1,
  8,
  0,
  2,
  8,
  2,
  5,
  8,
  5,
  7,
  10,
  5,
  2,
  -1,
  -1,
  -1,
  -1,
  2,
  10,
  5,
  2,
  5,
  3,
  3,
  5,
  7,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  7,
  9,
  5,
  7,
  8,
  9,
  3,
  11,
  2,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  9,
  5,
  7,
  9,
  7,
  2,
  9,
  2,
  0,
  2,
  7,
  11,
  -1,
  -1,
  -1,
  -1,
  2,
  3,
  11,
  0,
  1,
  8,
  1,
  7,
  8,
  1,
  5,
  7,
  -1,
  -1,
  -1,
  -1,
  11,
  2,
  1,
  11,
  1,
  7,
  7,
  1,
  5,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  9,
  5,
  8,
  8,
  5,
  7,
  10,
  1,
  3,
  10,
  3,
  11,
  -1,
  -1,
  -1,
  -1,
  5,
  7,
  0,
  5,
  0,
  9,
  7,
  11,
  0,
  1,
  0,
  10,
  11,
  10,
  0,
  -1,
  11,
  10,
  0,
  11,
  0,
  3,
  10,
  5,
  0,
  8,
  0,
  7,
  5,
  7,
  0,
  -1,
  11,
  10,
  5,
  7,
  11,
  5,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  10,
  6,
  5,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  0,
  8,
  3,
  5,
  10,
  6,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  9,
  0,
  1,
  5,
  10,
  6,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1,
  8,
  3,
  1,
  9,
  8,
  5,
  10,
  6,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1,
  6,
  5,
  2,
  6,
  1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1,
  6,
  5,
  1,
  2,
  6,
  3,
  0,
  8,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  9,
  6,
  5,
  9,
  0,
  6,
  0,
  2,
  6,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  5,
  9,
  8,
  5,
  8,
  2,
  5,
  2,
  6,
  3,
  2,
  8,
  -1,
  -1,
  -1,
  -1,
  2,
  3,
  11,
  10,
  6,
  5,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  11,
  0,
  8,
  11,
  2,
  0,
  10,
  6,
  5,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  0,
  1,
  9,
  2,
  3,
  11,
  5,
  10,
  6,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  5,
  10,
  6,
  1,
  9,
  2,
  9,
  11,
  2,
  9,
  8,
  11,
  -1,
  -1,
  -1,
  -1,
  6,
  3,
  11,
  6,
  5,
  3,
  5,
  1,
  3,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  0,
  8,
  11,
  0,
  11,
  5,
  0,
  5,
  1,
  5,
  11,
  6,
  -1,
  -1,
  -1,
  -1,
  3,
  11,
  6,
  0,
  3,
  6,
  0,
  6,
  5,
  0,
  5,
  9,
  -1,
  -1,
  -1,
  -1,
  6,
  5,
  9,
  6,
  9,
  11,
  11,
  9,
  8,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  5,
  10,
  6,
  4,
  7,
  8,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  4,
  3,
  0,
  4,
  7,
  3,
  6,
  5,
  10,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1,
  9,
  0,
  5,
  10,
  6,
  8,
  4,
  7,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  10,
  6,
  5,
  1,
  9,
  7,
  1,
  7,
  3,
  7,
  9,
  4,
  -1,
  -1,
  -1,
  -1,
  6,
  1,
  2,
  6,
  5,
  1,
  4,
  7,
  8,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1,
  2,
  5,
  5,
  2,
  6,
  3,
  0,
  4,
  3,
  4,
  7,
  -1,
  -1,
  -1,
  -1,
  8,
  4,
  7,
  9,
  0,
  5,
  0,
  6,
  5,
  0,
  2,
  6,
  -1,
  -1,
  -1,
  -1,
  7,
  3,
  9,
  7,
  9,
  4,
  3,
  2,
  9,
  5,
  9,
  6,
  2,
  6,
  9,
  -1,
  3,
  11,
  2,
  7,
  8,
  4,
  10,
  6,
  5,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  5,
  10,
  6,
  4,
  7,
  2,
  4,
  2,
  0,
  2,
  7,
  11,
  -1,
  -1,
  -1,
  -1,
  0,
  1,
  9,
  4,
  7,
  8,
  2,
  3,
  11,
  5,
  10,
  6,
  -1,
  -1,
  -1,
  -1,
  9,
  2,
  1,
  9,
  11,
  2,
  9,
  4,
  11,
  7,
  11,
  4,
  5,
  10,
  6,
  -1,
  8,
  4,
  7,
  3,
  11,
  5,
  3,
  5,
  1,
  5,
  11,
  6,
  -1,
  -1,
  -1,
  -1,
  5,
  1,
  11,
  5,
  11,
  6,
  1,
  0,
  11,
  7,
  11,
  4,
  0,
  4,
  11,
  -1,
  0,
  5,
  9,
  0,
  6,
  5,
  0,
  3,
  6,
  11,
  6,
  3,
  8,
  4,
  7,
  -1,
  6,
  5,
  9,
  6,
  9,
  11,
  4,
  7,
  9,
  7,
  11,
  9,
  -1,
  -1,
  -1,
  -1,
  10,
  4,
  9,
  6,
  4,
  10,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  4,
  10,
  6,
  4,
  9,
  10,
  0,
  8,
  3,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  10,
  0,
  1,
  10,
  6,
  0,
  6,
  4,
  0,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  8,
  3,
  1,
  8,
  1,
  6,
  8,
  6,
  4,
  6,
  1,
  10,
  -1,
  -1,
  -1,
  -1,
  1,
  4,
  9,
  1,
  2,
  4,
  2,
  6,
  4,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  3,
  0,
  8,
  1,
  2,
  9,
  2,
  4,
  9,
  2,
  6,
  4,
  -1,
  -1,
  -1,
  -1,
  0,
  2,
  4,
  4,
  2,
  6,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  8,
  3,
  2,
  8,
  2,
  4,
  4,
  2,
  6,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  10,
  4,
  9,
  10,
  6,
  4,
  11,
  2,
  3,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  0,
  8,
  2,
  2,
  8,
  11,
  4,
  9,
  10,
  4,
  10,
  6,
  -1,
  -1,
  -1,
  -1,
  3,
  11,
  2,
  0,
  1,
  6,
  0,
  6,
  4,
  6,
  1,
  10,
  -1,
  -1,
  -1,
  -1,
  6,
  4,
  1,
  6,
  1,
  10,
  4,
  8,
  1,
  2,
  1,
  11,
  8,
  11,
  1,
  -1,
  9,
  6,
  4,
  9,
  3,
  6,
  9,
  1,
  3,
  11,
  6,
  3,
  -1,
  -1,
  -1,
  -1,
  8,
  11,
  1,
  8,
  1,
  0,
  11,
  6,
  1,
  9,
  1,
  4,
  6,
  4,
  1,
  -1,
  3,
  11,
  6,
  3,
  6,
  0,
  0,
  6,
  4,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  6,
  4,
  8,
  11,
  6,
  8,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  7,
  10,
  6,
  7,
  8,
  10,
  8,
  9,
  10,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  0,
  7,
  3,
  0,
  10,
  7,
  0,
  9,
  10,
  6,
  7,
  10,
  -1,
  -1,
  -1,
  -1,
  10,
  6,
  7,
  1,
  10,
  7,
  1,
  7,
  8,
  1,
  8,
  0,
  -1,
  -1,
  -1,
  -1,
  10,
  6,
  7,
  10,
  7,
  1,
  1,
  7,
  3,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1,
  2,
  6,
  1,
  6,
  8,
  1,
  8,
  9,
  8,
  6,
  7,
  -1,
  -1,
  -1,
  -1,
  2,
  6,
  9,
  2,
  9,
  1,
  6,
  7,
  9,
  0,
  9,
  3,
  7,
  3,
  9,
  -1,
  7,
  8,
  0,
  7,
  0,
  6,
  6,
  0,
  2,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  7,
  3,
  2,
  6,
  7,
  2,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  2,
  3,
  11,
  10,
  6,
  8,
  10,
  8,
  9,
  8,
  6,
  7,
  -1,
  -1,
  -1,
  -1,
  2,
  0,
  7,
  2,
  7,
  11,
  0,
  9,
  7,
  6,
  7,
  10,
  9,
  10,
  7,
  -1,
  1,
  8,
  0,
  1,
  7,
  8,
  1,
  10,
  7,
  6,
  7,
  10,
  2,
  3,
  11,
  -1,
  11,
  2,
  1,
  11,
  1,
  7,
  10,
  6,
  1,
  6,
  7,
  1,
  -1,
  -1,
  -1,
  -1,
  8,
  9,
  6,
  8,
  6,
  7,
  9,
  1,
  6,
  11,
  6,
  3,
  1,
  3,
  6,
  -1,
  0,
  9,
  1,
  11,
  6,
  7,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  7,
  8,
  0,
  7,
  0,
  6,
  3,
  11,
  0,
  11,
  6,
  0,
  -1,
  -1,
  -1,
  -1,
  7,
  11,
  6,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  7,
  6,
  11,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  3,
  0,
  8,
  11,
  7,
  6,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  0,
  1,
  9,
  11,
  7,
  6,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  8,
  1,
  9,
  8,
  3,
  1,
  11,
  7,
  6,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  10,
  1,
  2,
  6,
  11,
  7,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1,
  2,
  10,
  3,
  0,
  8,
  6,
  11,
  7,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  2,
  9,
  0,
  2,
  10,
  9,
  6,
  11,
  7,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  6,
  11,
  7,
  2,
  10,
  3,
  10,
  8,
  3,
  10,
  9,
  8,
  -1,
  -1,
  -1,
  -1,
  7,
  2,
  3,
  6,
  2,
  7,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  7,
  0,
  8,
  7,
  6,
  0,
  6,
  2,
  0,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  2,
  7,
  6,
  2,
  3,
  7,
  0,
  1,
  9,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1,
  6,
  2,
  1,
  8,
  6,
  1,
  9,
  8,
  8,
  7,
  6,
  -1,
  -1,
  -1,
  -1,
  10,
  7,
  6,
  10,
  1,
  7,
  1,
  3,
  7,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  10,
  7,
  6,
  1,
  7,
  10,
  1,
  8,
  7,
  1,
  0,
  8,
  -1,
  -1,
  -1,
  -1,
  0,
  3,
  7,
  0,
  7,
  10,
  0,
  10,
  9,
  6,
  10,
  7,
  -1,
  -1,
  -1,
  -1,
  7,
  6,
  10,
  7,
  10,
  8,
  8,
  10,
  9,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  6,
  8,
  4,
  11,
  8,
  6,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  3,
  6,
  11,
  3,
  0,
  6,
  0,
  4,
  6,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  8,
  6,
  11,
  8,
  4,
  6,
  9,
  0,
  1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  9,
  4,
  6,
  9,
  6,
  3,
  9,
  3,
  1,
  11,
  3,
  6,
  -1,
  -1,
  -1,
  -1,
  6,
  8,
  4,
  6,
  11,
  8,
  2,
  10,
  1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1,
  2,
  10,
  3,
  0,
  11,
  0,
  6,
  11,
  0,
  4,
  6,
  -1,
  -1,
  -1,
  -1,
  4,
  11,
  8,
  4,
  6,
  11,
  0,
  2,
  9,
  2,
  10,
  9,
  -1,
  -1,
  -1,
  -1,
  10,
  9,
  3,
  10,
  3,
  2,
  9,
  4,
  3,
  11,
  3,
  6,
  4,
  6,
  3,
  -1,
  8,
  2,
  3,
  8,
  4,
  2,
  4,
  6,
  2,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  0,
  4,
  2,
  4,
  6,
  2,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1,
  9,
  0,
  2,
  3,
  4,
  2,
  4,
  6,
  4,
  3,
  8,
  -1,
  -1,
  -1,
  -1,
  1,
  9,
  4,
  1,
  4,
  2,
  2,
  4,
  6,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  8,
  1,
  3,
  8,
  6,
  1,
  8,
  4,
  6,
  6,
  10,
  1,
  -1,
  -1,
  -1,
  -1,
  10,
  1,
  0,
  10,
  0,
  6,
  6,
  0,
  4,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  4,
  6,
  3,
  4,
  3,
  8,
  6,
  10,
  3,
  0,
  3,
  9,
  10,
  9,
  3,
  -1,
  10,
  9,
  4,
  6,
  10,
  4,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  4,
  9,
  5,
  7,
  6,
  11,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  0,
  8,
  3,
  4,
  9,
  5,
  11,
  7,
  6,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  5,
  0,
  1,
  5,
  4,
  0,
  7,
  6,
  11,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  11,
  7,
  6,
  8,
  3,
  4,
  3,
  5,
  4,
  3,
  1,
  5,
  -1,
  -1,
  -1,
  -1,
  9,
  5,
  4,
  10,
  1,
  2,
  7,
  6,
  11,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  6,
  11,
  7,
  1,
  2,
  10,
  0,
  8,
  3,
  4,
  9,
  5,
  -1,
  -1,
  -1,
  -1,
  7,
  6,
  11,
  5,
  4,
  10,
  4,
  2,
  10,
  4,
  0,
  2,
  -1,
  -1,
  -1,
  -1,
  3,
  4,
  8,
  3,
  5,
  4,
  3,
  2,
  5,
  10,
  5,
  2,
  11,
  7,
  6,
  -1,
  7,
  2,
  3,
  7,
  6,
  2,
  5,
  4,
  9,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  9,
  5,
  4,
  0,
  8,
  6,
  0,
  6,
  2,
  6,
  8,
  7,
  -1,
  -1,
  -1,
  -1,
  3,
  6,
  2,
  3,
  7,
  6,
  1,
  5,
  0,
  5,
  4,
  0,
  -1,
  -1,
  -1,
  -1,
  6,
  2,
  8,
  6,
  8,
  7,
  2,
  1,
  8,
  4,
  8,
  5,
  1,
  5,
  8,
  -1,
  9,
  5,
  4,
  10,
  1,
  6,
  1,
  7,
  6,
  1,
  3,
  7,
  -1,
  -1,
  -1,
  -1,
  1,
  6,
  10,
  1,
  7,
  6,
  1,
  0,
  7,
  8,
  7,
  0,
  9,
  5,
  4,
  -1,
  4,
  0,
  10,
  4,
  10,
  5,
  0,
  3,
  10,
  6,
  10,
  7,
  3,
  7,
  10,
  -1,
  7,
  6,
  10,
  7,
  10,
  8,
  5,
  4,
  10,
  4,
  8,
  10,
  -1,
  -1,
  -1,
  -1,
  6,
  9,
  5,
  6,
  11,
  9,
  11,
  8,
  9,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  3,
  6,
  11,
  0,
  6,
  3,
  0,
  5,
  6,
  0,
  9,
  5,
  -1,
  -1,
  -1,
  -1,
  0,
  11,
  8,
  0,
  5,
  11,
  0,
  1,
  5,
  5,
  6,
  11,
  -1,
  -1,
  -1,
  -1,
  6,
  11,
  3,
  6,
  3,
  5,
  5,
  3,
  1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1,
  2,
  10,
  9,
  5,
  11,
  9,
  11,
  8,
  11,
  5,
  6,
  -1,
  -1,
  -1,
  -1,
  0,
  11,
  3,
  0,
  6,
  11,
  0,
  9,
  6,
  5,
  6,
  9,
  1,
  2,
  10,
  -1,
  11,
  8,
  5,
  11,
  5,
  6,
  8,
  0,
  5,
  10,
  5,
  2,
  0,
  2,
  5,
  -1,
  6,
  11,
  3,
  6,
  3,
  5,
  2,
  10,
  3,
  10,
  5,
  3,
  -1,
  -1,
  -1,
  -1,
  5,
  8,
  9,
  5,
  2,
  8,
  5,
  6,
  2,
  3,
  8,
  2,
  -1,
  -1,
  -1,
  -1,
  9,
  5,
  6,
  9,
  6,
  0,
  0,
  6,
  2,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1,
  5,
  8,
  1,
  8,
  0,
  5,
  6,
  8,
  3,
  8,
  2,
  6,
  2,
  8,
  -1,
  1,
  5,
  6,
  2,
  1,
  6,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1,
  3,
  6,
  1,
  6,
  10,
  3,
  8,
  6,
  5,
  6,
  9,
  8,
  9,
  6,
  -1,
  10,
  1,
  0,
  10,
  0,
  6,
  9,
  5,
  0,
  5,
  6,
  0,
  -1,
  -1,
  -1,
  -1,
  0,
  3,
  8,
  5,
  6,
  10,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  10,
  5,
  6,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  11,
  5,
  10,
  7,
  5,
  11,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  11,
  5,
  10,
  11,
  7,
  5,
  8,
  3,
  0,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  5,
  11,
  7,
  5,
  10,
  11,
  1,
  9,
  0,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  10,
  7,
  5,
  10,
  11,
  7,
  9,
  8,
  1,
  8,
  3,
  1,
  -1,
  -1,
  -1,
  -1,
  11,
  1,
  2,
  11,
  7,
  1,
  7,
  5,
  1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  0,
  8,
  3,
  1,
  2,
  7,
  1,
  7,
  5,
  7,
  2,
  11,
  -1,
  -1,
  -1,
  -1,
  9,
  7,
  5,
  9,
  2,
  7,
  9,
  0,
  2,
  2,
  11,
  7,
  -1,
  -1,
  -1,
  -1,
  7,
  5,
  2,
  7,
  2,
  11,
  5,
  9,
  2,
  3,
  2,
  8,
  9,
  8,
  2,
  -1,
  2,
  5,
  10,
  2,
  3,
  5,
  3,
  7,
  5,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  8,
  2,
  0,
  8,
  5,
  2,
  8,
  7,
  5,
  10,
  2,
  5,
  -1,
  -1,
  -1,
  -1,
  9,
  0,
  1,
  5,
  10,
  3,
  5,
  3,
  7,
  3,
  10,
  2,
  -1,
  -1,
  -1,
  -1,
  9,
  8,
  2,
  9,
  2,
  1,
  8,
  7,
  2,
  10,
  2,
  5,
  7,
  5,
  2,
  -1,
  1,
  3,
  5,
  3,
  7,
  5,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  0,
  8,
  7,
  0,
  7,
  1,
  1,
  7,
  5,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  9,
  0,
  3,
  9,
  3,
  5,
  5,
  3,
  7,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  9,
  8,
  7,
  5,
  9,
  7,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  5,
  8,
  4,
  5,
  10,
  8,
  10,
  11,
  8,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  5,
  0,
  4,
  5,
  11,
  0,
  5,
  10,
  11,
  11,
  3,
  0,
  -1,
  -1,
  -1,
  -1,
  0,
  1,
  9,
  8,
  4,
  10,
  8,
  10,
  11,
  10,
  4,
  5,
  -1,
  -1,
  -1,
  -1,
  10,
  11,
  4,
  10,
  4,
  5,
  11,
  3,
  4,
  9,
  4,
  1,
  3,
  1,
  4,
  -1,
  2,
  5,
  1,
  2,
  8,
  5,
  2,
  11,
  8,
  4,
  5,
  8,
  -1,
  -1,
  -1,
  -1,
  0,
  4,
  11,
  0,
  11,
  3,
  4,
  5,
  11,
  2,
  11,
  1,
  5,
  1,
  11,
  -1,
  0,
  2,
  5,
  0,
  5,
  9,
  2,
  11,
  5,
  4,
  5,
  8,
  11,
  8,
  5,
  -1,
  9,
  4,
  5,
  2,
  11,
  3,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  2,
  5,
  10,
  3,
  5,
  2,
  3,
  4,
  5,
  3,
  8,
  4,
  -1,
  -1,
  -1,
  -1,
  5,
  10,
  2,
  5,
  2,
  4,
  4,
  2,
  0,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  3,
  10,
  2,
  3,
  5,
  10,
  3,
  8,
  5,
  4,
  5,
  8,
  0,
  1,
  9,
  -1,
  5,
  10,
  2,
  5,
  2,
  4,
  1,
  9,
  2,
  9,
  4,
  2,
  -1,
  -1,
  -1,
  -1,
  8,
  4,
  5,
  8,
  5,
  3,
  3,
  5,
  1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  0,
  4,
  5,
  1,
  0,
  5,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  8,
  4,
  5,
  8,
  5,
  3,
  9,
  0,
  5,
  0,
  3,
  5,
  -1,
  -1,
  -1,
  -1,
  9,
  4,
  5,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  4,
  11,
  7,
  4,
  9,
  11,
  9,
  10,
  11,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  0,
  8,
  3,
  4,
  9,
  7,
  9,
  11,
  7,
  9,
  10,
  11,
  -1,
  -1,
  -1,
  -1,
  1,
  10,
  11,
  1,
  11,
  4,
  1,
  4,
  0,
  7,
  4,
  11,
  -1,
  -1,
  -1,
  -1,
  3,
  1,
  4,
  3,
  4,
  8,
  1,
  10,
  4,
  7,
  4,
  11,
  10,
  11,
  4,
  -1,
  4,
  11,
  7,
  9,
  11,
  4,
  9,
  2,
  11,
  9,
  1,
  2,
  -1,
  -1,
  -1,
  -1,
  9,
  7,
  4,
  9,
  11,
  7,
  9,
  1,
  11,
  2,
  11,
  1,
  0,
  8,
  3,
  -1,
  11,
  7,
  4,
  11,
  4,
  2,
  2,
  4,
  0,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  11,
  7,
  4,
  11,
  4,
  2,
  8,
  3,
  4,
  3,
  2,
  4,
  -1,
  -1,
  -1,
  -1,
  2,
  9,
  10,
  2,
  7,
  9,
  2,
  3,
  7,
  7,
  4,
  9,
  -1,
  -1,
  -1,
  -1,
  9,
  10,
  7,
  9,
  7,
  4,
  10,
  2,
  7,
  8,
  7,
  0,
  2,
  0,
  7,
  -1,
  3,
  7,
  10,
  3,
  10,
  2,
  7,
  4,
  10,
  1,
  10,
  0,
  4,
  0,
  10,
  -1,
  1,
  10,
  2,
  8,
  7,
  4,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  4,
  9,
  1,
  4,
  1,
  7,
  7,
  1,
  3,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  4,
  9,
  1,
  4,
  1,
  7,
  0,
  8,
  1,
  8,
  7,
  1,
  -1,
  -1,
  -1,
  -1,
  4,
  0,
  3,
  7,
  4,
  3,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  4,
  8,
  7,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  9,
  10,
  8,
  10,
  11,
  8,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  3,
  0,
  9,
  3,
  9,
  11,
  11,
  9,
  10,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  0,
  1,
  10,
  0,
  10,
  8,
  8,
  10,
  11,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  3,
  1,
  10,
  11,
  3,
  10,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1,
  2,
  11,
  1,
  11,
  9,
  9,
  11,
  8,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  3,
  0,
  9,
  3,
  9,
  11,
  1,
  2,
  9,
  2,
  11,
  9,
  -1,
  -1,
  -1,
  -1,
  0,
  2,
  11,
  8,
  0,
  11,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  3,
  2,
  11,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  2,
  3,
  8,
  2,
  8,
  10,
  10,
  8,
  9,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  9,
  10,
  2,
  0,
  9,
  2,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  2,
  3,
  8,
  2,
  8,
  10,
  0,
  1,
  8,
  1,
  10,
  8,
  -1,
  -1,
  -1,
  -1,
  1,
  10,
  2,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1,
  3,
  8,
  9,
  1,
  8,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  0,
  9,
  1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  0,
  3,
  8,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1
]);

// node_modules/three-stdlib/math/SimplexNoise.js
var __defProp5 = Object.defineProperty;
var __defNormalProp5 = (obj, key, value) => key in obj ? __defProp5(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField6 = (obj, key, value) => {
  __defNormalProp5(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var SimplexNoise = class {
  /**
   * You can pass in a random number generator object if you like.
   * It is assumed to have a random() method.
   */
  constructor(r = Math) {
    __publicField6(this, "grad3", [
      [1, 1, 0],
      [-1, 1, 0],
      [1, -1, 0],
      [-1, -1, 0],
      [1, 0, 1],
      [-1, 0, 1],
      [1, 0, -1],
      [-1, 0, -1],
      [0, 1, 1],
      [0, -1, 1],
      [0, 1, -1],
      [0, -1, -1]
    ]);
    __publicField6(this, "grad4", [
      [0, 1, 1, 1],
      [0, 1, 1, -1],
      [0, 1, -1, 1],
      [0, 1, -1, -1],
      [0, -1, 1, 1],
      [0, -1, 1, -1],
      [0, -1, -1, 1],
      [0, -1, -1, -1],
      [1, 0, 1, 1],
      [1, 0, 1, -1],
      [1, 0, -1, 1],
      [1, 0, -1, -1],
      [-1, 0, 1, 1],
      [-1, 0, 1, -1],
      [-1, 0, -1, 1],
      [-1, 0, -1, -1],
      [1, 1, 0, 1],
      [1, 1, 0, -1],
      [1, -1, 0, 1],
      [1, -1, 0, -1],
      [-1, 1, 0, 1],
      [-1, 1, 0, -1],
      [-1, -1, 0, 1],
      [-1, -1, 0, -1],
      [1, 1, 1, 0],
      [1, 1, -1, 0],
      [1, -1, 1, 0],
      [1, -1, -1, 0],
      [-1, 1, 1, 0],
      [-1, 1, -1, 0],
      [-1, -1, 1, 0],
      [-1, -1, -1, 0]
    ]);
    __publicField6(this, "p", []);
    __publicField6(this, "perm", []);
    __publicField6(this, "simplex", [
      [0, 1, 2, 3],
      [0, 1, 3, 2],
      [0, 0, 0, 0],
      [0, 2, 3, 1],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [1, 2, 3, 0],
      [0, 2, 1, 3],
      [0, 0, 0, 0],
      [0, 3, 1, 2],
      [0, 3, 2, 1],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [1, 3, 2, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [1, 2, 0, 3],
      [0, 0, 0, 0],
      [1, 3, 0, 2],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [2, 3, 0, 1],
      [2, 3, 1, 0],
      [1, 0, 2, 3],
      [1, 0, 3, 2],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [2, 0, 3, 1],
      [0, 0, 0, 0],
      [2, 1, 3, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [2, 0, 1, 3],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [3, 0, 1, 2],
      [3, 0, 2, 1],
      [0, 0, 0, 0],
      [3, 1, 2, 0],
      [2, 1, 0, 3],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [3, 1, 0, 2],
      [0, 0, 0, 0],
      [3, 2, 0, 1],
      [3, 2, 1, 0]
    ]);
    __publicField6(this, "dot", (g2, x, y) => {
      return g2[0] * x + g2[1] * y;
    });
    __publicField6(this, "dot3", (g2, x, y, z) => {
      return g2[0] * x + g2[1] * y + g2[2] * z;
    });
    __publicField6(this, "dot4", (g2, x, y, z, w) => {
      return g2[0] * x + g2[1] * y + g2[2] * z + g2[3] * w;
    });
    __publicField6(this, "noise", (xin, yin) => {
      let n0;
      let n1;
      let n2;
      const F22 = 0.5 * (Math.sqrt(3) - 1);
      const s = (xin + yin) * F22;
      const i3 = Math.floor(xin + s);
      const j = Math.floor(yin + s);
      const G22 = (3 - Math.sqrt(3)) / 6;
      const t2 = (i3 + j) * G22;
      const X0 = i3 - t2;
      const Y0 = j - t2;
      const x0 = xin - X0;
      const y0 = yin - Y0;
      let i1 = 0;
      let j1 = 1;
      if (x0 > y0) {
        i1 = 1;
        j1 = 0;
      }
      const x1 = x0 - i1 + G22;
      const y1 = y0 - j1 + G22;
      const x2 = x0 - 1 + 2 * G22;
      const y2 = y0 - 1 + 2 * G22;
      const ii = i3 & 255;
      const jj = j & 255;
      const gi0 = this.perm[ii + this.perm[jj]] % 12;
      const gi1 = this.perm[ii + i1 + this.perm[jj + j1]] % 12;
      const gi2 = this.perm[ii + 1 + this.perm[jj + 1]] % 12;
      let t0 = 0.5 - x0 * x0 - y0 * y0;
      if (t0 < 0) {
        n0 = 0;
      } else {
        t0 *= t0;
        n0 = t0 * t0 * this.dot(this.grad3[gi0], x0, y0);
      }
      let t1 = 0.5 - x1 * x1 - y1 * y1;
      if (t1 < 0) {
        n1 = 0;
      } else {
        t1 *= t1;
        n1 = t1 * t1 * this.dot(this.grad3[gi1], x1, y1);
      }
      let t22 = 0.5 - x2 * x2 - y2 * y2;
      if (t22 < 0) {
        n2 = 0;
      } else {
        t22 *= t22;
        n2 = t22 * t22 * this.dot(this.grad3[gi2], x2, y2);
      }
      return 70 * (n0 + n1 + n2);
    });
    __publicField6(this, "noise3d", (xin, yin, zin) => {
      let n0;
      let n1;
      let n2;
      let n3;
      const F32 = 1 / 3;
      const s = (xin + yin + zin) * F32;
      const i3 = Math.floor(xin + s);
      const j = Math.floor(yin + s);
      const k = Math.floor(zin + s);
      const G32 = 1 / 6;
      const t2 = (i3 + j + k) * G32;
      const X0 = i3 - t2;
      const Y0 = j - t2;
      const Z0 = k - t2;
      const x0 = xin - X0;
      const y0 = yin - Y0;
      const z0 = zin - Z0;
      let i1;
      let j1;
      let k1;
      let i22;
      let j2;
      let k2;
      if (x0 >= y0) {
        if (y0 >= z0) {
          i1 = 1;
          j1 = 0;
          k1 = 0;
          i22 = 1;
          j2 = 1;
          k2 = 0;
        } else if (x0 >= z0) {
          i1 = 1;
          j1 = 0;
          k1 = 0;
          i22 = 1;
          j2 = 0;
          k2 = 1;
        } else {
          i1 = 0;
          j1 = 0;
          k1 = 1;
          i22 = 1;
          j2 = 0;
          k2 = 1;
        }
      } else {
        if (y0 < z0) {
          i1 = 0;
          j1 = 0;
          k1 = 1;
          i22 = 0;
          j2 = 1;
          k2 = 1;
        } else if (x0 < z0) {
          i1 = 0;
          j1 = 1;
          k1 = 0;
          i22 = 0;
          j2 = 1;
          k2 = 1;
        } else {
          i1 = 0;
          j1 = 1;
          k1 = 0;
          i22 = 1;
          j2 = 1;
          k2 = 0;
        }
      }
      const x1 = x0 - i1 + G32;
      const y1 = y0 - j1 + G32;
      const z1 = z0 - k1 + G32;
      const x2 = x0 - i22 + 2 * G32;
      const y2 = y0 - j2 + 2 * G32;
      const z2 = z0 - k2 + 2 * G32;
      const x3 = x0 - 1 + 3 * G32;
      const y3 = y0 - 1 + 3 * G32;
      const z3 = z0 - 1 + 3 * G32;
      const ii = i3 & 255;
      const jj = j & 255;
      const kk = k & 255;
      const gi0 = this.perm[ii + this.perm[jj + this.perm[kk]]] % 12;
      const gi1 = this.perm[ii + i1 + this.perm[jj + j1 + this.perm[kk + k1]]] % 12;
      const gi2 = this.perm[ii + i22 + this.perm[jj + j2 + this.perm[kk + k2]]] % 12;
      const gi3 = this.perm[ii + 1 + this.perm[jj + 1 + this.perm[kk + 1]]] % 12;
      let t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0;
      if (t0 < 0) {
        n0 = 0;
      } else {
        t0 *= t0;
        n0 = t0 * t0 * this.dot3(this.grad3[gi0], x0, y0, z0);
      }
      let t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1;
      if (t1 < 0) {
        n1 = 0;
      } else {
        t1 *= t1;
        n1 = t1 * t1 * this.dot3(this.grad3[gi1], x1, y1, z1);
      }
      let t22 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2;
      if (t22 < 0) {
        n2 = 0;
      } else {
        t22 *= t22;
        n2 = t22 * t22 * this.dot3(this.grad3[gi2], x2, y2, z2);
      }
      let t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3;
      if (t3 < 0) {
        n3 = 0;
      } else {
        t3 *= t3;
        n3 = t3 * t3 * this.dot3(this.grad3[gi3], x3, y3, z3);
      }
      return 32 * (n0 + n1 + n2 + n3);
    });
    __publicField6(this, "noise4d", (x, y, z, w) => {
      const grad42 = this.grad4;
      const simplex = this.simplex;
      const perm = this.perm;
      const F42 = (Math.sqrt(5) - 1) / 4;
      const G42 = (5 - Math.sqrt(5)) / 20;
      let n0;
      let n1;
      let n2;
      let n3;
      let n4;
      const s = (x + y + z + w) * F42;
      const i3 = Math.floor(x + s);
      const j = Math.floor(y + s);
      const k = Math.floor(z + s);
      const l = Math.floor(w + s);
      const t2 = (i3 + j + k + l) * G42;
      const X0 = i3 - t2;
      const Y0 = j - t2;
      const Z0 = k - t2;
      const W0 = l - t2;
      const x0 = x - X0;
      const y0 = y - Y0;
      const z0 = z - Z0;
      const w0 = w - W0;
      const c1 = x0 > y0 ? 32 : 0;
      const c22 = x0 > z0 ? 16 : 0;
      const c3 = y0 > z0 ? 8 : 0;
      const c4 = x0 > w0 ? 4 : 0;
      const c5 = y0 > w0 ? 2 : 0;
      const c6 = z0 > w0 ? 1 : 0;
      const c7 = c1 + c22 + c3 + c4 + c5 + c6;
      let i1;
      let j1;
      let k1;
      let l1;
      let i22;
      let j2;
      let k2;
      let l2;
      let i32;
      let j3;
      let k3;
      let l3;
      i1 = simplex[c7][0] >= 3 ? 1 : 0;
      j1 = simplex[c7][1] >= 3 ? 1 : 0;
      k1 = simplex[c7][2] >= 3 ? 1 : 0;
      l1 = simplex[c7][3] >= 3 ? 1 : 0;
      i22 = simplex[c7][0] >= 2 ? 1 : 0;
      j2 = simplex[c7][1] >= 2 ? 1 : 0;
      k2 = simplex[c7][2] >= 2 ? 1 : 0;
      l2 = simplex[c7][3] >= 2 ? 1 : 0;
      i32 = simplex[c7][0] >= 1 ? 1 : 0;
      j3 = simplex[c7][1] >= 1 ? 1 : 0;
      k3 = simplex[c7][2] >= 1 ? 1 : 0;
      l3 = simplex[c7][3] >= 1 ? 1 : 0;
      const x1 = x0 - i1 + G42;
      const y1 = y0 - j1 + G42;
      const z1 = z0 - k1 + G42;
      const w1 = w0 - l1 + G42;
      const x2 = x0 - i22 + 2 * G42;
      const y2 = y0 - j2 + 2 * G42;
      const z2 = z0 - k2 + 2 * G42;
      const w2 = w0 - l2 + 2 * G42;
      const x3 = x0 - i32 + 3 * G42;
      const y3 = y0 - j3 + 3 * G42;
      const z3 = z0 - k3 + 3 * G42;
      const w3 = w0 - l3 + 3 * G42;
      const x4 = x0 - 1 + 4 * G42;
      const y4 = y0 - 1 + 4 * G42;
      const z4 = z0 - 1 + 4 * G42;
      const w4 = w0 - 1 + 4 * G42;
      const ii = i3 & 255;
      const jj = j & 255;
      const kk = k & 255;
      const ll = l & 255;
      const gi0 = perm[ii + perm[jj + perm[kk + perm[ll]]]] % 32;
      const gi1 = perm[ii + i1 + perm[jj + j1 + perm[kk + k1 + perm[ll + l1]]]] % 32;
      const gi2 = perm[ii + i22 + perm[jj + j2 + perm[kk + k2 + perm[ll + l2]]]] % 32;
      const gi3 = perm[ii + i32 + perm[jj + j3 + perm[kk + k3 + perm[ll + l3]]]] % 32;
      const gi4 = perm[ii + 1 + perm[jj + 1 + perm[kk + 1 + perm[ll + 1]]]] % 32;
      let t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0 - w0 * w0;
      if (t0 < 0) {
        n0 = 0;
      } else {
        t0 *= t0;
        n0 = t0 * t0 * this.dot4(grad42[gi0], x0, y0, z0, w0);
      }
      let t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1 - w1 * w1;
      if (t1 < 0) {
        n1 = 0;
      } else {
        t1 *= t1;
        n1 = t1 * t1 * this.dot4(grad42[gi1], x1, y1, z1, w1);
      }
      let t22 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2 - w2 * w2;
      if (t22 < 0) {
        n2 = 0;
      } else {
        t22 *= t22;
        n2 = t22 * t22 * this.dot4(grad42[gi2], x2, y2, z2, w2);
      }
      let t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3 - w3 * w3;
      if (t3 < 0) {
        n3 = 0;
      } else {
        t3 *= t3;
        n3 = t3 * t3 * this.dot4(grad42[gi3], x3, y3, z3, w3);
      }
      let t4 = 0.6 - x4 * x4 - y4 * y4 - z4 * z4 - w4 * w4;
      if (t4 < 0) {
        n4 = 0;
      } else {
        t4 *= t4;
        n4 = t4 * t4 * this.dot4(grad42[gi4], x4, y4, z4, w4);
      }
      return 27 * (n0 + n1 + n2 + n3 + n4);
    });
    for (let i3 = 0; i3 < 256; i3++) {
      this.p[i3] = Math.floor(r.random() * 256);
    }
    for (let i3 = 0; i3 < 512; i3++) {
      this.perm[i3] = this.p[i3 & 255];
    }
  }
};

// node_modules/three-stdlib/geometries/LightningStrike.js
var __defProp6 = Object.defineProperty;
var __defNormalProp6 = (obj, key, value) => key in obj ? __defProp6(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField7 = (obj, key, value) => {
  __defNormalProp6(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var _LightningStrike = class extends BufferGeometry {
  constructor(rayParameters = {}) {
    super();
    this.isLightningStrike = true;
    this.type = "LightningStrike";
    this.init(_LightningStrike.copyParameters(rayParameters, rayParameters));
    this.createMesh();
  }
  static createRandomGenerator() {
    const numSeeds = 2053;
    const seeds = [];
    for (let i3 = 0; i3 < numSeeds; i3++) {
      seeds.push(Math.random());
    }
    const generator = {
      currentSeed: 0,
      random: function() {
        const value = seeds[generator.currentSeed];
        generator.currentSeed = (generator.currentSeed + 1) % numSeeds;
        return value;
      },
      getSeed: function() {
        return generator.currentSeed / numSeeds;
      },
      setSeed: function(seed) {
        generator.currentSeed = Math.floor(seed * numSeeds) % numSeeds;
      }
    };
    return generator;
  }
  static copyParameters(dest = {}, source = {}) {
    const vecCopy = function(v) {
      if (source === dest) {
        return v;
      } else {
        return v.clone();
      }
    };
    dest.sourceOffset = source.sourceOffset !== void 0 ? vecCopy(source.sourceOffset) : new Vector3(0, 100, 0), dest.destOffset = source.destOffset !== void 0 ? vecCopy(source.destOffset) : new Vector3(0, 0, 0), dest.timeScale = source.timeScale !== void 0 ? source.timeScale : 1, dest.roughness = source.roughness !== void 0 ? source.roughness : 0.9, dest.straightness = source.straightness !== void 0 ? source.straightness : 0.7, dest.up0 = source.up0 !== void 0 ? vecCopy(source.up0) : new Vector3(0, 0, 1);
    dest.up1 = source.up1 !== void 0 ? vecCopy(source.up1) : new Vector3(0, 0, 1), dest.radius0 = source.radius0 !== void 0 ? source.radius0 : 1, dest.radius1 = source.radius1 !== void 0 ? source.radius1 : 1, dest.radius0Factor = source.radius0Factor !== void 0 ? source.radius0Factor : 0.5, dest.radius1Factor = source.radius1Factor !== void 0 ? source.radius1Factor : 0.2, dest.minRadius = source.minRadius !== void 0 ? source.minRadius : 0.2, // These parameters should not be changed after lightning creation. They can be changed but the ray will change its form abruptly:
    dest.isEternal = source.isEternal !== void 0 ? source.isEternal : source.birthTime === void 0 || source.deathTime === void 0, dest.birthTime = source.birthTime, dest.deathTime = source.deathTime, dest.propagationTimeFactor = source.propagationTimeFactor !== void 0 ? source.propagationTimeFactor : 0.1, dest.vanishingTimeFactor = source.vanishingTimeFactor !== void 0 ? source.vanishingTimeFactor : 0.9, dest.subrayPeriod = source.subrayPeriod !== void 0 ? source.subrayPeriod : 4, dest.subrayDutyCycle = source.subrayDutyCycle !== void 0 ? source.subrayDutyCycle : 0.6;
    dest.maxIterations = source.maxIterations !== void 0 ? source.maxIterations : 9;
    dest.isStatic = source.isStatic !== void 0 ? source.isStatic : false;
    dest.ramification = source.ramification !== void 0 ? source.ramification : 5;
    dest.maxSubrayRecursion = source.maxSubrayRecursion !== void 0 ? source.maxSubrayRecursion : 3;
    dest.recursionProbability = source.recursionProbability !== void 0 ? source.recursionProbability : 0.6;
    dest.generateUVs = source.generateUVs !== void 0 ? source.generateUVs : false;
    dest.randomGenerator = source.randomGenerator, dest.noiseSeed = source.noiseSeed, dest.onDecideSubrayCreation = source.onDecideSubrayCreation, dest.onSubrayCreation = source.onSubrayCreation;
    return dest;
  }
  update(time) {
    if (this.isStatic)
      return;
    if (this.rayParameters.isEternal || this.rayParameters.birthTime <= time && time <= this.rayParameters.deathTime) {
      this.updateMesh(time);
      if (time < this.subrays[0].endPropagationTime) {
        this.state = _LightningStrike.RAY_PROPAGATING;
      } else if (time > this.subrays[0].beginVanishingTime) {
        this.state = _LightningStrike.RAY_VANISHING;
      } else {
        this.state = _LightningStrike.RAY_STEADY;
      }
      this.visible = true;
    } else {
      this.visible = false;
      if (time < this.rayParameters.birthTime) {
        this.state = _LightningStrike.RAY_UNBORN;
      } else {
        this.state = _LightningStrike.RAY_EXTINGUISHED;
      }
    }
  }
  init(rayParameters) {
    this.rayParameters = rayParameters;
    this.maxIterations = rayParameters.maxIterations !== void 0 ? Math.floor(rayParameters.maxIterations) : 9;
    rayParameters.maxIterations = this.maxIterations;
    this.isStatic = rayParameters.isStatic !== void 0 ? rayParameters.isStatic : false;
    rayParameters.isStatic = this.isStatic;
    this.ramification = rayParameters.ramification !== void 0 ? Math.floor(rayParameters.ramification) : 5;
    rayParameters.ramification = this.ramification;
    this.maxSubrayRecursion = rayParameters.maxSubrayRecursion !== void 0 ? Math.floor(rayParameters.maxSubrayRecursion) : 3;
    rayParameters.maxSubrayRecursion = this.maxSubrayRecursion;
    this.recursionProbability = rayParameters.recursionProbability !== void 0 ? rayParameters.recursionProbability : 0.6;
    rayParameters.recursionProbability = this.recursionProbability;
    this.generateUVs = rayParameters.generateUVs !== void 0 ? rayParameters.generateUVs : false;
    rayParameters.generateUVs = this.generateUVs;
    if (rayParameters.randomGenerator !== void 0) {
      this.randomGenerator = rayParameters.randomGenerator;
      this.seedGenerator = rayParameters.randomGenerator;
      if (rayParameters.noiseSeed !== void 0) {
        this.seedGenerator.setSeed(rayParameters.noiseSeed);
      }
    } else {
      this.randomGenerator = _LightningStrike.createRandomGenerator();
      this.seedGenerator = Math;
    }
    if (rayParameters.onDecideSubrayCreation !== void 0) {
      this.onDecideSubrayCreation = rayParameters.onDecideSubrayCreation;
    } else {
      this.createDefaultSubrayCreationCallbacks();
      if (rayParameters.onSubrayCreation !== void 0) {
        this.onSubrayCreation = rayParameters.onSubrayCreation;
      }
    }
    this.state = _LightningStrike.RAY_INITIALIZED;
    this.maxSubrays = Math.ceil(1 + Math.pow(this.ramification, Math.max(0, this.maxSubrayRecursion - 1)));
    rayParameters.maxSubrays = this.maxSubrays;
    this.maxRaySegments = 2 * (1 << this.maxIterations);
    this.subrays = [];
    for (let i3 = 0; i3 < this.maxSubrays; i3++) {
      this.subrays.push(this.createSubray());
    }
    this.raySegments = [];
    for (let i3 = 0; i3 < this.maxRaySegments; i3++) {
      this.raySegments.push(this.createSegment());
    }
    this.time = 0;
    this.timeFraction = 0;
    this.currentSegmentCallback = null;
    this.currentCreateTriangleVertices = this.generateUVs ? this.createTriangleVerticesWithUVs : this.createTriangleVerticesWithoutUVs;
    this.numSubrays = 0;
    this.currentSubray = null;
    this.currentSegmentIndex = 0;
    this.isInitialSegment = false;
    this.subrayProbability = 0;
    this.currentVertex = 0;
    this.currentIndex = 0;
    this.currentCoordinate = 0;
    this.currentUVCoordinate = 0;
    this.vertices = null;
    this.uvs = null;
    this.indices = null;
    this.positionAttribute = null;
    this.uvsAttribute = null;
    this.simplexX = new SimplexNoise(this.seedGenerator);
    this.simplexY = new SimplexNoise(this.seedGenerator);
    this.simplexZ = new SimplexNoise(this.seedGenerator);
    this.forwards = new Vector3();
    this.forwardsFill = new Vector3();
    this.side = new Vector3();
    this.down = new Vector3();
    this.middlePos = new Vector3();
    this.middleLinPos = new Vector3();
    this.newPos = new Vector3();
    this.vPos = new Vector3();
    this.cross1 = new Vector3();
  }
  createMesh() {
    const maxDrawableSegmentsPerSubRay = 1 << this.maxIterations;
    const maxVerts = 3 * (maxDrawableSegmentsPerSubRay + 1) * this.maxSubrays;
    const maxIndices = 18 * maxDrawableSegmentsPerSubRay * this.maxSubrays;
    this.vertices = new Float32Array(maxVerts * 3);
    this.indices = new Uint32Array(maxIndices);
    if (this.generateUVs) {
      this.uvs = new Float32Array(maxVerts * 2);
    }
    this.fillMesh(0);
    this.setIndex(new Uint32BufferAttribute(this.indices, 1));
    this.positionAttribute = new Float32BufferAttribute(this.vertices, 3);
    this.setAttribute("position", this.positionAttribute);
    if (this.generateUVs) {
      this.uvsAttribute = new Float32BufferAttribute(new Float32Array(this.uvs), 2);
      this.setAttribute("uv", this.uvsAttribute);
    }
    if (!this.isStatic) {
      this.index.usage = DynamicDrawUsage;
      this.positionAttribute.usage = DynamicDrawUsage;
      if (this.generateUVs) {
        this.uvsAttribute.usage = DynamicDrawUsage;
      }
    }
    this.vertices = this.positionAttribute.array;
    this.indices = this.index.array;
    if (this.generateUVs) {
      this.uvs = this.uvsAttribute.array;
    }
  }
  updateMesh(time) {
    this.fillMesh(time);
    this.drawRange.count = this.currentIndex;
    this.index.needsUpdate = true;
    this.positionAttribute.needsUpdate = true;
    if (this.generateUVs) {
      this.uvsAttribute.needsUpdate = true;
    }
  }
  fillMesh(time) {
    const scope = this;
    this.currentVertex = 0;
    this.currentIndex = 0;
    this.currentCoordinate = 0;
    this.currentUVCoordinate = 0;
    this.fractalRay(time, function fillVertices(segment) {
      const subray = scope.currentSubray;
      if (time < subray.birthTime) {
        return;
      } else if (this.rayParameters.isEternal && scope.currentSubray.recursion == 0) {
        scope.createPrism(segment);
        scope.onDecideSubrayCreation(segment, scope);
      } else if (time < subray.endPropagationTime) {
        if (scope.timeFraction >= segment.fraction0 * subray.propagationTimeFactor) {
          scope.createPrism(segment);
          scope.onDecideSubrayCreation(segment, scope);
        }
      } else if (time < subray.beginVanishingTime) {
        scope.createPrism(segment);
        scope.onDecideSubrayCreation(segment, scope);
      } else {
        if (scope.timeFraction <= subray.vanishingTimeFactor + segment.fraction1 * (1 - subray.vanishingTimeFactor)) {
          scope.createPrism(segment);
        }
        scope.onDecideSubrayCreation(segment, scope);
      }
    });
  }
  addNewSubray() {
    return this.subrays[this.numSubrays++];
  }
  initSubray(subray, rayParameters) {
    subray.pos0.copy(rayParameters.sourceOffset);
    subray.pos1.copy(rayParameters.destOffset);
    subray.up0.copy(rayParameters.up0);
    subray.up1.copy(rayParameters.up1);
    subray.radius0 = rayParameters.radius0;
    subray.radius1 = rayParameters.radius1;
    subray.birthTime = rayParameters.birthTime;
    subray.deathTime = rayParameters.deathTime;
    subray.timeScale = rayParameters.timeScale;
    subray.roughness = rayParameters.roughness;
    subray.straightness = rayParameters.straightness;
    subray.propagationTimeFactor = rayParameters.propagationTimeFactor;
    subray.vanishingTimeFactor = rayParameters.vanishingTimeFactor;
    subray.maxIterations = this.maxIterations;
    subray.seed = rayParameters.noiseSeed !== void 0 ? rayParameters.noiseSeed : 0;
    subray.recursion = 0;
  }
  fractalRay(time, segmentCallback) {
    this.time = time;
    this.currentSegmentCallback = segmentCallback;
    this.numSubrays = 0;
    this.initSubray(this.addNewSubray(), this.rayParameters);
    for (let subrayIndex = 0; subrayIndex < this.numSubrays; subrayIndex++) {
      const subray = this.subrays[subrayIndex];
      this.currentSubray = subray;
      this.randomGenerator.setSeed(subray.seed);
      subray.endPropagationTime = MathUtils.lerp(subray.birthTime, subray.deathTime, subray.propagationTimeFactor);
      subray.beginVanishingTime = MathUtils.lerp(subray.deathTime, subray.birthTime, 1 - subray.vanishingTimeFactor);
      const random1 = this.randomGenerator.random;
      subray.linPos0.set(random1(), random1(), random1()).multiplyScalar(1e3);
      subray.linPos1.set(random1(), random1(), random1()).multiplyScalar(1e3);
      this.timeFraction = (time - subray.birthTime) / (subray.deathTime - subray.birthTime);
      this.currentSegmentIndex = 0;
      this.isInitialSegment = true;
      const segment = this.getNewSegment();
      segment.iteration = 0;
      segment.pos0.copy(subray.pos0);
      segment.pos1.copy(subray.pos1);
      segment.linPos0.copy(subray.linPos0);
      segment.linPos1.copy(subray.linPos1);
      segment.up0.copy(subray.up0);
      segment.up1.copy(subray.up1);
      segment.radius0 = subray.radius0;
      segment.radius1 = subray.radius1;
      segment.fraction0 = 0;
      segment.fraction1 = 1;
      segment.positionVariationFactor = 1 - subray.straightness;
      this.subrayProbability = this.ramification * Math.pow(this.recursionProbability, subray.recursion) / (1 << subray.maxIterations);
      this.fractalRayRecursive(segment);
    }
    this.currentSegmentCallback = null;
    this.currentSubray = null;
  }
  fractalRayRecursive(segment) {
    if (segment.iteration >= this.currentSubray.maxIterations) {
      this.currentSegmentCallback(segment);
      return;
    }
    this.forwards.subVectors(segment.pos1, segment.pos0);
    let lForwards = this.forwards.length();
    if (lForwards < 1e-6) {
      this.forwards.set(0, 0, 0.01);
      lForwards = this.forwards.length();
    }
    const middleRadius = (segment.radius0 + segment.radius1) * 0.5;
    const middleFraction = (segment.fraction0 + segment.fraction1) * 0.5;
    const timeDimension = this.time * this.currentSubray.timeScale * Math.pow(2, segment.iteration);
    this.middlePos.lerpVectors(segment.pos0, segment.pos1, 0.5);
    this.middleLinPos.lerpVectors(segment.linPos0, segment.linPos1, 0.5);
    const p = this.middleLinPos;
    this.newPos.set(
      this.simplexX.noise4d(p.x, p.y, p.z, timeDimension),
      this.simplexY.noise4d(p.x, p.y, p.z, timeDimension),
      this.simplexZ.noise4d(p.x, p.y, p.z, timeDimension)
    );
    this.newPos.multiplyScalar(segment.positionVariationFactor * lForwards);
    this.newPos.add(this.middlePos);
    const newSegment1 = this.getNewSegment();
    newSegment1.pos0.copy(segment.pos0);
    newSegment1.pos1.copy(this.newPos);
    newSegment1.linPos0.copy(segment.linPos0);
    newSegment1.linPos1.copy(this.middleLinPos);
    newSegment1.up0.copy(segment.up0);
    newSegment1.up1.copy(segment.up1);
    newSegment1.radius0 = segment.radius0;
    newSegment1.radius1 = middleRadius;
    newSegment1.fraction0 = segment.fraction0;
    newSegment1.fraction1 = middleFraction;
    newSegment1.positionVariationFactor = segment.positionVariationFactor * this.currentSubray.roughness;
    newSegment1.iteration = segment.iteration + 1;
    const newSegment2 = this.getNewSegment();
    newSegment2.pos0.copy(this.newPos);
    newSegment2.pos1.copy(segment.pos1);
    newSegment2.linPos0.copy(this.middleLinPos);
    newSegment2.linPos1.copy(segment.linPos1);
    this.cross1.crossVectors(segment.up0, this.forwards.normalize());
    newSegment2.up0.crossVectors(this.forwards, this.cross1).normalize();
    newSegment2.up1.copy(segment.up1);
    newSegment2.radius0 = middleRadius;
    newSegment2.radius1 = segment.radius1;
    newSegment2.fraction0 = middleFraction;
    newSegment2.fraction1 = segment.fraction1;
    newSegment2.positionVariationFactor = segment.positionVariationFactor * this.currentSubray.roughness;
    newSegment2.iteration = segment.iteration + 1;
    this.fractalRayRecursive(newSegment1);
    this.fractalRayRecursive(newSegment2);
  }
  createPrism(segment) {
    this.forwardsFill.subVectors(segment.pos1, segment.pos0).normalize();
    if (this.isInitialSegment) {
      this.currentCreateTriangleVertices(segment.pos0, segment.up0, this.forwardsFill, segment.radius0, 0);
      this.isInitialSegment = false;
    }
    this.currentCreateTriangleVertices(segment.pos1, segment.up0, this.forwardsFill, segment.radius1, segment.fraction1);
    this.createPrismFaces();
  }
  createTriangleVerticesWithoutUVs(pos, up, forwards, radius) {
    this.side.crossVectors(up, forwards).multiplyScalar(radius * _LightningStrike.COS30DEG);
    this.down.copy(up).multiplyScalar(-radius * _LightningStrike.SIN30DEG);
    const p = this.vPos;
    const v = this.vertices;
    p.copy(pos).sub(this.side).add(this.down);
    v[this.currentCoordinate++] = p.x;
    v[this.currentCoordinate++] = p.y;
    v[this.currentCoordinate++] = p.z;
    p.copy(pos).add(this.side).add(this.down);
    v[this.currentCoordinate++] = p.x;
    v[this.currentCoordinate++] = p.y;
    v[this.currentCoordinate++] = p.z;
    p.copy(up).multiplyScalar(radius).add(pos);
    v[this.currentCoordinate++] = p.x;
    v[this.currentCoordinate++] = p.y;
    v[this.currentCoordinate++] = p.z;
    this.currentVertex += 3;
  }
  createTriangleVerticesWithUVs(pos, up, forwards, radius, u) {
    this.side.crossVectors(up, forwards).multiplyScalar(radius * _LightningStrike.COS30DEG);
    this.down.copy(up).multiplyScalar(-radius * _LightningStrike.SIN30DEG);
    const p = this.vPos;
    const v = this.vertices;
    const uv = this.uvs;
    p.copy(pos).sub(this.side).add(this.down);
    v[this.currentCoordinate++] = p.x;
    v[this.currentCoordinate++] = p.y;
    v[this.currentCoordinate++] = p.z;
    uv[this.currentUVCoordinate++] = u;
    uv[this.currentUVCoordinate++] = 0;
    p.copy(pos).add(this.side).add(this.down);
    v[this.currentCoordinate++] = p.x;
    v[this.currentCoordinate++] = p.y;
    v[this.currentCoordinate++] = p.z;
    uv[this.currentUVCoordinate++] = u;
    uv[this.currentUVCoordinate++] = 0.5;
    p.copy(up).multiplyScalar(radius).add(pos);
    v[this.currentCoordinate++] = p.x;
    v[this.currentCoordinate++] = p.y;
    v[this.currentCoordinate++] = p.z;
    uv[this.currentUVCoordinate++] = u;
    uv[this.currentUVCoordinate++] = 1;
    this.currentVertex += 3;
  }
  createPrismFaces(vertex) {
    const indices = this.indices;
    vertex = this.currentVertex - 6;
    indices[this.currentIndex++] = vertex + 1;
    indices[this.currentIndex++] = vertex + 2;
    indices[this.currentIndex++] = vertex + 5;
    indices[this.currentIndex++] = vertex + 1;
    indices[this.currentIndex++] = vertex + 5;
    indices[this.currentIndex++] = vertex + 4;
    indices[this.currentIndex++] = vertex + 0;
    indices[this.currentIndex++] = vertex + 1;
    indices[this.currentIndex++] = vertex + 4;
    indices[this.currentIndex++] = vertex + 0;
    indices[this.currentIndex++] = vertex + 4;
    indices[this.currentIndex++] = vertex + 3;
    indices[this.currentIndex++] = vertex + 2;
    indices[this.currentIndex++] = vertex + 0;
    indices[this.currentIndex++] = vertex + 3;
    indices[this.currentIndex++] = vertex + 2;
    indices[this.currentIndex++] = vertex + 3;
    indices[this.currentIndex++] = vertex + 5;
  }
  createDefaultSubrayCreationCallbacks() {
    const random1 = this.randomGenerator.random;
    this.onDecideSubrayCreation = function(segment, lightningStrike) {
      const subray = lightningStrike.currentSubray;
      const period = lightningStrike.rayParameters.subrayPeriod;
      const dutyCycle = lightningStrike.rayParameters.subrayDutyCycle;
      const phase0 = lightningStrike.rayParameters.isEternal && subray.recursion == 0 ? -random1() * period : MathUtils.lerp(subray.birthTime, subray.endPropagationTime, segment.fraction0) - random1() * period;
      const phase = lightningStrike.time - phase0;
      const currentCycle = Math.floor(phase / period);
      const childSubraySeed = random1() * (currentCycle + 1);
      const isActive = phase % period <= dutyCycle * period;
      let probability = 0;
      if (isActive) {
        probability = lightningStrike.subrayProbability;
      }
      if (subray.recursion < lightningStrike.maxSubrayRecursion && lightningStrike.numSubrays < lightningStrike.maxSubrays && random1() < probability) {
        const childSubray = lightningStrike.addNewSubray();
        const parentSeed = lightningStrike.randomGenerator.getSeed();
        childSubray.seed = childSubraySeed;
        lightningStrike.randomGenerator.setSeed(childSubraySeed);
        childSubray.recursion = subray.recursion + 1;
        childSubray.maxIterations = Math.max(1, subray.maxIterations - 1);
        childSubray.linPos0.set(random1(), random1(), random1()).multiplyScalar(1e3);
        childSubray.linPos1.set(random1(), random1(), random1()).multiplyScalar(1e3);
        childSubray.up0.copy(subray.up0);
        childSubray.up1.copy(subray.up1);
        childSubray.radius0 = segment.radius0 * lightningStrike.rayParameters.radius0Factor;
        childSubray.radius1 = Math.min(
          lightningStrike.rayParameters.minRadius,
          segment.radius1 * lightningStrike.rayParameters.radius1Factor
        );
        childSubray.birthTime = phase0 + currentCycle * period;
        childSubray.deathTime = childSubray.birthTime + period * dutyCycle;
        if (!lightningStrike.rayParameters.isEternal && subray.recursion == 0) {
          childSubray.birthTime = Math.max(childSubray.birthTime, subray.birthTime);
          childSubray.deathTime = Math.min(childSubray.deathTime, subray.deathTime);
        }
        childSubray.timeScale = subray.timeScale * 2;
        childSubray.roughness = subray.roughness;
        childSubray.straightness = subray.straightness;
        childSubray.propagationTimeFactor = subray.propagationTimeFactor;
        childSubray.vanishingTimeFactor = subray.vanishingTimeFactor;
        lightningStrike.onSubrayCreation(segment, subray, childSubray, lightningStrike);
        lightningStrike.randomGenerator.setSeed(parentSeed);
      }
    };
    const vec1Pos = new Vector3();
    const vec2Forward = new Vector3();
    const vec3Side = new Vector3();
    const vec4Up = new Vector3();
    this.onSubrayCreation = function(segment, parentSubray, childSubray, lightningStrike) {
      lightningStrike.subrayCylinderPosition(segment, parentSubray, childSubray, 0.5, 0.6, 0.2);
    };
    this.subrayConePosition = function(segment, parentSubray, childSubray, heightFactor, sideWidthFactor, minSideWidthFactor) {
      childSubray.pos0.copy(segment.pos0);
      vec1Pos.subVectors(parentSubray.pos1, parentSubray.pos0);
      vec2Forward.copy(vec1Pos).normalize();
      vec1Pos.multiplyScalar(segment.fraction0 + (1 - segment.fraction0) * (random1() * heightFactor));
      const length = vec1Pos.length();
      vec3Side.crossVectors(parentSubray.up0, vec2Forward);
      const angle2 = 2 * Math.PI * random1();
      vec3Side.multiplyScalar(Math.cos(angle2));
      vec4Up.copy(parentSubray.up0).multiplyScalar(Math.sin(angle2));
      childSubray.pos1.copy(vec3Side).add(vec4Up).multiplyScalar(length * sideWidthFactor * (minSideWidthFactor + random1() * (1 - minSideWidthFactor))).add(vec1Pos).add(parentSubray.pos0);
    };
    this.subrayCylinderPosition = function(segment, parentSubray, childSubray, heightFactor, sideWidthFactor, minSideWidthFactor) {
      childSubray.pos0.copy(segment.pos0);
      vec1Pos.subVectors(parentSubray.pos1, parentSubray.pos0);
      vec2Forward.copy(vec1Pos).normalize();
      vec1Pos.multiplyScalar(segment.fraction0 + (1 - segment.fraction0) * ((2 * random1() - 1) * heightFactor));
      const length = vec1Pos.length();
      vec3Side.crossVectors(parentSubray.up0, vec2Forward);
      const angle2 = 2 * Math.PI * random1();
      vec3Side.multiplyScalar(Math.cos(angle2));
      vec4Up.copy(parentSubray.up0).multiplyScalar(Math.sin(angle2));
      childSubray.pos1.copy(vec3Side).add(vec4Up).multiplyScalar(length * sideWidthFactor * (minSideWidthFactor + random1() * (1 - minSideWidthFactor))).add(vec1Pos).add(parentSubray.pos0);
    };
  }
  createSubray() {
    return {
      seed: 0,
      maxIterations: 0,
      recursion: 0,
      pos0: new Vector3(),
      pos1: new Vector3(),
      linPos0: new Vector3(),
      linPos1: new Vector3(),
      up0: new Vector3(),
      up1: new Vector3(),
      radius0: 0,
      radius1: 0,
      birthTime: 0,
      deathTime: 0,
      timeScale: 0,
      roughness: 0,
      straightness: 0,
      propagationTimeFactor: 0,
      vanishingTimeFactor: 0,
      endPropagationTime: 0,
      beginVanishingTime: 0
    };
  }
  createSegment() {
    return {
      iteration: 0,
      pos0: new Vector3(),
      pos1: new Vector3(),
      linPos0: new Vector3(),
      linPos1: new Vector3(),
      up0: new Vector3(),
      up1: new Vector3(),
      radius0: 0,
      radius1: 0,
      fraction0: 0,
      fraction1: 0,
      positionVariationFactor: 0
    };
  }
  getNewSegment() {
    return this.raySegments[this.currentSegmentIndex++];
  }
  copy(source) {
    super.copy(source);
    this.init(_LightningStrike.copyParameters({}, source.rayParameters));
    return this;
  }
  clone() {
    return new this.constructor(_LightningStrike.copyParameters({}, this.rayParameters));
  }
};
var LightningStrike = _LightningStrike;
__publicField7(LightningStrike, "RAY_INITIALIZED", 0);
__publicField7(LightningStrike, "RAY_UNBORN", 1);
__publicField7(LightningStrike, "RAY_PROPAGATING", 2);
__publicField7(LightningStrike, "RAY_STEADY", 3);
__publicField7(LightningStrike, "RAY_VANISHING", 4);
__publicField7(LightningStrike, "RAY_EXTINGUISHED", 5);
__publicField7(LightningStrike, "COS30DEG", Math.cos(30 * Math.PI / 180));
__publicField7(LightningStrike, "SIN30DEG", Math.sin(30 * Math.PI / 180));

// node_modules/three-stdlib/objects/ReflectorForSSRPass.js
var __defProp7 = Object.defineProperty;
var __defNormalProp7 = (obj, key, value) => key in obj ? __defProp7(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField8 = (obj, key, value) => {
  __defNormalProp7(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var _ReflectorForSSRPass = class extends Mesh {
  constructor(geometry2, options = {}) {
    super(geometry2);
    this.isReflectorForSSRPass = true;
    this.type = "ReflectorForSSRPass";
    const scope = this;
    const color = options.color !== void 0 ? new Color(options.color) : new Color(8355711);
    const textureWidth = options.textureWidth || 512;
    const textureHeight = options.textureHeight || 512;
    const clipBias = options.clipBias || 0;
    const shader = options.shader || _ReflectorForSSRPass.ReflectorShader;
    const useDepthTexture = options.useDepthTexture === true;
    const yAxis2 = new Vector3(0, 1, 0);
    const vecTemp0 = new Vector3();
    const vecTemp1 = new Vector3();
    scope.needsUpdate = false;
    scope.maxDistance = _ReflectorForSSRPass.ReflectorShader.uniforms.maxDistance.value;
    scope.opacity = _ReflectorForSSRPass.ReflectorShader.uniforms.opacity.value;
    scope.color = color;
    scope.resolution = options.resolution || new Vector2(window.innerWidth, window.innerHeight);
    scope._distanceAttenuation = _ReflectorForSSRPass.ReflectorShader.defines.DISTANCE_ATTENUATION;
    Object.defineProperty(scope, "distanceAttenuation", {
      get() {
        return scope._distanceAttenuation;
      },
      set(val) {
        if (scope._distanceAttenuation === val)
          return;
        scope._distanceAttenuation = val;
        scope.material.defines.DISTANCE_ATTENUATION = val;
        scope.material.needsUpdate = true;
      }
    });
    scope._fresnel = _ReflectorForSSRPass.ReflectorShader.defines.FRESNEL;
    Object.defineProperty(scope, "fresnel", {
      get() {
        return scope._fresnel;
      },
      set(val) {
        if (scope._fresnel === val)
          return;
        scope._fresnel = val;
        scope.material.defines.FRESNEL = val;
        scope.material.needsUpdate = true;
      }
    });
    const normal = new Vector3();
    const reflectorWorldPosition = new Vector3();
    const cameraWorldPosition = new Vector3();
    const rotationMatrix2 = new Matrix4();
    const lookAtPosition = new Vector3(0, 0, -1);
    const view = new Vector3();
    const target = new Vector3();
    const textureMatrix = new Matrix4();
    const virtualCamera = new PerspectiveCamera();
    let depthTexture;
    if (useDepthTexture) {
      depthTexture = new DepthTexture();
      depthTexture.type = UnsignedShortType;
      depthTexture.minFilter = NearestFilter;
      depthTexture.magFilter = NearestFilter;
    }
    const parameters = {
      depthTexture: useDepthTexture ? depthTexture : null,
      type: HalfFloatType
    };
    const renderTarget = new WebGLRenderTarget(textureWidth, textureHeight, parameters);
    const material2 = new ShaderMaterial({
      transparent: useDepthTexture,
      defines: Object.assign({}, _ReflectorForSSRPass.ReflectorShader.defines, {
        useDepthTexture
      }),
      uniforms: UniformsUtils.clone(shader.uniforms),
      fragmentShader: shader.fragmentShader,
      vertexShader: shader.vertexShader
    });
    material2.uniforms["tDiffuse"].value = renderTarget.texture;
    material2.uniforms["color"].value = scope.color;
    material2.uniforms["textureMatrix"].value = textureMatrix;
    if (useDepthTexture) {
      material2.uniforms["tDepth"].value = renderTarget.depthTexture;
    }
    this.material = material2;
    const globalPlane = new Plane(new Vector3(0, 1, 0), clipBias);
    const globalPlanes = [globalPlane];
    this.doRender = function(renderer, scene, camera) {
      material2.uniforms["maxDistance"].value = scope.maxDistance;
      material2.uniforms["color"].value = scope.color;
      material2.uniforms["opacity"].value = scope.opacity;
      vecTemp0.copy(camera.position).normalize();
      vecTemp1.copy(vecTemp0).reflect(yAxis2);
      material2.uniforms["fresnelCoe"].value = (vecTemp0.dot(vecTemp1) + 1) / 2;
      reflectorWorldPosition.setFromMatrixPosition(scope.matrixWorld);
      cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);
      rotationMatrix2.extractRotation(scope.matrixWorld);
      normal.set(0, 0, 1);
      normal.applyMatrix4(rotationMatrix2);
      view.subVectors(reflectorWorldPosition, cameraWorldPosition);
      if (view.dot(normal) > 0)
        return;
      view.reflect(normal).negate();
      view.add(reflectorWorldPosition);
      rotationMatrix2.extractRotation(camera.matrixWorld);
      lookAtPosition.set(0, 0, -1);
      lookAtPosition.applyMatrix4(rotationMatrix2);
      lookAtPosition.add(cameraWorldPosition);
      target.subVectors(reflectorWorldPosition, lookAtPosition);
      target.reflect(normal).negate();
      target.add(reflectorWorldPosition);
      virtualCamera.position.copy(view);
      virtualCamera.up.set(0, 1, 0);
      virtualCamera.up.applyMatrix4(rotationMatrix2);
      virtualCamera.up.reflect(normal);
      virtualCamera.lookAt(target);
      virtualCamera.far = camera.far;
      virtualCamera.updateMatrixWorld();
      virtualCamera.projectionMatrix.copy(camera.projectionMatrix);
      material2.uniforms["virtualCameraNear"].value = camera.near;
      material2.uniforms["virtualCameraFar"].value = camera.far;
      material2.uniforms["virtualCameraMatrixWorld"].value = virtualCamera.matrixWorld;
      material2.uniforms["virtualCameraProjectionMatrix"].value = camera.projectionMatrix;
      material2.uniforms["virtualCameraProjectionMatrixInverse"].value = camera.projectionMatrixInverse;
      material2.uniforms["resolution"].value = scope.resolution;
      textureMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);
      textureMatrix.multiply(virtualCamera.projectionMatrix);
      textureMatrix.multiply(virtualCamera.matrixWorldInverse);
      textureMatrix.multiply(scope.matrixWorld);
      const currentRenderTarget = renderer.getRenderTarget();
      const currentXrEnabled = renderer.xr.enabled;
      const currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;
      const currentClippingPlanes = renderer.clippingPlanes;
      renderer.xr.enabled = false;
      renderer.shadowMap.autoUpdate = false;
      renderer.clippingPlanes = globalPlanes;
      renderer.setRenderTarget(renderTarget);
      renderer.state.buffers.depth.setMask(true);
      if (renderer.autoClear === false)
        renderer.clear();
      renderer.render(scene, virtualCamera);
      renderer.xr.enabled = currentXrEnabled;
      renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;
      renderer.clippingPlanes = currentClippingPlanes;
      renderer.setRenderTarget(currentRenderTarget);
      const viewport = camera.viewport;
      if (viewport !== void 0) {
        renderer.state.viewport(viewport);
      }
    };
    this.getRenderTarget = function() {
      return renderTarget;
    };
  }
};
var ReflectorForSSRPass = _ReflectorForSSRPass;
__publicField8(ReflectorForSSRPass, "ReflectorShader", {
  defines: {
    DISTANCE_ATTENUATION: true,
    FRESNEL: true
  },
  uniforms: {
    color: { value: null },
    tDiffuse: { value: null },
    tDepth: { value: null },
    textureMatrix: { value: new Matrix4() },
    maxDistance: { value: 180 },
    opacity: { value: 0.5 },
    fresnelCoe: { value: null },
    virtualCameraNear: { value: null },
    virtualCameraFar: { value: null },
    virtualCameraProjectionMatrix: { value: new Matrix4() },
    virtualCameraMatrixWorld: { value: new Matrix4() },
    virtualCameraProjectionMatrixInverse: { value: new Matrix4() },
    resolution: { value: new Vector2() }
  },
  vertexShader: (
    /* glsl */
    `
		uniform mat4 textureMatrix;
		varying vec4 vUv;

		void main() {

			vUv = textureMatrix * vec4( position, 1.0 );

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`
  ),
  fragmentShader: (
    /* glsl */
    `
		uniform vec3 color;
		uniform sampler2D tDiffuse;
		uniform sampler2D tDepth;
		uniform float maxDistance;
		uniform float opacity;
		uniform float fresnelCoe;
		uniform float virtualCameraNear;
		uniform float virtualCameraFar;
		uniform mat4 virtualCameraProjectionMatrix;
		uniform mat4 virtualCameraProjectionMatrixInverse;
		uniform mat4 virtualCameraMatrixWorld;
		uniform vec2 resolution;
		varying vec4 vUv;
		#include <packing>
		float blendOverlay( float base, float blend ) {
			return( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );
		}
		vec3 blendOverlay( vec3 base, vec3 blend ) {
			return vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );
		}
		float getDepth( const in vec2 uv ) {
			return texture2D( tDepth, uv ).x;
		}
		float getViewZ( const in float depth ) {
			return perspectiveDepthToViewZ( depth, virtualCameraNear, virtualCameraFar );
		}
		vec3 getViewPosition( const in vec2 uv, const in float depth/*clip space*/, const in float clipW ) {
			vec4 clipPosition = vec4( ( vec3( uv, depth ) - 0.5 ) * 2.0, 1.0 );//ndc
			clipPosition *= clipW; //clip
			return ( virtualCameraProjectionMatrixInverse * clipPosition ).xyz;//view
		}
		void main() {
			vec4 base = texture2DProj( tDiffuse, vUv );
			#ifdef useDepthTexture
				vec2 uv=(gl_FragCoord.xy-.5)/resolution.xy;
				uv.x=1.-uv.x;
				float depth = texture2DProj( tDepth, vUv ).r;
				float viewZ = getViewZ( depth );
				float clipW = virtualCameraProjectionMatrix[2][3] * viewZ+virtualCameraProjectionMatrix[3][3];
				vec3 viewPosition=getViewPosition( uv, depth, clipW );
				vec3 worldPosition=(virtualCameraMatrixWorld*vec4(viewPosition,1)).xyz;
				if(worldPosition.y>maxDistance) discard;
				float op=opacity;
				#ifdef DISTANCE_ATTENUATION
					float ratio=1.-(worldPosition.y/maxDistance);
					float attenuation=ratio*ratio;
					op=opacity*attenuation;
				#endif
				#ifdef FRESNEL
					op*=fresnelCoe;
				#endif
				gl_FragColor = vec4( blendOverlay( base.rgb, color ), op );
			#else
				gl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );
			#endif
		}
	`
  )
});

// node_modules/three-stdlib/objects/Sky.js
var __defProp8 = Object.defineProperty;
var __defNormalProp8 = (obj, key, value) => key in obj ? __defProp8(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField9 = (obj, key, value) => {
  __defNormalProp8(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var SkyShader = {
  uniforms: {
    turbidity: { value: 2 },
    rayleigh: { value: 1 },
    mieCoefficient: { value: 5e-3 },
    mieDirectionalG: { value: 0.8 },
    sunPosition: { value: new Vector3() },
    up: { value: new Vector3(0, 1, 0) }
  },
  vertexShader: (
    /* glsl */
    `
      uniform vec3 sunPosition;
      uniform float rayleigh;
      uniform float turbidity;
      uniform float mieCoefficient;
      uniform vec3 up;

      varying vec3 vWorldPosition;
      varying vec3 vSunDirection;
      varying float vSunfade;
      varying vec3 vBetaR;
      varying vec3 vBetaM;
      varying float vSunE;

      // constants for atmospheric scattering
      const float e = 2.71828182845904523536028747135266249775724709369995957;
      const float pi = 3.141592653589793238462643383279502884197169;

      // wavelength of used primaries, according to preetham
      const vec3 lambda = vec3( 680E-9, 550E-9, 450E-9 );
      // this pre-calcuation replaces older TotalRayleigh(vec3 lambda) function:
      // (8.0 * pow(pi, 3.0) * pow(pow(n, 2.0) - 1.0, 2.0) * (6.0 + 3.0 * pn)) / (3.0 * N * pow(lambda, vec3(4.0)) * (6.0 - 7.0 * pn))
      const vec3 totalRayleigh = vec3( 5.804542996261093E-6, 1.3562911419845635E-5, 3.0265902468824876E-5 );

      // mie stuff
      // K coefficient for the primaries
      const float v = 4.0;
      const vec3 K = vec3( 0.686, 0.678, 0.666 );
      // MieConst = pi * pow( ( 2.0 * pi ) / lambda, vec3( v - 2.0 ) ) * K
      const vec3 MieConst = vec3( 1.8399918514433978E14, 2.7798023919660528E14, 4.0790479543861094E14 );

      // earth shadow hack
      // cutoffAngle = pi / 1.95;
      const float cutoffAngle = 1.6110731556870734;
      const float steepness = 1.5;
      const float EE = 1000.0;

      float sunIntensity( float zenithAngleCos ) {
        zenithAngleCos = clamp( zenithAngleCos, -1.0, 1.0 );
        return EE * max( 0.0, 1.0 - pow( e, -( ( cutoffAngle - acos( zenithAngleCos ) ) / steepness ) ) );
      }

      vec3 totalMie( float T ) {
        float c = ( 0.2 * T ) * 10E-18;
        return 0.434 * c * MieConst;
      }

      void main() {

        vec4 worldPosition = modelMatrix * vec4( position, 1.0 );
        vWorldPosition = worldPosition.xyz;

        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
        gl_Position.z = gl_Position.w; // set z to camera.far

        vSunDirection = normalize( sunPosition );

        vSunE = sunIntensity( dot( vSunDirection, up ) );

        vSunfade = 1.0 - clamp( 1.0 - exp( ( sunPosition.y / 450000.0 ) ), 0.0, 1.0 );

        float rayleighCoefficient = rayleigh - ( 1.0 * ( 1.0 - vSunfade ) );

      // extinction (absorbtion + out scattering)
      // rayleigh coefficients
        vBetaR = totalRayleigh * rayleighCoefficient;

      // mie coefficients
        vBetaM = totalMie( turbidity ) * mieCoefficient;

      }
    `
  ),
  fragmentShader: (
    /* glsl */
    `
      varying vec3 vWorldPosition;
      varying vec3 vSunDirection;
      varying float vSunfade;
      varying vec3 vBetaR;
      varying vec3 vBetaM;
      varying float vSunE;

      uniform float mieDirectionalG;
      uniform vec3 up;

      const vec3 cameraPos = vec3( 0.0, 0.0, 0.0 );

      // constants for atmospheric scattering
      const float pi = 3.141592653589793238462643383279502884197169;

      const float n = 1.0003; // refractive index of air
      const float N = 2.545E25; // number of molecules per unit volume for air at 288.15K and 1013mb (sea level -45 celsius)

      // optical length at zenith for molecules
      const float rayleighZenithLength = 8.4E3;
      const float mieZenithLength = 1.25E3;
      // 66 arc seconds -> degrees, and the cosine of that
      const float sunAngularDiameterCos = 0.999956676946448443553574619906976478926848692873900859324;

      // 3.0 / ( 16.0 * pi )
      const float THREE_OVER_SIXTEENPI = 0.05968310365946075;
      // 1.0 / ( 4.0 * pi )
      const float ONE_OVER_FOURPI = 0.07957747154594767;

      float rayleighPhase( float cosTheta ) {
        return THREE_OVER_SIXTEENPI * ( 1.0 + pow( cosTheta, 2.0 ) );
      }

      float hgPhase( float cosTheta, float g ) {
        float g2 = pow( g, 2.0 );
        float inverse = 1.0 / pow( 1.0 - 2.0 * g * cosTheta + g2, 1.5 );
        return ONE_OVER_FOURPI * ( ( 1.0 - g2 ) * inverse );
      }

      void main() {

        vec3 direction = normalize( vWorldPosition - cameraPos );

      // optical length
      // cutoff angle at 90 to avoid singularity in next formula.
        float zenithAngle = acos( max( 0.0, dot( up, direction ) ) );
        float inverse = 1.0 / ( cos( zenithAngle ) + 0.15 * pow( 93.885 - ( ( zenithAngle * 180.0 ) / pi ), -1.253 ) );
        float sR = rayleighZenithLength * inverse;
        float sM = mieZenithLength * inverse;

      // combined extinction factor
        vec3 Fex = exp( -( vBetaR * sR + vBetaM * sM ) );

      // in scattering
        float cosTheta = dot( direction, vSunDirection );

        float rPhase = rayleighPhase( cosTheta * 0.5 + 0.5 );
        vec3 betaRTheta = vBetaR * rPhase;

        float mPhase = hgPhase( cosTheta, mieDirectionalG );
        vec3 betaMTheta = vBetaM * mPhase;

        vec3 Lin = pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * ( 1.0 - Fex ), vec3( 1.5 ) );
        Lin *= mix( vec3( 1.0 ), pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * Fex, vec3( 1.0 / 2.0 ) ), clamp( pow( 1.0 - dot( up, vSunDirection ), 5.0 ), 0.0, 1.0 ) );

      // nightsky
        float theta = acos( direction.y ); // elevation --> y-axis, [-pi/2, pi/2]
        float phi = atan( direction.z, direction.x ); // azimuth --> x-axis [-pi/2, pi/2]
        vec2 uv = vec2( phi, theta ) / vec2( 2.0 * pi, pi ) + vec2( 0.5, 0.0 );
        vec3 L0 = vec3( 0.1 ) * Fex;

      // composition + solar disc
        float sundisk = smoothstep( sunAngularDiameterCos, sunAngularDiameterCos + 0.00002, cosTheta );
        L0 += ( vSunE * 19000.0 * Fex ) * sundisk;

        vec3 texColor = ( Lin + L0 ) * 0.04 + vec3( 0.0, 0.0003, 0.00075 );

        vec3 retColor = pow( texColor, vec3( 1.0 / ( 1.2 + ( 1.2 * vSunfade ) ) ) );

        gl_FragColor = vec4( retColor, 1.0 );

      #include <tonemapping_fragment>
      #include <encodings_fragment>

      }
    `
  )
};
var material = new ShaderMaterial({
  name: "SkyShader",
  fragmentShader: SkyShader.fragmentShader,
  vertexShader: SkyShader.vertexShader,
  uniforms: UniformsUtils.clone(SkyShader.uniforms),
  side: BackSide,
  depthWrite: false
});
var Sky = class extends Mesh {
  constructor() {
    super(new BoxGeometry(1, 1, 1), material);
  }
};
__publicField9(Sky, "SkyShader", SkyShader);
__publicField9(Sky, "material", material);

// node_modules/three-stdlib/objects/Water2.js
var __defProp9 = Object.defineProperty;
var __defNormalProp9 = (obj, key, value) => key in obj ? __defProp9(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField10 = (obj, key, value) => {
  __defNormalProp9(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var _Water2 = class extends Mesh {
  constructor(geometry2, options = {}) {
    super(geometry2);
    this.isWater = true;
    this.type = "Water";
    const scope = this;
    const color = options.color !== void 0 ? new Color(options.color) : new Color(16777215);
    const textureWidth = options.textureWidth || 512;
    const textureHeight = options.textureHeight || 512;
    const clipBias = options.clipBias || 0;
    const flowDirection = options.flowDirection || new Vector2(1, 0);
    const flowSpeed = options.flowSpeed || 0.03;
    const reflectivity = options.reflectivity || 0.02;
    const scale = options.scale || 1;
    const shader = options.shader || _Water2.WaterShader;
    const encoding = options.encoding !== void 0 ? options.encoding : 3e3;
    const flowMap = options.flowMap || void 0;
    const normalMap0 = options.normalMap0;
    const normalMap1 = options.normalMap1;
    const cycle = 0.15;
    const halfCycle = cycle * 0.5;
    const textureMatrix = new Matrix4();
    const clock = new Clock();
    if (Reflector === void 0) {
      console.error("THREE.Water: Required component Reflector not found.");
      return;
    }
    if (Refractor === void 0) {
      console.error("THREE.Water: Required component Refractor not found.");
      return;
    }
    const reflector = new Reflector(geometry2, {
      textureWidth,
      textureHeight,
      clipBias,
      encoding
    });
    const refractor = new Refractor(geometry2, {
      textureWidth,
      textureHeight,
      clipBias,
      encoding
    });
    reflector.matrixAutoUpdate = false;
    refractor.matrixAutoUpdate = false;
    this.material = new ShaderMaterial({
      uniforms: UniformsUtils.merge([UniformsLib["fog"], shader.uniforms]),
      vertexShader: shader.vertexShader,
      fragmentShader: shader.fragmentShader,
      transparent: true,
      fog: true
    });
    if (flowMap !== void 0) {
      this.material.defines.USE_FLOWMAP = "";
      this.material.uniforms["tFlowMap"] = {
        type: "t",
        value: flowMap
      };
    } else {
      this.material.uniforms["flowDirection"] = {
        type: "v2",
        value: flowDirection
      };
    }
    normalMap0.wrapS = normalMap0.wrapT = RepeatWrapping;
    normalMap1.wrapS = normalMap1.wrapT = RepeatWrapping;
    this.material.uniforms["tReflectionMap"].value = reflector.getRenderTarget().texture;
    this.material.uniforms["tRefractionMap"].value = refractor.getRenderTarget().texture;
    this.material.uniforms["tNormalMap0"].value = normalMap0;
    this.material.uniforms["tNormalMap1"].value = normalMap1;
    this.material.uniforms["color"].value = color;
    this.material.uniforms["reflectivity"].value = reflectivity;
    this.material.uniforms["textureMatrix"].value = textureMatrix;
    this.material.uniforms["config"].value.x = 0;
    this.material.uniforms["config"].value.y = halfCycle;
    this.material.uniforms["config"].value.z = halfCycle;
    this.material.uniforms["config"].value.w = scale;
    function updateTextureMatrix(camera) {
      textureMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);
      textureMatrix.multiply(camera.projectionMatrix);
      textureMatrix.multiply(camera.matrixWorldInverse);
      textureMatrix.multiply(scope.matrixWorld);
    }
    function updateFlow() {
      const delta = clock.getDelta();
      const config3 = scope.material.uniforms["config"];
      config3.value.x += flowSpeed * delta;
      config3.value.y = config3.value.x + halfCycle;
      if (config3.value.x >= cycle) {
        config3.value.x = 0;
        config3.value.y = halfCycle;
      } else if (config3.value.y >= cycle) {
        config3.value.y = config3.value.y - cycle;
      }
    }
    this.onBeforeRender = function(renderer, scene, camera) {
      updateTextureMatrix(camera);
      updateFlow();
      scope.visible = false;
      reflector.matrixWorld.copy(scope.matrixWorld);
      refractor.matrixWorld.copy(scope.matrixWorld);
      reflector.onBeforeRender(renderer, scene, camera);
      refractor.onBeforeRender(renderer, scene, camera);
      scope.visible = true;
    };
  }
};
var Water2 = _Water2;
__publicField10(Water2, "WaterShader", {
  uniforms: {
    color: {
      value: null
    },
    reflectivity: {
      value: 0
    },
    tReflectionMap: {
      value: null
    },
    tRefractionMap: {
      value: null
    },
    tNormalMap0: {
      value: null
    },
    tNormalMap1: {
      value: null
    },
    textureMatrix: {
      value: null
    },
    config: {
      value: new Vector4()
    }
  },
  vertexShader: (
    /* glsl */
    `

		#include <common>
		#include <fog_pars_vertex>
		#include <logdepthbuf_pars_vertex>

		uniform mat4 textureMatrix;

		varying vec4 vCoord;
		varying vec2 vUv;
		varying vec3 vToEye;

		void main() {

			vUv = uv;
			vCoord = textureMatrix * vec4( position, 1.0 );

			vec4 worldPosition = modelMatrix * vec4( position, 1.0 );
			vToEye = cameraPosition - worldPosition.xyz;

			vec4 mvPosition =  viewMatrix * worldPosition; // used in fog_vertex
			gl_Position = projectionMatrix * mvPosition;

			#include <logdepthbuf_vertex>
			#include <fog_vertex>

		}`
  ),
  fragmentShader: (
    /* glsl */
    `

		#include <common>
		#include <fog_pars_fragment>
		#include <logdepthbuf_pars_fragment>

		uniform sampler2D tReflectionMap;
		uniform sampler2D tRefractionMap;
		uniform sampler2D tNormalMap0;
		uniform sampler2D tNormalMap1;

		#ifdef USE_FLOWMAP
			uniform sampler2D tFlowMap;
		#else
			uniform vec2 flowDirection;
		#endif

		uniform vec3 color;
		uniform float reflectivity;
		uniform vec4 config;

		varying vec4 vCoord;
		varying vec2 vUv;
		varying vec3 vToEye;

		void main() {

			#include <logdepthbuf_fragment>

			float flowMapOffset0 = config.x;
			float flowMapOffset1 = config.y;
			float halfCycle = config.z;
			float scale = config.w;

			vec3 toEye = normalize( vToEye );

			// determine flow direction
			vec2 flow;
			#ifdef USE_FLOWMAP
				flow = texture2D( tFlowMap, vUv ).rg * 2.0 - 1.0;
			#else
				flow = flowDirection;
			#endif
			flow.x *= - 1.0;

			// sample normal maps (distort uvs with flowdata)
			vec4 normalColor0 = texture2D( tNormalMap0, ( vUv * scale ) + flow * flowMapOffset0 );
			vec4 normalColor1 = texture2D( tNormalMap1, ( vUv * scale ) + flow * flowMapOffset1 );

			// linear interpolate to get the final normal color
			float flowLerp = abs( halfCycle - flowMapOffset0 ) / halfCycle;
			vec4 normalColor = mix( normalColor0, normalColor1, flowLerp );

			// calculate normal vector
			vec3 normal = normalize( vec3( normalColor.r * 2.0 - 1.0, normalColor.b,  normalColor.g * 2.0 - 1.0 ) );

			// calculate the fresnel term to blend reflection and refraction maps
			float theta = max( dot( toEye, normal ), 0.0 );
			float reflectance = reflectivity + ( 1.0 - reflectivity ) * pow( ( 1.0 - theta ), 5.0 );

			// calculate final uv coords
			vec3 coord = vCoord.xyz / vCoord.w;
			vec2 uv = coord.xy + coord.z * normal.xz * 0.05;

			vec4 reflectColor = texture2D( tReflectionMap, vec2( 1.0 - uv.x, uv.y ) );
			vec4 refractColor = texture2D( tRefractionMap, uv );

			// multiply water color with the mix of both textures
			gl_FragColor = vec4( color, 1.0 ) * mix( refractColor, reflectColor, reflectance );

			#include <tonemapping_fragment>
			#include <encodings_fragment>
			#include <fog_fragment>

		}`
  )
});

// node_modules/three-stdlib/utils/RoughnessMipmapper.js
var _mipmapMaterial = _getMipmapMaterial();
var _mesh = new Mesh(new PlaneGeometry(2, 2), _mipmapMaterial);
var _flatCamera = new OrthographicCamera(0, 1, 0, 1, 0, 1);
function _getMipmapMaterial() {
  var shaderMaterial = new RawShaderMaterial({
    uniforms: {
      roughnessMap: { value: null },
      normalMap: { value: null },
      texelSize: { value: new Vector2(1, 1) }
    },
    vertexShader: (
      /* glsl */
      `
			precision mediump float;
			precision mediump int;

			attribute vec3 position;
			attribute vec2 uv;

			varying vec2 vUv;

			void main() {

				vUv = uv;

				gl_Position = vec4( position, 1.0 );

			}
		`
    ),
    fragmentShader: (
      /* glsl */
      `
			precision mediump float;
			precision mediump int;

			varying vec2 vUv;

			uniform sampler2D roughnessMap;
			uniform sampler2D normalMap;
			uniform vec2 texelSize;

			#define ENVMAP_TYPE_CUBE_UV

			vec4 envMapTexelToLinear( vec4 a ) { return a; }

			#include <cube_uv_reflection_fragment>

			float roughnessToVariance( float roughness ) {

				float variance = 0.0;

				if ( roughness >= r1 ) {

					variance = ( r0 - roughness ) * ( v1 - v0 ) / ( r0 - r1 ) + v0;

				} else if ( roughness >= r4 ) {

					variance = ( r1 - roughness ) * ( v4 - v1 ) / ( r1 - r4 ) + v1;

				} else if ( roughness >= r5 ) {

					variance = ( r4 - roughness ) * ( v5 - v4 ) / ( r4 - r5 ) + v4;

				} else {

					float roughness2 = roughness * roughness;

					variance = 1.79 * roughness2 * roughness2;

				}

				return variance;

			}

			float varianceToRoughness( float variance ) {

				float roughness = 0.0;

				if ( variance >= v1 ) {

					roughness = ( v0 - variance ) * ( r1 - r0 ) / ( v0 - v1 ) + r0;

				} else if ( variance >= v4 ) {

					roughness = ( v1 - variance ) * ( r4 - r1 ) / ( v1 - v4 ) + r1;

				} else if ( variance >= v5 ) {

					roughness = ( v4 - variance ) * ( r5 - r4 ) / ( v4 - v5 ) + r4;

				} else {

					roughness = pow( 0.559 * variance, 0.25 ); // 0.559 = 1.0 / 1.79

				}

				return roughness;

			}

			void main() {

				gl_FragColor = texture2D( roughnessMap, vUv, - 1.0 );

				if ( texelSize.x == 0.0 ) return;

				float roughness = gl_FragColor.g;

				float variance = roughnessToVariance( roughness );

				vec3 avgNormal;

				for ( float x = - 1.0; x < 2.0; x += 2.0 ) {

					for ( float y = - 1.0; y < 2.0; y += 2.0 ) {

						vec2 uv = vUv + vec2( x, y ) * 0.25 * texelSize;

						avgNormal += normalize( texture2D( normalMap, uv, - 1.0 ).xyz - 0.5 );

					}

				}

				variance += 1.0 - 0.25 * length( avgNormal );

				gl_FragColor.g = varianceToRoughness( variance );

			}
		`
    ),
    blending: NoBlending,
    depthTest: false,
    depthWrite: false
  });
  shaderMaterial.type = "RoughnessMipmapper";
  return shaderMaterial;
}

// node_modules/three-stdlib/shaders/UnpackDepthRGBAShader.js
var UnpackDepthRGBAShader = {
  uniforms: {
    tDiffuse: { value: null },
    opacity: { value: 1 }
  },
  vertexShader: [
    "varying vec2 vUv;",
    "void main() {",
    "	vUv = uv;",
    "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
    "}"
  ].join("\n"),
  fragmentShader: [
    "uniform float opacity;",
    "uniform sampler2D tDiffuse;",
    "varying vec2 vUv;",
    "#include <packing>",
    "void main() {",
    "	float depth = 1.0 - unpackRGBAToDepth( texture2D( tDiffuse, vUv ) );",
    "	gl_FragColor = vec4( vec3( depth ), opacity );",
    "}"
  ].join("\n")
};

// node_modules/three-stdlib/shaders/BokehShader2.js
var BokehShader2 = {
  uniforms: {
    textureWidth: { value: 1 },
    textureHeight: { value: 1 },
    focalDepth: { value: 1 },
    focalLength: { value: 24 },
    fstop: { value: 0.9 },
    tColor: { value: null },
    tDepth: { value: null },
    maxblur: { value: 1 },
    showFocus: { value: 0 },
    manualdof: { value: 0 },
    vignetting: { value: 0 },
    depthblur: { value: 0 },
    threshold: { value: 0.5 },
    gain: { value: 2 },
    bias: { value: 0.5 },
    fringe: { value: 0.7 },
    znear: { value: 0.1 },
    zfar: { value: 100 },
    noise: { value: 1 },
    dithering: { value: 1e-4 },
    pentagon: { value: 0 },
    shaderFocus: { value: 1 },
    focusCoords: { value: new Vector2() }
  },
  vertexShader: [
    "varying vec2 vUv;",
    "void main() {",
    "	vUv = uv;",
    "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
    "}"
  ].join("\n"),
  fragmentShader: [
    "#include <common>",
    "varying vec2 vUv;",
    "uniform sampler2D tColor;",
    "uniform sampler2D tDepth;",
    "uniform float textureWidth;",
    "uniform float textureHeight;",
    "uniform float focalDepth;  //focal distance value in meters, but you may use autofocus option below",
    "uniform float focalLength; //focal length in mm",
    "uniform float fstop; //f-stop value",
    "uniform bool showFocus; //show debug focus point and focal range (red = focal point, green = focal range)",
    "/*",
    "make sure that these two values are the same for your camera, otherwise distances will be wrong.",
    "*/",
    "uniform float znear; // camera clipping start",
    "uniform float zfar; // camera clipping end",
    "//------------------------------------------",
    "//user variables",
    "const int samples = SAMPLES; //samples on the first ring",
    "const int rings = RINGS; //ring count",
    "const int maxringsamples = rings * samples;",
    "uniform bool manualdof; // manual dof calculation",
    "float ndofstart = 1.0; // near dof blur start",
    "float ndofdist = 2.0; // near dof blur falloff distance",
    "float fdofstart = 1.0; // far dof blur start",
    "float fdofdist = 3.0; // far dof blur falloff distance",
    "float CoC = 0.03; //circle of confusion size in mm (35mm film = 0.03mm)",
    "uniform bool vignetting; // use optical lens vignetting",
    "float vignout = 1.3; // vignetting outer border",
    "float vignin = 0.0; // vignetting inner border",
    "float vignfade = 22.0; // f-stops till vignete fades",
    "uniform bool shaderFocus;",
    "// disable if you use external focalDepth value",
    "uniform vec2 focusCoords;",
    "// autofocus point on screen (0.0,0.0 - left lower corner, 1.0,1.0 - upper right)",
    "// if center of screen use vec2(0.5, 0.5);",
    "uniform float maxblur;",
    "//clamp value of max blur (0.0 = no blur, 1.0 default)",
    "uniform float threshold; // highlight threshold;",
    "uniform float gain; // highlight gain;",
    "uniform float bias; // bokeh edge bias",
    "uniform float fringe; // bokeh chromatic aberration / fringing",
    "uniform bool noise; //use noise instead of pattern for sample dithering",
    "uniform float dithering;",
    "uniform bool depthblur; // blur the depth buffer",
    "float dbsize = 1.25; // depth blur size",
    "/*",
    "next part is experimental",
    "not looking good with small sample and ring count",
    "looks okay starting from samples = 4, rings = 4",
    "*/",
    "uniform bool pentagon; //use pentagon as bokeh shape?",
    "float feather = 0.4; //pentagon shape feather",
    "//------------------------------------------",
    "float penta(vec2 coords) {",
    "	//pentagonal shape",
    "	float scale = float(rings) - 1.3;",
    "	vec4  HS0 = vec4( 1.0,         0.0,         0.0,  1.0);",
    "	vec4  HS1 = vec4( 0.309016994, 0.951056516, 0.0,  1.0);",
    "	vec4  HS2 = vec4(-0.809016994, 0.587785252, 0.0,  1.0);",
    "	vec4  HS3 = vec4(-0.809016994,-0.587785252, 0.0,  1.0);",
    "	vec4  HS4 = vec4( 0.309016994,-0.951056516, 0.0,  1.0);",
    "	vec4  HS5 = vec4( 0.0        ,0.0         , 1.0,  1.0);",
    "	vec4  one = vec4( 1.0 );",
    "	vec4 P = vec4((coords),vec2(scale, scale));",
    "	vec4 dist = vec4(0.0);",
    "	float inorout = -4.0;",
    "	dist.x = dot( P, HS0 );",
    "	dist.y = dot( P, HS1 );",
    "	dist.z = dot( P, HS2 );",
    "	dist.w = dot( P, HS3 );",
    "	dist = smoothstep( -feather, feather, dist );",
    "	inorout += dot( dist, one );",
    "	dist.x = dot( P, HS4 );",
    "	dist.y = HS5.w - abs( P.z );",
    "	dist = smoothstep( -feather, feather, dist );",
    "	inorout += dist.x;",
    "	return clamp( inorout, 0.0, 1.0 );",
    "}",
    "float bdepth(vec2 coords) {",
    "	// Depth buffer blur",
    "	float d = 0.0;",
    "	float kernel[9];",
    "	vec2 offset[9];",
    "	vec2 wh = vec2(1.0/textureWidth,1.0/textureHeight) * dbsize;",
    "	offset[0] = vec2(-wh.x,-wh.y);",
    "	offset[1] = vec2( 0.0, -wh.y);",
    "	offset[2] = vec2( wh.x -wh.y);",
    "	offset[3] = vec2(-wh.x,  0.0);",
    "	offset[4] = vec2( 0.0,   0.0);",
    "	offset[5] = vec2( wh.x,  0.0);",
    "	offset[6] = vec2(-wh.x, wh.y);",
    "	offset[7] = vec2( 0.0,  wh.y);",
    "	offset[8] = vec2( wh.x, wh.y);",
    "	kernel[0] = 1.0/16.0;   kernel[1] = 2.0/16.0;   kernel[2] = 1.0/16.0;",
    "	kernel[3] = 2.0/16.0;   kernel[4] = 4.0/16.0;   kernel[5] = 2.0/16.0;",
    "	kernel[6] = 1.0/16.0;   kernel[7] = 2.0/16.0;   kernel[8] = 1.0/16.0;",
    "	for( int i=0; i<9; i++ ) {",
    "		float tmp = texture2D(tDepth, coords + offset[i]).r;",
    "		d += tmp * kernel[i];",
    "	}",
    "	return d;",
    "}",
    "vec3 color(vec2 coords,float blur) {",
    "	//processing the sample",
    "	vec3 col = vec3(0.0);",
    "	vec2 texel = vec2(1.0/textureWidth,1.0/textureHeight);",
    "	col.r = texture2D(tColor,coords + vec2(0.0,1.0)*texel*fringe*blur).r;",
    "	col.g = texture2D(tColor,coords + vec2(-0.866,-0.5)*texel*fringe*blur).g;",
    "	col.b = texture2D(tColor,coords + vec2(0.866,-0.5)*texel*fringe*blur).b;",
    "	vec3 lumcoeff = vec3(0.299,0.587,0.114);",
    "	float lum = dot(col.rgb, lumcoeff);",
    "	float thresh = max((lum-threshold)*gain, 0.0);",
    "	return col+mix(vec3(0.0),col,thresh*blur);",
    "}",
    "vec3 debugFocus(vec3 col, float blur, float depth) {",
    "	float edge = 0.002*depth; //distance based edge smoothing",
    "	float m = clamp(smoothstep(0.0,edge,blur),0.0,1.0);",
    "	float e = clamp(smoothstep(1.0-edge,1.0,blur),0.0,1.0);",
    "	col = mix(col,vec3(1.0,0.5,0.0),(1.0-m)*0.6);",
    "	col = mix(col,vec3(0.0,0.5,1.0),((1.0-e)-(1.0-m))*0.2);",
    "	return col;",
    "}",
    "float linearize(float depth) {",
    "	return -zfar * znear / (depth * (zfar - znear) - zfar);",
    "}",
    "float vignette() {",
    "	float dist = distance(vUv.xy, vec2(0.5,0.5));",
    "	dist = smoothstep(vignout+(fstop/vignfade), vignin+(fstop/vignfade), dist);",
    "	return clamp(dist,0.0,1.0);",
    "}",
    "float gather(float i, float j, int ringsamples, inout vec3 col, float w, float h, float blur) {",
    "	float rings2 = float(rings);",
    "	float step = PI*2.0 / float(ringsamples);",
    "	float pw = cos(j*step)*i;",
    "	float ph = sin(j*step)*i;",
    "	float p = 1.0;",
    "	if (pentagon) {",
    "		p = penta(vec2(pw,ph));",
    "	}",
    "	col += color(vUv.xy + vec2(pw*w,ph*h), blur) * mix(1.0, i/rings2, bias) * p;",
    "	return 1.0 * mix(1.0, i /rings2, bias) * p;",
    "}",
    "void main() {",
    "	//scene depth calculation",
    "	float depth = linearize(texture2D(tDepth,vUv.xy).x);",
    "	// Blur depth?",
    "	if ( depthblur ) {",
    "		depth = linearize(bdepth(vUv.xy));",
    "	}",
    "	//focal plane calculation",
    "	float fDepth = focalDepth;",
    "	if (shaderFocus) {",
    "		fDepth = linearize(texture2D(tDepth,focusCoords).x);",
    "	}",
    "	// dof blur factor calculation",
    "	float blur = 0.0;",
    "	if (manualdof) {",
    "		float a = depth-fDepth; // Focal plane",
    "		float b = (a-fdofstart)/fdofdist; // Far DoF",
    "		float c = (-a-ndofstart)/ndofdist; // Near Dof",
    "		blur = (a>0.0) ? b : c;",
    "	} else {",
    "		float f = focalLength; // focal length in mm",
    "		float d = fDepth*1000.0; // focal plane in mm",
    "		float o = depth*1000.0; // depth in mm",
    "		float a = (o*f)/(o-f);",
    "		float b = (d*f)/(d-f);",
    "		float c = (d-f)/(d*fstop*CoC);",
    "		blur = abs(a-b)*c;",
    "	}",
    "	blur = clamp(blur,0.0,1.0);",
    "	// calculation of pattern for dithering",
    "	vec2 noise = vec2(rand(vUv.xy), rand( vUv.xy + vec2( 0.4, 0.6 ) ) )*dithering*blur;",
    "	// getting blur x and y step factor",
    "	float w = (1.0/textureWidth)*blur*maxblur+noise.x;",
    "	float h = (1.0/textureHeight)*blur*maxblur+noise.y;",
    "	// calculation of final color",
    "	vec3 col = vec3(0.0);",
    "	if(blur < 0.05) {",
    "		//some optimization thingy",
    "		col = texture2D(tColor, vUv.xy).rgb;",
    "	} else {",
    "		col = texture2D(tColor, vUv.xy).rgb;",
    "		float s = 1.0;",
    "		int ringsamples;",
    "		for (int i = 1; i <= rings; i++) {",
    "			/*unboxstart*/",
    "			ringsamples = i * samples;",
    "			for (int j = 0 ; j < maxringsamples ; j++) {",
    "				if (j >= ringsamples) break;",
    "				s += gather(float(i), float(j), ringsamples, col, w, h, blur);",
    "			}",
    "			/*unboxend*/",
    "		}",
    "		col /= s; //divide by sample count",
    "	}",
    "	if (showFocus) {",
    "		col = debugFocus(col, blur, depth);",
    "	}",
    "	if (vignetting) {",
    "		col *= vignette();",
    "	}",
    "	gl_FragColor.rgb = col;",
    "	gl_FragColor.a = 1.0;",
    "} "
  ].join("\n")
};
var BokehDepthShader = {
  uniforms: {
    mNear: { value: 1 },
    mFar: { value: 1e3 }
  },
  vertexShader: [
    "varying float vViewZDepth;",
    "void main() {",
    "	#include <begin_vertex>",
    "	#include <project_vertex>",
    "	vViewZDepth = - mvPosition.z;",
    "}"
  ].join("\n"),
  fragmentShader: [
    "uniform float mNear;",
    "uniform float mFar;",
    "varying float vViewZDepth;",
    "void main() {",
    "	float color = 1.0 - smoothstep( mNear, mFar, vViewZDepth );",
    "	gl_FragColor = vec4( vec3( color ), 1.0 );",
    "} "
  ].join("\n")
};

// node_modules/three-stdlib/math/MeshSurfaceSampler.js
var _face = new Triangle();
var _color = new Vector3();
var MeshSurfaceSampler = class {
  constructor(mesh) {
    let geometry2 = mesh.geometry;
    if (geometry2.index) {
      console.warn("THREE.MeshSurfaceSampler: Converting geometry to non-indexed BufferGeometry.");
      geometry2 = geometry2.toNonIndexed();
    }
    this.geometry = geometry2;
    this.randomFunction = Math.random;
    this.positionAttribute = this.geometry.getAttribute("position");
    this.colorAttribute = this.geometry.getAttribute("color");
    this.weightAttribute = null;
    this.distribution = null;
  }
  setWeightAttribute(name) {
    this.weightAttribute = name ? this.geometry.getAttribute(name) : null;
    return this;
  }
  build() {
    const positionAttribute = this.positionAttribute;
    const weightAttribute = this.weightAttribute;
    const faceWeights = new Float32Array(positionAttribute.count / 3);
    for (let i3 = 0; i3 < positionAttribute.count; i3 += 3) {
      let faceWeight = 1;
      if (weightAttribute) {
        faceWeight = weightAttribute.getX(i3) + weightAttribute.getX(i3 + 1) + weightAttribute.getX(i3 + 2);
      }
      _face.a.fromBufferAttribute(positionAttribute, i3);
      _face.b.fromBufferAttribute(positionAttribute, i3 + 1);
      _face.c.fromBufferAttribute(positionAttribute, i3 + 2);
      faceWeight *= _face.getArea();
      faceWeights[i3 / 3] = faceWeight;
    }
    this.distribution = new Float32Array(positionAttribute.count / 3);
    let cumulativeTotal = 0;
    for (let i3 = 0; i3 < faceWeights.length; i3++) {
      cumulativeTotal += faceWeights[i3];
      this.distribution[i3] = cumulativeTotal;
    }
    return this;
  }
  setRandomGenerator(randomFunction) {
    this.randomFunction = randomFunction;
    return this;
  }
  sample(targetPosition2, targetNormal, targetColor) {
    const faceIndex = this.sampleFaceIndex();
    return this.sampleFace(faceIndex, targetPosition2, targetNormal, targetColor);
  }
  sampleFaceIndex() {
    const cumulativeTotal = this.distribution[this.distribution.length - 1];
    return this.binarySearch(this.randomFunction() * cumulativeTotal);
  }
  binarySearch(x) {
    const dist = this.distribution;
    let start = 0;
    let end = dist.length - 1;
    let index = -1;
    while (start <= end) {
      const mid = Math.ceil((start + end) / 2);
      if (mid === 0 || dist[mid - 1] <= x && dist[mid] > x) {
        index = mid;
        break;
      } else if (x < dist[mid]) {
        end = mid - 1;
      } else {
        start = mid + 1;
      }
    }
    return index;
  }
  sampleFace(faceIndex, targetPosition2, targetNormal, targetColor) {
    let u = this.randomFunction();
    let v = this.randomFunction();
    if (u + v > 1) {
      u = 1 - u;
      v = 1 - v;
    }
    _face.a.fromBufferAttribute(this.positionAttribute, faceIndex * 3);
    _face.b.fromBufferAttribute(this.positionAttribute, faceIndex * 3 + 1);
    _face.c.fromBufferAttribute(this.positionAttribute, faceIndex * 3 + 2);
    targetPosition2.set(0, 0, 0).addScaledVector(_face.a, u).addScaledVector(_face.b, v).addScaledVector(_face.c, 1 - (u + v));
    if (targetNormal !== void 0) {
      _face.getNormal(targetNormal);
    }
    if (targetColor !== void 0 && this.colorAttribute !== void 0) {
      _face.a.fromBufferAttribute(this.colorAttribute, faceIndex * 3);
      _face.b.fromBufferAttribute(this.colorAttribute, faceIndex * 3 + 1);
      _face.c.fromBufferAttribute(this.colorAttribute, faceIndex * 3 + 2);
      _color.set(0, 0, 0).addScaledVector(_face.a, u).addScaledVector(_face.b, v).addScaledVector(_face.c, 1 - (u + v));
      targetColor.r = _color.x;
      targetColor.g = _color.y;
      targetColor.b = _color.z;
    }
    return this;
  }
};

// node_modules/three-stdlib/math/OBB.js
var a2 = {
  c: null,
  // center
  u: [new Vector3(), new Vector3(), new Vector3()],
  // basis vectors
  e: []
  // half width
};
var b = {
  c: null,
  // center
  u: [new Vector3(), new Vector3(), new Vector3()],
  // basis vectors
  e: []
  // half width
};
var R = [[], [], []];
var AbsR = [[], [], []];
var t = [];
var xAxis = new Vector3();
var yAxis = new Vector3();
var zAxis = new Vector3();
var v1 = new Vector3();
var size = new Vector3();
var closestPoint = new Vector3();
var rotationMatrix = new Matrix3();
var aabb = new Box3();
var matrix2 = new Matrix4();
var inverse = new Matrix4();
var localRay = new Ray();
var OBB = class {
  constructor(center2 = new Vector3(), halfSize = new Vector3(), rotation = new Matrix3()) {
    this.center = center2;
    this.halfSize = halfSize;
    this.rotation = rotation;
  }
  set(center2, halfSize, rotation) {
    this.center = center2;
    this.halfSize = halfSize;
    this.rotation = rotation;
    return this;
  }
  copy(obb2) {
    this.center.copy(obb2.center);
    this.halfSize.copy(obb2.halfSize);
    this.rotation.copy(obb2.rotation);
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  getSize(result) {
    return result.copy(this.halfSize).multiplyScalar(2);
  }
  /**
   * Reference: Closest Point on OBB to Point in Real-Time Collision Detection
   * by Christer Ericson (chapter 5.1.4)
   */
  clampPoint(point, result) {
    const halfSize = this.halfSize;
    v1.subVectors(point, this.center);
    this.rotation.extractBasis(xAxis, yAxis, zAxis);
    result.copy(this.center);
    const x = MathUtils.clamp(v1.dot(xAxis), -halfSize.x, halfSize.x);
    result.add(xAxis.multiplyScalar(x));
    const y = MathUtils.clamp(v1.dot(yAxis), -halfSize.y, halfSize.y);
    result.add(yAxis.multiplyScalar(y));
    const z = MathUtils.clamp(v1.dot(zAxis), -halfSize.z, halfSize.z);
    result.add(zAxis.multiplyScalar(z));
    return result;
  }
  containsPoint(point) {
    v1.subVectors(point, this.center);
    this.rotation.extractBasis(xAxis, yAxis, zAxis);
    return Math.abs(v1.dot(xAxis)) <= this.halfSize.x && Math.abs(v1.dot(yAxis)) <= this.halfSize.y && Math.abs(v1.dot(zAxis)) <= this.halfSize.z;
  }
  intersectsBox3(box3) {
    return this.intersectsOBB(obb.fromBox3(box3));
  }
  intersectsSphere(sphere) {
    this.clampPoint(sphere.center, closestPoint);
    return closestPoint.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;
  }
  /**
   * Reference: OBB-OBB Intersection in Real-Time Collision Detection
   * by Christer Ericson (chapter 4.4.1)
   *
   */
  intersectsOBB(obb2, epsilon2 = Number.EPSILON) {
    a2.c = this.center;
    a2.e[0] = this.halfSize.x;
    a2.e[1] = this.halfSize.y;
    a2.e[2] = this.halfSize.z;
    this.rotation.extractBasis(a2.u[0], a2.u[1], a2.u[2]);
    b.c = obb2.center;
    b.e[0] = obb2.halfSize.x;
    b.e[1] = obb2.halfSize.y;
    b.e[2] = obb2.halfSize.z;
    obb2.rotation.extractBasis(b.u[0], b.u[1], b.u[2]);
    for (let i3 = 0; i3 < 3; i3++) {
      for (let j = 0; j < 3; j++) {
        R[i3][j] = a2.u[i3].dot(b.u[j]);
      }
    }
    v1.subVectors(b.c, a2.c);
    t[0] = v1.dot(a2.u[0]);
    t[1] = v1.dot(a2.u[1]);
    t[2] = v1.dot(a2.u[2]);
    for (let i3 = 0; i3 < 3; i3++) {
      for (let j = 0; j < 3; j++) {
        AbsR[i3][j] = Math.abs(R[i3][j]) + epsilon2;
      }
    }
    let ra, rb;
    for (let i3 = 0; i3 < 3; i3++) {
      ra = a2.e[i3];
      rb = b.e[0] * AbsR[i3][0] + b.e[1] * AbsR[i3][1] + b.e[2] * AbsR[i3][2];
      if (Math.abs(t[i3]) > ra + rb)
        return false;
    }
    for (let i3 = 0; i3 < 3; i3++) {
      ra = a2.e[0] * AbsR[0][i3] + a2.e[1] * AbsR[1][i3] + a2.e[2] * AbsR[2][i3];
      rb = b.e[i3];
      if (Math.abs(t[0] * R[0][i3] + t[1] * R[1][i3] + t[2] * R[2][i3]) > ra + rb)
        return false;
    }
    ra = a2.e[1] * AbsR[2][0] + a2.e[2] * AbsR[1][0];
    rb = b.e[1] * AbsR[0][2] + b.e[2] * AbsR[0][1];
    if (Math.abs(t[2] * R[1][0] - t[1] * R[2][0]) > ra + rb)
      return false;
    ra = a2.e[1] * AbsR[2][1] + a2.e[2] * AbsR[1][1];
    rb = b.e[0] * AbsR[0][2] + b.e[2] * AbsR[0][0];
    if (Math.abs(t[2] * R[1][1] - t[1] * R[2][1]) > ra + rb)
      return false;
    ra = a2.e[1] * AbsR[2][2] + a2.e[2] * AbsR[1][2];
    rb = b.e[0] * AbsR[0][1] + b.e[1] * AbsR[0][0];
    if (Math.abs(t[2] * R[1][2] - t[1] * R[2][2]) > ra + rb)
      return false;
    ra = a2.e[0] * AbsR[2][0] + a2.e[2] * AbsR[0][0];
    rb = b.e[1] * AbsR[1][2] + b.e[2] * AbsR[1][1];
    if (Math.abs(t[0] * R[2][0] - t[2] * R[0][0]) > ra + rb)
      return false;
    ra = a2.e[0] * AbsR[2][1] + a2.e[2] * AbsR[0][1];
    rb = b.e[0] * AbsR[1][2] + b.e[2] * AbsR[1][0];
    if (Math.abs(t[0] * R[2][1] - t[2] * R[0][1]) > ra + rb)
      return false;
    ra = a2.e[0] * AbsR[2][2] + a2.e[2] * AbsR[0][2];
    rb = b.e[0] * AbsR[1][1] + b.e[1] * AbsR[1][0];
    if (Math.abs(t[0] * R[2][2] - t[2] * R[0][2]) > ra + rb)
      return false;
    ra = a2.e[0] * AbsR[1][0] + a2.e[1] * AbsR[0][0];
    rb = b.e[1] * AbsR[2][2] + b.e[2] * AbsR[2][1];
    if (Math.abs(t[1] * R[0][0] - t[0] * R[1][0]) > ra + rb)
      return false;
    ra = a2.e[0] * AbsR[1][1] + a2.e[1] * AbsR[0][1];
    rb = b.e[0] * AbsR[2][2] + b.e[2] * AbsR[2][0];
    if (Math.abs(t[1] * R[0][1] - t[0] * R[1][1]) > ra + rb)
      return false;
    ra = a2.e[0] * AbsR[1][2] + a2.e[1] * AbsR[0][2];
    rb = b.e[0] * AbsR[2][1] + b.e[1] * AbsR[2][0];
    if (Math.abs(t[1] * R[0][2] - t[0] * R[1][2]) > ra + rb)
      return false;
    return true;
  }
  /**
   * Reference: Testing Box Against Plane in Real-Time Collision Detection
   * by Christer Ericson (chapter 5.2.3)
   */
  intersectsPlane(plane) {
    this.rotation.extractBasis(xAxis, yAxis, zAxis);
    const r = this.halfSize.x * Math.abs(plane.normal.dot(xAxis)) + this.halfSize.y * Math.abs(plane.normal.dot(yAxis)) + this.halfSize.z * Math.abs(plane.normal.dot(zAxis));
    const d = plane.normal.dot(this.center) - plane.constant;
    return Math.abs(d) <= r;
  }
  /**
   * Performs a ray/OBB intersection test and stores the intersection point
   * to the given 3D vector. If no intersection is detected, *null* is returned.
   */
  intersectRay(ray, result) {
    this.getSize(size);
    aabb.setFromCenterAndSize(v1.set(0, 0, 0), size);
    matrix2.setFromMatrix3(this.rotation);
    matrix2.setPosition(this.center);
    inverse.copy(matrix2).invert();
    localRay.copy(ray).applyMatrix4(inverse);
    if (localRay.intersectBox(aabb, result)) {
      return result.applyMatrix4(matrix2);
    } else {
      return null;
    }
  }
  /**
   * Performs a ray/OBB intersection test. Returns either true or false if
   * there is a intersection or not.
   */
  intersectsRay(ray) {
    return this.intersectRay(ray, v1) !== null;
  }
  fromBox3(box3) {
    box3.getCenter(this.center);
    box3.getSize(this.halfSize).multiplyScalar(0.5);
    this.rotation.identity();
    return this;
  }
  equals(obb2) {
    return obb2.center.equals(this.center) && obb2.halfSize.equals(this.halfSize) && obb2.rotation.equals(this.rotation);
  }
  applyMatrix4(matrix22) {
    const e = matrix22.elements;
    let sx = v1.set(e[0], e[1], e[2]).length();
    const sy = v1.set(e[4], e[5], e[6]).length();
    const sz = v1.set(e[8], e[9], e[10]).length();
    const det = matrix22.determinant();
    if (det < 0)
      sx = -sx;
    rotationMatrix.setFromMatrix4(matrix22);
    const invSX = 1 / sx;
    const invSY = 1 / sy;
    const invSZ = 1 / sz;
    rotationMatrix.elements[0] *= invSX;
    rotationMatrix.elements[1] *= invSX;
    rotationMatrix.elements[2] *= invSX;
    rotationMatrix.elements[3] *= invSY;
    rotationMatrix.elements[4] *= invSY;
    rotationMatrix.elements[5] *= invSY;
    rotationMatrix.elements[6] *= invSZ;
    rotationMatrix.elements[7] *= invSZ;
    rotationMatrix.elements[8] *= invSZ;
    this.rotation.multiply(rotationMatrix);
    this.halfSize.x *= sx;
    this.halfSize.y *= sy;
    this.halfSize.z *= sz;
    v1.setFromMatrixPosition(matrix22);
    this.center.add(v1);
    return this;
  }
};
var obb = new OBB();

// node_modules/three-stdlib/math/Capsule.js
var _v13 = new Vector3();
var _v2 = new Vector3();
var _v3 = new Vector3();
var EPS = 1e-10;
var Capsule = class {
  constructor(start = new Vector3(0, 0, 0), end = new Vector3(0, 1, 0), radius = 1) {
    this.start = start;
    this.end = end;
    this.radius = radius;
  }
  clone() {
    return new Capsule(this.start.clone(), this.end.clone(), this.radius);
  }
  set(start, end, radius) {
    this.start.copy(start);
    this.end.copy(end);
    this.radius = radius;
  }
  copy(capsule) {
    this.start.copy(capsule.start);
    this.end.copy(capsule.end);
    this.radius = capsule.radius;
  }
  getCenter(target) {
    return target.copy(this.end).add(this.start).multiplyScalar(0.5);
  }
  translate(v) {
    this.start.add(v);
    this.end.add(v);
  }
  checkAABBAxis(p1x, p1y, p2x, p2y, minx, maxx, miny, maxy, radius) {
    return (minx - p1x < radius || minx - p2x < radius) && (p1x - maxx < radius || p2x - maxx < radius) && (miny - p1y < radius || miny - p2y < radius) && (p1y - maxy < radius || p2y - maxy < radius);
  }
  intersectsBox(box) {
    return this.checkAABBAxis(
      this.start.x,
      this.start.y,
      this.end.x,
      this.end.y,
      box.min.x,
      box.max.x,
      box.min.y,
      box.max.y,
      this.radius
    ) && this.checkAABBAxis(
      this.start.x,
      this.start.z,
      this.end.x,
      this.end.z,
      box.min.x,
      box.max.x,
      box.min.z,
      box.max.z,
      this.radius
    ) && this.checkAABBAxis(
      this.start.y,
      this.start.z,
      this.end.y,
      this.end.z,
      box.min.y,
      box.max.y,
      box.min.z,
      box.max.z,
      this.radius
    );
  }
  lineLineMinimumPoints(line1, line2) {
    const r = _v13.copy(line1.end).sub(line1.start);
    const s = _v2.copy(line2.end).sub(line2.start);
    const w = _v3.copy(line2.start).sub(line1.start);
    const a4 = r.dot(s), b5 = r.dot(r), c3 = s.dot(s), d = s.dot(w), e = r.dot(w);
    let t1, t2;
    const divisor = b5 * c3 - a4 * a4;
    if (Math.abs(divisor) < EPS) {
      const d1 = -d / c3;
      const d2 = (a4 - d) / c3;
      if (Math.abs(d1 - 0.5) < Math.abs(d2 - 0.5)) {
        t1 = 0;
        t2 = d1;
      } else {
        t1 = 1;
        t2 = d2;
      }
    } else {
      t1 = (d * a4 + e * c3) / divisor;
      t2 = (t1 * a4 - d) / c3;
    }
    t2 = Math.max(0, Math.min(1, t2));
    t1 = Math.max(0, Math.min(1, t1));
    const point1 = r.multiplyScalar(t1).add(line1.start);
    const point2 = s.multiplyScalar(t2).add(line2.start);
    return [point1, point2];
  }
};

// node_modules/three-stdlib/math/ImprovedNoise.js
function init() {
  const _p2 = [
    151,
    160,
    137,
    91,
    90,
    15,
    131,
    13,
    201,
    95,
    96,
    53,
    194,
    233,
    7,
    225,
    140,
    36,
    103,
    30,
    69,
    142,
    8,
    99,
    37,
    240,
    21,
    10,
    23,
    190,
    6,
    148,
    247,
    120,
    234,
    75,
    0,
    26,
    197,
    62,
    94,
    252,
    219,
    203,
    117,
    35,
    11,
    32,
    57,
    177,
    33,
    88,
    237,
    149,
    56,
    87,
    174,
    20,
    125,
    136,
    171,
    168,
    68,
    175,
    74,
    165,
    71,
    134,
    139,
    48,
    27,
    166,
    77,
    146,
    158,
    231,
    83,
    111,
    229,
    122,
    60,
    211,
    133,
    230,
    220,
    105,
    92,
    41,
    55,
    46,
    245,
    40,
    244,
    102,
    143,
    54,
    65,
    25,
    63,
    161,
    1,
    216,
    80,
    73,
    209,
    76,
    132,
    187,
    208,
    89,
    18,
    169,
    200,
    196,
    135,
    130,
    116,
    188,
    159,
    86,
    164,
    100,
    109,
    198,
    173,
    186,
    3,
    64,
    52,
    217,
    226,
    250,
    124,
    123,
    5,
    202,
    38,
    147,
    118,
    126,
    255,
    82,
    85,
    212,
    207,
    206,
    59,
    227,
    47,
    16,
    58,
    17,
    182,
    189,
    28,
    42,
    223,
    183,
    170,
    213,
    119,
    248,
    152,
    2,
    44,
    154,
    163,
    70,
    221,
    153,
    101,
    155,
    167,
    43,
    172,
    9,
    129,
    22,
    39,
    253,
    19,
    98,
    108,
    110,
    79,
    113,
    224,
    232,
    178,
    185,
    112,
    104,
    218,
    246,
    97,
    228,
    251,
    34,
    242,
    193,
    238,
    210,
    144,
    12,
    191,
    179,
    162,
    241,
    81,
    51,
    145,
    235,
    249,
    14,
    239,
    107,
    49,
    192,
    214,
    31,
    181,
    199,
    106,
    157,
    184,
    84,
    204,
    176,
    115,
    121,
    50,
    45,
    127,
    4,
    150,
    254,
    138,
    236,
    205,
    93,
    222,
    114,
    67,
    29,
    24,
    72,
    243,
    141,
    128,
    195,
    78,
    66,
    215,
    61,
    156,
    180
  ];
  for (let i3 = 0; i3 < 256; i3++) {
    _p2[256 + i3] = _p2[i3];
  }
  return _p2;
}
var _p = init();

// node_modules/three-stdlib/math/Octree.js
var _v14 = new Vector3();
var _v22 = new Vector3();
var _plane2 = new Plane();
var _line1 = new Line3();
var _line2 = new Line3();
var _sphere = new Sphere();
var _capsule = new Capsule();

// node_modules/three-stdlib/controls/experimental/CameraControls.js
var STATE = ((STATE22) => {
  STATE22[STATE22["NONE"] = -1] = "NONE";
  STATE22[STATE22["ROTATE"] = 0] = "ROTATE";
  STATE22[STATE22["DOLLY"] = 1] = "DOLLY";
  STATE22[STATE22["PAN"] = 2] = "PAN";
  STATE22[STATE22["TOUCH_ROTATE"] = 3] = "TOUCH_ROTATE";
  STATE22[STATE22["TOUCH_PAN"] = 4] = "TOUCH_PAN";
  STATE22[STATE22["TOUCH_DOLLY_PAN"] = 5] = "TOUCH_DOLLY_PAN";
  STATE22[STATE22["TOUCH_DOLLY_ROTATE"] = 6] = "TOUCH_DOLLY_ROTATE";
  return STATE22;
})(STATE || {});

// node_modules/three-stdlib/controls/FirstPersonControls.js
var targetPosition = new Vector3();

// node_modules/three-stdlib/controls/PointerLockControls.js
var _euler = new Euler(0, 0, 0, "YXZ");
var _vector3 = new Vector3();
var _PI_2 = Math.PI / 2;

// node_modules/three-stdlib/controls/OrbitControls.js
var __defProp10 = Object.defineProperty;
var __defNormalProp10 = (obj, key, value) => key in obj ? __defProp10(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField11 = (obj, key, value) => {
  __defNormalProp10(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var moduloWrapAround = (offset, capacity) => (offset % capacity + capacity) % capacity;
var OrbitControls = class extends EventDispatcher {
  constructor(object, domElement) {
    super();
    __publicField11(this, "object");
    __publicField11(this, "domElement");
    __publicField11(this, "enabled", true);
    __publicField11(this, "target", new Vector3());
    __publicField11(this, "minDistance", 0);
    __publicField11(this, "maxDistance", Infinity);
    __publicField11(this, "minZoom", 0);
    __publicField11(this, "maxZoom", Infinity);
    __publicField11(this, "minPolarAngle", 0);
    __publicField11(this, "maxPolarAngle", Math.PI);
    __publicField11(this, "minAzimuthAngle", -Infinity);
    __publicField11(this, "maxAzimuthAngle", Infinity);
    __publicField11(this, "enableDamping", false);
    __publicField11(this, "dampingFactor", 0.05);
    __publicField11(this, "enableZoom", true);
    __publicField11(this, "zoomSpeed", 1);
    __publicField11(this, "enableRotate", true);
    __publicField11(this, "rotateSpeed", 1);
    __publicField11(this, "enablePan", true);
    __publicField11(this, "panSpeed", 1);
    __publicField11(this, "screenSpacePanning", true);
    __publicField11(this, "keyPanSpeed", 7);
    __publicField11(this, "autoRotate", false);
    __publicField11(this, "autoRotateSpeed", 2);
    __publicField11(this, "reverseOrbit", false);
    __publicField11(this, "keys", { LEFT: "ArrowLeft", UP: "ArrowUp", RIGHT: "ArrowRight", BOTTOM: "ArrowDown" });
    __publicField11(this, "mouseButtons", {
      LEFT: MOUSE.ROTATE,
      MIDDLE: MOUSE.DOLLY,
      RIGHT: MOUSE.PAN
    });
    __publicField11(this, "touches", { ONE: TOUCH.ROTATE, TWO: TOUCH.DOLLY_PAN });
    __publicField11(this, "target0");
    __publicField11(this, "position0");
    __publicField11(this, "zoom0");
    __publicField11(this, "_domElementKeyEvents", null);
    __publicField11(this, "getPolarAngle");
    __publicField11(this, "getAzimuthalAngle");
    __publicField11(this, "setPolarAngle");
    __publicField11(this, "setAzimuthalAngle");
    __publicField11(this, "getDistance");
    __publicField11(this, "listenToKeyEvents");
    __publicField11(this, "saveState");
    __publicField11(this, "reset");
    __publicField11(this, "update");
    __publicField11(this, "connect");
    __publicField11(this, "dispose");
    this.object = object;
    this.domElement = domElement;
    this.target0 = this.target.clone();
    this.position0 = this.object.position.clone();
    this.zoom0 = this.object.zoom;
    this.getPolarAngle = () => spherical.phi;
    this.getAzimuthalAngle = () => spherical.theta;
    this.setPolarAngle = (value) => {
      let phi = moduloWrapAround(value, 2 * Math.PI);
      let currentPhi = spherical.phi;
      if (currentPhi < 0)
        currentPhi += 2 * Math.PI;
      if (phi < 0)
        phi += 2 * Math.PI;
      let phiDist = Math.abs(phi - currentPhi);
      if (2 * Math.PI - phiDist < phiDist) {
        if (phi < currentPhi) {
          phi += 2 * Math.PI;
        } else {
          currentPhi += 2 * Math.PI;
        }
      }
      sphericalDelta.phi = phi - currentPhi;
      scope.update();
    };
    this.setAzimuthalAngle = (value) => {
      let theta = moduloWrapAround(value, 2 * Math.PI);
      let currentTheta = spherical.theta;
      if (currentTheta < 0)
        currentTheta += 2 * Math.PI;
      if (theta < 0)
        theta += 2 * Math.PI;
      let thetaDist = Math.abs(theta - currentTheta);
      if (2 * Math.PI - thetaDist < thetaDist) {
        if (theta < currentTheta) {
          theta += 2 * Math.PI;
        } else {
          currentTheta += 2 * Math.PI;
        }
      }
      sphericalDelta.theta = theta - currentTheta;
      scope.update();
    };
    this.getDistance = () => scope.object.position.distanceTo(scope.target);
    this.listenToKeyEvents = (domElement2) => {
      domElement2.addEventListener("keydown", onKeyDown);
      this._domElementKeyEvents = domElement2;
    };
    this.saveState = () => {
      scope.target0.copy(scope.target);
      scope.position0.copy(scope.object.position);
      scope.zoom0 = scope.object.zoom;
    };
    this.reset = () => {
      scope.target.copy(scope.target0);
      scope.object.position.copy(scope.position0);
      scope.object.zoom = scope.zoom0;
      scope.object.updateProjectionMatrix();
      scope.dispatchEvent(changeEvent);
      scope.update();
      state = STATE3.NONE;
    };
    this.update = (() => {
      const offset = new Vector3();
      const quat = new Quaternion().setFromUnitVectors(object.up, new Vector3(0, 1, 0));
      const quatInverse = quat.clone().invert();
      const lastPosition = new Vector3();
      const lastQuaternion = new Quaternion();
      const twoPI = 2 * Math.PI;
      return function update() {
        const position = scope.object.position;
        offset.copy(position).sub(scope.target);
        offset.applyQuaternion(quat);
        spherical.setFromVector3(offset);
        if (scope.autoRotate && state === STATE3.NONE) {
          rotateLeft(getAutoRotationAngle());
        }
        if (scope.enableDamping) {
          spherical.theta += sphericalDelta.theta * scope.dampingFactor;
          spherical.phi += sphericalDelta.phi * scope.dampingFactor;
        } else {
          spherical.theta += sphericalDelta.theta;
          spherical.phi += sphericalDelta.phi;
        }
        let min = scope.minAzimuthAngle;
        let max3 = scope.maxAzimuthAngle;
        if (isFinite(min) && isFinite(max3)) {
          if (min < -Math.PI)
            min += twoPI;
          else if (min > Math.PI)
            min -= twoPI;
          if (max3 < -Math.PI)
            max3 += twoPI;
          else if (max3 > Math.PI)
            max3 -= twoPI;
          if (min <= max3) {
            spherical.theta = Math.max(min, Math.min(max3, spherical.theta));
          } else {
            spherical.theta = spherical.theta > (min + max3) / 2 ? Math.max(min, spherical.theta) : Math.min(max3, spherical.theta);
          }
        }
        spherical.phi = Math.max(scope.minPolarAngle, Math.min(scope.maxPolarAngle, spherical.phi));
        spherical.makeSafe();
        spherical.radius *= scale;
        spherical.radius = Math.max(scope.minDistance, Math.min(scope.maxDistance, spherical.radius));
        if (scope.enableDamping === true) {
          scope.target.addScaledVector(panOffset, scope.dampingFactor);
        } else {
          scope.target.add(panOffset);
        }
        offset.setFromSpherical(spherical);
        offset.applyQuaternion(quatInverse);
        position.copy(scope.target).add(offset);
        scope.object.lookAt(scope.target);
        if (scope.enableDamping === true) {
          sphericalDelta.theta *= 1 - scope.dampingFactor;
          sphericalDelta.phi *= 1 - scope.dampingFactor;
          panOffset.multiplyScalar(1 - scope.dampingFactor);
        } else {
          sphericalDelta.set(0, 0, 0);
          panOffset.set(0, 0, 0);
        }
        scale = 1;
        if (zoomChanged || lastPosition.distanceToSquared(scope.object.position) > EPS2 || 8 * (1 - lastQuaternion.dot(scope.object.quaternion)) > EPS2) {
          scope.dispatchEvent(changeEvent);
          lastPosition.copy(scope.object.position);
          lastQuaternion.copy(scope.object.quaternion);
          zoomChanged = false;
          return true;
        }
        return false;
      };
    })();
    this.connect = (domElement2) => {
      if (domElement2 === document) {
        console.error(
          'THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'
        );
      }
      scope.domElement = domElement2;
      scope.domElement.style.touchAction = "none";
      scope.domElement.addEventListener("contextmenu", onContextMenu);
      scope.domElement.addEventListener("pointerdown", onPointerDown);
      scope.domElement.addEventListener("pointercancel", onPointerCancel);
      scope.domElement.addEventListener("wheel", onMouseWheel);
    };
    this.dispose = () => {
      var _a4, _b4, _c, _d, _e, _f;
      (_a4 = scope.domElement) == null ? void 0 : _a4.removeEventListener("contextmenu", onContextMenu);
      (_b4 = scope.domElement) == null ? void 0 : _b4.removeEventListener("pointerdown", onPointerDown);
      (_c = scope.domElement) == null ? void 0 : _c.removeEventListener("pointercancel", onPointerCancel);
      (_d = scope.domElement) == null ? void 0 : _d.removeEventListener("wheel", onMouseWheel);
      (_e = scope.domElement) == null ? void 0 : _e.ownerDocument.removeEventListener("pointermove", onPointerMove);
      (_f = scope.domElement) == null ? void 0 : _f.ownerDocument.removeEventListener("pointerup", onPointerUp);
      if (scope._domElementKeyEvents !== null) {
        scope._domElementKeyEvents.removeEventListener("keydown", onKeyDown);
      }
    };
    const scope = this;
    const changeEvent = { type: "change" };
    const startEvent = { type: "start" };
    const endEvent = { type: "end" };
    const STATE3 = {
      NONE: -1,
      ROTATE: 0,
      DOLLY: 1,
      PAN: 2,
      TOUCH_ROTATE: 3,
      TOUCH_PAN: 4,
      TOUCH_DOLLY_PAN: 5,
      TOUCH_DOLLY_ROTATE: 6
    };
    let state = STATE3.NONE;
    const EPS2 = 1e-6;
    const spherical = new Spherical();
    const sphericalDelta = new Spherical();
    let scale = 1;
    const panOffset = new Vector3();
    let zoomChanged = false;
    const rotateStart = new Vector2();
    const rotateEnd = new Vector2();
    const rotateDelta = new Vector2();
    const panStart = new Vector2();
    const panEnd = new Vector2();
    const panDelta = new Vector2();
    const dollyStart = new Vector2();
    const dollyEnd = new Vector2();
    const dollyDelta = new Vector2();
    const pointers = [];
    const pointerPositions = {};
    function getAutoRotationAngle() {
      return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;
    }
    function getZoomScale() {
      return Math.pow(0.95, scope.zoomSpeed);
    }
    function rotateLeft(angle2) {
      if (scope.reverseOrbit) {
        sphericalDelta.theta += angle2;
      } else {
        sphericalDelta.theta -= angle2;
      }
    }
    function rotateUp(angle2) {
      if (scope.reverseOrbit) {
        sphericalDelta.phi += angle2;
      } else {
        sphericalDelta.phi -= angle2;
      }
    }
    const panLeft = (() => {
      const v = new Vector3();
      return function panLeft2(distance2, objectMatrix) {
        v.setFromMatrixColumn(objectMatrix, 0);
        v.multiplyScalar(-distance2);
        panOffset.add(v);
      };
    })();
    const panUp = (() => {
      const v = new Vector3();
      return function panUp2(distance2, objectMatrix) {
        if (scope.screenSpacePanning === true) {
          v.setFromMatrixColumn(objectMatrix, 1);
        } else {
          v.setFromMatrixColumn(objectMatrix, 0);
          v.crossVectors(scope.object.up, v);
        }
        v.multiplyScalar(distance2);
        panOffset.add(v);
      };
    })();
    const pan = (() => {
      const offset = new Vector3();
      return function pan2(deltaX, deltaY) {
        const element = scope.domElement;
        if (element && scope.object instanceof PerspectiveCamera && scope.object.isPerspectiveCamera) {
          const position = scope.object.position;
          offset.copy(position).sub(scope.target);
          let targetDistance = offset.length();
          targetDistance *= Math.tan(scope.object.fov / 2 * Math.PI / 180);
          panLeft(2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix);
          panUp(2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix);
        } else if (element && scope.object instanceof OrthographicCamera && scope.object.isOrthographicCamera) {
          panLeft(
            deltaX * (scope.object.right - scope.object.left) / scope.object.zoom / element.clientWidth,
            scope.object.matrix
          );
          panUp(
            deltaY * (scope.object.top - scope.object.bottom) / scope.object.zoom / element.clientHeight,
            scope.object.matrix
          );
        } else {
          console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.");
          scope.enablePan = false;
        }
      };
    })();
    function dollyOut(dollyScale) {
      if (scope.object instanceof PerspectiveCamera && scope.object.isPerspectiveCamera) {
        scale /= dollyScale;
      } else if (scope.object instanceof OrthographicCamera && scope.object.isOrthographicCamera) {
        scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom * dollyScale));
        scope.object.updateProjectionMatrix();
        zoomChanged = true;
      } else {
        console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.");
        scope.enableZoom = false;
      }
    }
    function dollyIn(dollyScale) {
      if (scope.object instanceof PerspectiveCamera && scope.object.isPerspectiveCamera) {
        scale *= dollyScale;
      } else if (scope.object instanceof OrthographicCamera && scope.object.isOrthographicCamera) {
        scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom / dollyScale));
        scope.object.updateProjectionMatrix();
        zoomChanged = true;
      } else {
        console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.");
        scope.enableZoom = false;
      }
    }
    function handleMouseDownRotate(event) {
      rotateStart.set(event.clientX, event.clientY);
    }
    function handleMouseDownDolly(event) {
      dollyStart.set(event.clientX, event.clientY);
    }
    function handleMouseDownPan(event) {
      panStart.set(event.clientX, event.clientY);
    }
    function handleMouseMoveRotate(event) {
      rotateEnd.set(event.clientX, event.clientY);
      rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed);
      const element = scope.domElement;
      if (element) {
        rotateLeft(2 * Math.PI * rotateDelta.x / element.clientHeight);
        rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight);
      }
      rotateStart.copy(rotateEnd);
      scope.update();
    }
    function handleMouseMoveDolly(event) {
      dollyEnd.set(event.clientX, event.clientY);
      dollyDelta.subVectors(dollyEnd, dollyStart);
      if (dollyDelta.y > 0) {
        dollyOut(getZoomScale());
      } else if (dollyDelta.y < 0) {
        dollyIn(getZoomScale());
      }
      dollyStart.copy(dollyEnd);
      scope.update();
    }
    function handleMouseMovePan(event) {
      panEnd.set(event.clientX, event.clientY);
      panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);
      pan(panDelta.x, panDelta.y);
      panStart.copy(panEnd);
      scope.update();
    }
    function handleMouseWheel(event) {
      if (event.deltaY < 0) {
        dollyIn(getZoomScale());
      } else if (event.deltaY > 0) {
        dollyOut(getZoomScale());
      }
      scope.update();
    }
    function handleKeyDown(event) {
      let needsUpdate = false;
      switch (event.code) {
        case scope.keys.UP:
          pan(0, scope.keyPanSpeed);
          needsUpdate = true;
          break;
        case scope.keys.BOTTOM:
          pan(0, -scope.keyPanSpeed);
          needsUpdate = true;
          break;
        case scope.keys.LEFT:
          pan(scope.keyPanSpeed, 0);
          needsUpdate = true;
          break;
        case scope.keys.RIGHT:
          pan(-scope.keyPanSpeed, 0);
          needsUpdate = true;
          break;
      }
      if (needsUpdate) {
        event.preventDefault();
        scope.update();
      }
    }
    function handleTouchStartRotate() {
      if (pointers.length == 1) {
        rotateStart.set(pointers[0].pageX, pointers[0].pageY);
      } else {
        const x = 0.5 * (pointers[0].pageX + pointers[1].pageX);
        const y = 0.5 * (pointers[0].pageY + pointers[1].pageY);
        rotateStart.set(x, y);
      }
    }
    function handleTouchStartPan() {
      if (pointers.length == 1) {
        panStart.set(pointers[0].pageX, pointers[0].pageY);
      } else {
        const x = 0.5 * (pointers[0].pageX + pointers[1].pageX);
        const y = 0.5 * (pointers[0].pageY + pointers[1].pageY);
        panStart.set(x, y);
      }
    }
    function handleTouchStartDolly() {
      const dx = pointers[0].pageX - pointers[1].pageX;
      const dy = pointers[0].pageY - pointers[1].pageY;
      const distance2 = Math.sqrt(dx * dx + dy * dy);
      dollyStart.set(0, distance2);
    }
    function handleTouchStartDollyPan() {
      if (scope.enableZoom)
        handleTouchStartDolly();
      if (scope.enablePan)
        handleTouchStartPan();
    }
    function handleTouchStartDollyRotate() {
      if (scope.enableZoom)
        handleTouchStartDolly();
      if (scope.enableRotate)
        handleTouchStartRotate();
    }
    function handleTouchMoveRotate(event) {
      if (pointers.length == 1) {
        rotateEnd.set(event.pageX, event.pageY);
      } else {
        const position = getSecondPointerPosition(event);
        const x = 0.5 * (event.pageX + position.x);
        const y = 0.5 * (event.pageY + position.y);
        rotateEnd.set(x, y);
      }
      rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed);
      const element = scope.domElement;
      if (element) {
        rotateLeft(2 * Math.PI * rotateDelta.x / element.clientHeight);
        rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight);
      }
      rotateStart.copy(rotateEnd);
    }
    function handleTouchMovePan(event) {
      if (pointers.length == 1) {
        panEnd.set(event.pageX, event.pageY);
      } else {
        const position = getSecondPointerPosition(event);
        const x = 0.5 * (event.pageX + position.x);
        const y = 0.5 * (event.pageY + position.y);
        panEnd.set(x, y);
      }
      panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);
      pan(panDelta.x, panDelta.y);
      panStart.copy(panEnd);
    }
    function handleTouchMoveDolly(event) {
      const position = getSecondPointerPosition(event);
      const dx = event.pageX - position.x;
      const dy = event.pageY - position.y;
      const distance2 = Math.sqrt(dx * dx + dy * dy);
      dollyEnd.set(0, distance2);
      dollyDelta.set(0, Math.pow(dollyEnd.y / dollyStart.y, scope.zoomSpeed));
      dollyOut(dollyDelta.y);
      dollyStart.copy(dollyEnd);
    }
    function handleTouchMoveDollyPan(event) {
      if (scope.enableZoom)
        handleTouchMoveDolly(event);
      if (scope.enablePan)
        handleTouchMovePan(event);
    }
    function handleTouchMoveDollyRotate(event) {
      if (scope.enableZoom)
        handleTouchMoveDolly(event);
      if (scope.enableRotate)
        handleTouchMoveRotate(event);
    }
    function onPointerDown(event) {
      var _a4, _b4;
      if (scope.enabled === false)
        return;
      if (pointers.length === 0) {
        (_a4 = scope.domElement) == null ? void 0 : _a4.ownerDocument.addEventListener("pointermove", onPointerMove);
        (_b4 = scope.domElement) == null ? void 0 : _b4.ownerDocument.addEventListener("pointerup", onPointerUp);
      }
      addPointer(event);
      if (event.pointerType === "touch") {
        onTouchStart(event);
      } else {
        onMouseDown(event);
      }
    }
    function onPointerMove(event) {
      if (scope.enabled === false)
        return;
      if (event.pointerType === "touch") {
        onTouchMove(event);
      } else {
        onMouseMove(event);
      }
    }
    function onPointerUp(event) {
      var _a4, _b4, _c;
      removePointer(event);
      if (pointers.length === 0) {
        (_a4 = scope.domElement) == null ? void 0 : _a4.releasePointerCapture(event.pointerId);
        (_b4 = scope.domElement) == null ? void 0 : _b4.ownerDocument.removeEventListener("pointermove", onPointerMove);
        (_c = scope.domElement) == null ? void 0 : _c.ownerDocument.removeEventListener("pointerup", onPointerUp);
      }
      scope.dispatchEvent(endEvent);
      state = STATE3.NONE;
    }
    function onPointerCancel(event) {
      removePointer(event);
    }
    function onMouseDown(event) {
      let mouseAction;
      switch (event.button) {
        case 0:
          mouseAction = scope.mouseButtons.LEFT;
          break;
        case 1:
          mouseAction = scope.mouseButtons.MIDDLE;
          break;
        case 2:
          mouseAction = scope.mouseButtons.RIGHT;
          break;
        default:
          mouseAction = -1;
      }
      switch (mouseAction) {
        case MOUSE.DOLLY:
          if (scope.enableZoom === false)
            return;
          handleMouseDownDolly(event);
          state = STATE3.DOLLY;
          break;
        case MOUSE.ROTATE:
          if (event.ctrlKey || event.metaKey || event.shiftKey) {
            if (scope.enablePan === false)
              return;
            handleMouseDownPan(event);
            state = STATE3.PAN;
          } else {
            if (scope.enableRotate === false)
              return;
            handleMouseDownRotate(event);
            state = STATE3.ROTATE;
          }
          break;
        case MOUSE.PAN:
          if (event.ctrlKey || event.metaKey || event.shiftKey) {
            if (scope.enableRotate === false)
              return;
            handleMouseDownRotate(event);
            state = STATE3.ROTATE;
          } else {
            if (scope.enablePan === false)
              return;
            handleMouseDownPan(event);
            state = STATE3.PAN;
          }
          break;
        default:
          state = STATE3.NONE;
      }
      if (state !== STATE3.NONE) {
        scope.dispatchEvent(startEvent);
      }
    }
    function onMouseMove(event) {
      if (scope.enabled === false)
        return;
      switch (state) {
        case STATE3.ROTATE:
          if (scope.enableRotate === false)
            return;
          handleMouseMoveRotate(event);
          break;
        case STATE3.DOLLY:
          if (scope.enableZoom === false)
            return;
          handleMouseMoveDolly(event);
          break;
        case STATE3.PAN:
          if (scope.enablePan === false)
            return;
          handleMouseMovePan(event);
          break;
      }
    }
    function onMouseWheel(event) {
      if (scope.enabled === false || scope.enableZoom === false || state !== STATE3.NONE && state !== STATE3.ROTATE) {
        return;
      }
      event.preventDefault();
      scope.dispatchEvent(startEvent);
      handleMouseWheel(event);
      scope.dispatchEvent(endEvent);
    }
    function onKeyDown(event) {
      if (scope.enabled === false || scope.enablePan === false)
        return;
      handleKeyDown(event);
    }
    function onTouchStart(event) {
      trackPointer(event);
      switch (pointers.length) {
        case 1:
          switch (scope.touches.ONE) {
            case TOUCH.ROTATE:
              if (scope.enableRotate === false)
                return;
              handleTouchStartRotate();
              state = STATE3.TOUCH_ROTATE;
              break;
            case TOUCH.PAN:
              if (scope.enablePan === false)
                return;
              handleTouchStartPan();
              state = STATE3.TOUCH_PAN;
              break;
            default:
              state = STATE3.NONE;
          }
          break;
        case 2:
          switch (scope.touches.TWO) {
            case TOUCH.DOLLY_PAN:
              if (scope.enableZoom === false && scope.enablePan === false)
                return;
              handleTouchStartDollyPan();
              state = STATE3.TOUCH_DOLLY_PAN;
              break;
            case TOUCH.DOLLY_ROTATE:
              if (scope.enableZoom === false && scope.enableRotate === false)
                return;
              handleTouchStartDollyRotate();
              state = STATE3.TOUCH_DOLLY_ROTATE;
              break;
            default:
              state = STATE3.NONE;
          }
          break;
        default:
          state = STATE3.NONE;
      }
      if (state !== STATE3.NONE) {
        scope.dispatchEvent(startEvent);
      }
    }
    function onTouchMove(event) {
      trackPointer(event);
      switch (state) {
        case STATE3.TOUCH_ROTATE:
          if (scope.enableRotate === false)
            return;
          handleTouchMoveRotate(event);
          scope.update();
          break;
        case STATE3.TOUCH_PAN:
          if (scope.enablePan === false)
            return;
          handleTouchMovePan(event);
          scope.update();
          break;
        case STATE3.TOUCH_DOLLY_PAN:
          if (scope.enableZoom === false && scope.enablePan === false)
            return;
          handleTouchMoveDollyPan(event);
          scope.update();
          break;
        case STATE3.TOUCH_DOLLY_ROTATE:
          if (scope.enableZoom === false && scope.enableRotate === false)
            return;
          handleTouchMoveDollyRotate(event);
          scope.update();
          break;
        default:
          state = STATE3.NONE;
      }
    }
    function onContextMenu(event) {
      if (scope.enabled === false)
        return;
      event.preventDefault();
    }
    function addPointer(event) {
      pointers.push(event);
    }
    function removePointer(event) {
      delete pointerPositions[event.pointerId];
      for (let i3 = 0; i3 < pointers.length; i3++) {
        if (pointers[i3].pointerId == event.pointerId) {
          pointers.splice(i3, 1);
          return;
        }
      }
    }
    function trackPointer(event) {
      let position = pointerPositions[event.pointerId];
      if (position === void 0) {
        position = new Vector2();
        pointerPositions[event.pointerId] = position;
      }
      position.set(event.pageX, event.pageY);
    }
    function getSecondPointerPosition(event) {
      const pointer = event.pointerId === pointers[0].pointerId ? pointers[1] : pointers[0];
      return pointerPositions[pointer.pointerId];
    }
    if (domElement !== void 0)
      this.connect(domElement);
    this.update();
  }
};

// node_modules/three-stdlib/controls/ArcballControls.js
var STATE2 = {
  IDLE: Symbol(),
  ROTATE: Symbol(),
  PAN: Symbol(),
  SCALE: Symbol(),
  FOV: Symbol(),
  FOCUS: Symbol(),
  ZROTATE: Symbol(),
  TOUCH_MULTI: Symbol(),
  ANIMATION_FOCUS: Symbol(),
  ANIMATION_ROTATE: Symbol()
};
var INPUT = {
  NONE: Symbol(),
  ONE_FINGER: Symbol(),
  ONE_FINGER_SWITCHED: Symbol(),
  TWO_FINGER: Symbol(),
  MULT_FINGER: Symbol(),
  CURSOR: Symbol()
};
var _transformation = {
  camera: new Matrix4(),
  gizmos: new Matrix4()
};

// node_modules/three-stdlib/postprocessing/Pass.js
var __defProp11 = Object.defineProperty;
var __defNormalProp11 = (obj, key, value) => key in obj ? __defProp11(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField12 = (obj, key, value) => {
  __defNormalProp11(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var Pass = class {
  constructor() {
    __publicField12(this, "enabled", true);
    __publicField12(this, "needsSwap", true);
    __publicField12(this, "clear", false);
    __publicField12(this, "renderToScreen", false);
  }
  setSize(width, height) {
  }
  render(renderer, writeBuffer, readBuffer, deltaTime, maskActive) {
    console.error("THREE.Pass: .render() must be implemented in derived pass.");
  }
};
var FullScreenQuad = class {
  constructor(material2) {
    __publicField12(this, "camera", new OrthographicCamera(-1, 1, 1, -1, 0, 1));
    __publicField12(this, "geometry", new PlaneGeometry(2, 2));
    __publicField12(this, "mesh");
    this.mesh = new Mesh(this.geometry, material2);
  }
  get material() {
    return this.mesh.material;
  }
  set material(value) {
    this.mesh.material = value;
  }
  dispose() {
    this.mesh.geometry.dispose();
  }
  render(renderer) {
    renderer.render(this.mesh, this.camera);
  }
};

// node_modules/three-stdlib/postprocessing/ShaderPass.js
var __defProp12 = Object.defineProperty;
var __defNormalProp12 = (obj, key, value) => key in obj ? __defProp12(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField13 = (obj, key, value) => {
  __defNormalProp12(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var ShaderPass = class extends Pass {
  constructor(shader, textureID = "tDiffuse") {
    super();
    __publicField13(this, "textureID");
    __publicField13(this, "uniforms");
    __publicField13(this, "material");
    __publicField13(this, "fsQuad");
    this.textureID = textureID;
    if (shader instanceof ShaderMaterial) {
      this.uniforms = shader.uniforms;
      this.material = shader;
    } else {
      this.uniforms = UniformsUtils.clone(shader.uniforms);
      this.material = new ShaderMaterial({
        defines: Object.assign({}, shader.defines),
        uniforms: this.uniforms,
        vertexShader: shader.vertexShader,
        fragmentShader: shader.fragmentShader
      });
    }
    this.fsQuad = new FullScreenQuad(this.material);
  }
  render(renderer, writeBuffer, readBuffer) {
    if (this.uniforms[this.textureID]) {
      this.uniforms[this.textureID].value = readBuffer.texture;
    }
    this.fsQuad.material = this.material;
    if (this.renderToScreen) {
      renderer.setRenderTarget(null);
      this.fsQuad.render(renderer);
    } else {
      renderer.setRenderTarget(writeBuffer);
      if (this.clear)
        renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);
      this.fsQuad.render(renderer);
    }
  }
};

// node_modules/three-stdlib/shaders/HalftoneShader.js
var HalftoneShader = {
  uniforms: {
    tDiffuse: { value: null },
    shape: { value: 1 },
    radius: { value: 4 },
    rotateR: { value: Math.PI / 12 * 1 },
    rotateG: { value: Math.PI / 12 * 2 },
    rotateB: { value: Math.PI / 12 * 3 },
    scatter: { value: 0 },
    width: { value: 1 },
    height: { value: 1 },
    blending: { value: 1 },
    blendingMode: { value: 1 },
    greyscale: { value: false },
    disable: { value: false }
  },
  vertexShader: [
    "varying vec2 vUV;",
    "void main() {",
    "	vUV = uv;",
    "	gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);",
    "}"
  ].join("\n"),
  fragmentShader: [
    "#define SQRT2_MINUS_ONE 0.41421356",
    "#define SQRT2_HALF_MINUS_ONE 0.20710678",
    "#define PI2 6.28318531",
    "#define SHAPE_DOT 1",
    "#define SHAPE_ELLIPSE 2",
    "#define SHAPE_LINE 3",
    "#define SHAPE_SQUARE 4",
    "#define BLENDING_LINEAR 1",
    "#define BLENDING_MULTIPLY 2",
    "#define BLENDING_ADD 3",
    "#define BLENDING_LIGHTER 4",
    "#define BLENDING_DARKER 5",
    "uniform sampler2D tDiffuse;",
    "uniform float radius;",
    "uniform float rotateR;",
    "uniform float rotateG;",
    "uniform float rotateB;",
    "uniform float scatter;",
    "uniform float width;",
    "uniform float height;",
    "uniform int shape;",
    "uniform bool disable;",
    "uniform float blending;",
    "uniform int blendingMode;",
    "varying vec2 vUV;",
    "uniform bool greyscale;",
    "const int samples = 8;",
    "float blend( float a, float b, float t ) {",
    // linear blend
    "	return a * ( 1.0 - t ) + b * t;",
    "}",
    "float hypot( float x, float y ) {",
    // vector magnitude
    "	return sqrt( x * x + y * y );",
    "}",
    "float rand( vec2 seed ){",
    // get pseudo-random number
    "return fract( sin( dot( seed.xy, vec2( 12.9898, 78.233 ) ) ) * 43758.5453 );",
    "}",
    "float distanceToDotRadius( float channel, vec2 coord, vec2 normal, vec2 p, float angle, float rad_max ) {",
    // apply shape-specific transforms
    "	float dist = hypot( coord.x - p.x, coord.y - p.y );",
    "	float rad = channel;",
    "	if ( shape == SHAPE_DOT ) {",
    "		rad = pow( abs( rad ), 1.125 ) * rad_max;",
    "	} else if ( shape == SHAPE_ELLIPSE ) {",
    "		rad = pow( abs( rad ), 1.125 ) * rad_max;",
    "		if ( dist != 0.0 ) {",
    "			float dot_p = abs( ( p.x - coord.x ) / dist * normal.x + ( p.y - coord.y ) / dist * normal.y );",
    "			dist = ( dist * ( 1.0 - SQRT2_HALF_MINUS_ONE ) ) + dot_p * dist * SQRT2_MINUS_ONE;",
    "		}",
    "	} else if ( shape == SHAPE_LINE ) {",
    "		rad = pow( abs( rad ), 1.5) * rad_max;",
    "		float dot_p = ( p.x - coord.x ) * normal.x + ( p.y - coord.y ) * normal.y;",
    "		dist = hypot( normal.x * dot_p, normal.y * dot_p );",
    "	} else if ( shape == SHAPE_SQUARE ) {",
    "		float theta = atan( p.y - coord.y, p.x - coord.x ) - angle;",
    "		float sin_t = abs( sin( theta ) );",
    "		float cos_t = abs( cos( theta ) );",
    "		rad = pow( abs( rad ), 1.4 );",
    "		rad = rad_max * ( rad + ( ( sin_t > cos_t ) ? rad - sin_t * rad : rad - cos_t * rad ) );",
    "	}",
    "	return rad - dist;",
    "}",
    "struct Cell {",
    // grid sample positions
    "	vec2 normal;",
    "	vec2 p1;",
    "	vec2 p2;",
    "	vec2 p3;",
    "	vec2 p4;",
    "	float samp2;",
    "	float samp1;",
    "	float samp3;",
    "	float samp4;",
    "};",
    "vec4 getSample( vec2 point ) {",
    // multi-sampled point
    "	vec4 tex = texture2D( tDiffuse, vec2( point.x / width, point.y / height ) );",
    "	float base = rand( vec2( floor( point.x ), floor( point.y ) ) ) * PI2;",
    "	float step = PI2 / float( samples );",
    "	float dist = radius * 0.66;",
    "	for ( int i = 0; i < samples; ++i ) {",
    "		float r = base + step * float( i );",
    "		vec2 coord = point + vec2( cos( r ) * dist, sin( r ) * dist );",
    "		tex += texture2D( tDiffuse, vec2( coord.x / width, coord.y / height ) );",
    "	}",
    "	tex /= float( samples ) + 1.0;",
    "	return tex;",
    "}",
    "float getDotColour( Cell c, vec2 p, int channel, float angle, float aa ) {",
    // get colour for given point
    "	float dist_c_1, dist_c_2, dist_c_3, dist_c_4, res;",
    "	if ( channel == 0 ) {",
    "		c.samp1 = getSample( c.p1 ).r;",
    "		c.samp2 = getSample( c.p2 ).r;",
    "		c.samp3 = getSample( c.p3 ).r;",
    "		c.samp4 = getSample( c.p4 ).r;",
    "	} else if (channel == 1) {",
    "		c.samp1 = getSample( c.p1 ).g;",
    "		c.samp2 = getSample( c.p2 ).g;",
    "		c.samp3 = getSample( c.p3 ).g;",
    "		c.samp4 = getSample( c.p4 ).g;",
    "	} else {",
    "		c.samp1 = getSample( c.p1 ).b;",
    "		c.samp3 = getSample( c.p3 ).b;",
    "		c.samp2 = getSample( c.p2 ).b;",
    "		c.samp4 = getSample( c.p4 ).b;",
    "	}",
    "	dist_c_1 = distanceToDotRadius( c.samp1, c.p1, c.normal, p, angle, radius );",
    "	dist_c_2 = distanceToDotRadius( c.samp2, c.p2, c.normal, p, angle, radius );",
    "	dist_c_3 = distanceToDotRadius( c.samp3, c.p3, c.normal, p, angle, radius );",
    "	dist_c_4 = distanceToDotRadius( c.samp4, c.p4, c.normal, p, angle, radius );",
    "	res = ( dist_c_1 > 0.0 ) ? clamp( dist_c_1 / aa, 0.0, 1.0 ) : 0.0;",
    "	res += ( dist_c_2 > 0.0 ) ? clamp( dist_c_2 / aa, 0.0, 1.0 ) : 0.0;",
    "	res += ( dist_c_3 > 0.0 ) ? clamp( dist_c_3 / aa, 0.0, 1.0 ) : 0.0;",
    "	res += ( dist_c_4 > 0.0 ) ? clamp( dist_c_4 / aa, 0.0, 1.0 ) : 0.0;",
    "	res = clamp( res, 0.0, 1.0 );",
    "	return res;",
    "}",
    "Cell getReferenceCell( vec2 p, vec2 origin, float grid_angle, float step ) {",
    // get containing cell
    "	Cell c;",
    // calc grid
    "	vec2 n = vec2( cos( grid_angle ), sin( grid_angle ) );",
    "	float threshold = step * 0.5;",
    "	float dot_normal = n.x * ( p.x - origin.x ) + n.y * ( p.y - origin.y );",
    "	float dot_line = -n.y * ( p.x - origin.x ) + n.x * ( p.y - origin.y );",
    "	vec2 offset = vec2( n.x * dot_normal, n.y * dot_normal );",
    "	float offset_normal = mod( hypot( offset.x, offset.y ), step );",
    "	float normal_dir = ( dot_normal < 0.0 ) ? 1.0 : -1.0;",
    "	float normal_scale = ( ( offset_normal < threshold ) ? -offset_normal : step - offset_normal ) * normal_dir;",
    "	float offset_line = mod( hypot( ( p.x - offset.x ) - origin.x, ( p.y - offset.y ) - origin.y ), step );",
    "	float line_dir = ( dot_line < 0.0 ) ? 1.0 : -1.0;",
    "	float line_scale = ( ( offset_line < threshold ) ? -offset_line : step - offset_line ) * line_dir;",
    // get closest corner
    "	c.normal = n;",
    "	c.p1.x = p.x - n.x * normal_scale + n.y * line_scale;",
    "	c.p1.y = p.y - n.y * normal_scale - n.x * line_scale;",
    // scatter
    "	if ( scatter != 0.0 ) {",
    "		float off_mag = scatter * threshold * 0.5;",
    "		float off_angle = rand( vec2( floor( c.p1.x ), floor( c.p1.y ) ) ) * PI2;",
    "		c.p1.x += cos( off_angle ) * off_mag;",
    "		c.p1.y += sin( off_angle ) * off_mag;",
    "	}",
    // find corners
    "	float normal_step = normal_dir * ( ( offset_normal < threshold ) ? step : -step );",
    "	float line_step = line_dir * ( ( offset_line < threshold ) ? step : -step );",
    "	c.p2.x = c.p1.x - n.x * normal_step;",
    "	c.p2.y = c.p1.y - n.y * normal_step;",
    "	c.p3.x = c.p1.x + n.y * line_step;",
    "	c.p3.y = c.p1.y - n.x * line_step;",
    "	c.p4.x = c.p1.x - n.x * normal_step + n.y * line_step;",
    "	c.p4.y = c.p1.y - n.y * normal_step - n.x * line_step;",
    "	return c;",
    "}",
    "float blendColour( float a, float b, float t ) {",
    // blend colours
    "	if ( blendingMode == BLENDING_LINEAR ) {",
    "		return blend( a, b, 1.0 - t );",
    "	} else if ( blendingMode == BLENDING_ADD ) {",
    "		return blend( a, min( 1.0, a + b ), t );",
    "	} else if ( blendingMode == BLENDING_MULTIPLY ) {",
    "		return blend( a, max( 0.0, a * b ), t );",
    "	} else if ( blendingMode == BLENDING_LIGHTER ) {",
    "		return blend( a, max( a, b ), t );",
    "	} else if ( blendingMode == BLENDING_DARKER ) {",
    "		return blend( a, min( a, b ), t );",
    "	} else {",
    "		return blend( a, b, 1.0 - t );",
    "	}",
    "}",
    "void main() {",
    "	if ( ! disable ) {",
    // setup
    "		vec2 p = vec2( vUV.x * width, vUV.y * height );",
    "		vec2 origin = vec2( 0, 0 );",
    "		float aa = ( radius < 2.5 ) ? radius * 0.5 : 1.25;",
    // get channel samples
    "		Cell cell_r = getReferenceCell( p, origin, rotateR, radius );",
    "		Cell cell_g = getReferenceCell( p, origin, rotateG, radius );",
    "		Cell cell_b = getReferenceCell( p, origin, rotateB, radius );",
    "		float r = getDotColour( cell_r, p, 0, rotateR, aa );",
    "		float g = getDotColour( cell_g, p, 1, rotateG, aa );",
    "		float b = getDotColour( cell_b, p, 2, rotateB, aa );",
    // blend with original
    "		vec4 colour = texture2D( tDiffuse, vUV );",
    "		r = blendColour( r, colour.r, blending );",
    "		g = blendColour( g, colour.g, blending );",
    "		b = blendColour( b, colour.b, blending );",
    "		if ( greyscale ) {",
    "			r = g = b = (r + b + g) / 3.0;",
    "		}",
    "		gl_FragColor = vec4( r, g, b, 1.0 );",
    "	} else {",
    "		gl_FragColor = texture2D( tDiffuse, vUV );",
    "	}",
    "}"
  ].join("\n")
};

// node_modules/three-stdlib/shaders/SMAAShader.js
var SMAAEdgesShader = {
  defines: {
    SMAA_THRESHOLD: "0.1"
  },
  uniforms: {
    tDiffuse: { value: null },
    resolution: { value: new Vector2(1 / 1024, 1 / 512) }
  },
  vertexShader: [
    "uniform vec2 resolution;",
    "varying vec2 vUv;",
    "varying vec4 vOffset[ 3 ];",
    "void SMAAEdgeDetectionVS( vec2 texcoord ) {",
    "	vOffset[ 0 ] = texcoord.xyxy + resolution.xyxy * vec4( -1.0, 0.0, 0.0,  1.0 );",
    // WebGL port note: Changed sign in W component
    "	vOffset[ 1 ] = texcoord.xyxy + resolution.xyxy * vec4(  1.0, 0.0, 0.0, -1.0 );",
    // WebGL port note: Changed sign in W component
    "	vOffset[ 2 ] = texcoord.xyxy + resolution.xyxy * vec4( -2.0, 0.0, 0.0,  2.0 );",
    // WebGL port note: Changed sign in W component
    "}",
    "void main() {",
    "	vUv = uv;",
    "	SMAAEdgeDetectionVS( vUv );",
    "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
    "}"
  ].join("\n"),
  fragmentShader: [
    "uniform sampler2D tDiffuse;",
    "varying vec2 vUv;",
    "varying vec4 vOffset[ 3 ];",
    "vec4 SMAAColorEdgeDetectionPS( vec2 texcoord, vec4 offset[3], sampler2D colorTex ) {",
    "	vec2 threshold = vec2( SMAA_THRESHOLD, SMAA_THRESHOLD );",
    // Calculate color deltas:
    "	vec4 delta;",
    "	vec3 C = texture2D( colorTex, texcoord ).rgb;",
    "	vec3 Cleft = texture2D( colorTex, offset[0].xy ).rgb;",
    "	vec3 t = abs( C - Cleft );",
    "	delta.x = max( max( t.r, t.g ), t.b );",
    "	vec3 Ctop = texture2D( colorTex, offset[0].zw ).rgb;",
    "	t = abs( C - Ctop );",
    "	delta.y = max( max( t.r, t.g ), t.b );",
    // We do the usual threshold:
    "	vec2 edges = step( threshold, delta.xy );",
    // Then discard if there is no edge:
    "	if ( dot( edges, vec2( 1.0, 1.0 ) ) == 0.0 )",
    "		discard;",
    // Calculate right and bottom deltas:
    "	vec3 Cright = texture2D( colorTex, offset[1].xy ).rgb;",
    "	t = abs( C - Cright );",
    "	delta.z = max( max( t.r, t.g ), t.b );",
    "	vec3 Cbottom  = texture2D( colorTex, offset[1].zw ).rgb;",
    "	t = abs( C - Cbottom );",
    "	delta.w = max( max( t.r, t.g ), t.b );",
    // Calculate the maximum delta in the direct neighborhood:
    "	float maxDelta = max( max( max( delta.x, delta.y ), delta.z ), delta.w );",
    // Calculate left-left and top-top deltas:
    "	vec3 Cleftleft  = texture2D( colorTex, offset[2].xy ).rgb;",
    "	t = abs( C - Cleftleft );",
    "	delta.z = max( max( t.r, t.g ), t.b );",
    "	vec3 Ctoptop = texture2D( colorTex, offset[2].zw ).rgb;",
    "	t = abs( C - Ctoptop );",
    "	delta.w = max( max( t.r, t.g ), t.b );",
    // Calculate the final maximum delta:
    "	maxDelta = max( max( maxDelta, delta.z ), delta.w );",
    // Local contrast adaptation in action:
    "	edges.xy *= step( 0.5 * maxDelta, delta.xy );",
    "	return vec4( edges, 0.0, 0.0 );",
    "}",
    "void main() {",
    "	gl_FragColor = SMAAColorEdgeDetectionPS( vUv, vOffset, tDiffuse );",
    "}"
  ].join("\n")
};
var SMAAWeightsShader = {
  defines: {
    SMAA_MAX_SEARCH_STEPS: "8",
    SMAA_AREATEX_MAX_DISTANCE: "16",
    SMAA_AREATEX_PIXEL_SIZE: "( 1.0 / vec2( 160.0, 560.0 ) )",
    SMAA_AREATEX_SUBTEX_SIZE: "( 1.0 / 7.0 )"
  },
  uniforms: {
    tDiffuse: { value: null },
    tArea: { value: null },
    tSearch: { value: null },
    resolution: { value: new Vector2(1 / 1024, 1 / 512) }
  },
  vertexShader: [
    "uniform vec2 resolution;",
    "varying vec2 vUv;",
    "varying vec4 vOffset[ 3 ];",
    "varying vec2 vPixcoord;",
    "void SMAABlendingWeightCalculationVS( vec2 texcoord ) {",
    "	vPixcoord = texcoord / resolution;",
    // We will use these offsets for the searches later on (see @PSEUDO_GATHER4):
    "	vOffset[ 0 ] = texcoord.xyxy + resolution.xyxy * vec4( -0.25, 0.125, 1.25, 0.125 );",
    // WebGL port note: Changed sign in Y and W components
    "	vOffset[ 1 ] = texcoord.xyxy + resolution.xyxy * vec4( -0.125, 0.25, -0.125, -1.25 );",
    // WebGL port note: Changed sign in Y and W components
    // And these for the searches, they indicate the ends of the loops:
    "	vOffset[ 2 ] = vec4( vOffset[ 0 ].xz, vOffset[ 1 ].yw ) + vec4( -2.0, 2.0, -2.0, 2.0 ) * resolution.xxyy * float( SMAA_MAX_SEARCH_STEPS );",
    "}",
    "void main() {",
    "	vUv = uv;",
    "	SMAABlendingWeightCalculationVS( vUv );",
    "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
    "}"
  ].join("\n"),
  fragmentShader: [
    "#define SMAASampleLevelZeroOffset( tex, coord, offset ) texture2D( tex, coord + float( offset ) * resolution, 0.0 )",
    "uniform sampler2D tDiffuse;",
    "uniform sampler2D tArea;",
    "uniform sampler2D tSearch;",
    "uniform vec2 resolution;",
    "varying vec2 vUv;",
    "varying vec4 vOffset[3];",
    "varying vec2 vPixcoord;",
    "#if __VERSION__ == 100",
    "vec2 round( vec2 x ) {",
    "	return sign( x ) * floor( abs( x ) + 0.5 );",
    "}",
    "#endif",
    "float SMAASearchLength( sampler2D searchTex, vec2 e, float bias, float scale ) {",
    // Not required if searchTex accesses are set to point:
    // float2 SEARCH_TEX_PIXEL_SIZE = 1.0 / float2(66.0, 33.0);
    // e = float2(bias, 0.0) + 0.5 * SEARCH_TEX_PIXEL_SIZE +
    //     e * float2(scale, 1.0) * float2(64.0, 32.0) * SEARCH_TEX_PIXEL_SIZE;
    "	e.r = bias + e.r * scale;",
    "	return 255.0 * texture2D( searchTex, e, 0.0 ).r;",
    "}",
    "float SMAASearchXLeft( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {",
    /**
     * @PSEUDO_GATHER4
     * This texcoord has been offset by (-0.25, -0.125) in the vertex shader to
     * sample between edge, thus fetching four edges in a row.
     * Sampling with different offsets in each direction allows to disambiguate
     * which edges are active from the four fetched ones.
     */
    "	vec2 e = vec2( 0.0, 1.0 );",
    "	for ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) {",
    // WebGL port note: Changed while to for
    "		e = texture2D( edgesTex, texcoord, 0.0 ).rg;",
    "		texcoord -= vec2( 2.0, 0.0 ) * resolution;",
    "		if ( ! ( texcoord.x > end && e.g > 0.8281 && e.r == 0.0 ) ) break;",
    "	}",
    // We correct the previous (-0.25, -0.125) offset we applied:
    "	texcoord.x += 0.25 * resolution.x;",
    // The searches are bias by 1, so adjust the coords accordingly:
    "	texcoord.x += resolution.x;",
    // Disambiguate the length added by the last step:
    "	texcoord.x += 2.0 * resolution.x;",
    // Undo last step
    "	texcoord.x -= resolution.x * SMAASearchLength(searchTex, e, 0.0, 0.5);",
    "	return texcoord.x;",
    "}",
    "float SMAASearchXRight( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {",
    "	vec2 e = vec2( 0.0, 1.0 );",
    "	for ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) {",
    // WebGL port note: Changed while to for
    "		e = texture2D( edgesTex, texcoord, 0.0 ).rg;",
    "		texcoord += vec2( 2.0, 0.0 ) * resolution;",
    "		if ( ! ( texcoord.x < end && e.g > 0.8281 && e.r == 0.0 ) ) break;",
    "	}",
    "	texcoord.x -= 0.25 * resolution.x;",
    "	texcoord.x -= resolution.x;",
    "	texcoord.x -= 2.0 * resolution.x;",
    "	texcoord.x += resolution.x * SMAASearchLength( searchTex, e, 0.5, 0.5 );",
    "	return texcoord.x;",
    "}",
    "float SMAASearchYUp( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {",
    "	vec2 e = vec2( 1.0, 0.0 );",
    "	for ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) {",
    // WebGL port note: Changed while to for
    "		e = texture2D( edgesTex, texcoord, 0.0 ).rg;",
    "		texcoord += vec2( 0.0, 2.0 ) * resolution;",
    // WebGL port note: Changed sign
    "		if ( ! ( texcoord.y > end && e.r > 0.8281 && e.g == 0.0 ) ) break;",
    "	}",
    "	texcoord.y -= 0.25 * resolution.y;",
    // WebGL port note: Changed sign
    "	texcoord.y -= resolution.y;",
    // WebGL port note: Changed sign
    "	texcoord.y -= 2.0 * resolution.y;",
    // WebGL port note: Changed sign
    "	texcoord.y += resolution.y * SMAASearchLength( searchTex, e.gr, 0.0, 0.5 );",
    // WebGL port note: Changed sign
    "	return texcoord.y;",
    "}",
    "float SMAASearchYDown( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {",
    "	vec2 e = vec2( 1.0, 0.0 );",
    "	for ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) {",
    // WebGL port note: Changed while to for
    "		e = texture2D( edgesTex, texcoord, 0.0 ).rg;",
    "		texcoord -= vec2( 0.0, 2.0 ) * resolution;",
    // WebGL port note: Changed sign
    "		if ( ! ( texcoord.y < end && e.r > 0.8281 && e.g == 0.0 ) ) break;",
    "	}",
    "	texcoord.y += 0.25 * resolution.y;",
    // WebGL port note: Changed sign
    "	texcoord.y += resolution.y;",
    // WebGL port note: Changed sign
    "	texcoord.y += 2.0 * resolution.y;",
    // WebGL port note: Changed sign
    "	texcoord.y -= resolution.y * SMAASearchLength( searchTex, e.gr, 0.5, 0.5 );",
    // WebGL port note: Changed sign
    "	return texcoord.y;",
    "}",
    "vec2 SMAAArea( sampler2D areaTex, vec2 dist, float e1, float e2, float offset ) {",
    // Rounding prevents precision errors of bilinear filtering:
    "	vec2 texcoord = float( SMAA_AREATEX_MAX_DISTANCE ) * round( 4.0 * vec2( e1, e2 ) ) + dist;",
    // We do a scale and bias for mapping to texel space:
    "	texcoord = SMAA_AREATEX_PIXEL_SIZE * texcoord + ( 0.5 * SMAA_AREATEX_PIXEL_SIZE );",
    // Move to proper place, according to the subpixel offset:
    "	texcoord.y += SMAA_AREATEX_SUBTEX_SIZE * offset;",
    "	return texture2D( areaTex, texcoord, 0.0 ).rg;",
    "}",
    "vec4 SMAABlendingWeightCalculationPS( vec2 texcoord, vec2 pixcoord, vec4 offset[ 3 ], sampler2D edgesTex, sampler2D areaTex, sampler2D searchTex, ivec4 subsampleIndices ) {",
    "	vec4 weights = vec4( 0.0, 0.0, 0.0, 0.0 );",
    "	vec2 e = texture2D( edgesTex, texcoord ).rg;",
    "	if ( e.g > 0.0 ) {",
    // Edge at north
    "		vec2 d;",
    // Find the distance to the left:
    "		vec2 coords;",
    "		coords.x = SMAASearchXLeft( edgesTex, searchTex, offset[ 0 ].xy, offset[ 2 ].x );",
    "		coords.y = offset[ 1 ].y;",
    // offset[1].y = texcoord.y - 0.25 * resolution.y (@CROSSING_OFFSET)
    "		d.x = coords.x;",
    // Now fetch the left crossing edges, two at a time using bilinear
    // filtering. Sampling at -0.25 (see @CROSSING_OFFSET) enables to
    // discern what value each edge has:
    "		float e1 = texture2D( edgesTex, coords, 0.0 ).r;",
    // Find the distance to the right:
    "		coords.x = SMAASearchXRight( edgesTex, searchTex, offset[ 0 ].zw, offset[ 2 ].y );",
    "		d.y = coords.x;",
    // We want the distances to be in pixel units (doing this here allow to
    // better interleave arithmetic and memory accesses):
    "		d = d / resolution.x - pixcoord.x;",
    // SMAAArea below needs a sqrt, as the areas texture is compressed
    // quadratically:
    "		vec2 sqrt_d = sqrt( abs( d ) );",
    // Fetch the right crossing edges:
    "		coords.y -= 1.0 * resolution.y;",
    // WebGL port note: Added
    "		float e2 = SMAASampleLevelZeroOffset( edgesTex, coords, ivec2( 1, 0 ) ).r;",
    // Ok, we know how this pattern looks like, now it is time for getting
    // the actual area:
    "		weights.rg = SMAAArea( areaTex, sqrt_d, e1, e2, float( subsampleIndices.y ) );",
    "	}",
    "	if ( e.r > 0.0 ) {",
    // Edge at west
    "		vec2 d;",
    // Find the distance to the top:
    "		vec2 coords;",
    "		coords.y = SMAASearchYUp( edgesTex, searchTex, offset[ 1 ].xy, offset[ 2 ].z );",
    "		coords.x = offset[ 0 ].x;",
    // offset[1].x = texcoord.x - 0.25 * resolution.x;
    "		d.x = coords.y;",
    // Fetch the top crossing edges:
    "		float e1 = texture2D( edgesTex, coords, 0.0 ).g;",
    // Find the distance to the bottom:
    "		coords.y = SMAASearchYDown( edgesTex, searchTex, offset[ 1 ].zw, offset[ 2 ].w );",
    "		d.y = coords.y;",
    // We want the distances to be in pixel units:
    "		d = d / resolution.y - pixcoord.y;",
    // SMAAArea below needs a sqrt, as the areas texture is compressed
    // quadratically:
    "		vec2 sqrt_d = sqrt( abs( d ) );",
    // Fetch the bottom crossing edges:
    "		coords.y -= 1.0 * resolution.y;",
    // WebGL port note: Added
    "		float e2 = SMAASampleLevelZeroOffset( edgesTex, coords, ivec2( 0, 1 ) ).g;",
    // Get the area for this direction:
    "		weights.ba = SMAAArea( areaTex, sqrt_d, e1, e2, float( subsampleIndices.x ) );",
    "	}",
    "	return weights;",
    "}",
    "void main() {",
    "	gl_FragColor = SMAABlendingWeightCalculationPS( vUv, vPixcoord, vOffset, tDiffuse, tArea, tSearch, ivec4( 0.0 ) );",
    "}"
  ].join("\n")
};
var SMAABlendShader = {
  uniforms: {
    tDiffuse: { value: null },
    tColor: { value: null },
    resolution: { value: new Vector2(1 / 1024, 1 / 512) }
  },
  vertexShader: [
    "uniform vec2 resolution;",
    "varying vec2 vUv;",
    "varying vec4 vOffset[ 2 ];",
    "void SMAANeighborhoodBlendingVS( vec2 texcoord ) {",
    "	vOffset[ 0 ] = texcoord.xyxy + resolution.xyxy * vec4( -1.0, 0.0, 0.0, 1.0 );",
    // WebGL port note: Changed sign in W component
    "	vOffset[ 1 ] = texcoord.xyxy + resolution.xyxy * vec4( 1.0, 0.0, 0.0, -1.0 );",
    // WebGL port note: Changed sign in W component
    "}",
    "void main() {",
    "	vUv = uv;",
    "	SMAANeighborhoodBlendingVS( vUv );",
    "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
    "}"
  ].join("\n"),
  fragmentShader: [
    "uniform sampler2D tDiffuse;",
    "uniform sampler2D tColor;",
    "uniform vec2 resolution;",
    "varying vec2 vUv;",
    "varying vec4 vOffset[ 2 ];",
    "vec4 SMAANeighborhoodBlendingPS( vec2 texcoord, vec4 offset[ 2 ], sampler2D colorTex, sampler2D blendTex ) {",
    // Fetch the blending weights for current pixel:
    "	vec4 a;",
    "	a.xz = texture2D( blendTex, texcoord ).xz;",
    "	a.y = texture2D( blendTex, offset[ 1 ].zw ).g;",
    "	a.w = texture2D( blendTex, offset[ 1 ].xy ).a;",
    // Is there any blending weight with a value greater than 0.0?
    "	if ( dot(a, vec4( 1.0, 1.0, 1.0, 1.0 )) < 1e-5 ) {",
    "		return texture2D( colorTex, texcoord, 0.0 );",
    "	} else {",
    // Up to 4 lines can be crossing a pixel (one through each edge). We
    // favor blending by choosing the line with the maximum weight for each
    // direction:
    "		vec2 offset;",
    "		offset.x = a.a > a.b ? a.a : -a.b;",
    // left vs. right
    "		offset.y = a.g > a.r ? -a.g : a.r;",
    // top vs. bottom // WebGL port note: Changed signs
    // Then we go in the direction that has the maximum weight:
    "		if ( abs( offset.x ) > abs( offset.y )) {",
    // horizontal vs. vertical
    "			offset.y = 0.0;",
    "		} else {",
    "			offset.x = 0.0;",
    "		}",
    // Fetch the opposite color and lerp by hand:
    "		vec4 C = texture2D( colorTex, texcoord, 0.0 );",
    "		texcoord += sign( offset ) * resolution;",
    "		vec4 Cop = texture2D( colorTex, texcoord, 0.0 );",
    "		float s = abs( offset.x ) > abs( offset.y ) ? abs( offset.x ) : abs( offset.y );",
    // WebGL port note: Added gamma correction
    "		C.xyz = pow(C.xyz, vec3(2.2));",
    "		Cop.xyz = pow(Cop.xyz, vec3(2.2));",
    "		vec4 mixed = mix(C, Cop, s);",
    "		mixed.xyz = pow(mixed.xyz, vec3(1.0 / 2.2));",
    "		return mixed;",
    "	}",
    "}",
    "void main() {",
    "	gl_FragColor = SMAANeighborhoodBlendingPS( vUv, vOffset, tColor, tDiffuse );",
    "}"
  ].join("\n")
};

// node_modules/three-stdlib/shaders/FilmShader.js
var FilmShader = {
  uniforms: {
    tDiffuse: { value: null },
    time: { value: 0 },
    nIntensity: { value: 0.5 },
    sIntensity: { value: 0.05 },
    sCount: { value: 4096 },
    grayscale: { value: 1 }
  },
  vertexShader: [
    "varying vec2 vUv;",
    "void main() {",
    "	vUv = uv;",
    "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
    "}"
  ].join("\n"),
  fragmentShader: [
    "#include <common>",
    // control parameter
    "uniform float time;",
    "uniform bool grayscale;",
    // noise effect intensity value (0 = no effect, 1 = full effect)
    "uniform float nIntensity;",
    // scanlines effect intensity value (0 = no effect, 1 = full effect)
    "uniform float sIntensity;",
    // scanlines effect count value (0 = no effect, 4096 = full effect)
    "uniform float sCount;",
    "uniform sampler2D tDiffuse;",
    "varying vec2 vUv;",
    "void main() {",
    // sample the source
    "	vec4 cTextureScreen = texture2D( tDiffuse, vUv );",
    // make some noise
    "	float dx = rand( vUv + time );",
    // add noise
    "	vec3 cResult = cTextureScreen.rgb + cTextureScreen.rgb * clamp( 0.1 + dx, 0.0, 1.0 );",
    // get us a sine and cosine
    "	vec2 sc = vec2( sin( vUv.y * sCount ), cos( vUv.y * sCount ) );",
    // add scanlines
    "	cResult += cTextureScreen.rgb * vec3( sc.x, sc.y, sc.x ) * sIntensity;",
    // interpolate between source and result by intensity
    "	cResult = cTextureScreen.rgb + clamp( nIntensity, 0.0,1.0 ) * ( cResult - cTextureScreen.rgb );",
    // convert to grayscale if desired
    "	if( grayscale ) {",
    "		cResult = vec3( cResult.r * 0.3 + cResult.g * 0.59 + cResult.b * 0.11 );",
    "	}",
    "	gl_FragColor =  vec4( cResult, cTextureScreen.a );",
    "}"
  ].join("\n")
};

// node_modules/three-stdlib/shaders/CopyShader.js
var CopyShader = {
  uniforms: {
    tDiffuse: { value: null },
    opacity: { value: 1 }
  },
  vertexShader: [
    "varying vec2 vUv;",
    "void main() {",
    "	vUv = uv;",
    "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
    "}"
  ].join("\n"),
  fragmentShader: [
    "uniform float opacity;",
    "uniform sampler2D tDiffuse;",
    "varying vec2 vUv;",
    "void main() {",
    "	vec4 texel = texture2D( tDiffuse, vUv );",
    "	gl_FragColor = opacity * texel;",
    "}"
  ].join("\n")
};

// node_modules/three-stdlib/shaders/SSAOShader.js
var SSAOShader = {
  defines: {
    PERSPECTIVE_CAMERA: 1,
    KERNEL_SIZE: 32
  },
  uniforms: {
    tDiffuse: { value: null },
    tNormal: { value: null },
    tDepth: { value: null },
    tNoise: { value: null },
    kernel: { value: null },
    cameraNear: { value: null },
    cameraFar: { value: null },
    resolution: { value: new Vector2() },
    cameraProjectionMatrix: { value: new Matrix4() },
    cameraInverseProjectionMatrix: { value: new Matrix4() },
    kernelRadius: { value: 8 },
    minDistance: { value: 5e-3 },
    maxDistance: { value: 0.05 }
  },
  vertexShader: [
    "varying vec2 vUv;",
    "void main() {",
    "	vUv = uv;",
    "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
    "}"
  ].join("\n"),
  fragmentShader: [
    "uniform sampler2D tDiffuse;",
    "uniform sampler2D tNormal;",
    "uniform sampler2D tDepth;",
    "uniform sampler2D tNoise;",
    "uniform vec3 kernel[ KERNEL_SIZE ];",
    "uniform vec2 resolution;",
    "uniform float cameraNear;",
    "uniform float cameraFar;",
    "uniform mat4 cameraProjectionMatrix;",
    "uniform mat4 cameraInverseProjectionMatrix;",
    "uniform float kernelRadius;",
    "uniform float minDistance;",
    // avoid artifacts caused by neighbour fragments with minimal depth difference
    "uniform float maxDistance;",
    // avoid the influence of fragments which are too far away
    "varying vec2 vUv;",
    "#include <packing>",
    "float getDepth( const in vec2 screenPosition ) {",
    "	return texture2D( tDepth, screenPosition ).x;",
    "}",
    "float getLinearDepth( const in vec2 screenPosition ) {",
    "	#if PERSPECTIVE_CAMERA == 1",
    "		float fragCoordZ = texture2D( tDepth, screenPosition ).x;",
    "		float viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );",
    "		return viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );",
    "	#else",
    "		return texture2D( tDepth, screenPosition ).x;",
    "	#endif",
    "}",
    "float getViewZ( const in float depth ) {",
    "	#if PERSPECTIVE_CAMERA == 1",
    "		return perspectiveDepthToViewZ( depth, cameraNear, cameraFar );",
    "	#else",
    "		return orthographicDepthToViewZ( depth, cameraNear, cameraFar );",
    "	#endif",
    "}",
    "vec3 getViewPosition( const in vec2 screenPosition, const in float depth, const in float viewZ ) {",
    "	float clipW = cameraProjectionMatrix[2][3] * viewZ + cameraProjectionMatrix[3][3];",
    "	vec4 clipPosition = vec4( ( vec3( screenPosition, depth ) - 0.5 ) * 2.0, 1.0 );",
    "	clipPosition *= clipW; // unprojection.",
    "	return ( cameraInverseProjectionMatrix * clipPosition ).xyz;",
    "}",
    "vec3 getViewNormal( const in vec2 screenPosition ) {",
    "	return unpackRGBToNormal( texture2D( tNormal, screenPosition ).xyz );",
    "}",
    "void main() {",
    "	float depth = getDepth( vUv );",
    "	float viewZ = getViewZ( depth );",
    "	vec3 viewPosition = getViewPosition( vUv, depth, viewZ );",
    "	vec3 viewNormal = getViewNormal( vUv );",
    " vec2 noiseScale = vec2( resolution.x / 4.0, resolution.y / 4.0 );",
    "	vec3 random = texture2D( tNoise, vUv * noiseScale ).xyz;",
    // compute matrix used to reorient a kernel vector
    "	vec3 tangent = normalize( random - viewNormal * dot( random, viewNormal ) );",
    "	vec3 bitangent = cross( viewNormal, tangent );",
    "	mat3 kernelMatrix = mat3( tangent, bitangent, viewNormal );",
    " float occlusion = 0.0;",
    " for ( int i = 0; i < KERNEL_SIZE; i ++ ) {",
    "		vec3 sampleVector = kernelMatrix * kernel[ i ];",
    // reorient sample vector in view space
    "		vec3 samplePoint = viewPosition + ( sampleVector * kernelRadius );",
    // calculate sample point
    "		vec4 samplePointNDC = cameraProjectionMatrix * vec4( samplePoint, 1.0 );",
    // project point and calculate NDC
    "		samplePointNDC /= samplePointNDC.w;",
    "		vec2 samplePointUv = samplePointNDC.xy * 0.5 + 0.5;",
    // compute uv coordinates
    "		float realDepth = getLinearDepth( samplePointUv );",
    // get linear depth from depth texture
    "		float sampleDepth = viewZToOrthographicDepth( samplePoint.z, cameraNear, cameraFar );",
    // compute linear depth of the sample view Z value
    "		float delta = sampleDepth - realDepth;",
    "		if ( delta > minDistance && delta < maxDistance ) {",
    // if fragment is before sample point, increase occlusion
    "			occlusion += 1.0;",
    "		}",
    "	}",
    "	occlusion = clamp( occlusion / float( KERNEL_SIZE ), 0.0, 1.0 );",
    "	gl_FragColor = vec4( vec3( 1.0 - occlusion ), 1.0 );",
    "}"
  ].join("\n")
};
var SSAODepthShader = {
  defines: {
    PERSPECTIVE_CAMERA: 1
  },
  uniforms: {
    tDepth: { value: null },
    cameraNear: { value: null },
    cameraFar: { value: null }
  },
  vertexShader: [
    "varying vec2 vUv;",
    "void main() {",
    "	vUv = uv;",
    "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
    "}"
  ].join("\n"),
  fragmentShader: [
    "uniform sampler2D tDepth;",
    "uniform float cameraNear;",
    "uniform float cameraFar;",
    "varying vec2 vUv;",
    "#include <packing>",
    "float getLinearDepth( const in vec2 screenPosition ) {",
    "	#if PERSPECTIVE_CAMERA == 1",
    "		float fragCoordZ = texture2D( tDepth, screenPosition ).x;",
    "		float viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );",
    "		return viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );",
    "	#else",
    "		return texture2D( tDepth, screenPosition ).x;",
    "	#endif",
    "}",
    "void main() {",
    "	float depth = getLinearDepth( vUv );",
    "	gl_FragColor = vec4( vec3( 1.0 - depth ), 1.0 );",
    "}"
  ].join("\n")
};
var SSAOBlurShader = {
  uniforms: {
    tDiffuse: { value: null },
    resolution: { value: new Vector2() }
  },
  vertexShader: [
    "varying vec2 vUv;",
    "void main() {",
    "	vUv = uv;",
    "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
    "}"
  ].join("\n"),
  fragmentShader: [
    "uniform sampler2D tDiffuse;",
    "uniform vec2 resolution;",
    "varying vec2 vUv;",
    "void main() {",
    "	vec2 texelSize = ( 1.0 / resolution );",
    "	float result = 0.0;",
    "	for ( int i = - 2; i <= 2; i ++ ) {",
    "		for ( int j = - 2; j <= 2; j ++ ) {",
    "			vec2 offset = ( vec2( float( i ), float( j ) ) ) * texelSize;",
    "			result += texture2D( tDiffuse, vUv + offset ).r;",
    "		}",
    "	}",
    "	gl_FragColor = vec4( vec3( result / ( 5.0 * 5.0 ) ), 1.0 );",
    "}"
  ].join("\n")
};

// node_modules/three-stdlib/postprocessing/SSAOPass.js
var __defProp13 = Object.defineProperty;
var __defNormalProp13 = (obj, key, value) => key in obj ? __defProp13(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField14 = (obj, key, value) => {
  __defNormalProp13(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var _SSAOPass = class extends Pass {
  constructor(scene, camera, width, height) {
    super();
    this.width = width !== void 0 ? width : 512;
    this.height = height !== void 0 ? height : 512;
    this.clear = true;
    this.camera = camera;
    this.scene = scene;
    this.kernelRadius = 8;
    this.kernelSize = 32;
    this.kernel = [];
    this.noiseTexture = null;
    this.output = 0;
    this.minDistance = 5e-3;
    this.maxDistance = 0.1;
    this._visibilityCache = /* @__PURE__ */ new Map();
    this.generateSampleKernel();
    this.generateRandomKernelRotations();
    const depthTexture = new DepthTexture();
    depthTexture.format = DepthStencilFormat;
    depthTexture.type = UnsignedInt248Type;
    this.beautyRenderTarget = new WebGLRenderTarget(this.width, this.height);
    this.normalRenderTarget = new WebGLRenderTarget(this.width, this.height, {
      minFilter: NearestFilter,
      magFilter: NearestFilter,
      depthTexture
    });
    this.ssaoRenderTarget = new WebGLRenderTarget(this.width, this.height);
    this.blurRenderTarget = this.ssaoRenderTarget.clone();
    if (SSAOShader === void 0) {
      console.error("THREE.SSAOPass: The pass relies on SSAOShader.");
    }
    this.ssaoMaterial = new ShaderMaterial({
      defines: Object.assign({}, SSAOShader.defines),
      uniforms: UniformsUtils.clone(SSAOShader.uniforms),
      vertexShader: SSAOShader.vertexShader,
      fragmentShader: SSAOShader.fragmentShader,
      blending: NoBlending
    });
    this.ssaoMaterial.uniforms["tDiffuse"].value = this.beautyRenderTarget.texture;
    this.ssaoMaterial.uniforms["tNormal"].value = this.normalRenderTarget.texture;
    this.ssaoMaterial.uniforms["tDepth"].value = this.normalRenderTarget.depthTexture;
    this.ssaoMaterial.uniforms["tNoise"].value = this.noiseTexture;
    this.ssaoMaterial.uniforms["kernel"].value = this.kernel;
    this.ssaoMaterial.uniforms["cameraNear"].value = this.camera.near;
    this.ssaoMaterial.uniforms["cameraFar"].value = this.camera.far;
    this.ssaoMaterial.uniforms["resolution"].value.set(this.width, this.height);
    this.ssaoMaterial.uniforms["cameraProjectionMatrix"].value.copy(this.camera.projectionMatrix);
    this.ssaoMaterial.uniforms["cameraInverseProjectionMatrix"].value.copy(this.camera.projectionMatrixInverse);
    this.normalMaterial = new MeshNormalMaterial();
    this.normalMaterial.blending = NoBlending;
    this.blurMaterial = new ShaderMaterial({
      defines: Object.assign({}, SSAOBlurShader.defines),
      uniforms: UniformsUtils.clone(SSAOBlurShader.uniforms),
      vertexShader: SSAOBlurShader.vertexShader,
      fragmentShader: SSAOBlurShader.fragmentShader
    });
    this.blurMaterial.uniforms["tDiffuse"].value = this.ssaoRenderTarget.texture;
    this.blurMaterial.uniforms["resolution"].value.set(this.width, this.height);
    this.depthRenderMaterial = new ShaderMaterial({
      defines: Object.assign({}, SSAODepthShader.defines),
      uniforms: UniformsUtils.clone(SSAODepthShader.uniforms),
      vertexShader: SSAODepthShader.vertexShader,
      fragmentShader: SSAODepthShader.fragmentShader,
      blending: NoBlending
    });
    this.depthRenderMaterial.uniforms["tDepth"].value = this.normalRenderTarget.depthTexture;
    this.depthRenderMaterial.uniforms["cameraNear"].value = this.camera.near;
    this.depthRenderMaterial.uniforms["cameraFar"].value = this.camera.far;
    this.copyMaterial = new ShaderMaterial({
      uniforms: UniformsUtils.clone(CopyShader.uniforms),
      vertexShader: CopyShader.vertexShader,
      fragmentShader: CopyShader.fragmentShader,
      transparent: true,
      depthTest: false,
      depthWrite: false,
      blendSrc: DstColorFactor,
      blendDst: ZeroFactor,
      blendEquation: AddEquation,
      blendSrcAlpha: DstAlphaFactor,
      blendDstAlpha: ZeroFactor,
      blendEquationAlpha: AddEquation
    });
    this.fsQuad = new FullScreenQuad(null);
    this.originalClearColor = new Color();
  }
  dispose() {
    this.beautyRenderTarget.dispose();
    this.normalRenderTarget.dispose();
    this.ssaoRenderTarget.dispose();
    this.blurRenderTarget.dispose();
    this.normalMaterial.dispose();
    this.blurMaterial.dispose();
    this.copyMaterial.dispose();
    this.depthRenderMaterial.dispose();
    this.fsQuad.dispose();
  }
  render(renderer, writeBuffer) {
    if (renderer.capabilities.isWebGL2 === false)
      this.noiseTexture.format = LuminanceFormat;
    renderer.setRenderTarget(this.beautyRenderTarget);
    renderer.clear();
    renderer.render(this.scene, this.camera);
    this.overrideVisibility();
    this.renderOverride(renderer, this.normalMaterial, this.normalRenderTarget, 7829503, 1);
    this.restoreVisibility();
    this.ssaoMaterial.uniforms["kernelRadius"].value = this.kernelRadius;
    this.ssaoMaterial.uniforms["minDistance"].value = this.minDistance;
    this.ssaoMaterial.uniforms["maxDistance"].value = this.maxDistance;
    this.renderPass(renderer, this.ssaoMaterial, this.ssaoRenderTarget);
    this.renderPass(renderer, this.blurMaterial, this.blurRenderTarget);
    switch (this.output) {
      case _SSAOPass.OUTPUT.SSAO:
        this.copyMaterial.uniforms["tDiffuse"].value = this.ssaoRenderTarget.texture;
        this.copyMaterial.blending = NoBlending;
        this.renderPass(renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer);
        break;
      case _SSAOPass.OUTPUT.Blur:
        this.copyMaterial.uniforms["tDiffuse"].value = this.blurRenderTarget.texture;
        this.copyMaterial.blending = NoBlending;
        this.renderPass(renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer);
        break;
      case _SSAOPass.OUTPUT.Beauty:
        this.copyMaterial.uniforms["tDiffuse"].value = this.beautyRenderTarget.texture;
        this.copyMaterial.blending = NoBlending;
        this.renderPass(renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer);
        break;
      case _SSAOPass.OUTPUT.Depth:
        this.renderPass(renderer, this.depthRenderMaterial, this.renderToScreen ? null : writeBuffer);
        break;
      case _SSAOPass.OUTPUT.Normal:
        this.copyMaterial.uniforms["tDiffuse"].value = this.normalRenderTarget.texture;
        this.copyMaterial.blending = NoBlending;
        this.renderPass(renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer);
        break;
      case _SSAOPass.OUTPUT.Default:
        this.copyMaterial.uniforms["tDiffuse"].value = this.beautyRenderTarget.texture;
        this.copyMaterial.blending = NoBlending;
        this.renderPass(renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer);
        this.copyMaterial.uniforms["tDiffuse"].value = this.blurRenderTarget.texture;
        this.copyMaterial.blending = CustomBlending;
        this.renderPass(renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer);
        break;
      default:
        console.warn("THREE.SSAOPass: Unknown output type.");
    }
  }
  renderPass(renderer, passMaterial, renderTarget, clearColor, clearAlpha) {
    renderer.getClearColor(this.originalClearColor);
    const originalClearAlpha = renderer.getClearAlpha();
    const originalAutoClear = renderer.autoClear;
    renderer.setRenderTarget(renderTarget);
    renderer.autoClear = false;
    if (clearColor !== void 0 && clearColor !== null) {
      renderer.setClearColor(clearColor);
      renderer.setClearAlpha(clearAlpha || 0);
      renderer.clear();
    }
    this.fsQuad.material = passMaterial;
    this.fsQuad.render(renderer);
    renderer.autoClear = originalAutoClear;
    renderer.setClearColor(this.originalClearColor);
    renderer.setClearAlpha(originalClearAlpha);
  }
  renderOverride(renderer, overrideMaterial, renderTarget, clearColor, clearAlpha) {
    renderer.getClearColor(this.originalClearColor);
    const originalClearAlpha = renderer.getClearAlpha();
    const originalAutoClear = renderer.autoClear;
    renderer.setRenderTarget(renderTarget);
    renderer.autoClear = false;
    clearColor = overrideMaterial.clearColor || clearColor;
    clearAlpha = overrideMaterial.clearAlpha || clearAlpha;
    if (clearColor !== void 0 && clearColor !== null) {
      renderer.setClearColor(clearColor);
      renderer.setClearAlpha(clearAlpha || 0);
      renderer.clear();
    }
    this.scene.overrideMaterial = overrideMaterial;
    renderer.render(this.scene, this.camera);
    this.scene.overrideMaterial = null;
    renderer.autoClear = originalAutoClear;
    renderer.setClearColor(this.originalClearColor);
    renderer.setClearAlpha(originalClearAlpha);
  }
  setSize(width, height) {
    this.width = width;
    this.height = height;
    this.beautyRenderTarget.setSize(width, height);
    this.ssaoRenderTarget.setSize(width, height);
    this.normalRenderTarget.setSize(width, height);
    this.blurRenderTarget.setSize(width, height);
    this.ssaoMaterial.uniforms["resolution"].value.set(width, height);
    this.ssaoMaterial.uniforms["cameraProjectionMatrix"].value.copy(this.camera.projectionMatrix);
    this.ssaoMaterial.uniforms["cameraInverseProjectionMatrix"].value.copy(this.camera.projectionMatrixInverse);
    this.blurMaterial.uniforms["resolution"].value.set(width, height);
  }
  generateSampleKernel() {
    const kernelSize = this.kernelSize;
    const kernel = this.kernel;
    for (let i3 = 0; i3 < kernelSize; i3++) {
      const sample2 = new Vector3();
      sample2.x = Math.random() * 2 - 1;
      sample2.y = Math.random() * 2 - 1;
      sample2.z = Math.random();
      sample2.normalize();
      let scale = i3 / kernelSize;
      scale = MathUtils.lerp(0.1, 1, scale * scale);
      sample2.multiplyScalar(scale);
      kernel.push(sample2);
    }
  }
  generateRandomKernelRotations() {
    const width = 4, height = 4;
    if (SimplexNoise === void 0) {
      console.error("THREE.SSAOPass: The pass relies on SimplexNoise.");
    }
    const simplex = new SimplexNoise();
    const size2 = width * height;
    const data = new Float32Array(size2);
    for (let i3 = 0; i3 < size2; i3++) {
      const x = Math.random() * 2 - 1;
      const y = Math.random() * 2 - 1;
      const z = 0;
      data[i3] = simplex.noise3d(x, y, z);
    }
    this.noiseTexture = new DataTexture(data, width, height, RedFormat, FloatType);
    this.noiseTexture.wrapS = RepeatWrapping;
    this.noiseTexture.wrapT = RepeatWrapping;
    this.noiseTexture.needsUpdate = true;
  }
  overrideVisibility() {
    const scene = this.scene;
    const cache = this._visibilityCache;
    scene.traverse(function(object) {
      cache.set(object, object.visible);
      if (object.isPoints || object.isLine)
        object.visible = false;
    });
  }
  restoreVisibility() {
    const scene = this.scene;
    const cache = this._visibilityCache;
    scene.traverse(function(object) {
      const visible = cache.get(object);
      object.visible = visible;
    });
    cache.clear();
  }
};
var SSAOPass = _SSAOPass;
__publicField14(SSAOPass, "OUTPUT", {
  Default: 0,
  SSAO: 1,
  Blur: 2,
  Beauty: 3,
  Depth: 4,
  Normal: 5
});

// node_modules/three-stdlib/shaders/BokehShader.js
var BokehShader = {
  defines: {
    DEPTH_PACKING: 1,
    PERSPECTIVE_CAMERA: 1
  },
  uniforms: {
    tColor: { value: null },
    tDepth: { value: null },
    focus: { value: 1 },
    aspect: { value: 1 },
    aperture: { value: 0.025 },
    maxblur: { value: 0.01 },
    nearClip: { value: 1 },
    farClip: { value: 1e3 }
  },
  vertexShader: [
    "varying vec2 vUv;",
    "void main() {",
    "	vUv = uv;",
    "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
    "}"
  ].join("\n"),
  fragmentShader: [
    "#include <common>",
    "varying vec2 vUv;",
    "uniform sampler2D tColor;",
    "uniform sampler2D tDepth;",
    "uniform float maxblur;",
    // max blur amount
    "uniform float aperture;",
    // aperture - bigger values for shallower depth of field
    "uniform float nearClip;",
    "uniform float farClip;",
    "uniform float focus;",
    "uniform float aspect;",
    "#include <packing>",
    "float getDepth( const in vec2 screenPosition ) {",
    "	#if DEPTH_PACKING == 1",
    "	return unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );",
    "	#else",
    "	return texture2D( tDepth, screenPosition ).x;",
    "	#endif",
    "}",
    "float getViewZ( const in float depth ) {",
    "	#if PERSPECTIVE_CAMERA == 1",
    "	return perspectiveDepthToViewZ( depth, nearClip, farClip );",
    "	#else",
    "	return orthographicDepthToViewZ( depth, nearClip, farClip );",
    "	#endif",
    "}",
    "void main() {",
    "	vec2 aspectcorrect = vec2( 1.0, aspect );",
    "	float viewZ = getViewZ( getDepth( vUv ) );",
    "	float factor = ( focus + viewZ );",
    // viewZ is <= 0, so this is a difference equation
    "	vec2 dofblur = vec2 ( clamp( factor * aperture, -maxblur, maxblur ) );",
    "	vec2 dofblur9 = dofblur * 0.9;",
    "	vec2 dofblur7 = dofblur * 0.7;",
    "	vec2 dofblur4 = dofblur * 0.4;",
    "	vec4 col = vec4( 0.0 );",
    "	col += texture2D( tColor, vUv.xy );",
    "	col += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur );",
    "	col += texture2D( tColor, vUv.xy + ( vec2(  0.15,  0.37 ) * aspectcorrect ) * dofblur );",
    "	col += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur );",
    "	col += texture2D( tColor, vUv.xy + ( vec2( -0.37,  0.15 ) * aspectcorrect ) * dofblur );",
    "	col += texture2D( tColor, vUv.xy + ( vec2(  0.40,  0.0  ) * aspectcorrect ) * dofblur );",
    "	col += texture2D( tColor, vUv.xy + ( vec2(  0.37, -0.15 ) * aspectcorrect ) * dofblur );",
    "	col += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur );",
    "	col += texture2D( tColor, vUv.xy + ( vec2( -0.15, -0.37 ) * aspectcorrect ) * dofblur );",
    "	col += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur );",
    "	col += texture2D( tColor, vUv.xy + ( vec2( -0.15,  0.37 ) * aspectcorrect ) * dofblur );",
    "	col += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur );",
    "	col += texture2D( tColor, vUv.xy + ( vec2(  0.37,  0.15 ) * aspectcorrect ) * dofblur );",
    "	col += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur );",
    "	col += texture2D( tColor, vUv.xy + ( vec2( -0.37, -0.15 ) * aspectcorrect ) * dofblur );",
    "	col += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur );",
    "	col += texture2D( tColor, vUv.xy + ( vec2(  0.15, -0.37 ) * aspectcorrect ) * dofblur );",
    "	col += texture2D( tColor, vUv.xy + ( vec2(  0.15,  0.37 ) * aspectcorrect ) * dofblur9 );",
    "	col += texture2D( tColor, vUv.xy + ( vec2( -0.37,  0.15 ) * aspectcorrect ) * dofblur9 );",
    "	col += texture2D( tColor, vUv.xy + ( vec2(  0.37, -0.15 ) * aspectcorrect ) * dofblur9 );",
    "	col += texture2D( tColor, vUv.xy + ( vec2( -0.15, -0.37 ) * aspectcorrect ) * dofblur9 );",
    "	col += texture2D( tColor, vUv.xy + ( vec2( -0.15,  0.37 ) * aspectcorrect ) * dofblur9 );",
    "	col += texture2D( tColor, vUv.xy + ( vec2(  0.37,  0.15 ) * aspectcorrect ) * dofblur9 );",
    "	col += texture2D( tColor, vUv.xy + ( vec2( -0.37, -0.15 ) * aspectcorrect ) * dofblur9 );",
    "	col += texture2D( tColor, vUv.xy + ( vec2(  0.15, -0.37 ) * aspectcorrect ) * dofblur9 );",
    "	col += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur7 );",
    "	col += texture2D( tColor, vUv.xy + ( vec2(  0.40,  0.0  ) * aspectcorrect ) * dofblur7 );",
    "	col += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur7 );",
    "	col += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur7 );",
    "	col += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur7 );",
    "	col += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur7 );",
    "	col += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur7 );",
    "	col += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur7 );",
    "	col += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur4 );",
    "	col += texture2D( tColor, vUv.xy + ( vec2(  0.4,   0.0  ) * aspectcorrect ) * dofblur4 );",
    "	col += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur4 );",
    "	col += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur4 );",
    "	col += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur4 );",
    "	col += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur4 );",
    "	col += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur4 );",
    "	col += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur4 );",
    "	gl_FragColor = col / 41.0;",
    "	gl_FragColor.a = 1.0;",
    "}"
  ].join("\n")
};

// node_modules/three-stdlib/shaders/LuminosityShader.js
var LuminosityShader = {
  uniforms: {
    tDiffuse: { value: null }
  },
  vertexShader: [
    "varying vec2 vUv;",
    "void main() {",
    "	vUv = uv;",
    "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
    "}"
  ].join("\n"),
  fragmentShader: [
    "#include <common>",
    "uniform sampler2D tDiffuse;",
    "varying vec2 vUv;",
    "void main() {",
    "	vec4 texel = texture2D( tDiffuse, vUv );",
    "	float l = linearToRelativeLuminance( texel.rgb );",
    "	gl_FragColor = vec4( l, l, l, texel.w );",
    "}"
  ].join("\n")
};

// node_modules/three-stdlib/shaders/ToneMapShader.js
var ToneMapShader = {
  uniforms: {
    tDiffuse: { value: null },
    averageLuminance: { value: 1 },
    luminanceMap: { value: null },
    maxLuminance: { value: 16 },
    minLuminance: { value: 0.01 },
    middleGrey: { value: 0.6 }
  },
  vertexShader: [
    "varying vec2 vUv;",
    "void main() {",
    "	vUv = uv;",
    "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
    "}"
  ].join("\n"),
  fragmentShader: [
    "#include <common>",
    "uniform sampler2D tDiffuse;",
    "varying vec2 vUv;",
    "uniform float middleGrey;",
    "uniform float minLuminance;",
    "uniform float maxLuminance;",
    "#ifdef ADAPTED_LUMINANCE",
    "	uniform sampler2D luminanceMap;",
    "#else",
    "	uniform float averageLuminance;",
    "#endif",
    "vec3 ToneMap( vec3 vColor ) {",
    "	#ifdef ADAPTED_LUMINANCE",
    // Get the calculated average luminance
    "		float fLumAvg = texture2D(luminanceMap, vec2(0.5, 0.5)).r;",
    "	#else",
    "		float fLumAvg = averageLuminance;",
    "	#endif",
    // Calculate the luminance of the current pixel
    "	float fLumPixel = linearToRelativeLuminance( vColor );",
    // Apply the modified operator (Eq. 4)
    "	float fLumScaled = (fLumPixel * middleGrey) / max( minLuminance, fLumAvg );",
    "	float fLumCompressed = (fLumScaled * (1.0 + (fLumScaled / (maxLuminance * maxLuminance)))) / (1.0 + fLumScaled);",
    "	return fLumCompressed * vColor;",
    "}",
    "void main() {",
    "	vec4 texel = texture2D( tDiffuse, vUv );",
    "	gl_FragColor = vec4( ToneMap( texel.xyz ), texel.w );",
    "}"
  ].join("\n")
};

// node_modules/three-stdlib/shaders/LuminosityHighPassShader.js
var LuminosityHighPassShader = {
  shaderID: "luminosityHighPass",
  uniforms: {
    tDiffuse: { value: null },
    luminosityThreshold: { value: 1 },
    smoothWidth: { value: 1 },
    defaultColor: { value: new Color(0) },
    defaultOpacity: { value: 0 }
  },
  vertexShader: [
    "varying vec2 vUv;",
    "void main() {",
    "	vUv = uv;",
    "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
    "}"
  ].join("\n"),
  fragmentShader: [
    "uniform sampler2D tDiffuse;",
    "uniform vec3 defaultColor;",
    "uniform float defaultOpacity;",
    "uniform float luminosityThreshold;",
    "uniform float smoothWidth;",
    "varying vec2 vUv;",
    "void main() {",
    "	vec4 texel = texture2D( tDiffuse, vUv );",
    "	vec3 luma = vec3( 0.299, 0.587, 0.114 );",
    "	float v = dot( texel.xyz, luma );",
    "	vec4 outputColor = vec4( defaultColor.rgb, defaultOpacity );",
    "	float alpha = smoothstep( luminosityThreshold, luminosityThreshold + smoothWidth, v );",
    "	gl_FragColor = mix( outputColor, texel, alpha );",
    "}"
  ].join("\n")
};

// node_modules/three-stdlib/postprocessing/UnrealBloomPass.js
var __defProp14 = Object.defineProperty;
var __defNormalProp14 = (obj, key, value) => key in obj ? __defProp14(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField15 = (obj, key, value) => {
  __defNormalProp14(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var _UnrealBloomPass = class extends Pass {
  constructor(resolution, strength, radius, threshold) {
    super();
    this.strength = strength !== void 0 ? strength : 1;
    this.radius = radius;
    this.threshold = threshold;
    this.resolution = resolution !== void 0 ? new Vector2(resolution.x, resolution.y) : new Vector2(256, 256);
    this.clearColor = new Color(0, 0, 0);
    this.renderTargetsHorizontal = [];
    this.renderTargetsVertical = [];
    this.nMips = 5;
    let resx = Math.round(this.resolution.x / 2);
    let resy = Math.round(this.resolution.y / 2);
    this.renderTargetBright = new WebGLRenderTarget(resx, resy, { type: HalfFloatType });
    this.renderTargetBright.texture.name = "UnrealBloomPass.bright";
    this.renderTargetBright.texture.generateMipmaps = false;
    for (let i3 = 0; i3 < this.nMips; i3++) {
      const renderTargetHorizonal = new WebGLRenderTarget(resx, resy, { type: HalfFloatType });
      renderTargetHorizonal.texture.name = "UnrealBloomPass.h" + i3;
      renderTargetHorizonal.texture.generateMipmaps = false;
      this.renderTargetsHorizontal.push(renderTargetHorizonal);
      const renderTargetVertical = new WebGLRenderTarget(resx, resy, { type: HalfFloatType });
      renderTargetVertical.texture.name = "UnrealBloomPass.v" + i3;
      renderTargetVertical.texture.generateMipmaps = false;
      this.renderTargetsVertical.push(renderTargetVertical);
      resx = Math.round(resx / 2);
      resy = Math.round(resy / 2);
    }
    const highPassShader = LuminosityHighPassShader;
    this.highPassUniforms = UniformsUtils.clone(highPassShader.uniforms);
    this.highPassUniforms["luminosityThreshold"].value = threshold;
    this.highPassUniforms["smoothWidth"].value = 0.01;
    this.materialHighPassFilter = new ShaderMaterial({
      uniforms: this.highPassUniforms,
      vertexShader: highPassShader.vertexShader,
      fragmentShader: highPassShader.fragmentShader,
      defines: {}
    });
    this.separableBlurMaterials = [];
    const kernelSizeArray = [3, 5, 7, 9, 11];
    resx = Math.round(this.resolution.x / 2);
    resy = Math.round(this.resolution.y / 2);
    for (let i3 = 0; i3 < this.nMips; i3++) {
      this.separableBlurMaterials.push(this.getSeperableBlurMaterial(kernelSizeArray[i3]));
      this.separableBlurMaterials[i3].uniforms["texSize"].value = new Vector2(resx, resy);
      resx = Math.round(resx / 2);
      resy = Math.round(resy / 2);
    }
    this.compositeMaterial = this.getCompositeMaterial(this.nMips);
    this.compositeMaterial.uniforms["blurTexture1"].value = this.renderTargetsVertical[0].texture;
    this.compositeMaterial.uniforms["blurTexture2"].value = this.renderTargetsVertical[1].texture;
    this.compositeMaterial.uniforms["blurTexture3"].value = this.renderTargetsVertical[2].texture;
    this.compositeMaterial.uniforms["blurTexture4"].value = this.renderTargetsVertical[3].texture;
    this.compositeMaterial.uniforms["blurTexture5"].value = this.renderTargetsVertical[4].texture;
    this.compositeMaterial.uniforms["bloomStrength"].value = strength;
    this.compositeMaterial.uniforms["bloomRadius"].value = 0.1;
    this.compositeMaterial.needsUpdate = true;
    const bloomFactors = [1, 0.8, 0.6, 0.4, 0.2];
    this.compositeMaterial.uniforms["bloomFactors"].value = bloomFactors;
    this.bloomTintColors = [
      new Vector3(1, 1, 1),
      new Vector3(1, 1, 1),
      new Vector3(1, 1, 1),
      new Vector3(1, 1, 1),
      new Vector3(1, 1, 1)
    ];
    this.compositeMaterial.uniforms["bloomTintColors"].value = this.bloomTintColors;
    const copyShader = CopyShader;
    this.copyUniforms = UniformsUtils.clone(copyShader.uniforms);
    this.copyUniforms["opacity"].value = 1;
    this.materialCopy = new ShaderMaterial({
      uniforms: this.copyUniforms,
      vertexShader: copyShader.vertexShader,
      fragmentShader: copyShader.fragmentShader,
      blending: AdditiveBlending,
      depthTest: false,
      depthWrite: false,
      transparent: true
    });
    this.enabled = true;
    this.needsSwap = false;
    this._oldClearColor = new Color();
    this.oldClearAlpha = 1;
    this.basic = new MeshBasicMaterial();
    this.fsQuad = new FullScreenQuad(null);
  }
  dispose() {
    for (let i3 = 0; i3 < this.renderTargetsHorizontal.length; i3++) {
      this.renderTargetsHorizontal[i3].dispose();
    }
    for (let i3 = 0; i3 < this.renderTargetsVertical.length; i3++) {
      this.renderTargetsVertical[i3].dispose();
    }
    this.renderTargetBright.dispose();
    for (let i3 = 0; i3 < this.separableBlurMaterials.length; i3++) {
      this.separableBlurMaterials[i3].dispose();
    }
    this.compositeMaterial.dispose();
    this.materialCopy.dispose();
    this.basic.dispose();
    this.fsQuad.dispose();
  }
  setSize(width, height) {
    let resx = Math.round(width / 2);
    let resy = Math.round(height / 2);
    this.renderTargetBright.setSize(resx, resy);
    for (let i3 = 0; i3 < this.nMips; i3++) {
      this.renderTargetsHorizontal[i3].setSize(resx, resy);
      this.renderTargetsVertical[i3].setSize(resx, resy);
      this.separableBlurMaterials[i3].uniforms["texSize"].value = new Vector2(resx, resy);
      resx = Math.round(resx / 2);
      resy = Math.round(resy / 2);
    }
  }
  render(renderer, writeBuffer, readBuffer, deltaTime, maskActive) {
    renderer.getClearColor(this._oldClearColor);
    this.oldClearAlpha = renderer.getClearAlpha();
    const oldAutoClear = renderer.autoClear;
    renderer.autoClear = false;
    renderer.setClearColor(this.clearColor, 0);
    if (maskActive)
      renderer.state.buffers.stencil.setTest(false);
    if (this.renderToScreen) {
      this.fsQuad.material = this.basic;
      this.basic.map = readBuffer.texture;
      renderer.setRenderTarget(null);
      renderer.clear();
      this.fsQuad.render(renderer);
    }
    this.highPassUniforms["tDiffuse"].value = readBuffer.texture;
    this.highPassUniforms["luminosityThreshold"].value = this.threshold;
    this.fsQuad.material = this.materialHighPassFilter;
    renderer.setRenderTarget(this.renderTargetBright);
    renderer.clear();
    this.fsQuad.render(renderer);
    let inputRenderTarget = this.renderTargetBright;
    for (let i3 = 0; i3 < this.nMips; i3++) {
      this.fsQuad.material = this.separableBlurMaterials[i3];
      this.separableBlurMaterials[i3].uniforms["colorTexture"].value = inputRenderTarget.texture;
      this.separableBlurMaterials[i3].uniforms["direction"].value = _UnrealBloomPass.BlurDirectionX;
      renderer.setRenderTarget(this.renderTargetsHorizontal[i3]);
      renderer.clear();
      this.fsQuad.render(renderer);
      this.separableBlurMaterials[i3].uniforms["colorTexture"].value = this.renderTargetsHorizontal[i3].texture;
      this.separableBlurMaterials[i3].uniforms["direction"].value = _UnrealBloomPass.BlurDirectionY;
      renderer.setRenderTarget(this.renderTargetsVertical[i3]);
      renderer.clear();
      this.fsQuad.render(renderer);
      inputRenderTarget = this.renderTargetsVertical[i3];
    }
    this.fsQuad.material = this.compositeMaterial;
    this.compositeMaterial.uniforms["bloomStrength"].value = this.strength;
    this.compositeMaterial.uniforms["bloomRadius"].value = this.radius;
    this.compositeMaterial.uniforms["bloomTintColors"].value = this.bloomTintColors;
    renderer.setRenderTarget(this.renderTargetsHorizontal[0]);
    renderer.clear();
    this.fsQuad.render(renderer);
    this.fsQuad.material = this.materialCopy;
    this.copyUniforms["tDiffuse"].value = this.renderTargetsHorizontal[0].texture;
    if (maskActive)
      renderer.state.buffers.stencil.setTest(true);
    if (this.renderToScreen) {
      renderer.setRenderTarget(null);
      this.fsQuad.render(renderer);
    } else {
      renderer.setRenderTarget(readBuffer);
      this.fsQuad.render(renderer);
    }
    renderer.setClearColor(this._oldClearColor, this.oldClearAlpha);
    renderer.autoClear = oldAutoClear;
  }
  getSeperableBlurMaterial(kernelRadius) {
    return new ShaderMaterial({
      defines: {
        KERNEL_RADIUS: kernelRadius,
        SIGMA: kernelRadius
      },
      uniforms: {
        colorTexture: { value: null },
        texSize: { value: new Vector2(0.5, 0.5) },
        direction: { value: new Vector2(0.5, 0.5) }
      },
      vertexShader: `varying vec2 vUv;
				void main() {
					vUv = uv;
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
				}`,
      fragmentShader: `#include <common>
				varying vec2 vUv;
				uniform sampler2D colorTexture;
				uniform vec2 texSize;
				uniform vec2 direction;

				float gaussianPdf(in float x, in float sigma) {
					return 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;
				}
				void main() {
					vec2 invSize = 1.0 / texSize;
					float fSigma = float(SIGMA);
					float weightSum = gaussianPdf(0.0, fSigma);
					vec3 diffuseSum = texture2D( colorTexture, vUv).rgb * weightSum;
					for( int i = 1; i < KERNEL_RADIUS; i ++ ) {
						float x = float(i);
						float w = gaussianPdf(x, fSigma);
						vec2 uvOffset = direction * invSize * x;
						vec3 sample1 = texture2D( colorTexture, vUv + uvOffset).rgb;
						vec3 sample2 = texture2D( colorTexture, vUv - uvOffset).rgb;
						diffuseSum += (sample1 + sample2) * w;
						weightSum += 2.0 * w;
					}
					gl_FragColor = vec4(diffuseSum/weightSum, 1.0);
				}`
    });
  }
  getCompositeMaterial(nMips) {
    return new ShaderMaterial({
      defines: {
        NUM_MIPS: nMips
      },
      uniforms: {
        blurTexture1: { value: null },
        blurTexture2: { value: null },
        blurTexture3: { value: null },
        blurTexture4: { value: null },
        blurTexture5: { value: null },
        bloomStrength: { value: 1 },
        bloomFactors: { value: null },
        bloomTintColors: { value: null },
        bloomRadius: { value: 0 }
      },
      vertexShader: `varying vec2 vUv;
				void main() {
					vUv = uv;
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
				}`,
      fragmentShader: `varying vec2 vUv;
				uniform sampler2D blurTexture1;
				uniform sampler2D blurTexture2;
				uniform sampler2D blurTexture3;
				uniform sampler2D blurTexture4;
				uniform sampler2D blurTexture5;
				uniform float bloomStrength;
				uniform float bloomRadius;
				uniform float bloomFactors[NUM_MIPS];
				uniform vec3 bloomTintColors[NUM_MIPS];

				float lerpBloomFactor(const in float factor) {
					float mirrorFactor = 1.2 - factor;
					return mix(factor, mirrorFactor, bloomRadius);
				}

				void main() {
					gl_FragColor = bloomStrength * ( lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) +
						lerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) +
						lerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) +
						lerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) +
						lerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );
				}`
    });
  }
};
var UnrealBloomPass = _UnrealBloomPass;
__publicField15(UnrealBloomPass, "BlurDirectionX", new Vector2(1, 0));
__publicField15(UnrealBloomPass, "BlurDirectionY", new Vector2(0, 1));

// node_modules/three-stdlib/shaders/SAOShader.js
var SAOShader = {
  defines: {
    NUM_SAMPLES: 7,
    NUM_RINGS: 4,
    NORMAL_TEXTURE: 0,
    DIFFUSE_TEXTURE: 0,
    DEPTH_PACKING: 1,
    PERSPECTIVE_CAMERA: 1
  },
  uniforms: {
    tDepth: { value: null },
    tDiffuse: { value: null },
    tNormal: { value: null },
    size: { value: new Vector2(512, 512) },
    cameraNear: { value: 1 },
    cameraFar: { value: 100 },
    cameraProjectionMatrix: { value: new Matrix4() },
    cameraInverseProjectionMatrix: { value: new Matrix4() },
    scale: { value: 1 },
    intensity: { value: 0.1 },
    bias: { value: 0.5 },
    minResolution: { value: 0 },
    kernelRadius: { value: 100 },
    randomSeed: { value: 0 }
  },
  vertexShader: [
    "varying vec2 vUv;",
    "void main() {",
    "	vUv = uv;",
    "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
    "}"
  ].join("\n"),
  fragmentShader: [
    "#include <common>",
    "varying vec2 vUv;",
    "#if DIFFUSE_TEXTURE == 1",
    "uniform sampler2D tDiffuse;",
    "#endif",
    "uniform sampler2D tDepth;",
    "#if NORMAL_TEXTURE == 1",
    "uniform sampler2D tNormal;",
    "#endif",
    "uniform float cameraNear;",
    "uniform float cameraFar;",
    "uniform mat4 cameraProjectionMatrix;",
    "uniform mat4 cameraInverseProjectionMatrix;",
    "uniform float scale;",
    "uniform float intensity;",
    "uniform float bias;",
    "uniform float kernelRadius;",
    "uniform float minResolution;",
    "uniform vec2 size;",
    "uniform float randomSeed;",
    "// RGBA depth",
    "#include <packing>",
    "vec4 getDefaultColor( const in vec2 screenPosition ) {",
    "	#if DIFFUSE_TEXTURE == 1",
    "	return texture2D( tDiffuse, vUv );",
    "	#else",
    "	return vec4( 1.0 );",
    "	#endif",
    "}",
    "float getDepth( const in vec2 screenPosition ) {",
    "	#if DEPTH_PACKING == 1",
    "	return unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );",
    "	#else",
    "	return texture2D( tDepth, screenPosition ).x;",
    "	#endif",
    "}",
    "float getViewZ( const in float depth ) {",
    "	#if PERSPECTIVE_CAMERA == 1",
    "	return perspectiveDepthToViewZ( depth, cameraNear, cameraFar );",
    "	#else",
    "	return orthographicDepthToViewZ( depth, cameraNear, cameraFar );",
    "	#endif",
    "}",
    "vec3 getViewPosition( const in vec2 screenPosition, const in float depth, const in float viewZ ) {",
    "	float clipW = cameraProjectionMatrix[2][3] * viewZ + cameraProjectionMatrix[3][3];",
    "	vec4 clipPosition = vec4( ( vec3( screenPosition, depth ) - 0.5 ) * 2.0, 1.0 );",
    "	clipPosition *= clipW; // unprojection.",
    "	return ( cameraInverseProjectionMatrix * clipPosition ).xyz;",
    "}",
    "vec3 getViewNormal( const in vec3 viewPosition, const in vec2 screenPosition ) {",
    "	#if NORMAL_TEXTURE == 1",
    "	return unpackRGBToNormal( texture2D( tNormal, screenPosition ).xyz );",
    "	#else",
    "	return normalize( cross( dFdx( viewPosition ), dFdy( viewPosition ) ) );",
    "	#endif",
    "}",
    "float scaleDividedByCameraFar;",
    "float minResolutionMultipliedByCameraFar;",
    "float getOcclusion( const in vec3 centerViewPosition, const in vec3 centerViewNormal, const in vec3 sampleViewPosition ) {",
    "	vec3 viewDelta = sampleViewPosition - centerViewPosition;",
    "	float viewDistance = length( viewDelta );",
    "	float scaledScreenDistance = scaleDividedByCameraFar * viewDistance;",
    "	return max(0.0, (dot(centerViewNormal, viewDelta) - minResolutionMultipliedByCameraFar) / scaledScreenDistance - bias) / (1.0 + pow2( scaledScreenDistance ) );",
    "}",
    "// moving costly divides into consts",
    "const float ANGLE_STEP = PI2 * float( NUM_RINGS ) / float( NUM_SAMPLES );",
    "const float INV_NUM_SAMPLES = 1.0 / float( NUM_SAMPLES );",
    "float getAmbientOcclusion( const in vec3 centerViewPosition ) {",
    "	// precompute some variables require in getOcclusion.",
    "	scaleDividedByCameraFar = scale / cameraFar;",
    "	minResolutionMultipliedByCameraFar = minResolution * cameraFar;",
    "	vec3 centerViewNormal = getViewNormal( centerViewPosition, vUv );",
    "	// jsfiddle that shows sample pattern: https://jsfiddle.net/a16ff1p7/",
    "	float angle = rand( vUv + randomSeed ) * PI2;",
    "	vec2 radius = vec2( kernelRadius * INV_NUM_SAMPLES ) / size;",
    "	vec2 radiusStep = radius;",
    "	float occlusionSum = 0.0;",
    "	float weightSum = 0.0;",
    "	for( int i = 0; i < NUM_SAMPLES; i ++ ) {",
    "		vec2 sampleUv = vUv + vec2( cos( angle ), sin( angle ) ) * radius;",
    "		radius += radiusStep;",
    "		angle += ANGLE_STEP;",
    "		float sampleDepth = getDepth( sampleUv );",
    "		if( sampleDepth >= ( 1.0 - EPSILON ) ) {",
    "			continue;",
    "		}",
    "		float sampleViewZ = getViewZ( sampleDepth );",
    "		vec3 sampleViewPosition = getViewPosition( sampleUv, sampleDepth, sampleViewZ );",
    "		occlusionSum += getOcclusion( centerViewPosition, centerViewNormal, sampleViewPosition );",
    "		weightSum += 1.0;",
    "	}",
    "	if( weightSum == 0.0 ) discard;",
    "	return occlusionSum * ( intensity / weightSum );",
    "}",
    "void main() {",
    "	float centerDepth = getDepth( vUv );",
    "	if( centerDepth >= ( 1.0 - EPSILON ) ) {",
    "		discard;",
    "	}",
    "	float centerViewZ = getViewZ( centerDepth );",
    "	vec3 viewPosition = getViewPosition( vUv, centerDepth, centerViewZ );",
    "	float ambientOcclusion = getAmbientOcclusion( viewPosition );",
    "	gl_FragColor = getDefaultColor( vUv );",
    "	gl_FragColor.xyz *=  1.0 - ambientOcclusion;",
    "}"
  ].join("\n")
};

// node_modules/three-stdlib/shaders/DepthLimitedBlurShader.js
var DepthLimitedBlurShader = {
  defines: {
    KERNEL_RADIUS: 4,
    DEPTH_PACKING: 1,
    PERSPECTIVE_CAMERA: 1
  },
  uniforms: {
    tDiffuse: { value: null },
    size: { value: new Vector2(512, 512) },
    sampleUvOffsets: { value: [new Vector2(0, 0)] },
    sampleWeights: { value: [1] },
    tDepth: { value: null },
    cameraNear: { value: 10 },
    cameraFar: { value: 1e3 },
    depthCutoff: { value: 10 }
  },
  vertexShader: [
    "#include <common>",
    "uniform vec2 size;",
    "varying vec2 vUv;",
    "varying vec2 vInvSize;",
    "void main() {",
    "	vUv = uv;",
    "	vInvSize = 1.0 / size;",
    "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
    "}"
  ].join("\n"),
  fragmentShader: [
    "#include <common>",
    "#include <packing>",
    "uniform sampler2D tDiffuse;",
    "uniform sampler2D tDepth;",
    "uniform float cameraNear;",
    "uniform float cameraFar;",
    "uniform float depthCutoff;",
    "uniform vec2 sampleUvOffsets[ KERNEL_RADIUS + 1 ];",
    "uniform float sampleWeights[ KERNEL_RADIUS + 1 ];",
    "varying vec2 vUv;",
    "varying vec2 vInvSize;",
    "float getDepth( const in vec2 screenPosition ) {",
    "	#if DEPTH_PACKING == 1",
    "	return unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );",
    "	#else",
    "	return texture2D( tDepth, screenPosition ).x;",
    "	#endif",
    "}",
    "float getViewZ( const in float depth ) {",
    "	#if PERSPECTIVE_CAMERA == 1",
    "	return perspectiveDepthToViewZ( depth, cameraNear, cameraFar );",
    "	#else",
    "	return orthographicDepthToViewZ( depth, cameraNear, cameraFar );",
    "	#endif",
    "}",
    "void main() {",
    "	float depth = getDepth( vUv );",
    "	if( depth >= ( 1.0 - EPSILON ) ) {",
    "		discard;",
    "	}",
    "	float centerViewZ = -getViewZ( depth );",
    "	bool rBreak = false, lBreak = false;",
    "	float weightSum = sampleWeights[0];",
    "	vec4 diffuseSum = texture2D( tDiffuse, vUv ) * weightSum;",
    "	for( int i = 1; i <= KERNEL_RADIUS; i ++ ) {",
    "		float sampleWeight = sampleWeights[i];",
    "		vec2 sampleUvOffset = sampleUvOffsets[i] * vInvSize;",
    "		vec2 sampleUv = vUv + sampleUvOffset;",
    "		float viewZ = -getViewZ( getDepth( sampleUv ) );",
    "		if( abs( viewZ - centerViewZ ) > depthCutoff ) rBreak = true;",
    "		if( ! rBreak ) {",
    "			diffuseSum += texture2D( tDiffuse, sampleUv ) * sampleWeight;",
    "			weightSum += sampleWeight;",
    "		}",
    "		sampleUv = vUv - sampleUvOffset;",
    "		viewZ = -getViewZ( getDepth( sampleUv ) );",
    "		if( abs( viewZ - centerViewZ ) > depthCutoff ) lBreak = true;",
    "		if( ! lBreak ) {",
    "			diffuseSum += texture2D( tDiffuse, sampleUv ) * sampleWeight;",
    "			weightSum += sampleWeight;",
    "		}",
    "	}",
    "	gl_FragColor = diffuseSum / weightSum;",
    "}"
  ].join("\n")
};
var BlurShaderUtils = {
  createSampleWeights: (kernelRadius, stdDev) => {
    const gaussian = (x, stdDev2) => {
      return Math.exp(-(x * x) / (2 * (stdDev2 * stdDev2))) / (Math.sqrt(2 * Math.PI) * stdDev2);
    };
    const weights = [];
    for (let i3 = 0; i3 <= kernelRadius; i3++) {
      weights.push(gaussian(i3, stdDev));
    }
    return weights;
  },
  createSampleOffsets: (kernelRadius, uvIncrement) => {
    const offsets = [];
    for (let i3 = 0; i3 <= kernelRadius; i3++) {
      offsets.push(uvIncrement.clone().multiplyScalar(i3));
    }
    return offsets;
  },
  configure: (shader, kernelRadius, stdDev, uvIncrement) => {
    shader.defines["KERNEL_RADIUS"] = kernelRadius;
    shader.uniforms["sampleUvOffsets"].value = BlurShaderUtils.createSampleOffsets(kernelRadius, uvIncrement);
    shader.uniforms["sampleWeights"].value = BlurShaderUtils.createSampleWeights(kernelRadius, stdDev);
    shader.needsUpdate = true;
  }
};

// node_modules/three-stdlib/postprocessing/SAOPass.js
var __defProp15 = Object.defineProperty;
var __defNormalProp15 = (obj, key, value) => key in obj ? __defProp15(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField16 = (obj, key, value) => {
  __defNormalProp15(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var SAOPass = class extends Pass {
  constructor(scene, camera, useDepthTexture = false, useNormals = false, resolution = new Vector2(256, 256)) {
    super();
    this.scene = scene;
    this.camera = camera;
    this.clear = true;
    this.needsSwap = false;
    this.supportsDepthTextureExtension = useDepthTexture;
    this.supportsNormalTexture = useNormals;
    this.originalClearColor = new Color();
    this._oldClearColor = new Color();
    this.oldClearAlpha = 1;
    this.params = {
      output: 0,
      saoBias: 0.5,
      saoIntensity: 0.18,
      saoScale: 1,
      saoKernelRadius: 100,
      saoMinResolution: 0,
      saoBlur: true,
      saoBlurRadius: 8,
      saoBlurStdDev: 4,
      saoBlurDepthCutoff: 0.01
    };
    this.resolution = new Vector2(resolution.x, resolution.y);
    this.saoRenderTarget = new WebGLRenderTarget(this.resolution.x, this.resolution.y, { type: HalfFloatType });
    this.blurIntermediateRenderTarget = this.saoRenderTarget.clone();
    this.beautyRenderTarget = this.saoRenderTarget.clone();
    this.normalRenderTarget = new WebGLRenderTarget(this.resolution.x, this.resolution.y, {
      minFilter: NearestFilter,
      magFilter: NearestFilter,
      type: HalfFloatType
    });
    this.depthRenderTarget = this.normalRenderTarget.clone();
    let depthTexture;
    if (this.supportsDepthTextureExtension) {
      depthTexture = new DepthTexture();
      depthTexture.type = UnsignedShortType;
      this.beautyRenderTarget.depthTexture = depthTexture;
      this.beautyRenderTarget.depthBuffer = true;
    }
    this.depthMaterial = new MeshDepthMaterial();
    this.depthMaterial.depthPacking = RGBADepthPacking;
    this.depthMaterial.blending = NoBlending;
    this.normalMaterial = new MeshNormalMaterial();
    this.normalMaterial.blending = NoBlending;
    this.saoMaterial = new ShaderMaterial({
      defines: Object.assign({}, SAOShader.defines),
      fragmentShader: SAOShader.fragmentShader,
      vertexShader: SAOShader.vertexShader,
      uniforms: UniformsUtils.clone(SAOShader.uniforms)
    });
    this.saoMaterial.extensions.derivatives = true;
    this.saoMaterial.defines["DEPTH_PACKING"] = this.supportsDepthTextureExtension ? 0 : 1;
    this.saoMaterial.defines["NORMAL_TEXTURE"] = this.supportsNormalTexture ? 1 : 0;
    this.saoMaterial.defines["PERSPECTIVE_CAMERA"] = this.camera.isPerspectiveCamera ? 1 : 0;
    this.saoMaterial.uniforms["tDepth"].value = this.supportsDepthTextureExtension ? depthTexture : this.depthRenderTarget.texture;
    this.saoMaterial.uniforms["tNormal"].value = this.normalRenderTarget.texture;
    this.saoMaterial.uniforms["size"].value.set(this.resolution.x, this.resolution.y);
    this.saoMaterial.uniforms["cameraInverseProjectionMatrix"].value.copy(this.camera.projectionMatrixInverse);
    this.saoMaterial.uniforms["cameraProjectionMatrix"].value = this.camera.projectionMatrix;
    this.saoMaterial.blending = NoBlending;
    this.vBlurMaterial = new ShaderMaterial({
      uniforms: UniformsUtils.clone(DepthLimitedBlurShader.uniforms),
      defines: Object.assign({}, DepthLimitedBlurShader.defines),
      vertexShader: DepthLimitedBlurShader.vertexShader,
      fragmentShader: DepthLimitedBlurShader.fragmentShader
    });
    this.vBlurMaterial.defines["DEPTH_PACKING"] = this.supportsDepthTextureExtension ? 0 : 1;
    this.vBlurMaterial.defines["PERSPECTIVE_CAMERA"] = this.camera.isPerspectiveCamera ? 1 : 0;
    this.vBlurMaterial.uniforms["tDiffuse"].value = this.saoRenderTarget.texture;
    this.vBlurMaterial.uniforms["tDepth"].value = this.supportsDepthTextureExtension ? depthTexture : this.depthRenderTarget.texture;
    this.vBlurMaterial.uniforms["size"].value.set(this.resolution.x, this.resolution.y);
    this.vBlurMaterial.blending = NoBlending;
    this.hBlurMaterial = new ShaderMaterial({
      uniforms: UniformsUtils.clone(DepthLimitedBlurShader.uniforms),
      defines: Object.assign({}, DepthLimitedBlurShader.defines),
      vertexShader: DepthLimitedBlurShader.vertexShader,
      fragmentShader: DepthLimitedBlurShader.fragmentShader
    });
    this.hBlurMaterial.defines["DEPTH_PACKING"] = this.supportsDepthTextureExtension ? 0 : 1;
    this.hBlurMaterial.defines["PERSPECTIVE_CAMERA"] = this.camera.isPerspectiveCamera ? 1 : 0;
    this.hBlurMaterial.uniforms["tDiffuse"].value = this.blurIntermediateRenderTarget.texture;
    this.hBlurMaterial.uniforms["tDepth"].value = this.supportsDepthTextureExtension ? depthTexture : this.depthRenderTarget.texture;
    this.hBlurMaterial.uniforms["size"].value.set(this.resolution.x, this.resolution.y);
    this.hBlurMaterial.blending = NoBlending;
    this.materialCopy = new ShaderMaterial({
      uniforms: UniformsUtils.clone(CopyShader.uniforms),
      vertexShader: CopyShader.vertexShader,
      fragmentShader: CopyShader.fragmentShader,
      blending: NoBlending
    });
    this.materialCopy.transparent = true;
    this.materialCopy.depthTest = false;
    this.materialCopy.depthWrite = false;
    this.materialCopy.blending = CustomBlending;
    this.materialCopy.blendSrc = DstColorFactor;
    this.materialCopy.blendDst = ZeroFactor;
    this.materialCopy.blendEquation = AddEquation;
    this.materialCopy.blendSrcAlpha = DstAlphaFactor;
    this.materialCopy.blendDstAlpha = ZeroFactor;
    this.materialCopy.blendEquationAlpha = AddEquation;
    this.depthCopy = new ShaderMaterial({
      uniforms: UniformsUtils.clone(UnpackDepthRGBAShader.uniforms),
      vertexShader: UnpackDepthRGBAShader.vertexShader,
      fragmentShader: UnpackDepthRGBAShader.fragmentShader,
      blending: NoBlending
    });
    this.fsQuad = new FullScreenQuad(null);
  }
  render(renderer, writeBuffer, readBuffer) {
    if (this.renderToScreen) {
      this.materialCopy.blending = NoBlending;
      this.materialCopy.uniforms["tDiffuse"].value = readBuffer.texture;
      this.materialCopy.needsUpdate = true;
      this.renderPass(renderer, this.materialCopy, null);
    }
    if (this.params.output === 1) {
      return;
    }
    renderer.getClearColor(this._oldClearColor);
    this.oldClearAlpha = renderer.getClearAlpha();
    const oldAutoClear = renderer.autoClear;
    renderer.autoClear = false;
    renderer.setRenderTarget(this.depthRenderTarget);
    renderer.clear();
    this.saoMaterial.uniforms["bias"].value = this.params.saoBias;
    this.saoMaterial.uniforms["intensity"].value = this.params.saoIntensity;
    this.saoMaterial.uniforms["scale"].value = this.params.saoScale;
    this.saoMaterial.uniforms["kernelRadius"].value = this.params.saoKernelRadius;
    this.saoMaterial.uniforms["minResolution"].value = this.params.saoMinResolution;
    this.saoMaterial.uniforms["cameraNear"].value = this.camera.near;
    this.saoMaterial.uniforms["cameraFar"].value = this.camera.far;
    const depthCutoff = this.params.saoBlurDepthCutoff * (this.camera.far - this.camera.near);
    this.vBlurMaterial.uniforms["depthCutoff"].value = depthCutoff;
    this.hBlurMaterial.uniforms["depthCutoff"].value = depthCutoff;
    this.vBlurMaterial.uniforms["cameraNear"].value = this.camera.near;
    this.vBlurMaterial.uniforms["cameraFar"].value = this.camera.far;
    this.hBlurMaterial.uniforms["cameraNear"].value = this.camera.near;
    this.hBlurMaterial.uniforms["cameraFar"].value = this.camera.far;
    this.params.saoBlurRadius = Math.floor(this.params.saoBlurRadius);
    if (this.prevStdDev !== this.params.saoBlurStdDev || this.prevNumSamples !== this.params.saoBlurRadius) {
      BlurShaderUtils.configure(
        this.vBlurMaterial,
        this.params.saoBlurRadius,
        this.params.saoBlurStdDev,
        new Vector2(0, 1)
      );
      BlurShaderUtils.configure(
        this.hBlurMaterial,
        this.params.saoBlurRadius,
        this.params.saoBlurStdDev,
        new Vector2(1, 0)
      );
      this.prevStdDev = this.params.saoBlurStdDev;
      this.prevNumSamples = this.params.saoBlurRadius;
    }
    renderer.setClearColor(0);
    renderer.setRenderTarget(this.beautyRenderTarget);
    renderer.clear();
    renderer.render(this.scene, this.camera);
    if (!this.supportsDepthTextureExtension) {
      this.renderOverride(renderer, this.depthMaterial, this.depthRenderTarget, 0, 1);
    }
    if (this.supportsNormalTexture) {
      this.renderOverride(renderer, this.normalMaterial, this.normalRenderTarget, 7829503, 1);
    }
    this.renderPass(renderer, this.saoMaterial, this.saoRenderTarget, 16777215, 1);
    if (this.params.saoBlur) {
      this.renderPass(renderer, this.vBlurMaterial, this.blurIntermediateRenderTarget, 16777215, 1);
      this.renderPass(renderer, this.hBlurMaterial, this.saoRenderTarget, 16777215, 1);
    }
    let outputMaterial = this.materialCopy;
    if (this.params.output === 3) {
      if (this.supportsDepthTextureExtension) {
        this.materialCopy.uniforms["tDiffuse"].value = this.beautyRenderTarget.depthTexture;
        this.materialCopy.needsUpdate = true;
      } else {
        this.depthCopy.uniforms["tDiffuse"].value = this.depthRenderTarget.texture;
        this.depthCopy.needsUpdate = true;
        outputMaterial = this.depthCopy;
      }
    } else if (this.params.output === 4) {
      this.materialCopy.uniforms["tDiffuse"].value = this.normalRenderTarget.texture;
      this.materialCopy.needsUpdate = true;
    } else {
      this.materialCopy.uniforms["tDiffuse"].value = this.saoRenderTarget.texture;
      this.materialCopy.needsUpdate = true;
    }
    if (this.params.output === 0) {
      outputMaterial.blending = CustomBlending;
    } else {
      outputMaterial.blending = NoBlending;
    }
    this.renderPass(renderer, outputMaterial, this.renderToScreen ? null : readBuffer);
    renderer.setClearColor(this._oldClearColor, this.oldClearAlpha);
    renderer.autoClear = oldAutoClear;
  }
  renderPass(renderer, passMaterial, renderTarget, clearColor, clearAlpha) {
    renderer.getClearColor(this.originalClearColor);
    const originalClearAlpha = renderer.getClearAlpha();
    const originalAutoClear = renderer.autoClear;
    renderer.setRenderTarget(renderTarget);
    renderer.autoClear = false;
    if (clearColor !== void 0 && clearColor !== null) {
      renderer.setClearColor(clearColor);
      renderer.setClearAlpha(clearAlpha || 0);
      renderer.clear();
    }
    this.fsQuad.material = passMaterial;
    this.fsQuad.render(renderer);
    renderer.autoClear = originalAutoClear;
    renderer.setClearColor(this.originalClearColor);
    renderer.setClearAlpha(originalClearAlpha);
  }
  renderOverride(renderer, overrideMaterial, renderTarget, clearColor, clearAlpha) {
    renderer.getClearColor(this.originalClearColor);
    const originalClearAlpha = renderer.getClearAlpha();
    const originalAutoClear = renderer.autoClear;
    renderer.setRenderTarget(renderTarget);
    renderer.autoClear = false;
    clearColor = overrideMaterial.clearColor || clearColor;
    clearAlpha = overrideMaterial.clearAlpha || clearAlpha;
    if (clearColor !== void 0 && clearColor !== null) {
      renderer.setClearColor(clearColor);
      renderer.setClearAlpha(clearAlpha || 0);
      renderer.clear();
    }
    this.scene.overrideMaterial = overrideMaterial;
    renderer.render(this.scene, this.camera);
    this.scene.overrideMaterial = null;
    renderer.autoClear = originalAutoClear;
    renderer.setClearColor(this.originalClearColor);
    renderer.setClearAlpha(originalClearAlpha);
  }
  setSize(width, height) {
    this.beautyRenderTarget.setSize(width, height);
    this.saoRenderTarget.setSize(width, height);
    this.blurIntermediateRenderTarget.setSize(width, height);
    this.normalRenderTarget.setSize(width, height);
    this.depthRenderTarget.setSize(width, height);
    this.saoMaterial.uniforms["size"].value.set(width, height);
    this.saoMaterial.uniforms["cameraInverseProjectionMatrix"].value.copy(this.camera.projectionMatrixInverse);
    this.saoMaterial.uniforms["cameraProjectionMatrix"].value = this.camera.projectionMatrix;
    this.saoMaterial.needsUpdate = true;
    this.vBlurMaterial.uniforms["size"].value.set(width, height);
    this.vBlurMaterial.needsUpdate = true;
    this.hBlurMaterial.uniforms["size"].value.set(width, height);
    this.hBlurMaterial.needsUpdate = true;
  }
  dispose() {
    this.saoRenderTarget.dispose();
    this.blurIntermediateRenderTarget.dispose();
    this.beautyRenderTarget.dispose();
    this.normalRenderTarget.dispose();
    this.depthRenderTarget.dispose();
    this.depthMaterial.dispose();
    this.normalMaterial.dispose();
    this.saoMaterial.dispose();
    this.vBlurMaterial.dispose();
    this.hBlurMaterial.dispose();
    this.materialCopy.dispose();
    this.depthCopy.dispose();
    this.fsQuad.dispose();
  }
};
__publicField16(SAOPass, "OUTPUT", {
  Beauty: 1,
  Default: 0,
  SAO: 2,
  Depth: 3,
  Normal: 4
});

// node_modules/three-stdlib/shaders/AfterimageShader.js
var AfterimageShader = {
  uniforms: {
    damp: { value: 0.96 },
    tOld: { value: null },
    tNew: { value: null }
  },
  vertexShader: [
    "varying vec2 vUv;",
    "void main() {",
    "	vUv = uv;",
    "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
    "}"
  ].join("\n"),
  fragmentShader: [
    "uniform float damp;",
    "uniform sampler2D tOld;",
    "uniform sampler2D tNew;",
    "varying vec2 vUv;",
    "vec4 when_gt( vec4 x, float y ) {",
    "	return max( sign( x - y ), 0.0 );",
    "}",
    "void main() {",
    "	vec4 texelOld = texture2D( tOld, vUv );",
    "	vec4 texelNew = texture2D( tNew, vUv );",
    "	texelOld *= damp * when_gt( texelOld, 0.1 );",
    "	gl_FragColor = max(texelNew, texelOld);",
    "}"
  ].join("\n")
};

// node_modules/three-stdlib/postprocessing/MaskPass.js
var __defProp16 = Object.defineProperty;
var __defNormalProp16 = (obj, key, value) => key in obj ? __defProp16(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField17 = (obj, key, value) => {
  __defNormalProp16(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var MaskPass = class extends Pass {
  constructor(scene, camera) {
    super();
    __publicField17(this, "scene");
    __publicField17(this, "camera");
    __publicField17(this, "inverse");
    this.scene = scene;
    this.camera = camera;
    this.clear = true;
    this.needsSwap = false;
    this.inverse = false;
  }
  render(renderer, writeBuffer, readBuffer) {
    const context3 = renderer.getContext();
    const state = renderer.state;
    state.buffers.color.setMask(false);
    state.buffers.depth.setMask(false);
    state.buffers.color.setLocked(true);
    state.buffers.depth.setLocked(true);
    let writeValue, clearValue;
    if (this.inverse) {
      writeValue = 0;
      clearValue = 1;
    } else {
      writeValue = 1;
      clearValue = 0;
    }
    state.buffers.stencil.setTest(true);
    state.buffers.stencil.setOp(context3.REPLACE, context3.REPLACE, context3.REPLACE);
    state.buffers.stencil.setFunc(context3.ALWAYS, writeValue, 4294967295);
    state.buffers.stencil.setClear(clearValue);
    state.buffers.stencil.setLocked(true);
    renderer.setRenderTarget(readBuffer);
    if (this.clear)
      renderer.clear();
    renderer.render(this.scene, this.camera);
    renderer.setRenderTarget(writeBuffer);
    if (this.clear)
      renderer.clear();
    renderer.render(this.scene, this.camera);
    state.buffers.color.setLocked(false);
    state.buffers.depth.setLocked(false);
    state.buffers.stencil.setLocked(false);
    state.buffers.stencil.setFunc(context3.EQUAL, 1, 4294967295);
    state.buffers.stencil.setOp(context3.KEEP, context3.KEEP, context3.KEEP);
    state.buffers.stencil.setLocked(true);
  }
};
var ClearMaskPass = class extends Pass {
  constructor() {
    super();
    this.needsSwap = false;
  }
  render(renderer) {
    renderer.state.buffers.stencil.setLocked(false);
    renderer.state.buffers.stencil.setTest(false);
  }
};

// node_modules/three-stdlib/postprocessing/EffectComposer.js
var __defProp17 = Object.defineProperty;
var __defNormalProp17 = (obj, key, value) => key in obj ? __defProp17(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField18 = (obj, key, value) => {
  __defNormalProp17(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var EffectComposer = class {
  constructor(renderer, renderTarget) {
    __publicField18(this, "renderer");
    __publicField18(this, "_pixelRatio");
    __publicField18(this, "_width");
    __publicField18(this, "_height");
    __publicField18(this, "renderTarget1");
    __publicField18(this, "renderTarget2");
    __publicField18(this, "writeBuffer");
    __publicField18(this, "readBuffer");
    __publicField18(this, "renderToScreen");
    __publicField18(this, "passes", []);
    __publicField18(this, "copyPass");
    __publicField18(this, "clock");
    this.renderer = renderer;
    if (renderTarget === void 0) {
      const parameters = {
        minFilter: LinearFilter,
        magFilter: LinearFilter,
        format: RGBAFormat
      };
      const size2 = renderer.getSize(new Vector2());
      this._pixelRatio = renderer.getPixelRatio();
      this._width = size2.width;
      this._height = size2.height;
      renderTarget = new WebGLRenderTarget(
        this._width * this._pixelRatio,
        this._height * this._pixelRatio,
        parameters
      );
      renderTarget.texture.name = "EffectComposer.rt1";
    } else {
      this._pixelRatio = 1;
      this._width = renderTarget.width;
      this._height = renderTarget.height;
    }
    this.renderTarget1 = renderTarget;
    this.renderTarget2 = renderTarget.clone();
    this.renderTarget2.texture.name = "EffectComposer.rt2";
    this.writeBuffer = this.renderTarget1;
    this.readBuffer = this.renderTarget2;
    this.renderToScreen = true;
    if (CopyShader === void 0) {
      console.error("THREE.EffectComposer relies on CopyShader");
    }
    if (ShaderPass === void 0) {
      console.error("THREE.EffectComposer relies on ShaderPass");
    }
    this.copyPass = new ShaderPass(CopyShader);
    this.clock = new Clock();
  }
  swapBuffers() {
    const tmp2 = this.readBuffer;
    this.readBuffer = this.writeBuffer;
    this.writeBuffer = tmp2;
  }
  addPass(pass) {
    this.passes.push(pass);
    pass.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
  }
  insertPass(pass, index) {
    this.passes.splice(index, 0, pass);
    pass.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
  }
  removePass(pass) {
    const index = this.passes.indexOf(pass);
    if (index !== -1) {
      this.passes.splice(index, 1);
    }
  }
  isLastEnabledPass(passIndex) {
    for (let i3 = passIndex + 1; i3 < this.passes.length; i3++) {
      if (this.passes[i3].enabled) {
        return false;
      }
    }
    return true;
  }
  render(deltaTime) {
    if (deltaTime === void 0) {
      deltaTime = this.clock.getDelta();
    }
    const currentRenderTarget = this.renderer.getRenderTarget();
    let maskActive = false;
    const il = this.passes.length;
    for (let i3 = 0; i3 < il; i3++) {
      const pass = this.passes[i3];
      if (pass.enabled === false)
        continue;
      pass.renderToScreen = this.renderToScreen && this.isLastEnabledPass(i3);
      pass.render(this.renderer, this.writeBuffer, this.readBuffer, deltaTime, maskActive);
      if (pass.needsSwap) {
        if (maskActive) {
          const context3 = this.renderer.getContext();
          const stencil = this.renderer.state.buffers.stencil;
          stencil.setFunc(context3.NOTEQUAL, 1, 4294967295);
          this.copyPass.render(this.renderer, this.writeBuffer, this.readBuffer, deltaTime);
          stencil.setFunc(context3.EQUAL, 1, 4294967295);
        }
        this.swapBuffers();
      }
      if (MaskPass !== void 0) {
        if (pass instanceof MaskPass) {
          maskActive = true;
        } else if (pass instanceof ClearMaskPass) {
          maskActive = false;
        }
      }
    }
    this.renderer.setRenderTarget(currentRenderTarget);
  }
  reset(renderTarget) {
    if (renderTarget === void 0) {
      const size2 = this.renderer.getSize(new Vector2());
      this._pixelRatio = this.renderer.getPixelRatio();
      this._width = size2.width;
      this._height = size2.height;
      renderTarget = this.renderTarget1.clone();
      renderTarget.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
    }
    this.renderTarget1.dispose();
    this.renderTarget2.dispose();
    this.renderTarget1 = renderTarget;
    this.renderTarget2 = renderTarget.clone();
    this.writeBuffer = this.renderTarget1;
    this.readBuffer = this.renderTarget2;
  }
  setSize(width, height) {
    this._width = width;
    this._height = height;
    const effectiveWidth = this._width * this._pixelRatio;
    const effectiveHeight = this._height * this._pixelRatio;
    this.renderTarget1.setSize(effectiveWidth, effectiveHeight);
    this.renderTarget2.setSize(effectiveWidth, effectiveHeight);
    for (let i3 = 0; i3 < this.passes.length; i3++) {
      this.passes[i3].setSize(effectiveWidth, effectiveHeight);
    }
  }
  setPixelRatio(pixelRatio) {
    this._pixelRatio = pixelRatio;
    this.setSize(this._width, this._height);
  }
};

// node_modules/three-stdlib/shaders/DotScreenShader.js
var DotScreenShader = {
  uniforms: {
    tDiffuse: { value: null },
    tSize: { value: new Vector2(256, 256) },
    center: { value: new Vector2(0.5, 0.5) },
    angle: { value: 1.57 },
    scale: { value: 1 }
  },
  vertexShader: [
    "varying vec2 vUv;",
    "void main() {",
    "	vUv = uv;",
    "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
    "}"
  ].join("\n"),
  fragmentShader: [
    "uniform vec2 center;",
    "uniform float angle;",
    "uniform float scale;",
    "uniform vec2 tSize;",
    "uniform sampler2D tDiffuse;",
    "varying vec2 vUv;",
    "float pattern() {",
    "	float s = sin( angle ), c = cos( angle );",
    "	vec2 tex = vUv * tSize - center;",
    "	vec2 point = vec2( c * tex.x - s * tex.y, s * tex.x + c * tex.y ) * scale;",
    "	return ( sin( point.x ) * sin( point.y ) ) * 4.0;",
    "}",
    "void main() {",
    "	vec4 color = texture2D( tDiffuse, vUv );",
    "	float average = ( color.r + color.g + color.b ) / 3.0;",
    "	gl_FragColor = vec4( vec3( average * 10.0 - 5.0 + pattern() ), color.a );",
    "}"
  ].join("\n")
};

// node_modules/three-stdlib/shaders/SSRShader.js
var SSRShader = {
  defines: {
    MAX_STEP: 0,
    isPerspectiveCamera: true,
    isDistanceAttenuation: true,
    isFresnel: true,
    isInfiniteThick: false,
    isSelective: false
  },
  uniforms: {
    tDiffuse: { value: null },
    tNormal: { value: null },
    tMetalness: { value: null },
    tDepth: { value: null },
    cameraNear: { value: null },
    cameraFar: { value: null },
    resolution: { value: new Vector2() },
    cameraProjectionMatrix: { value: new Matrix4() },
    cameraInverseProjectionMatrix: { value: new Matrix4() },
    opacity: { value: 0.5 },
    maxDistance: { value: 180 },
    cameraRange: { value: 0 },
    surfDist: { value: 7e-3 },
    thickTolerance: { value: 0.03 }
  },
  vertexShader: (
    /* glsl */
    `

    varying vec2 vUv;

    void main() {

			vUv = uv;

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

    }

  `
  ),
  fragmentShader: (
    /* glsl */
    `
		// precision highp float;
		precision highp sampler2D;
		varying vec2 vUv;
		uniform sampler2D tDepth;
		uniform sampler2D tNormal;
		uniform sampler2D tMetalness;
		uniform sampler2D tDiffuse;
		uniform float cameraRange;
		uniform vec2 resolution;
		uniform float opacity;
		uniform float cameraNear;
		uniform float cameraFar;
		uniform float maxDistance;
		uniform float surfDist;
		uniform mat4 cameraProjectionMatrix;
		uniform mat4 cameraInverseProjectionMatrix;
		uniform float thickTolerance;
		#include <packing>
		float pointToLineDistance(vec3 x0, vec3 x1, vec3 x2) {
			//x0: point, x1: linePointA, x2: linePointB
			//https://mathworld.wolfram.com/Point-LineDistance3-Dimensional.html
			return length(cross(x0-x1,x0-x2))/length(x2-x1);
		}
		float pointPlaneDistance(vec3 point,vec3 planePoint,vec3 planeNormal){
			// https://mathworld.wolfram.com/Point-PlaneDistance.html
			//// https://en.wikipedia.org/wiki/Plane_(geometry)
			//// http://paulbourke.net/geometry/pointlineplane/
			float a=planeNormal.x,b=planeNormal.y,c=planeNormal.z;
			float x0=point.x,y0=point.y,z0=point.z;
			float x=planePoint.x,y=planePoint.y,z=planePoint.z;
			float d=-(a*x+b*y+c*z);
			float distance=(a*x0+b*y0+c*z0+d)/sqrt(a*a+b*b+c*c);
			return distance;
		}
		float getDepth( const in vec2 uv ) {
			return texture2D( tDepth, uv ).x;
		}
		float getViewZ( const in float depth ) {
			#ifdef isPerspectiveCamera
				return perspectiveDepthToViewZ( depth, cameraNear, cameraFar );
			#else
				return orthographicDepthToViewZ( depth, cameraNear, cameraFar );
			#endif
		}
		vec3 getViewPosition( const in vec2 uv, const in float depth/*clip space*/, const in float clipW ) {
			vec4 clipPosition = vec4( ( vec3( uv, depth ) - 0.5 ) * 2.0, 1.0 );//ndc
			clipPosition *= clipW; //clip
			return ( cameraInverseProjectionMatrix * clipPosition ).xyz;//view
		}
		vec3 getViewNormal( const in vec2 uv ) {
			return unpackRGBToNormal( texture2D( tNormal, uv ).xyz );
		}
		vec2 viewPositionToXY(vec3 viewPosition){
			vec2 xy;
			vec4 clip=cameraProjectionMatrix*vec4(viewPosition,1);
			xy=clip.xy;//clip
			float clipW=clip.w;
			xy/=clipW;//NDC
			xy=(xy+1.)/2.;//uv
			xy*=resolution;//screen
			return xy;
		}
		void main(){
			#ifdef isSelective
				float metalness=texture2D(tMetalness,vUv).r;
				if(metalness==0.) return;
			#endif

			float depth = getDepth( vUv );
			float viewZ = getViewZ( depth );
			if(-viewZ>=cameraFar) return;

			float clipW = cameraProjectionMatrix[2][3] * viewZ+cameraProjectionMatrix[3][3];
			vec3 viewPosition=getViewPosition( vUv, depth, clipW );

			vec2 d0=gl_FragCoord.xy;
			vec2 d1;

			vec3 viewNormal=getViewNormal( vUv );

			#ifdef isPerspectiveCamera
				vec3 viewIncidenceDir=normalize(viewPosition);
				vec3 viewReflectDir=reflect(viewIncidenceDir,viewNormal);
			#else
				vec3 viewIncidenceDir=vec3(0,0,-1);
				vec3 viewReflectDir=reflect(viewIncidenceDir,viewNormal);
			#endif

			float maxReflectRayLen=maxDistance/dot(-viewIncidenceDir,viewNormal);
			// dot(a,b)==length(a)*length(b)*cos(theta) // https://www.mathsisfun.com/algebra/vectors-dot-product.html
			// if(a.isNormalized&&b.isNormalized) dot(a,b)==cos(theta)
			// maxDistance/maxReflectRayLen=cos(theta)
			// maxDistance/maxReflectRayLen==dot(a,b)
			// maxReflectRayLen==maxDistance/dot(a,b)

			vec3 d1viewPosition=viewPosition+viewReflectDir*maxReflectRayLen;
			#ifdef isPerspectiveCamera
				if(d1viewPosition.z>-cameraNear){
					//https://tutorial.math.lamar.edu/Classes/CalcIII/EqnsOfLines.aspx
					float t=(-cameraNear-viewPosition.z)/viewReflectDir.z;
					d1viewPosition=viewPosition+viewReflectDir*t;
				}
			#endif
			d1=viewPositionToXY(d1viewPosition);

			float totalLen=length(d1-d0);
			float xLen=d1.x-d0.x;
			float yLen=d1.y-d0.y;
			float totalStep=max(abs(xLen),abs(yLen));
			float xSpan=xLen/totalStep;
			float ySpan=yLen/totalStep;
			for(float i=0.;i<MAX_STEP;i++){
				if(i>=totalStep) break;
				vec2 xy=vec2(d0.x+i*xSpan,d0.y+i*ySpan);
				if(xy.x<0.||xy.x>resolution.x||xy.y<0.||xy.y>resolution.y) break;
				float s=length(xy-d0)/totalLen;
				vec2 uv=xy/resolution;

				float d = getDepth(uv);
				float vZ = getViewZ( d );
				if(-vZ>=cameraFar) continue;
				float cW = cameraProjectionMatrix[2][3] * vZ+cameraProjectionMatrix[3][3];
				vec3 vP=getViewPosition( uv, d, cW );

				#ifdef isPerspectiveCamera
					// https://www.comp.nus.edu.sg/~lowkl/publications/lowk_persp_interp_techrep.pdf
					float recipVPZ=1./viewPosition.z;
					float viewReflectRayZ=1./(recipVPZ+s*(1./d1viewPosition.z-recipVPZ));
					float sD=surfDist*cW;
				#else
					float viewReflectRayZ=viewPosition.z+s*(d1viewPosition.z-viewPosition.z);
					float sD=surfDist;
				#endif
				if(viewReflectRayZ-sD>vZ) continue;

				#ifdef isInfiniteThick
					if(viewReflectRayZ+thickTolerance*clipW<vP.z) break;
				#endif
				float away=pointToLineDistance(vP,viewPosition,d1viewPosition);

				float op=opacity;

				if(away<sD){
					vec3 vN=getViewNormal( uv );
					if(dot(viewReflectDir,vN)>=0.) continue;
					float distance=pointPlaneDistance(vP,viewPosition,viewNormal);
					if(distance>maxDistance) break;
					#ifdef isDistanceAttenuation
						float ratio=1.-(distance/maxDistance);
						float attenuation=ratio*ratio;
						op=opacity*attenuation;
					#endif
					#ifdef isFresnel
						float fresnel=(dot(viewIncidenceDir,viewReflectDir)+1.)/2.;
						op*=fresnel;
					#endif
					vec4 reflectColor=texture2D(tDiffuse,uv);
					gl_FragColor.xyz=reflectColor.xyz;
					gl_FragColor.a=op;
					break;
				}
			}
		}
	`
  )
};
var SSRDepthShader = {
  defines: {
    PERSPECTIVE_CAMERA: 1
  },
  uniforms: {
    tDepth: { value: null },
    cameraNear: { value: null },
    cameraFar: { value: null }
  },
  vertexShader: (
    /* glsl */
    `

    varying vec2 vUv;

    void main() {

    	vUv = uv;
    	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

    }

  `
  ),
  fragmentShader: (
    /* glsl */
    `

    uniform sampler2D tDepth;

    uniform float cameraNear;
    uniform float cameraFar;

    varying vec2 vUv;

    #include <packing>

		float getLinearDepth( const in vec2 uv ) {

			#if PERSPECTIVE_CAMERA == 1

				float fragCoordZ = texture2D( tDepth, uv ).x;
				float viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );
				return viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );

			#else

				return texture2D( tDepth, uv ).x;

			#endif

		}

    void main() {

    	float depth = getLinearDepth( vUv );
			float d = 1.0 - depth;
			// d=(d-.999)*1000.;
    	gl_FragColor = vec4( vec3( d ), 1.0 );

    }

  `
  )
};
var SSRBlurShader = {
  uniforms: {
    tDiffuse: { value: null },
    resolution: { value: new Vector2() },
    opacity: { value: 0.5 }
  },
  vertexShader: (
    /* glsl */
    `

    varying vec2 vUv;

    void main() {

    	vUv = uv;
    	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

    }

  `
  ),
  fragmentShader: (
    /* glsl */
    `

    uniform sampler2D tDiffuse;
    uniform vec2 resolution;
    varying vec2 vUv;
    void main() {
			//reverse engineering from PhotoShop blur filter, then change coefficient

    	vec2 texelSize = ( 1.0 / resolution );

			vec4 c=texture2D(tDiffuse,vUv);

			vec2 offset;

			offset=(vec2(-1,0))*texelSize;
			vec4 cl=texture2D(tDiffuse,vUv+offset);

			offset=(vec2(1,0))*texelSize;
			vec4 cr=texture2D(tDiffuse,vUv+offset);

			offset=(vec2(0,-1))*texelSize;
			vec4 cb=texture2D(tDiffuse,vUv+offset);

			offset=(vec2(0,1))*texelSize;
			vec4 ct=texture2D(tDiffuse,vUv+offset);

			// float coeCenter=.5;
			// float coeSide=.125;
			float coeCenter=.2;
			float coeSide=.2;
			float a=c.a*coeCenter+cl.a*coeSide+cr.a*coeSide+cb.a*coeSide+ct.a*coeSide;
			vec3 rgb=(c.rgb*c.a*coeCenter+cl.rgb*cl.a*coeSide+cr.rgb*cr.a*coeSide+cb.rgb*cb.a*coeSide+ct.rgb*ct.a*coeSide)/a;
			gl_FragColor=vec4(rgb,a);

		}
	`
  )
};

// node_modules/three-stdlib/postprocessing/SSRPass.js
var __defProp18 = Object.defineProperty;
var __defNormalProp18 = (obj, key, value) => key in obj ? __defProp18(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField19 = (obj, key, value) => {
  __defNormalProp18(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var _SSRPass = class extends Pass {
  constructor({ renderer, scene, camera, width, height, selects, bouncing = false, groundReflector }) {
    super();
    this.width = width !== void 0 ? width : 512;
    this.height = height !== void 0 ? height : 512;
    this.clear = true;
    this.renderer = renderer;
    this.scene = scene;
    this.camera = camera;
    this.groundReflector = groundReflector;
    this.opacity = SSRShader.uniforms.opacity.value;
    this.output = 0;
    this.maxDistance = SSRShader.uniforms.maxDistance.value;
    this.thickness = SSRShader.uniforms.thickness.value;
    this.tempColor = new Color();
    this._selects = selects;
    this.selective = Array.isArray(this._selects);
    Object.defineProperty(this, "selects", {
      get() {
        return this._selects;
      },
      set(val) {
        if (this._selects === val)
          return;
        this._selects = val;
        if (Array.isArray(val)) {
          this.selective = true;
          this.ssrMaterial.defines.SELECTIVE = true;
          this.ssrMaterial.needsUpdate = true;
        } else {
          this.selective = false;
          this.ssrMaterial.defines.SELECTIVE = false;
          this.ssrMaterial.needsUpdate = true;
        }
      }
    });
    this._bouncing = bouncing;
    Object.defineProperty(this, "bouncing", {
      get() {
        return this._bouncing;
      },
      set(val) {
        if (this._bouncing === val)
          return;
        this._bouncing = val;
        if (val) {
          this.ssrMaterial.uniforms["tDiffuse"].value = this.prevRenderTarget.texture;
        } else {
          this.ssrMaterial.uniforms["tDiffuse"].value = this.beautyRenderTarget.texture;
        }
      }
    });
    this.blur = true;
    this._distanceAttenuation = SSRShader.defines.DISTANCE_ATTENUATION;
    Object.defineProperty(this, "distanceAttenuation", {
      get() {
        return this._distanceAttenuation;
      },
      set(val) {
        if (this._distanceAttenuation === val)
          return;
        this._distanceAttenuation = val;
        this.ssrMaterial.defines.DISTANCE_ATTENUATION = val;
        this.ssrMaterial.needsUpdate = true;
      }
    });
    this._fresnel = SSRShader.defines.FRESNEL;
    Object.defineProperty(this, "fresnel", {
      get() {
        return this._fresnel;
      },
      set(val) {
        if (this._fresnel === val)
          return;
        this._fresnel = val;
        this.ssrMaterial.defines.FRESNEL = val;
        this.ssrMaterial.needsUpdate = true;
      }
    });
    this._infiniteThick = SSRShader.defines.INFINITE_THICK;
    Object.defineProperty(this, "infiniteThick", {
      get() {
        return this._infiniteThick;
      },
      set(val) {
        if (this._infiniteThick === val)
          return;
        this._infiniteThick = val;
        this.ssrMaterial.defines.INFINITE_THICK = val;
        this.ssrMaterial.needsUpdate = true;
      }
    });
    const depthTexture = new DepthTexture();
    depthTexture.type = UnsignedShortType;
    depthTexture.minFilter = NearestFilter;
    depthTexture.magFilter = NearestFilter;
    this.beautyRenderTarget = new WebGLRenderTarget(this.width, this.height, {
      minFilter: NearestFilter,
      magFilter: NearestFilter,
      type: HalfFloatType,
      depthTexture,
      depthBuffer: true
    });
    this.prevRenderTarget = new WebGLRenderTarget(this.width, this.height, {
      minFilter: NearestFilter,
      magFilter: NearestFilter
    });
    this.normalRenderTarget = new WebGLRenderTarget(this.width, this.height, {
      minFilter: NearestFilter,
      magFilter: NearestFilter,
      type: HalfFloatType
    });
    this.metalnessRenderTarget = new WebGLRenderTarget(this.width, this.height, {
      minFilter: NearestFilter,
      magFilter: NearestFilter,
      type: HalfFloatType
    });
    this.ssrRenderTarget = new WebGLRenderTarget(this.width, this.height, {
      minFilter: NearestFilter,
      magFilter: NearestFilter
    });
    this.blurRenderTarget = this.ssrRenderTarget.clone();
    this.blurRenderTarget2 = this.ssrRenderTarget.clone();
    this.ssrMaterial = new ShaderMaterial({
      defines: Object.assign({}, SSRShader.defines, {
        MAX_STEP: Math.sqrt(this.width * this.width + this.height * this.height)
      }),
      uniforms: UniformsUtils.clone(SSRShader.uniforms),
      vertexShader: SSRShader.vertexShader,
      fragmentShader: SSRShader.fragmentShader,
      blending: NoBlending
    });
    this.ssrMaterial.uniforms["tDiffuse"].value = this.beautyRenderTarget.texture;
    this.ssrMaterial.uniforms["tNormal"].value = this.normalRenderTarget.texture;
    this.ssrMaterial.defines.SELECTIVE = this.selective;
    this.ssrMaterial.needsUpdate = true;
    this.ssrMaterial.uniforms["tMetalness"].value = this.metalnessRenderTarget.texture;
    this.ssrMaterial.uniforms["tDepth"].value = this.beautyRenderTarget.depthTexture;
    this.ssrMaterial.uniforms["cameraNear"].value = this.camera.near;
    this.ssrMaterial.uniforms["cameraFar"].value = this.camera.far;
    this.ssrMaterial.uniforms["thickness"].value = this.thickness;
    this.ssrMaterial.uniforms["resolution"].value.set(this.width, this.height);
    this.ssrMaterial.uniforms["cameraProjectionMatrix"].value.copy(this.camera.projectionMatrix);
    this.ssrMaterial.uniforms["cameraInverseProjectionMatrix"].value.copy(this.camera.projectionMatrixInverse);
    this.normalMaterial = new MeshNormalMaterial();
    this.normalMaterial.blending = NoBlending;
    this.metalnessOnMaterial = new MeshBasicMaterial({
      color: "white"
    });
    this.metalnessOffMaterial = new MeshBasicMaterial({
      color: "black"
    });
    this.blurMaterial = new ShaderMaterial({
      defines: Object.assign({}, SSRBlurShader.defines),
      uniforms: UniformsUtils.clone(SSRBlurShader.uniforms),
      vertexShader: SSRBlurShader.vertexShader,
      fragmentShader: SSRBlurShader.fragmentShader
    });
    this.blurMaterial.uniforms["tDiffuse"].value = this.ssrRenderTarget.texture;
    this.blurMaterial.uniforms["resolution"].value.set(this.width, this.height);
    this.blurMaterial2 = new ShaderMaterial({
      defines: Object.assign({}, SSRBlurShader.defines),
      uniforms: UniformsUtils.clone(SSRBlurShader.uniforms),
      vertexShader: SSRBlurShader.vertexShader,
      fragmentShader: SSRBlurShader.fragmentShader
    });
    this.blurMaterial2.uniforms["tDiffuse"].value = this.blurRenderTarget.texture;
    this.blurMaterial2.uniforms["resolution"].value.set(this.width, this.height);
    this.depthRenderMaterial = new ShaderMaterial({
      defines: Object.assign({}, SSRDepthShader.defines),
      uniforms: UniformsUtils.clone(SSRDepthShader.uniforms),
      vertexShader: SSRDepthShader.vertexShader,
      fragmentShader: SSRDepthShader.fragmentShader,
      blending: NoBlending
    });
    this.depthRenderMaterial.uniforms["tDepth"].value = this.beautyRenderTarget.depthTexture;
    this.depthRenderMaterial.uniforms["cameraNear"].value = this.camera.near;
    this.depthRenderMaterial.uniforms["cameraFar"].value = this.camera.far;
    this.copyMaterial = new ShaderMaterial({
      uniforms: UniformsUtils.clone(CopyShader.uniforms),
      vertexShader: CopyShader.vertexShader,
      fragmentShader: CopyShader.fragmentShader,
      transparent: true,
      depthTest: false,
      depthWrite: false,
      blendSrc: SrcAlphaFactor,
      blendDst: OneMinusSrcAlphaFactor,
      blendEquation: AddEquation,
      blendSrcAlpha: SrcAlphaFactor,
      blendDstAlpha: OneMinusSrcAlphaFactor,
      blendEquationAlpha: AddEquation
      // premultipliedAlpha:true,
    });
    this.fsQuad = new FullScreenQuad(null);
    this.originalClearColor = new Color();
  }
  dispose() {
    this.beautyRenderTarget.dispose();
    this.prevRenderTarget.dispose();
    this.normalRenderTarget.dispose();
    this.metalnessRenderTarget.dispose();
    this.ssrRenderTarget.dispose();
    this.blurRenderTarget.dispose();
    this.blurRenderTarget2.dispose();
    this.normalMaterial.dispose();
    this.metalnessOnMaterial.dispose();
    this.metalnessOffMaterial.dispose();
    this.blurMaterial.dispose();
    this.blurMaterial2.dispose();
    this.copyMaterial.dispose();
    this.depthRenderMaterial.dispose();
    this.fsQuad.dispose();
  }
  render(renderer, writeBuffer) {
    renderer.setRenderTarget(this.beautyRenderTarget);
    renderer.clear();
    if (this.groundReflector) {
      this.groundReflector.visible = false;
      this.groundReflector.doRender(this.renderer, this.scene, this.camera);
      this.groundReflector.visible = true;
    }
    renderer.render(this.scene, this.camera);
    if (this.groundReflector)
      this.groundReflector.visible = false;
    this.renderOverride(renderer, this.normalMaterial, this.normalRenderTarget, 0, 0);
    if (this.selective) {
      this.renderMetalness(renderer, this.metalnessOnMaterial, this.metalnessRenderTarget, 0, 0);
    }
    this.ssrMaterial.uniforms["opacity"].value = this.opacity;
    this.ssrMaterial.uniforms["maxDistance"].value = this.maxDistance;
    this.ssrMaterial.uniforms["thickness"].value = this.thickness;
    this.renderPass(renderer, this.ssrMaterial, this.ssrRenderTarget);
    if (this.blur) {
      this.renderPass(renderer, this.blurMaterial, this.blurRenderTarget);
      this.renderPass(renderer, this.blurMaterial2, this.blurRenderTarget2);
    }
    switch (this.output) {
      case _SSRPass.OUTPUT.Default:
        if (this.bouncing) {
          this.copyMaterial.uniforms["tDiffuse"].value = this.beautyRenderTarget.texture;
          this.copyMaterial.blending = NoBlending;
          this.renderPass(renderer, this.copyMaterial, this.prevRenderTarget);
          if (this.blur)
            this.copyMaterial.uniforms["tDiffuse"].value = this.blurRenderTarget2.texture;
          else
            this.copyMaterial.uniforms["tDiffuse"].value = this.ssrRenderTarget.texture;
          this.copyMaterial.blending = NormalBlending;
          this.renderPass(renderer, this.copyMaterial, this.prevRenderTarget);
          this.copyMaterial.uniforms["tDiffuse"].value = this.prevRenderTarget.texture;
          this.copyMaterial.blending = NoBlending;
          this.renderPass(renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer);
        } else {
          this.copyMaterial.uniforms["tDiffuse"].value = this.beautyRenderTarget.texture;
          this.copyMaterial.blending = NoBlending;
          this.renderPass(renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer);
          if (this.blur)
            this.copyMaterial.uniforms["tDiffuse"].value = this.blurRenderTarget2.texture;
          else
            this.copyMaterial.uniforms["tDiffuse"].value = this.ssrRenderTarget.texture;
          this.copyMaterial.blending = NormalBlending;
          this.renderPass(renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer);
        }
        break;
      case _SSRPass.OUTPUT.SSR:
        if (this.blur)
          this.copyMaterial.uniforms["tDiffuse"].value = this.blurRenderTarget2.texture;
        else
          this.copyMaterial.uniforms["tDiffuse"].value = this.ssrRenderTarget.texture;
        this.copyMaterial.blending = NoBlending;
        this.renderPass(renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer);
        if (this.bouncing) {
          if (this.blur)
            this.copyMaterial.uniforms["tDiffuse"].value = this.blurRenderTarget2.texture;
          else
            this.copyMaterial.uniforms["tDiffuse"].value = this.beautyRenderTarget.texture;
          this.copyMaterial.blending = NoBlending;
          this.renderPass(renderer, this.copyMaterial, this.prevRenderTarget);
          this.copyMaterial.uniforms["tDiffuse"].value = this.ssrRenderTarget.texture;
          this.copyMaterial.blending = NormalBlending;
          this.renderPass(renderer, this.copyMaterial, this.prevRenderTarget);
        }
        break;
      case _SSRPass.OUTPUT.Beauty:
        this.copyMaterial.uniforms["tDiffuse"].value = this.beautyRenderTarget.texture;
        this.copyMaterial.blending = NoBlending;
        this.renderPass(renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer);
        break;
      case _SSRPass.OUTPUT.Depth:
        this.renderPass(renderer, this.depthRenderMaterial, this.renderToScreen ? null : writeBuffer);
        break;
      case _SSRPass.OUTPUT.Normal:
        this.copyMaterial.uniforms["tDiffuse"].value = this.normalRenderTarget.texture;
        this.copyMaterial.blending = NoBlending;
        this.renderPass(renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer);
        break;
      case _SSRPass.OUTPUT.Metalness:
        this.copyMaterial.uniforms["tDiffuse"].value = this.metalnessRenderTarget.texture;
        this.copyMaterial.blending = NoBlending;
        this.renderPass(renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer);
        break;
      default:
        console.warn("THREE.SSRPass: Unknown output type.");
    }
  }
  renderPass(renderer, passMaterial, renderTarget, clearColor, clearAlpha) {
    this.originalClearColor.copy(renderer.getClearColor(this.tempColor));
    const originalClearAlpha = renderer.getClearAlpha(this.tempColor);
    const originalAutoClear = renderer.autoClear;
    renderer.setRenderTarget(renderTarget);
    renderer.autoClear = false;
    if (clearColor !== void 0 && clearColor !== null) {
      renderer.setClearColor(clearColor);
      renderer.setClearAlpha(clearAlpha || 0);
      renderer.clear();
    }
    this.fsQuad.material = passMaterial;
    this.fsQuad.render(renderer);
    renderer.autoClear = originalAutoClear;
    renderer.setClearColor(this.originalClearColor);
    renderer.setClearAlpha(originalClearAlpha);
  }
  renderOverride(renderer, overrideMaterial, renderTarget, clearColor, clearAlpha) {
    this.originalClearColor.copy(renderer.getClearColor(this.tempColor));
    const originalClearAlpha = renderer.getClearAlpha(this.tempColor);
    const originalAutoClear = renderer.autoClear;
    renderer.setRenderTarget(renderTarget);
    renderer.autoClear = false;
    clearColor = overrideMaterial.clearColor || clearColor;
    clearAlpha = overrideMaterial.clearAlpha || clearAlpha;
    if (clearColor !== void 0 && clearColor !== null) {
      renderer.setClearColor(clearColor);
      renderer.setClearAlpha(clearAlpha || 0);
      renderer.clear();
    }
    this.scene.overrideMaterial = overrideMaterial;
    renderer.render(this.scene, this.camera);
    this.scene.overrideMaterial = null;
    renderer.autoClear = originalAutoClear;
    renderer.setClearColor(this.originalClearColor);
    renderer.setClearAlpha(originalClearAlpha);
  }
  renderMetalness(renderer, overrideMaterial, renderTarget, clearColor, clearAlpha) {
    this.originalClearColor.copy(renderer.getClearColor(this.tempColor));
    const originalClearAlpha = renderer.getClearAlpha(this.tempColor);
    const originalAutoClear = renderer.autoClear;
    renderer.setRenderTarget(renderTarget);
    renderer.autoClear = false;
    clearColor = overrideMaterial.clearColor || clearColor;
    clearAlpha = overrideMaterial.clearAlpha || clearAlpha;
    if (clearColor !== void 0 && clearColor !== null) {
      renderer.setClearColor(clearColor);
      renderer.setClearAlpha(clearAlpha || 0);
      renderer.clear();
    }
    this.scene.traverseVisible((child) => {
      child._SSRPassBackupMaterial = child.material;
      if (this._selects.includes(child)) {
        child.material = this.metalnessOnMaterial;
      } else {
        child.material = this.metalnessOffMaterial;
      }
    });
    renderer.render(this.scene, this.camera);
    this.scene.traverseVisible((child) => {
      child.material = child._SSRPassBackupMaterial;
    });
    renderer.autoClear = originalAutoClear;
    renderer.setClearColor(this.originalClearColor);
    renderer.setClearAlpha(originalClearAlpha);
  }
  setSize(width, height) {
    this.width = width;
    this.height = height;
    this.ssrMaterial.defines.MAX_STEP = Math.sqrt(width * width + height * height);
    this.ssrMaterial.needsUpdate = true;
    this.beautyRenderTarget.setSize(width, height);
    this.prevRenderTarget.setSize(width, height);
    this.ssrRenderTarget.setSize(width, height);
    this.normalRenderTarget.setSize(width, height);
    this.metalnessRenderTarget.setSize(width, height);
    this.blurRenderTarget.setSize(width, height);
    this.blurRenderTarget2.setSize(width, height);
    this.ssrMaterial.uniforms["resolution"].value.set(width, height);
    this.ssrMaterial.uniforms["cameraProjectionMatrix"].value.copy(this.camera.projectionMatrix);
    this.ssrMaterial.uniforms["cameraInverseProjectionMatrix"].value.copy(this.camera.projectionMatrixInverse);
    this.blurMaterial.uniforms["resolution"].value.set(width, height);
    this.blurMaterial2.uniforms["resolution"].value.set(width, height);
  }
};
var SSRPass = _SSRPass;
__publicField19(SSRPass, "OUTPUT", {
  Default: 0,
  SSR: 1,
  Beauty: 3,
  Depth: 4,
  Normal: 5,
  Metalness: 7
});

// node_modules/three-stdlib/postprocessing/RenderPass.js
var __defProp19 = Object.defineProperty;
var __defNormalProp19 = (obj, key, value) => key in obj ? __defProp19(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField20 = (obj, key, value) => {
  __defNormalProp19(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var RenderPass = class extends Pass {
  constructor(scene, camera, overrideMaterial, clearColor, clearAlpha = 0) {
    super();
    __publicField20(this, "scene");
    __publicField20(this, "camera");
    __publicField20(this, "overrideMaterial");
    __publicField20(this, "clearColor");
    __publicField20(this, "clearAlpha");
    __publicField20(this, "clearDepth", false);
    __publicField20(this, "_oldClearColor", new Color());
    this.scene = scene;
    this.camera = camera;
    this.overrideMaterial = overrideMaterial;
    this.clearColor = clearColor;
    this.clearAlpha = clearAlpha;
    this.clear = true;
    this.needsSwap = false;
  }
  render(renderer, writeBuffer, readBuffer) {
    let oldAutoClear = renderer.autoClear;
    renderer.autoClear = false;
    let oldClearAlpha;
    let oldOverrideMaterial = null;
    if (this.overrideMaterial !== void 0) {
      oldOverrideMaterial = this.scene.overrideMaterial;
      this.scene.overrideMaterial = this.overrideMaterial;
    }
    if (this.clearColor) {
      renderer.getClearColor(this._oldClearColor);
      oldClearAlpha = renderer.getClearAlpha();
      renderer.setClearColor(this.clearColor, this.clearAlpha);
    }
    if (this.clearDepth) {
      renderer.clearDepth();
    }
    renderer.setRenderTarget(this.renderToScreen ? null : readBuffer);
    if (this.clear)
      renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);
    renderer.render(this.scene, this.camera);
    if (this.clearColor) {
      renderer.setClearColor(this._oldClearColor, oldClearAlpha);
    }
    if (this.overrideMaterial !== void 0) {
      this.scene.overrideMaterial = oldOverrideMaterial;
    }
    renderer.autoClear = oldAutoClear;
  }
};

// node_modules/three-stdlib/shaders/ConvolutionShader.js
var ConvolutionShader = {
  defines: {
    KERNEL_SIZE_FLOAT: "25.0",
    KERNEL_SIZE_INT: "25"
  },
  uniforms: {
    tDiffuse: { value: null },
    uImageIncrement: { value: new Vector2(1953125e-9, 0) },
    cKernel: { value: [] }
  },
  vertexShader: [
    "uniform vec2 uImageIncrement;",
    "varying vec2 vUv;",
    "void main() {",
    "	vUv = uv - ( ( KERNEL_SIZE_FLOAT - 1.0 ) / 2.0 ) * uImageIncrement;",
    "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
    "}"
  ].join("\n"),
  fragmentShader: [
    "uniform float cKernel[ KERNEL_SIZE_INT ];",
    "uniform sampler2D tDiffuse;",
    "uniform vec2 uImageIncrement;",
    "varying vec2 vUv;",
    "void main() {",
    "	vec2 imageCoord = vUv;",
    "	vec4 sum = vec4( 0.0, 0.0, 0.0, 0.0 );",
    "	for( int i = 0; i < KERNEL_SIZE_INT; i ++ ) {",
    "		sum += texture2D( tDiffuse, imageCoord ) * cKernel[ i ];",
    "		imageCoord += uImageIncrement;",
    "	}",
    "	gl_FragColor = sum;",
    "}"
  ].join("\n"),
  buildKernel: function(sigma) {
    function gauss(x, sigma2) {
      return Math.exp(-(x * x) / (2 * sigma2 * sigma2));
    }
    const kMaxKernelSize = 25;
    const kernelSize = Math.min(2 * Math.ceil(sigma * 3) + 1, kMaxKernelSize);
    const halfWidth = (kernelSize - 1) * 0.5;
    const values = new Array(kernelSize);
    let sum = 0;
    for (let i3 = 0; i3 < kernelSize; ++i3) {
      values[i3] = gauss(i3 - halfWidth, sigma);
      sum += values[i3];
    }
    for (let i3 = 0; i3 < kernelSize; ++i3)
      values[i3] /= sum;
    return values;
  }
};

// node_modules/three-stdlib/loaders/GLTFLoader.js
var GLTFLoader = class extends Loader {
  constructor(manager) {
    super(manager);
    this.dracoLoader = null;
    this.ktx2Loader = null;
    this.meshoptDecoder = null;
    this.pluginCallbacks = [];
    this.register(function(parser) {
      return new GLTFMaterialsClearcoatExtension2(parser);
    });
    this.register(function(parser) {
      return new GLTFTextureBasisUExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFTextureWebPExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFTextureAVIFExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsSheenExtension2(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsTransmissionExtension2(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsVolumeExtension2(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsIorExtension2(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsEmissiveStrengthExtension2(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsSpecularExtension2(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsIridescenceExtension2(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsAnisotropyExtension2(parser);
    });
    this.register(function(parser) {
      return new GLTFLightsExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMeshoptCompression(parser);
    });
    this.register(function(parser) {
      return new GLTFMeshGpuInstancing(parser);
    });
  }
  load(url, onLoad, onProgress, onError) {
    const scope = this;
    let resourcePath;
    if (this.resourcePath !== "") {
      resourcePath = this.resourcePath;
    } else if (this.path !== "") {
      resourcePath = this.path;
    } else {
      resourcePath = LoaderUtils.extractUrlBase(url);
    }
    this.manager.itemStart(url);
    const _onError = function(e) {
      if (onError) {
        onError(e);
      } else {
        console.error(e);
      }
      scope.manager.itemError(url);
      scope.manager.itemEnd(url);
    };
    const loader = new FileLoader(this.manager);
    loader.setPath(this.path);
    loader.setResponseType("arraybuffer");
    loader.setRequestHeader(this.requestHeader);
    loader.setWithCredentials(this.withCredentials);
    loader.load(
      url,
      function(data) {
        try {
          scope.parse(
            data,
            resourcePath,
            function(gltf) {
              onLoad(gltf);
              scope.manager.itemEnd(url);
            },
            _onError
          );
        } catch (e) {
          _onError(e);
        }
      },
      onProgress,
      _onError
    );
  }
  setDRACOLoader(dracoLoader2) {
    this.dracoLoader = dracoLoader2;
    return this;
  }
  setDDSLoader() {
    throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".');
  }
  setKTX2Loader(ktx2Loader) {
    this.ktx2Loader = ktx2Loader;
    return this;
  }
  setMeshoptDecoder(meshoptDecoder) {
    this.meshoptDecoder = meshoptDecoder;
    return this;
  }
  register(callback) {
    if (this.pluginCallbacks.indexOf(callback) === -1) {
      this.pluginCallbacks.push(callback);
    }
    return this;
  }
  unregister(callback) {
    if (this.pluginCallbacks.indexOf(callback) !== -1) {
      this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(callback), 1);
    }
    return this;
  }
  parse(data, path, onLoad, onError) {
    let json;
    const extensions = {};
    const plugins = {};
    if (typeof data === "string") {
      json = JSON.parse(data);
    } else if (data instanceof ArrayBuffer) {
      const magic = LoaderUtils.decodeText(new Uint8Array(data.slice(0, 4)));
      if (magic === BINARY_EXTENSION_HEADER_MAGIC) {
        try {
          extensions[EXTENSIONS.KHR_BINARY_GLTF] = new GLTFBinaryExtension(data);
        } catch (error) {
          if (onError)
            onError(error);
          return;
        }
        json = JSON.parse(extensions[EXTENSIONS.KHR_BINARY_GLTF].content);
      } else {
        json = JSON.parse(LoaderUtils.decodeText(new Uint8Array(data)));
      }
    } else {
      json = data;
    }
    if (json.asset === void 0 || json.asset.version[0] < 2) {
      if (onError)
        onError(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));
      return;
    }
    const parser = new GLTFParser(json, {
      path: path || this.resourcePath || "",
      crossOrigin: this.crossOrigin,
      requestHeader: this.requestHeader,
      manager: this.manager,
      ktx2Loader: this.ktx2Loader,
      meshoptDecoder: this.meshoptDecoder
    });
    parser.fileLoader.setRequestHeader(this.requestHeader);
    for (let i3 = 0; i3 < this.pluginCallbacks.length; i3++) {
      const plugin = this.pluginCallbacks[i3](parser);
      plugins[plugin.name] = plugin;
      extensions[plugin.name] = true;
    }
    if (json.extensionsUsed) {
      for (let i3 = 0; i3 < json.extensionsUsed.length; ++i3) {
        const extensionName = json.extensionsUsed[i3];
        const extensionsRequired = json.extensionsRequired || [];
        switch (extensionName) {
          case EXTENSIONS.KHR_MATERIALS_UNLIT:
            extensions[extensionName] = new GLTFMaterialsUnlitExtension2();
            break;
          case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:
            extensions[extensionName] = new GLTFDracoMeshCompressionExtension(json, this.dracoLoader);
            break;
          case EXTENSIONS.KHR_TEXTURE_TRANSFORM:
            extensions[extensionName] = new GLTFTextureTransformExtension();
            break;
          case EXTENSIONS.KHR_MESH_QUANTIZATION:
            extensions[extensionName] = new GLTFMeshQuantizationExtension();
            break;
          default:
            if (extensionsRequired.indexOf(extensionName) >= 0 && plugins[extensionName] === void 0) {
              console.warn('THREE.GLTFLoader: Unknown extension "' + extensionName + '".');
            }
        }
      }
    }
    parser.setExtensions(extensions);
    parser.setPlugins(plugins);
    parser.parse(onLoad, onError);
  }
  parseAsync(data, path) {
    const scope = this;
    return new Promise(function(resolve, reject) {
      scope.parse(data, path, resolve, reject);
    });
  }
};
function GLTFRegistry() {
  let objects = {};
  return {
    get: function(key) {
      return objects[key];
    },
    add: function(key, object) {
      objects[key] = object;
    },
    remove: function(key) {
      delete objects[key];
    },
    removeAll: function() {
      objects = {};
    }
  };
}
var EXTENSIONS = {
  KHR_BINARY_GLTF: "KHR_binary_glTF",
  KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
  KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
  KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
  KHR_MATERIALS_IOR: "KHR_materials_ior",
  KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
  KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
  KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
  KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
  KHR_MATERIALS_ANISOTROPY: "KHR_materials_anisotropy",
  KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
  KHR_MATERIALS_VOLUME: "KHR_materials_volume",
  KHR_TEXTURE_BASISU: "KHR_texture_basisu",
  KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
  KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
  KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
  EXT_TEXTURE_WEBP: "EXT_texture_webp",
  EXT_TEXTURE_AVIF: "EXT_texture_avif",
  EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
  EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing"
};
var GLTFLightsExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL;
    this.cache = { refs: {}, uses: {} };
  }
  _markDefs() {
    const parser = this.parser;
    const nodeDefs = this.parser.json.nodes || [];
    for (let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {
      const nodeDef = nodeDefs[nodeIndex];
      if (nodeDef.extensions && nodeDef.extensions[this.name] && nodeDef.extensions[this.name].light !== void 0) {
        parser._addNodeRef(this.cache, nodeDef.extensions[this.name].light);
      }
    }
  }
  _loadLight(lightIndex) {
    const parser = this.parser;
    const cacheKey = "light:" + lightIndex;
    let dependency = parser.cache.get(cacheKey);
    if (dependency)
      return dependency;
    const json = parser.json;
    const extensions = json.extensions && json.extensions[this.name] || {};
    const lightDefs = extensions.lights || [];
    const lightDef = lightDefs[lightIndex];
    let lightNode;
    const color = new Color(16777215);
    if (lightDef.color !== void 0)
      color.fromArray(lightDef.color);
    const range2 = lightDef.range !== void 0 ? lightDef.range : 0;
    switch (lightDef.type) {
      case "directional":
        lightNode = new DirectionalLight(color);
        lightNode.target.position.set(0, 0, -1);
        lightNode.add(lightNode.target);
        break;
      case "point":
        lightNode = new PointLight(color);
        lightNode.distance = range2;
        break;
      case "spot":
        lightNode = new SpotLight(color);
        lightNode.distance = range2;
        lightDef.spot = lightDef.spot || {};
        lightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== void 0 ? lightDef.spot.innerConeAngle : 0;
        lightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== void 0 ? lightDef.spot.outerConeAngle : Math.PI / 4;
        lightNode.angle = lightDef.spot.outerConeAngle;
        lightNode.penumbra = 1 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle;
        lightNode.target.position.set(0, 0, -1);
        lightNode.add(lightNode.target);
        break;
      default:
        throw new Error("THREE.GLTFLoader: Unexpected light type: " + lightDef.type);
    }
    lightNode.position.set(0, 0, 0);
    lightNode.decay = 2;
    assignExtrasToUserData(lightNode, lightDef);
    if (lightDef.intensity !== void 0)
      lightNode.intensity = lightDef.intensity;
    lightNode.name = parser.createUniqueName(lightDef.name || "light_" + lightIndex);
    dependency = Promise.resolve(lightNode);
    parser.cache.add(cacheKey, dependency);
    return dependency;
  }
  getDependency(type, index) {
    if (type !== "light")
      return;
    return this._loadLight(index);
  }
  createNodeAttachment(nodeIndex) {
    const self2 = this;
    const parser = this.parser;
    const json = parser.json;
    const nodeDef = json.nodes[nodeIndex];
    const lightDef = nodeDef.extensions && nodeDef.extensions[this.name] || {};
    const lightIndex = lightDef.light;
    if (lightIndex === void 0)
      return null;
    return this._loadLight(lightIndex).then(function(light) {
      return parser._getNodeRef(self2.cache, lightIndex, light);
    });
  }
};
var GLTFMaterialsUnlitExtension2 = class {
  constructor() {
    this.name = EXTENSIONS.KHR_MATERIALS_UNLIT;
  }
  getMaterialType() {
    return MeshBasicMaterial;
  }
  extendParams(materialParams, materialDef, parser) {
    const pending = [];
    materialParams.color = new Color(1, 1, 1);
    materialParams.opacity = 1;
    const metallicRoughness = materialDef.pbrMetallicRoughness;
    if (metallicRoughness) {
      if (Array.isArray(metallicRoughness.baseColorFactor)) {
        const array = metallicRoughness.baseColorFactor;
        materialParams.color.fromArray(array);
        materialParams.opacity = array[3];
      }
      if (metallicRoughness.baseColorTexture !== void 0) {
        pending.push(parser.assignTexture(materialParams, "map", metallicRoughness.baseColorTexture, 3001));
      }
    }
    return Promise.all(pending);
  }
};
var GLTFMaterialsEmissiveStrengthExtension2 = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_EMISSIVE_STRENGTH;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const emissiveStrength = materialDef.extensions[this.name].emissiveStrength;
    if (emissiveStrength !== void 0) {
      materialParams.emissiveIntensity = emissiveStrength;
    }
    return Promise.resolve();
  }
};
var GLTFMaterialsClearcoatExtension2 = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name])
      return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const pending = [];
    const extension = materialDef.extensions[this.name];
    if (extension.clearcoatFactor !== void 0) {
      materialParams.clearcoat = extension.clearcoatFactor;
    }
    if (extension.clearcoatTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "clearcoatMap", extension.clearcoatTexture));
    }
    if (extension.clearcoatRoughnessFactor !== void 0) {
      materialParams.clearcoatRoughness = extension.clearcoatRoughnessFactor;
    }
    if (extension.clearcoatRoughnessTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "clearcoatRoughnessMap", extension.clearcoatRoughnessTexture));
    }
    if (extension.clearcoatNormalTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "clearcoatNormalMap", extension.clearcoatNormalTexture));
      if (extension.clearcoatNormalTexture.scale !== void 0) {
        const scale = extension.clearcoatNormalTexture.scale;
        materialParams.clearcoatNormalScale = new Vector2(scale, scale);
      }
    }
    return Promise.all(pending);
  }
};
var GLTFMaterialsIridescenceExtension2 = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_IRIDESCENCE;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name])
      return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const pending = [];
    const extension = materialDef.extensions[this.name];
    if (extension.iridescenceFactor !== void 0) {
      materialParams.iridescence = extension.iridescenceFactor;
    }
    if (extension.iridescenceTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "iridescenceMap", extension.iridescenceTexture));
    }
    if (extension.iridescenceIor !== void 0) {
      materialParams.iridescenceIOR = extension.iridescenceIor;
    }
    if (materialParams.iridescenceThicknessRange === void 0) {
      materialParams.iridescenceThicknessRange = [100, 400];
    }
    if (extension.iridescenceThicknessMinimum !== void 0) {
      materialParams.iridescenceThicknessRange[0] = extension.iridescenceThicknessMinimum;
    }
    if (extension.iridescenceThicknessMaximum !== void 0) {
      materialParams.iridescenceThicknessRange[1] = extension.iridescenceThicknessMaximum;
    }
    if (extension.iridescenceThicknessTexture !== void 0) {
      pending.push(
        parser.assignTexture(materialParams, "iridescenceThicknessMap", extension.iridescenceThicknessTexture)
      );
    }
    return Promise.all(pending);
  }
};
var GLTFMaterialsSheenExtension2 = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_SHEEN;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name])
      return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const pending = [];
    materialParams.sheenColor = new Color(0, 0, 0);
    materialParams.sheenRoughness = 0;
    materialParams.sheen = 1;
    const extension = materialDef.extensions[this.name];
    if (extension.sheenColorFactor !== void 0) {
      materialParams.sheenColor.fromArray(extension.sheenColorFactor);
    }
    if (extension.sheenRoughnessFactor !== void 0) {
      materialParams.sheenRoughness = extension.sheenRoughnessFactor;
    }
    if (extension.sheenColorTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "sheenColorMap", extension.sheenColorTexture, 3001));
    }
    if (extension.sheenRoughnessTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "sheenRoughnessMap", extension.sheenRoughnessTexture));
    }
    return Promise.all(pending);
  }
};
var GLTFMaterialsTransmissionExtension2 = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_TRANSMISSION;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name])
      return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const pending = [];
    const extension = materialDef.extensions[this.name];
    if (extension.transmissionFactor !== void 0) {
      materialParams.transmission = extension.transmissionFactor;
    }
    if (extension.transmissionTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "transmissionMap", extension.transmissionTexture));
    }
    return Promise.all(pending);
  }
};
var GLTFMaterialsVolumeExtension2 = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_VOLUME;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name])
      return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const pending = [];
    const extension = materialDef.extensions[this.name];
    materialParams.thickness = extension.thicknessFactor !== void 0 ? extension.thicknessFactor : 0;
    if (extension.thicknessTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "thicknessMap", extension.thicknessTexture));
    }
    materialParams.attenuationDistance = extension.attenuationDistance || Infinity;
    const colorArray = extension.attenuationColor || [1, 1, 1];
    materialParams.attenuationColor = new Color(colorArray[0], colorArray[1], colorArray[2]);
    return Promise.all(pending);
  }
};
var GLTFMaterialsIorExtension2 = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_IOR;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name])
      return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const extension = materialDef.extensions[this.name];
    materialParams.ior = extension.ior !== void 0 ? extension.ior : 1.5;
    return Promise.resolve();
  }
};
var GLTFMaterialsSpecularExtension2 = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_SPECULAR;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name])
      return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const pending = [];
    const extension = materialDef.extensions[this.name];
    materialParams.specularIntensity = extension.specularFactor !== void 0 ? extension.specularFactor : 1;
    if (extension.specularTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "specularIntensityMap", extension.specularTexture));
    }
    const colorArray = extension.specularColorFactor || [1, 1, 1];
    materialParams.specularColor = new Color(colorArray[0], colorArray[1], colorArray[2]);
    if (extension.specularColorTexture !== void 0) {
      pending.push(
        parser.assignTexture(materialParams, "specularColorMap", extension.specularColorTexture, 3001)
        // sRGBEncoding
      );
    }
    return Promise.all(pending);
  }
};
var GLTFMaterialsAnisotropyExtension2 = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_ANISOTROPY;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name])
      return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const pending = [];
    const extension = materialDef.extensions[this.name];
    if (extension.anisotropyStrength !== void 0) {
      materialParams.anisotropy = extension.anisotropyStrength;
    }
    if (extension.anisotropyRotation !== void 0) {
      materialParams.anisotropyRotation = extension.anisotropyRotation;
    }
    if (extension.anisotropyTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "anisotropyMap", extension.anisotropyTexture));
    }
    return Promise.all(pending);
  }
};
var GLTFTextureBasisUExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_TEXTURE_BASISU;
  }
  loadTexture(textureIndex) {
    const parser = this.parser;
    const json = parser.json;
    const textureDef = json.textures[textureIndex];
    if (!textureDef.extensions || !textureDef.extensions[this.name]) {
      return null;
    }
    const extension = textureDef.extensions[this.name];
    const loader = parser.options.ktx2Loader;
    if (!loader) {
      if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {
        throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
      } else {
        return null;
      }
    }
    return parser.loadTextureImage(textureIndex, extension.source, loader);
  }
};
var GLTFTextureWebPExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.EXT_TEXTURE_WEBP;
    this.isSupported = null;
  }
  loadTexture(textureIndex) {
    const name = this.name;
    const parser = this.parser;
    const json = parser.json;
    const textureDef = json.textures[textureIndex];
    if (!textureDef.extensions || !textureDef.extensions[name]) {
      return null;
    }
    const extension = textureDef.extensions[name];
    const source = json.images[extension.source];
    let loader = parser.textureLoader;
    if (source.uri) {
      const handler = parser.options.manager.getHandler(source.uri);
      if (handler !== null)
        loader = handler;
    }
    return this.detectSupport().then(function(isSupported) {
      if (isSupported)
        return parser.loadTextureImage(textureIndex, extension.source, loader);
      if (json.extensionsRequired && json.extensionsRequired.indexOf(name) >= 0) {
        throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
      }
      return parser.loadTexture(textureIndex);
    });
  }
  detectSupport() {
    if (!this.isSupported) {
      this.isSupported = new Promise(function(resolve) {
        const image = new Image();
        image.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA";
        image.onload = image.onerror = function() {
          resolve(image.height === 1);
        };
      });
    }
    return this.isSupported;
  }
};
var GLTFTextureAVIFExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.EXT_TEXTURE_AVIF;
    this.isSupported = null;
  }
  loadTexture(textureIndex) {
    const name = this.name;
    const parser = this.parser;
    const json = parser.json;
    const textureDef = json.textures[textureIndex];
    if (!textureDef.extensions || !textureDef.extensions[name]) {
      return null;
    }
    const extension = textureDef.extensions[name];
    const source = json.images[extension.source];
    let loader = parser.textureLoader;
    if (source.uri) {
      const handler = parser.options.manager.getHandler(source.uri);
      if (handler !== null)
        loader = handler;
    }
    return this.detectSupport().then(function(isSupported) {
      if (isSupported)
        return parser.loadTextureImage(textureIndex, extension.source, loader);
      if (json.extensionsRequired && json.extensionsRequired.indexOf(name) >= 0) {
        throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");
      }
      return parser.loadTexture(textureIndex);
    });
  }
  detectSupport() {
    if (!this.isSupported) {
      this.isSupported = new Promise(function(resolve) {
        const image = new Image();
        image.src = "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=";
        image.onload = image.onerror = function() {
          resolve(image.height === 1);
        };
      });
    }
    return this.isSupported;
  }
};
var GLTFMeshoptCompression = class {
  constructor(parser) {
    this.name = EXTENSIONS.EXT_MESHOPT_COMPRESSION;
    this.parser = parser;
  }
  loadBufferView(index) {
    const json = this.parser.json;
    const bufferView = json.bufferViews[index];
    if (bufferView.extensions && bufferView.extensions[this.name]) {
      const extensionDef = bufferView.extensions[this.name];
      const buffer = this.parser.getDependency("buffer", extensionDef.buffer);
      const decoder = this.parser.options.meshoptDecoder;
      if (!decoder || !decoder.supported) {
        if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {
          throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
        } else {
          return null;
        }
      }
      return buffer.then(function(res) {
        const byteOffset = extensionDef.byteOffset || 0;
        const byteLength = extensionDef.byteLength || 0;
        const count = extensionDef.count;
        const stride = extensionDef.byteStride;
        const source = new Uint8Array(res, byteOffset, byteLength);
        if (decoder.decodeGltfBufferAsync) {
          return decoder.decodeGltfBufferAsync(count, stride, source, extensionDef.mode, extensionDef.filter).then(function(res2) {
            return res2.buffer;
          });
        } else {
          return decoder.ready.then(function() {
            const result = new ArrayBuffer(count * stride);
            decoder.decodeGltfBuffer(
              new Uint8Array(result),
              count,
              stride,
              source,
              extensionDef.mode,
              extensionDef.filter
            );
            return result;
          });
        }
      });
    } else {
      return null;
    }
  }
};
var GLTFMeshGpuInstancing = class {
  constructor(parser) {
    this.name = EXTENSIONS.EXT_MESH_GPU_INSTANCING;
    this.parser = parser;
  }
  createNodeMesh(nodeIndex) {
    const json = this.parser.json;
    const nodeDef = json.nodes[nodeIndex];
    if (!nodeDef.extensions || !nodeDef.extensions[this.name] || nodeDef.mesh === void 0) {
      return null;
    }
    const meshDef = json.meshes[nodeDef.mesh];
    for (const primitive of meshDef.primitives) {
      if (primitive.mode !== WEBGL_CONSTANTS2.TRIANGLES && primitive.mode !== WEBGL_CONSTANTS2.TRIANGLE_STRIP && primitive.mode !== WEBGL_CONSTANTS2.TRIANGLE_FAN && primitive.mode !== void 0) {
        return null;
      }
    }
    const extensionDef = nodeDef.extensions[this.name];
    const attributesDef = extensionDef.attributes;
    const pending = [];
    const attributes = {};
    for (const key in attributesDef) {
      pending.push(
        this.parser.getDependency("accessor", attributesDef[key]).then((accessor) => {
          attributes[key] = accessor;
          return attributes[key];
        })
      );
    }
    if (pending.length < 1) {
      return null;
    }
    pending.push(this.parser.createNodeMesh(nodeIndex));
    return Promise.all(pending).then((results) => {
      const nodeObject = results.pop();
      const meshes = nodeObject.isGroup ? nodeObject.children : [nodeObject];
      const count = results[0].count;
      const instancedMeshes = [];
      for (const mesh of meshes) {
        const m = new Matrix4();
        const p = new Vector3();
        const q = new Quaternion();
        const s = new Vector3(1, 1, 1);
        const instancedMesh = new InstancedMesh(mesh.geometry, mesh.material, count);
        for (let i3 = 0; i3 < count; i3++) {
          if (attributes.TRANSLATION) {
            p.fromBufferAttribute(attributes.TRANSLATION, i3);
          }
          if (attributes.ROTATION) {
            q.fromBufferAttribute(attributes.ROTATION, i3);
          }
          if (attributes.SCALE) {
            s.fromBufferAttribute(attributes.SCALE, i3);
          }
          instancedMesh.setMatrixAt(i3, m.compose(p, q, s));
        }
        for (const attributeName in attributes) {
          if (attributeName !== "TRANSLATION" && attributeName !== "ROTATION" && attributeName !== "SCALE") {
            mesh.geometry.setAttribute(attributeName, attributes[attributeName]);
          }
        }
        Object3D.prototype.copy.call(instancedMesh, mesh);
        this.parser.assignFinalMaterial(instancedMesh);
        instancedMeshes.push(instancedMesh);
      }
      if (nodeObject.isGroup) {
        nodeObject.clear();
        nodeObject.add(...instancedMeshes);
        return nodeObject;
      }
      return instancedMeshes[0];
    });
  }
};
var BINARY_EXTENSION_HEADER_MAGIC = "glTF";
var BINARY_EXTENSION_HEADER_LENGTH = 12;
var BINARY_EXTENSION_CHUNK_TYPES = { JSON: 1313821514, BIN: 5130562 };
var GLTFBinaryExtension = class {
  constructor(data) {
    this.name = EXTENSIONS.KHR_BINARY_GLTF;
    this.content = null;
    this.body = null;
    const headerView = new DataView(data, 0, BINARY_EXTENSION_HEADER_LENGTH);
    this.header = {
      magic: LoaderUtils.decodeText(new Uint8Array(data.slice(0, 4))),
      version: headerView.getUint32(4, true),
      length: headerView.getUint32(8, true)
    };
    if (this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC) {
      throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
    } else if (this.header.version < 2) {
      throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
    }
    const chunkContentsLength = this.header.length - BINARY_EXTENSION_HEADER_LENGTH;
    const chunkView = new DataView(data, BINARY_EXTENSION_HEADER_LENGTH);
    let chunkIndex = 0;
    while (chunkIndex < chunkContentsLength) {
      const chunkLength = chunkView.getUint32(chunkIndex, true);
      chunkIndex += 4;
      const chunkType = chunkView.getUint32(chunkIndex, true);
      chunkIndex += 4;
      if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON) {
        const contentArray = new Uint8Array(data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength);
        this.content = LoaderUtils.decodeText(contentArray);
      } else if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN) {
        const byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;
        this.body = data.slice(byteOffset, byteOffset + chunkLength);
      }
      chunkIndex += chunkLength;
    }
    if (this.content === null) {
      throw new Error("THREE.GLTFLoader: JSON content not found.");
    }
  }
};
var GLTFDracoMeshCompressionExtension = class {
  constructor(json, dracoLoader2) {
    if (!dracoLoader2) {
      throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
    }
    this.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;
    this.json = json;
    this.dracoLoader = dracoLoader2;
    this.dracoLoader.preload();
  }
  decodePrimitive(primitive, parser) {
    const json = this.json;
    const dracoLoader2 = this.dracoLoader;
    const bufferViewIndex = primitive.extensions[this.name].bufferView;
    const gltfAttributeMap = primitive.extensions[this.name].attributes;
    const threeAttributeMap = {};
    const attributeNormalizedMap = {};
    const attributeTypeMap = {};
    for (const attributeName in gltfAttributeMap) {
      const threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();
      threeAttributeMap[threeAttributeName] = gltfAttributeMap[attributeName];
    }
    for (const attributeName in primitive.attributes) {
      const threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();
      if (gltfAttributeMap[attributeName] !== void 0) {
        const accessorDef = json.accessors[primitive.attributes[attributeName]];
        const componentType = WEBGL_COMPONENT_TYPES[accessorDef.componentType];
        attributeTypeMap[threeAttributeName] = componentType.name;
        attributeNormalizedMap[threeAttributeName] = accessorDef.normalized === true;
      }
    }
    return parser.getDependency("bufferView", bufferViewIndex).then(function(bufferView) {
      return new Promise(function(resolve) {
        dracoLoader2.decodeDracoFile(
          bufferView,
          function(geometry2) {
            for (const attributeName in geometry2.attributes) {
              const attribute = geometry2.attributes[attributeName];
              const normalized = attributeNormalizedMap[attributeName];
              if (normalized !== void 0)
                attribute.normalized = normalized;
            }
            resolve(geometry2);
          },
          threeAttributeMap,
          attributeTypeMap
        );
      });
    });
  }
};
var GLTFTextureTransformExtension = class {
  constructor() {
    this.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM;
  }
  extendTexture(texture, transform) {
    if ((transform.texCoord === void 0 || transform.texCoord === texture.channel) && transform.offset === void 0 && transform.rotation === void 0 && transform.scale === void 0) {
      return texture;
    }
    texture = texture.clone();
    if (transform.texCoord !== void 0) {
      texture.channel = transform.texCoord;
    }
    if (transform.offset !== void 0) {
      texture.offset.fromArray(transform.offset);
    }
    if (transform.rotation !== void 0) {
      texture.rotation = transform.rotation;
    }
    if (transform.scale !== void 0) {
      texture.repeat.fromArray(transform.scale);
    }
    texture.needsUpdate = true;
    return texture;
  }
};
var GLTFMeshQuantizationExtension = class {
  constructor() {
    this.name = EXTENSIONS.KHR_MESH_QUANTIZATION;
  }
};
var GLTFCubicSplineInterpolant = class extends Interpolant {
  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    super(parameterPositions, sampleValues, sampleSize, resultBuffer);
  }
  copySampleValue_(index) {
    const result = this.resultBuffer, values = this.sampleValues, valueSize = this.valueSize, offset = index * valueSize * 3 + valueSize;
    for (let i3 = 0; i3 !== valueSize; i3++) {
      result[i3] = values[offset + i3];
    }
    return result;
  }
  interpolate_(i1, t0, t2, t1) {
    const result = this.resultBuffer;
    const values = this.sampleValues;
    const stride = this.valueSize;
    const stride2 = stride * 2;
    const stride3 = stride * 3;
    const td3 = t1 - t0;
    const p = (t2 - t0) / td3;
    const pp = p * p;
    const ppp = pp * p;
    const offset1 = i1 * stride3;
    const offset0 = offset1 - stride3;
    const s2 = -2 * ppp + 3 * pp;
    const s3 = ppp - pp;
    const s0 = 1 - s2;
    const s1 = s3 - pp + p;
    for (let i3 = 0; i3 !== stride; i3++) {
      const p0 = values[offset0 + i3 + stride];
      const m0 = values[offset0 + i3 + stride2] * td3;
      const p1 = values[offset1 + i3 + stride];
      const m1 = values[offset1 + i3] * td3;
      result[i3] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1;
    }
    return result;
  }
};
var _q3 = new Quaternion();
var GLTFCubicSplineQuaternionInterpolant = class extends GLTFCubicSplineInterpolant {
  interpolate_(i1, t0, t2, t1) {
    const result = super.interpolate_(i1, t0, t2, t1);
    _q3.fromArray(result).normalize().toArray(result);
    return result;
  }
};
var WEBGL_CONSTANTS2 = {
  FLOAT: 5126,
  //FLOAT_MAT2: 35674,
  FLOAT_MAT3: 35675,
  FLOAT_MAT4: 35676,
  FLOAT_VEC2: 35664,
  FLOAT_VEC3: 35665,
  FLOAT_VEC4: 35666,
  LINEAR: 9729,
  REPEAT: 10497,
  SAMPLER_2D: 35678,
  POINTS: 0,
  LINES: 1,
  LINE_LOOP: 2,
  LINE_STRIP: 3,
  TRIANGLES: 4,
  TRIANGLE_STRIP: 5,
  TRIANGLE_FAN: 6,
  UNSIGNED_BYTE: 5121,
  UNSIGNED_SHORT: 5123
};
var WEBGL_COMPONENT_TYPES = {
  5120: Int8Array,
  5121: Uint8Array,
  5122: Int16Array,
  5123: Uint16Array,
  5125: Uint32Array,
  5126: Float32Array
};
var WEBGL_FILTERS = {
  9728: NearestFilter,
  9729: LinearFilter,
  9984: NearestMipmapNearestFilter,
  9985: LinearMipmapNearestFilter,
  9986: NearestMipmapLinearFilter,
  9987: LinearMipmapLinearFilter
};
var WEBGL_WRAPPINGS = {
  33071: ClampToEdgeWrapping,
  33648: MirroredRepeatWrapping,
  10497: RepeatWrapping
};
var WEBGL_TYPE_SIZES = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
};
var ATTRIBUTES = {
  POSITION: "position",
  NORMAL: "normal",
  TANGENT: "tangent",
  // uv => uv1, 4 uv channels
  // https://github.com/mrdoob/three.js/pull/25943
  // https://github.com/mrdoob/three.js/pull/25788
  ...REVISION.replace(/\D+/g, "") >= 152 ? {
    TEXCOORD_0: "uv",
    TEXCOORD_1: "uv1",
    TEXCOORD_2: "uv2",
    TEXCOORD_3: "uv3"
  } : {
    TEXCOORD_0: "uv",
    TEXCOORD_1: "uv2"
  },
  COLOR_0: "color",
  WEIGHTS_0: "skinWeight",
  JOINTS_0: "skinIndex"
};
var PATH_PROPERTIES2 = {
  scale: "scale",
  translation: "position",
  rotation: "quaternion",
  weights: "morphTargetInfluences"
};
var INTERPOLATION = {
  CUBICSPLINE: void 0,
  // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each
  // keyframe track will be initialized with a default interpolation type, then modified.
  LINEAR: InterpolateLinear,
  STEP: InterpolateDiscrete
};
var ALPHA_MODES = {
  OPAQUE: "OPAQUE",
  MASK: "MASK",
  BLEND: "BLEND"
};
function createDefaultMaterial(cache) {
  if (cache["DefaultMaterial"] === void 0) {
    cache["DefaultMaterial"] = new MeshStandardMaterial({
      color: 16777215,
      emissive: 0,
      metalness: 1,
      roughness: 1,
      transparent: false,
      depthTest: true,
      side: FrontSide
    });
  }
  return cache["DefaultMaterial"];
}
function addUnknownExtensionsToUserData(knownExtensions, object, objectDef) {
  for (const name in objectDef.extensions) {
    if (knownExtensions[name] === void 0) {
      object.userData.gltfExtensions = object.userData.gltfExtensions || {};
      object.userData.gltfExtensions[name] = objectDef.extensions[name];
    }
  }
}
function assignExtrasToUserData(object, gltfDef) {
  if (gltfDef.extras !== void 0) {
    if (typeof gltfDef.extras === "object") {
      Object.assign(object.userData, gltfDef.extras);
    } else {
      console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + gltfDef.extras);
    }
  }
}
function addMorphTargets(geometry2, targets, parser) {
  let hasMorphPosition = false;
  let hasMorphNormal = false;
  let hasMorphColor = false;
  for (let i3 = 0, il = targets.length; i3 < il; i3++) {
    const target = targets[i3];
    if (target.POSITION !== void 0)
      hasMorphPosition = true;
    if (target.NORMAL !== void 0)
      hasMorphNormal = true;
    if (target.COLOR_0 !== void 0)
      hasMorphColor = true;
    if (hasMorphPosition && hasMorphNormal && hasMorphColor)
      break;
  }
  if (!hasMorphPosition && !hasMorphNormal && !hasMorphColor)
    return Promise.resolve(geometry2);
  const pendingPositionAccessors = [];
  const pendingNormalAccessors = [];
  const pendingColorAccessors = [];
  for (let i3 = 0, il = targets.length; i3 < il; i3++) {
    const target = targets[i3];
    if (hasMorphPosition) {
      const pendingAccessor = target.POSITION !== void 0 ? parser.getDependency("accessor", target.POSITION) : geometry2.attributes.position;
      pendingPositionAccessors.push(pendingAccessor);
    }
    if (hasMorphNormal) {
      const pendingAccessor = target.NORMAL !== void 0 ? parser.getDependency("accessor", target.NORMAL) : geometry2.attributes.normal;
      pendingNormalAccessors.push(pendingAccessor);
    }
    if (hasMorphColor) {
      const pendingAccessor = target.COLOR_0 !== void 0 ? parser.getDependency("accessor", target.COLOR_0) : geometry2.attributes.color;
      pendingColorAccessors.push(pendingAccessor);
    }
  }
  return Promise.all([
    Promise.all(pendingPositionAccessors),
    Promise.all(pendingNormalAccessors),
    Promise.all(pendingColorAccessors)
  ]).then(function(accessors) {
    const morphPositions = accessors[0];
    const morphNormals = accessors[1];
    const morphColors = accessors[2];
    if (hasMorphPosition)
      geometry2.morphAttributes.position = morphPositions;
    if (hasMorphNormal)
      geometry2.morphAttributes.normal = morphNormals;
    if (hasMorphColor)
      geometry2.morphAttributes.color = morphColors;
    geometry2.morphTargetsRelative = true;
    return geometry2;
  });
}
function updateMorphTargets(mesh, meshDef) {
  mesh.updateMorphTargets();
  if (meshDef.weights !== void 0) {
    for (let i3 = 0, il = meshDef.weights.length; i3 < il; i3++) {
      mesh.morphTargetInfluences[i3] = meshDef.weights[i3];
    }
  }
  if (meshDef.extras && Array.isArray(meshDef.extras.targetNames)) {
    const targetNames = meshDef.extras.targetNames;
    if (mesh.morphTargetInfluences.length === targetNames.length) {
      mesh.morphTargetDictionary = {};
      for (let i3 = 0, il = targetNames.length; i3 < il; i3++) {
        mesh.morphTargetDictionary[targetNames[i3]] = i3;
      }
    } else {
      console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.");
    }
  }
}
function createPrimitiveKey(primitiveDef) {
  let geometryKey;
  const dracoExtension = primitiveDef.extensions && primitiveDef.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION];
  if (dracoExtension) {
    geometryKey = "draco:" + dracoExtension.bufferView + ":" + dracoExtension.indices + ":" + createAttributesKey(dracoExtension.attributes);
  } else {
    geometryKey = primitiveDef.indices + ":" + createAttributesKey(primitiveDef.attributes) + ":" + primitiveDef.mode;
  }
  if (primitiveDef.targets !== void 0) {
    for (let i3 = 0, il = primitiveDef.targets.length; i3 < il; i3++) {
      geometryKey += ":" + createAttributesKey(primitiveDef.targets[i3]);
    }
  }
  return geometryKey;
}
function createAttributesKey(attributes) {
  let attributesKey = "";
  const keys = Object.keys(attributes).sort();
  for (let i3 = 0, il = keys.length; i3 < il; i3++) {
    attributesKey += keys[i3] + ":" + attributes[keys[i3]] + ";";
  }
  return attributesKey;
}
function getNormalizedComponentScale(constructor) {
  switch (constructor) {
    case Int8Array:
      return 1 / 127;
    case Uint8Array:
      return 1 / 255;
    case Int16Array:
      return 1 / 32767;
    case Uint16Array:
      return 1 / 65535;
    default:
      throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.");
  }
}
function getImageURIMimeType(uri) {
  if (uri.search(/\.jpe?g($|\?)/i) > 0 || uri.search(/^data\:image\/jpeg/) === 0)
    return "image/jpeg";
  if (uri.search(/\.webp($|\?)/i) > 0 || uri.search(/^data\:image\/webp/) === 0)
    return "image/webp";
  return "image/png";
}
var _identityMatrix = new Matrix4();
var GLTFParser = class {
  constructor(json = {}, options = {}) {
    this.json = json;
    this.extensions = {};
    this.plugins = {};
    this.options = options;
    this.cache = new GLTFRegistry();
    this.associations = /* @__PURE__ */ new Map();
    this.primitiveCache = {};
    this.nodeCache = {};
    this.meshCache = { refs: {}, uses: {} };
    this.cameraCache = { refs: {}, uses: {} };
    this.lightCache = { refs: {}, uses: {} };
    this.sourceCache = {};
    this.textureCache = {};
    this.nodeNamesUsed = {};
    let isSafari = false;
    let isFirefox = false;
    let firefoxVersion = -1;
    if (typeof navigator !== "undefined" && typeof navigator.userAgent !== "undefined") {
      isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent) === true;
      isFirefox = navigator.userAgent.indexOf("Firefox") > -1;
      firefoxVersion = isFirefox ? navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1] : -1;
    }
    if (typeof createImageBitmap === "undefined" || isSafari || isFirefox && firefoxVersion < 98) {
      this.textureLoader = new TextureLoader(this.options.manager);
    } else {
      this.textureLoader = new ImageBitmapLoader(this.options.manager);
    }
    this.textureLoader.setCrossOrigin(this.options.crossOrigin);
    this.textureLoader.setRequestHeader(this.options.requestHeader);
    this.fileLoader = new FileLoader(this.options.manager);
    this.fileLoader.setResponseType("arraybuffer");
    if (this.options.crossOrigin === "use-credentials") {
      this.fileLoader.setWithCredentials(true);
    }
  }
  setExtensions(extensions) {
    this.extensions = extensions;
  }
  setPlugins(plugins) {
    this.plugins = plugins;
  }
  parse(onLoad, onError) {
    const parser = this;
    const json = this.json;
    const extensions = this.extensions;
    this.cache.removeAll();
    this.nodeCache = {};
    this._invokeAll(function(ext) {
      return ext._markDefs && ext._markDefs();
    });
    Promise.all(
      this._invokeAll(function(ext) {
        return ext.beforeRoot && ext.beforeRoot();
      })
    ).then(function() {
      return Promise.all([
        parser.getDependencies("scene"),
        parser.getDependencies("animation"),
        parser.getDependencies("camera")
      ]);
    }).then(function(dependencies) {
      const result = {
        scene: dependencies[0][json.scene || 0],
        scenes: dependencies[0],
        animations: dependencies[1],
        cameras: dependencies[2],
        asset: json.asset,
        parser,
        userData: {}
      };
      addUnknownExtensionsToUserData(extensions, result, json);
      assignExtrasToUserData(result, json);
      Promise.all(
        parser._invokeAll(function(ext) {
          return ext.afterRoot && ext.afterRoot(result);
        })
      ).then(function() {
        onLoad(result);
      });
    }).catch(onError);
  }
  /**
   * Marks the special nodes/meshes in json for efficient parse.
   */
  _markDefs() {
    const nodeDefs = this.json.nodes || [];
    const skinDefs = this.json.skins || [];
    const meshDefs = this.json.meshes || [];
    for (let skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex++) {
      const joints = skinDefs[skinIndex].joints;
      for (let i3 = 0, il = joints.length; i3 < il; i3++) {
        nodeDefs[joints[i3]].isBone = true;
      }
    }
    for (let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {
      const nodeDef = nodeDefs[nodeIndex];
      if (nodeDef.mesh !== void 0) {
        this._addNodeRef(this.meshCache, nodeDef.mesh);
        if (nodeDef.skin !== void 0) {
          meshDefs[nodeDef.mesh].isSkinnedMesh = true;
        }
      }
      if (nodeDef.camera !== void 0) {
        this._addNodeRef(this.cameraCache, nodeDef.camera);
      }
    }
  }
  /**
   * Counts references to shared node / Object3D resources. These resources
   * can be reused, or "instantiated", at multiple nodes in the scene
   * hierarchy. Mesh, Camera, and Light instances are instantiated and must
   * be marked. Non-scenegraph resources (like Materials, Geometries, and
   * Textures) can be reused directly and are not marked here.
   *
   * Example: CesiumMilkTruck sample model reuses "Wheel" meshes.
   */
  _addNodeRef(cache, index) {
    if (index === void 0)
      return;
    if (cache.refs[index] === void 0) {
      cache.refs[index] = cache.uses[index] = 0;
    }
    cache.refs[index]++;
  }
  /** Returns a reference to a shared resource, cloning it if necessary. */
  _getNodeRef(cache, index, object) {
    if (cache.refs[index] <= 1)
      return object;
    const ref = object.clone();
    const updateMappings = (original, clone2) => {
      const mappings = this.associations.get(original);
      if (mappings != null) {
        this.associations.set(clone2, mappings);
      }
      for (const [i3, child] of original.children.entries()) {
        updateMappings(child, clone2.children[i3]);
      }
    };
    updateMappings(object, ref);
    ref.name += "_instance_" + cache.uses[index]++;
    return ref;
  }
  _invokeOne(func) {
    const extensions = Object.values(this.plugins);
    extensions.push(this);
    for (let i3 = 0; i3 < extensions.length; i3++) {
      const result = func(extensions[i3]);
      if (result)
        return result;
    }
    return null;
  }
  _invokeAll(func) {
    const extensions = Object.values(this.plugins);
    extensions.unshift(this);
    const pending = [];
    for (let i3 = 0; i3 < extensions.length; i3++) {
      const result = func(extensions[i3]);
      if (result)
        pending.push(result);
    }
    return pending;
  }
  /**
   * Requests the specified dependency asynchronously, with caching.
   * @param {string} type
   * @param {number} index
   * @return {Promise<Object3D|Material|THREE.Texture|AnimationClip|ArrayBuffer|Object>}
   */
  getDependency(type, index) {
    const cacheKey = type + ":" + index;
    let dependency = this.cache.get(cacheKey);
    if (!dependency) {
      switch (type) {
        case "scene":
          dependency = this.loadScene(index);
          break;
        case "node":
          dependency = this._invokeOne(function(ext) {
            return ext.loadNode && ext.loadNode(index);
          });
          break;
        case "mesh":
          dependency = this._invokeOne(function(ext) {
            return ext.loadMesh && ext.loadMesh(index);
          });
          break;
        case "accessor":
          dependency = this.loadAccessor(index);
          break;
        case "bufferView":
          dependency = this._invokeOne(function(ext) {
            return ext.loadBufferView && ext.loadBufferView(index);
          });
          break;
        case "buffer":
          dependency = this.loadBuffer(index);
          break;
        case "material":
          dependency = this._invokeOne(function(ext) {
            return ext.loadMaterial && ext.loadMaterial(index);
          });
          break;
        case "texture":
          dependency = this._invokeOne(function(ext) {
            return ext.loadTexture && ext.loadTexture(index);
          });
          break;
        case "skin":
          dependency = this.loadSkin(index);
          break;
        case "animation":
          dependency = this._invokeOne(function(ext) {
            return ext.loadAnimation && ext.loadAnimation(index);
          });
          break;
        case "camera":
          dependency = this.loadCamera(index);
          break;
        default:
          dependency = this._invokeOne(function(ext) {
            return ext != this && ext.getDependency && ext.getDependency(type, index);
          });
          if (!dependency) {
            throw new Error("Unknown type: " + type);
          }
          break;
      }
      this.cache.add(cacheKey, dependency);
    }
    return dependency;
  }
  /**
   * Requests all dependencies of the specified type asynchronously, with caching.
   * @param {string} type
   * @return {Promise<Array<Object>>}
   */
  getDependencies(type) {
    let dependencies = this.cache.get(type);
    if (!dependencies) {
      const parser = this;
      const defs = this.json[type + (type === "mesh" ? "es" : "s")] || [];
      dependencies = Promise.all(
        defs.map(function(def, index) {
          return parser.getDependency(type, index);
        })
      );
      this.cache.add(type, dependencies);
    }
    return dependencies;
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
   * @param {number} bufferIndex
   * @return {Promise<ArrayBuffer>}
   */
  loadBuffer(bufferIndex) {
    const bufferDef = this.json.buffers[bufferIndex];
    const loader = this.fileLoader;
    if (bufferDef.type && bufferDef.type !== "arraybuffer") {
      throw new Error("THREE.GLTFLoader: " + bufferDef.type + " buffer type is not supported.");
    }
    if (bufferDef.uri === void 0 && bufferIndex === 0) {
      return Promise.resolve(this.extensions[EXTENSIONS.KHR_BINARY_GLTF].body);
    }
    const options = this.options;
    return new Promise(function(resolve, reject) {
      loader.load(LoaderUtils.resolveURL(bufferDef.uri, options.path), resolve, void 0, function() {
        reject(new Error('THREE.GLTFLoader: Failed to load buffer "' + bufferDef.uri + '".'));
      });
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
   * @param {number} bufferViewIndex
   * @return {Promise<ArrayBuffer>}
   */
  loadBufferView(bufferViewIndex) {
    const bufferViewDef = this.json.bufferViews[bufferViewIndex];
    return this.getDependency("buffer", bufferViewDef.buffer).then(function(buffer) {
      const byteLength = bufferViewDef.byteLength || 0;
      const byteOffset = bufferViewDef.byteOffset || 0;
      return buffer.slice(byteOffset, byteOffset + byteLength);
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors
   * @param {number} accessorIndex
   * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}
   */
  loadAccessor(accessorIndex) {
    const parser = this;
    const json = this.json;
    const accessorDef = this.json.accessors[accessorIndex];
    if (accessorDef.bufferView === void 0 && accessorDef.sparse === void 0) {
      const itemSize = WEBGL_TYPE_SIZES[accessorDef.type];
      const TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType];
      const normalized = accessorDef.normalized === true;
      const array = new TypedArray(accessorDef.count * itemSize);
      return Promise.resolve(new BufferAttribute(array, itemSize, normalized));
    }
    const pendingBufferViews = [];
    if (accessorDef.bufferView !== void 0) {
      pendingBufferViews.push(this.getDependency("bufferView", accessorDef.bufferView));
    } else {
      pendingBufferViews.push(null);
    }
    if (accessorDef.sparse !== void 0) {
      pendingBufferViews.push(this.getDependency("bufferView", accessorDef.sparse.indices.bufferView));
      pendingBufferViews.push(this.getDependency("bufferView", accessorDef.sparse.values.bufferView));
    }
    return Promise.all(pendingBufferViews).then(function(bufferViews) {
      const bufferView = bufferViews[0];
      const itemSize = WEBGL_TYPE_SIZES[accessorDef.type];
      const TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType];
      const elementBytes = TypedArray.BYTES_PER_ELEMENT;
      const itemBytes = elementBytes * itemSize;
      const byteOffset = accessorDef.byteOffset || 0;
      const byteStride = accessorDef.bufferView !== void 0 ? json.bufferViews[accessorDef.bufferView].byteStride : void 0;
      const normalized = accessorDef.normalized === true;
      let array, bufferAttribute;
      if (byteStride && byteStride !== itemBytes) {
        const ibSlice = Math.floor(byteOffset / byteStride);
        const ibCacheKey = "InterleavedBuffer:" + accessorDef.bufferView + ":" + accessorDef.componentType + ":" + ibSlice + ":" + accessorDef.count;
        let ib = parser.cache.get(ibCacheKey);
        if (!ib) {
          array = new TypedArray(bufferView, ibSlice * byteStride, accessorDef.count * byteStride / elementBytes);
          ib = new InterleavedBuffer(array, byteStride / elementBytes);
          parser.cache.add(ibCacheKey, ib);
        }
        bufferAttribute = new InterleavedBufferAttribute(
          ib,
          itemSize,
          byteOffset % byteStride / elementBytes,
          normalized
        );
      } else {
        if (bufferView === null) {
          array = new TypedArray(accessorDef.count * itemSize);
        } else {
          array = new TypedArray(bufferView, byteOffset, accessorDef.count * itemSize);
        }
        bufferAttribute = new BufferAttribute(array, itemSize, normalized);
      }
      if (accessorDef.sparse !== void 0) {
        const itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;
        const TypedArrayIndices = WEBGL_COMPONENT_TYPES[accessorDef.sparse.indices.componentType];
        const byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;
        const byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;
        const sparseIndices = new TypedArrayIndices(
          bufferViews[1],
          byteOffsetIndices,
          accessorDef.sparse.count * itemSizeIndices
        );
        const sparseValues = new TypedArray(bufferViews[2], byteOffsetValues, accessorDef.sparse.count * itemSize);
        if (bufferView !== null) {
          bufferAttribute = new BufferAttribute(
            bufferAttribute.array.slice(),
            bufferAttribute.itemSize,
            bufferAttribute.normalized
          );
        }
        for (let i3 = 0, il = sparseIndices.length; i3 < il; i3++) {
          const index = sparseIndices[i3];
          bufferAttribute.setX(index, sparseValues[i3 * itemSize]);
          if (itemSize >= 2)
            bufferAttribute.setY(index, sparseValues[i3 * itemSize + 1]);
          if (itemSize >= 3)
            bufferAttribute.setZ(index, sparseValues[i3 * itemSize + 2]);
          if (itemSize >= 4)
            bufferAttribute.setW(index, sparseValues[i3 * itemSize + 3]);
          if (itemSize >= 5)
            throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.");
        }
      }
      return bufferAttribute;
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures
   * @param {number} textureIndex
   * @return {Promise<THREE.Texture|null>}
   */
  loadTexture(textureIndex) {
    const json = this.json;
    const options = this.options;
    const textureDef = json.textures[textureIndex];
    const sourceIndex = textureDef.source;
    const sourceDef = json.images[sourceIndex];
    let loader = this.textureLoader;
    if (sourceDef.uri) {
      const handler = options.manager.getHandler(sourceDef.uri);
      if (handler !== null)
        loader = handler;
    }
    return this.loadTextureImage(textureIndex, sourceIndex, loader);
  }
  loadTextureImage(textureIndex, sourceIndex, loader) {
    const parser = this;
    const json = this.json;
    const textureDef = json.textures[textureIndex];
    const sourceDef = json.images[sourceIndex];
    const cacheKey = (sourceDef.uri || sourceDef.bufferView) + ":" + textureDef.sampler;
    if (this.textureCache[cacheKey]) {
      return this.textureCache[cacheKey];
    }
    const promise = this.loadImageSource(sourceIndex, loader).then(function(texture) {
      texture.flipY = false;
      texture.name = textureDef.name || sourceDef.name || "";
      if (texture.name === "" && typeof sourceDef.uri === "string" && sourceDef.uri.startsWith("data:image/") === false) {
        texture.name = sourceDef.uri;
      }
      const samplers = json.samplers || {};
      const sampler = samplers[textureDef.sampler] || {};
      texture.magFilter = WEBGL_FILTERS[sampler.magFilter] || LinearFilter;
      texture.minFilter = WEBGL_FILTERS[sampler.minFilter] || LinearMipmapLinearFilter;
      texture.wrapS = WEBGL_WRAPPINGS[sampler.wrapS] || RepeatWrapping;
      texture.wrapT = WEBGL_WRAPPINGS[sampler.wrapT] || RepeatWrapping;
      parser.associations.set(texture, { textures: textureIndex });
      return texture;
    }).catch(function() {
      return null;
    });
    this.textureCache[cacheKey] = promise;
    return promise;
  }
  loadImageSource(sourceIndex, loader) {
    const parser = this;
    const json = this.json;
    const options = this.options;
    if (this.sourceCache[sourceIndex] !== void 0) {
      return this.sourceCache[sourceIndex].then((texture) => texture.clone());
    }
    const sourceDef = json.images[sourceIndex];
    const URL2 = self.URL || self.webkitURL;
    let sourceURI = sourceDef.uri || "";
    let isObjectURL = false;
    if (sourceDef.bufferView !== void 0) {
      sourceURI = parser.getDependency("bufferView", sourceDef.bufferView).then(function(bufferView) {
        isObjectURL = true;
        const blob = new Blob([bufferView], { type: sourceDef.mimeType });
        sourceURI = URL2.createObjectURL(blob);
        return sourceURI;
      });
    } else if (sourceDef.uri === void 0) {
      throw new Error("THREE.GLTFLoader: Image " + sourceIndex + " is missing URI and bufferView");
    }
    const promise = Promise.resolve(sourceURI).then(function(sourceURI2) {
      return new Promise(function(resolve, reject) {
        let onLoad = resolve;
        if (loader.isImageBitmapLoader === true) {
          onLoad = function(imageBitmap) {
            const texture = new Texture(imageBitmap);
            texture.needsUpdate = true;
            resolve(texture);
          };
        }
        loader.load(LoaderUtils.resolveURL(sourceURI2, options.path), onLoad, void 0, reject);
      });
    }).then(function(texture) {
      if (isObjectURL === true) {
        URL2.revokeObjectURL(sourceURI);
      }
      texture.userData.mimeType = sourceDef.mimeType || getImageURIMimeType(sourceDef.uri);
      return texture;
    }).catch(function(error) {
      console.error("THREE.GLTFLoader: Couldn't load texture", sourceURI);
      throw error;
    });
    this.sourceCache[sourceIndex] = promise;
    return promise;
  }
  /**
   * Asynchronously assigns a texture to the given material parameters.
   * @param {Object} materialParams
   * @param {string} mapName
   * @param {Object} mapDef
   * @return {Promise<Texture>}
   */
  assignTexture(materialParams, mapName, mapDef, encoding) {
    const parser = this;
    return this.getDependency("texture", mapDef.index).then(function(texture) {
      if (!texture)
        return null;
      if (mapDef.texCoord !== void 0 && mapDef.texCoord > 0) {
        texture = texture.clone();
        texture.channel = mapDef.texCoord;
      }
      if (parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM]) {
        const transform = mapDef.extensions !== void 0 ? mapDef.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM] : void 0;
        if (transform) {
          const gltfReference = parser.associations.get(texture);
          texture = parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM].extendTexture(texture, transform);
          parser.associations.set(texture, gltfReference);
        }
      }
      if (encoding !== void 0) {
        if ("colorSpace" in texture)
          texture.colorSpace = encoding === 3001 ? "srgb" : "srgb-linear";
        else
          texture.encoding = encoding;
      }
      materialParams[mapName] = texture;
      return texture;
    });
  }
  /**
   * Assigns final material to a Mesh, Line, or Points instance. The instance
   * already has a material (generated from the glTF material options alone)
   * but reuse of the same glTF material may require multiple threejs materials
   * to accommodate different primitive types, defines, etc. New materials will
   * be created if necessary, and reused from a cache.
   * @param  {Object3D} mesh Mesh, Line, or Points instance.
   */
  assignFinalMaterial(mesh) {
    const geometry2 = mesh.geometry;
    let material2 = mesh.material;
    const useDerivativeTangents = geometry2.attributes.tangent === void 0;
    const useVertexColors = geometry2.attributes.color !== void 0;
    const useFlatShading = geometry2.attributes.normal === void 0;
    if (mesh.isPoints) {
      const cacheKey = "PointsMaterial:" + material2.uuid;
      let pointsMaterial = this.cache.get(cacheKey);
      if (!pointsMaterial) {
        pointsMaterial = new PointsMaterial();
        Material.prototype.copy.call(pointsMaterial, material2);
        pointsMaterial.color.copy(material2.color);
        pointsMaterial.map = material2.map;
        pointsMaterial.sizeAttenuation = false;
        this.cache.add(cacheKey, pointsMaterial);
      }
      material2 = pointsMaterial;
    } else if (mesh.isLine) {
      const cacheKey = "LineBasicMaterial:" + material2.uuid;
      let lineMaterial = this.cache.get(cacheKey);
      if (!lineMaterial) {
        lineMaterial = new LineBasicMaterial();
        Material.prototype.copy.call(lineMaterial, material2);
        lineMaterial.color.copy(material2.color);
        lineMaterial.map = material2.map;
        this.cache.add(cacheKey, lineMaterial);
      }
      material2 = lineMaterial;
    }
    if (useDerivativeTangents || useVertexColors || useFlatShading) {
      let cacheKey = "ClonedMaterial:" + material2.uuid + ":";
      if (useDerivativeTangents)
        cacheKey += "derivative-tangents:";
      if (useVertexColors)
        cacheKey += "vertex-colors:";
      if (useFlatShading)
        cacheKey += "flat-shading:";
      let cachedMaterial = this.cache.get(cacheKey);
      if (!cachedMaterial) {
        cachedMaterial = material2.clone();
        if (useVertexColors)
          cachedMaterial.vertexColors = true;
        if (useFlatShading)
          cachedMaterial.flatShading = true;
        if (useDerivativeTangents) {
          if (cachedMaterial.normalScale)
            cachedMaterial.normalScale.y *= -1;
          if (cachedMaterial.clearcoatNormalScale)
            cachedMaterial.clearcoatNormalScale.y *= -1;
        }
        this.cache.add(cacheKey, cachedMaterial);
        this.associations.set(cachedMaterial, this.associations.get(material2));
      }
      material2 = cachedMaterial;
    }
    mesh.material = material2;
  }
  getMaterialType() {
    return MeshStandardMaterial;
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials
   * @param {number} materialIndex
   * @return {Promise<Material>}
   */
  loadMaterial(materialIndex) {
    const parser = this;
    const json = this.json;
    const extensions = this.extensions;
    const materialDef = json.materials[materialIndex];
    let materialType;
    const materialParams = {};
    const materialExtensions = materialDef.extensions || {};
    const pending = [];
    if (materialExtensions[EXTENSIONS.KHR_MATERIALS_UNLIT]) {
      const kmuExtension = extensions[EXTENSIONS.KHR_MATERIALS_UNLIT];
      materialType = kmuExtension.getMaterialType();
      pending.push(kmuExtension.extendParams(materialParams, materialDef, parser));
    } else {
      const metallicRoughness = materialDef.pbrMetallicRoughness || {};
      materialParams.color = new Color(1, 1, 1);
      materialParams.opacity = 1;
      if (Array.isArray(metallicRoughness.baseColorFactor)) {
        const array = metallicRoughness.baseColorFactor;
        materialParams.color.fromArray(array);
        materialParams.opacity = array[3];
      }
      if (metallicRoughness.baseColorTexture !== void 0) {
        pending.push(parser.assignTexture(materialParams, "map", metallicRoughness.baseColorTexture, 3001));
      }
      materialParams.metalness = metallicRoughness.metallicFactor !== void 0 ? metallicRoughness.metallicFactor : 1;
      materialParams.roughness = metallicRoughness.roughnessFactor !== void 0 ? metallicRoughness.roughnessFactor : 1;
      if (metallicRoughness.metallicRoughnessTexture !== void 0) {
        pending.push(parser.assignTexture(materialParams, "metalnessMap", metallicRoughness.metallicRoughnessTexture));
        pending.push(parser.assignTexture(materialParams, "roughnessMap", metallicRoughness.metallicRoughnessTexture));
      }
      materialType = this._invokeOne(function(ext) {
        return ext.getMaterialType && ext.getMaterialType(materialIndex);
      });
      pending.push(
        Promise.all(
          this._invokeAll(function(ext) {
            return ext.extendMaterialParams && ext.extendMaterialParams(materialIndex, materialParams);
          })
        )
      );
    }
    if (materialDef.doubleSided === true) {
      materialParams.side = DoubleSide;
    }
    const alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;
    if (alphaMode === ALPHA_MODES.BLEND) {
      materialParams.transparent = true;
      materialParams.depthWrite = false;
    } else {
      materialParams.transparent = false;
      if (alphaMode === ALPHA_MODES.MASK) {
        materialParams.alphaTest = materialDef.alphaCutoff !== void 0 ? materialDef.alphaCutoff : 0.5;
      }
    }
    if (materialDef.normalTexture !== void 0 && materialType !== MeshBasicMaterial) {
      pending.push(parser.assignTexture(materialParams, "normalMap", materialDef.normalTexture));
      materialParams.normalScale = new Vector2(1, 1);
      if (materialDef.normalTexture.scale !== void 0) {
        const scale = materialDef.normalTexture.scale;
        materialParams.normalScale.set(scale, scale);
      }
    }
    if (materialDef.occlusionTexture !== void 0 && materialType !== MeshBasicMaterial) {
      pending.push(parser.assignTexture(materialParams, "aoMap", materialDef.occlusionTexture));
      if (materialDef.occlusionTexture.strength !== void 0) {
        materialParams.aoMapIntensity = materialDef.occlusionTexture.strength;
      }
    }
    if (materialDef.emissiveFactor !== void 0 && materialType !== MeshBasicMaterial) {
      materialParams.emissive = new Color().fromArray(materialDef.emissiveFactor);
    }
    if (materialDef.emissiveTexture !== void 0 && materialType !== MeshBasicMaterial) {
      pending.push(parser.assignTexture(materialParams, "emissiveMap", materialDef.emissiveTexture, 3001));
    }
    return Promise.all(pending).then(function() {
      const material2 = new materialType(materialParams);
      if (materialDef.name)
        material2.name = materialDef.name;
      assignExtrasToUserData(material2, materialDef);
      parser.associations.set(material2, { materials: materialIndex });
      if (materialDef.extensions)
        addUnknownExtensionsToUserData(extensions, material2, materialDef);
      return material2;
    });
  }
  /** When Object3D instances are targeted by animation, they need unique names. */
  createUniqueName(originalName) {
    const sanitizedName = PropertyBinding.sanitizeNodeName(originalName || "");
    if (sanitizedName in this.nodeNamesUsed) {
      return sanitizedName + "_" + ++this.nodeNamesUsed[sanitizedName];
    } else {
      this.nodeNamesUsed[sanitizedName] = 0;
      return sanitizedName;
    }
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry
   *
   * Creates BufferGeometries from primitives.
   *
   * @param {Array<GLTF.Primitive>} primitives
   * @return {Promise<Array<BufferGeometry>>}
   */
  loadGeometries(primitives) {
    const parser = this;
    const extensions = this.extensions;
    const cache = this.primitiveCache;
    function createDracoPrimitive(primitive) {
      return extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(primitive, parser).then(function(geometry2) {
        return addPrimitiveAttributes(geometry2, primitive, parser);
      });
    }
    const pending = [];
    for (let i3 = 0, il = primitives.length; i3 < il; i3++) {
      const primitive = primitives[i3];
      const cacheKey = createPrimitiveKey(primitive);
      const cached = cache[cacheKey];
      if (cached) {
        pending.push(cached.promise);
      } else {
        let geometryPromise;
        if (primitive.extensions && primitive.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]) {
          geometryPromise = createDracoPrimitive(primitive);
        } else {
          geometryPromise = addPrimitiveAttributes(new BufferGeometry(), primitive, parser);
        }
        cache[cacheKey] = { primitive, promise: geometryPromise };
        pending.push(geometryPromise);
      }
    }
    return Promise.all(pending);
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes
   * @param {number} meshIndex
   * @return {Promise<Group|Mesh|SkinnedMesh>}
   */
  loadMesh(meshIndex) {
    const parser = this;
    const json = this.json;
    const extensions = this.extensions;
    const meshDef = json.meshes[meshIndex];
    const primitives = meshDef.primitives;
    const pending = [];
    for (let i3 = 0, il = primitives.length; i3 < il; i3++) {
      const material2 = primitives[i3].material === void 0 ? createDefaultMaterial(this.cache) : this.getDependency("material", primitives[i3].material);
      pending.push(material2);
    }
    pending.push(parser.loadGeometries(primitives));
    return Promise.all(pending).then(function(results) {
      const materials = results.slice(0, results.length - 1);
      const geometries = results[results.length - 1];
      const meshes = [];
      for (let i3 = 0, il = geometries.length; i3 < il; i3++) {
        const geometry2 = geometries[i3];
        const primitive = primitives[i3];
        let mesh;
        const material2 = materials[i3];
        if (primitive.mode === WEBGL_CONSTANTS2.TRIANGLES || primitive.mode === WEBGL_CONSTANTS2.TRIANGLE_STRIP || primitive.mode === WEBGL_CONSTANTS2.TRIANGLE_FAN || primitive.mode === void 0) {
          mesh = meshDef.isSkinnedMesh === true ? new SkinnedMesh(geometry2, material2) : new Mesh(geometry2, material2);
          if (mesh.isSkinnedMesh === true) {
            mesh.normalizeSkinWeights();
          }
          if (primitive.mode === WEBGL_CONSTANTS2.TRIANGLE_STRIP) {
            mesh.geometry = toTrianglesDrawMode(mesh.geometry, TriangleStripDrawMode);
          } else if (primitive.mode === WEBGL_CONSTANTS2.TRIANGLE_FAN) {
            mesh.geometry = toTrianglesDrawMode(mesh.geometry, TriangleFanDrawMode);
          }
        } else if (primitive.mode === WEBGL_CONSTANTS2.LINES) {
          mesh = new LineSegments(geometry2, material2);
        } else if (primitive.mode === WEBGL_CONSTANTS2.LINE_STRIP) {
          mesh = new Line(geometry2, material2);
        } else if (primitive.mode === WEBGL_CONSTANTS2.LINE_LOOP) {
          mesh = new LineLoop(geometry2, material2);
        } else if (primitive.mode === WEBGL_CONSTANTS2.POINTS) {
          mesh = new Points(geometry2, material2);
        } else {
          throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + primitive.mode);
        }
        if (Object.keys(mesh.geometry.morphAttributes).length > 0) {
          updateMorphTargets(mesh, meshDef);
        }
        mesh.name = parser.createUniqueName(meshDef.name || "mesh_" + meshIndex);
        assignExtrasToUserData(mesh, meshDef);
        if (primitive.extensions)
          addUnknownExtensionsToUserData(extensions, mesh, primitive);
        parser.assignFinalMaterial(mesh);
        meshes.push(mesh);
      }
      for (let i3 = 0, il = meshes.length; i3 < il; i3++) {
        parser.associations.set(meshes[i3], {
          meshes: meshIndex,
          primitives: i3
        });
      }
      if (meshes.length === 1) {
        if (meshDef.extensions)
          addUnknownExtensionsToUserData(extensions, meshes[0], meshDef);
        return meshes[0];
      }
      const group = new Group();
      if (meshDef.extensions)
        addUnknownExtensionsToUserData(extensions, group, meshDef);
      parser.associations.set(group, { meshes: meshIndex });
      for (let i3 = 0, il = meshes.length; i3 < il; i3++) {
        group.add(meshes[i3]);
      }
      return group;
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras
   * @param {number} cameraIndex
   * @return {Promise<THREE.Camera>}
   */
  loadCamera(cameraIndex) {
    let camera;
    const cameraDef = this.json.cameras[cameraIndex];
    const params = cameraDef[cameraDef.type];
    if (!params) {
      console.warn("THREE.GLTFLoader: Missing camera parameters.");
      return;
    }
    if (cameraDef.type === "perspective") {
      camera = new PerspectiveCamera(
        MathUtils.radToDeg(params.yfov),
        params.aspectRatio || 1,
        params.znear || 1,
        params.zfar || 2e6
      );
    } else if (cameraDef.type === "orthographic") {
      camera = new OrthographicCamera(-params.xmag, params.xmag, params.ymag, -params.ymag, params.znear, params.zfar);
    }
    if (cameraDef.name)
      camera.name = this.createUniqueName(cameraDef.name);
    assignExtrasToUserData(camera, cameraDef);
    return Promise.resolve(camera);
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins
   * @param {number} skinIndex
   * @return {Promise<Skeleton>}
   */
  loadSkin(skinIndex) {
    const skinDef = this.json.skins[skinIndex];
    const pending = [];
    for (let i3 = 0, il = skinDef.joints.length; i3 < il; i3++) {
      pending.push(this._loadNodeShallow(skinDef.joints[i3]));
    }
    if (skinDef.inverseBindMatrices !== void 0) {
      pending.push(this.getDependency("accessor", skinDef.inverseBindMatrices));
    } else {
      pending.push(null);
    }
    return Promise.all(pending).then(function(results) {
      const inverseBindMatrices = results.pop();
      const jointNodes = results;
      const bones = [];
      const boneInverses = [];
      for (let i3 = 0, il = jointNodes.length; i3 < il; i3++) {
        const jointNode = jointNodes[i3];
        if (jointNode) {
          bones.push(jointNode);
          const mat = new Matrix4();
          if (inverseBindMatrices !== null) {
            mat.fromArray(inverseBindMatrices.array, i3 * 16);
          }
          boneInverses.push(mat);
        } else {
          console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', skinDef.joints[i3]);
        }
      }
      return new Skeleton(bones, boneInverses);
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations
   * @param {number} animationIndex
   * @return {Promise<AnimationClip>}
   */
  loadAnimation(animationIndex) {
    const json = this.json;
    const animationDef = json.animations[animationIndex];
    const animationName = animationDef.name ? animationDef.name : "animation_" + animationIndex;
    const pendingNodes = [];
    const pendingInputAccessors = [];
    const pendingOutputAccessors = [];
    const pendingSamplers = [];
    const pendingTargets = [];
    for (let i3 = 0, il = animationDef.channels.length; i3 < il; i3++) {
      const channel = animationDef.channels[i3];
      const sampler = animationDef.samplers[channel.sampler];
      const target = channel.target;
      const name = target.node;
      const input = animationDef.parameters !== void 0 ? animationDef.parameters[sampler.input] : sampler.input;
      const output = animationDef.parameters !== void 0 ? animationDef.parameters[sampler.output] : sampler.output;
      if (target.node === void 0)
        continue;
      pendingNodes.push(this.getDependency("node", name));
      pendingInputAccessors.push(this.getDependency("accessor", input));
      pendingOutputAccessors.push(this.getDependency("accessor", output));
      pendingSamplers.push(sampler);
      pendingTargets.push(target);
    }
    return Promise.all([
      Promise.all(pendingNodes),
      Promise.all(pendingInputAccessors),
      Promise.all(pendingOutputAccessors),
      Promise.all(pendingSamplers),
      Promise.all(pendingTargets)
    ]).then(function(dependencies) {
      const nodes = dependencies[0];
      const inputAccessors = dependencies[1];
      const outputAccessors = dependencies[2];
      const samplers = dependencies[3];
      const targets = dependencies[4];
      const tracks = [];
      for (let i3 = 0, il = nodes.length; i3 < il; i3++) {
        const node = nodes[i3];
        const inputAccessor = inputAccessors[i3];
        const outputAccessor = outputAccessors[i3];
        const sampler = samplers[i3];
        const target = targets[i3];
        if (node === void 0)
          continue;
        node.updateMatrix();
        let TypedKeyframeTrack;
        switch (PATH_PROPERTIES2[target.path]) {
          case PATH_PROPERTIES2.weights:
            TypedKeyframeTrack = NumberKeyframeTrack;
            break;
          case PATH_PROPERTIES2.rotation:
            TypedKeyframeTrack = QuaternionKeyframeTrack;
            break;
          case PATH_PROPERTIES2.position:
          case PATH_PROPERTIES2.scale:
          default:
            TypedKeyframeTrack = VectorKeyframeTrack;
            break;
        }
        const targetName = node.name ? node.name : node.uuid;
        const interpolation = sampler.interpolation !== void 0 ? INTERPOLATION[sampler.interpolation] : InterpolateLinear;
        const targetNames = [];
        if (PATH_PROPERTIES2[target.path] === PATH_PROPERTIES2.weights) {
          node.traverse(function(object) {
            if (object.morphTargetInfluences) {
              targetNames.push(object.name ? object.name : object.uuid);
            }
          });
        } else {
          targetNames.push(targetName);
        }
        let outputArray = outputAccessor.array;
        if (outputAccessor.normalized) {
          const scale = getNormalizedComponentScale(outputArray.constructor);
          const scaled = new Float32Array(outputArray.length);
          for (let j = 0, jl = outputArray.length; j < jl; j++) {
            scaled[j] = outputArray[j] * scale;
          }
          outputArray = scaled;
        }
        for (let j = 0, jl = targetNames.length; j < jl; j++) {
          const track = new TypedKeyframeTrack(
            targetNames[j] + "." + PATH_PROPERTIES2[target.path],
            inputAccessor.array,
            outputArray,
            interpolation
          );
          if (sampler.interpolation === "CUBICSPLINE") {
            track.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline(result) {
              const interpolantType = this instanceof QuaternionKeyframeTrack ? GLTFCubicSplineQuaternionInterpolant : GLTFCubicSplineInterpolant;
              return new interpolantType(this.times, this.values, this.getValueSize() / 3, result);
            };
            track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;
          }
          tracks.push(track);
        }
      }
      return new AnimationClip(animationName, void 0, tracks);
    });
  }
  createNodeMesh(nodeIndex) {
    const json = this.json;
    const parser = this;
    const nodeDef = json.nodes[nodeIndex];
    if (nodeDef.mesh === void 0)
      return null;
    return parser.getDependency("mesh", nodeDef.mesh).then(function(mesh) {
      const node = parser._getNodeRef(parser.meshCache, nodeDef.mesh, mesh);
      if (nodeDef.weights !== void 0) {
        node.traverse(function(o) {
          if (!o.isMesh)
            return;
          for (let i3 = 0, il = nodeDef.weights.length; i3 < il; i3++) {
            o.morphTargetInfluences[i3] = nodeDef.weights[i3];
          }
        });
      }
      return node;
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy
   * @param {number} nodeIndex
   * @return {Promise<Object3D>}
   */
  loadNode(nodeIndex) {
    const json = this.json;
    const parser = this;
    const nodeDef = json.nodes[nodeIndex];
    const nodePending = parser._loadNodeShallow(nodeIndex);
    const childPending = [];
    const childrenDef = nodeDef.children || [];
    for (let i3 = 0, il = childrenDef.length; i3 < il; i3++) {
      childPending.push(parser.getDependency("node", childrenDef[i3]));
    }
    const skeletonPending = nodeDef.skin === void 0 ? Promise.resolve(null) : parser.getDependency("skin", nodeDef.skin);
    return Promise.all([nodePending, Promise.all(childPending), skeletonPending]).then(function(results) {
      const node = results[0];
      const children = results[1];
      const skeleton = results[2];
      if (skeleton !== null) {
        node.traverse(function(mesh) {
          if (!mesh.isSkinnedMesh)
            return;
          mesh.bind(skeleton, _identityMatrix);
        });
      }
      for (let i3 = 0, il = children.length; i3 < il; i3++) {
        node.add(children[i3]);
      }
      return node;
    });
  }
  // ._loadNodeShallow() parses a single node.
  // skin and child nodes are created and added in .loadNode() (no '_' prefix).
  _loadNodeShallow(nodeIndex) {
    const json = this.json;
    const extensions = this.extensions;
    const parser = this;
    if (this.nodeCache[nodeIndex] !== void 0) {
      return this.nodeCache[nodeIndex];
    }
    const nodeDef = json.nodes[nodeIndex];
    const nodeName = nodeDef.name ? parser.createUniqueName(nodeDef.name) : "";
    const pending = [];
    const meshPromise = parser._invokeOne(function(ext) {
      return ext.createNodeMesh && ext.createNodeMesh(nodeIndex);
    });
    if (meshPromise) {
      pending.push(meshPromise);
    }
    if (nodeDef.camera !== void 0) {
      pending.push(
        parser.getDependency("camera", nodeDef.camera).then(function(camera) {
          return parser._getNodeRef(parser.cameraCache, nodeDef.camera, camera);
        })
      );
    }
    parser._invokeAll(function(ext) {
      return ext.createNodeAttachment && ext.createNodeAttachment(nodeIndex);
    }).forEach(function(promise) {
      pending.push(promise);
    });
    this.nodeCache[nodeIndex] = Promise.all(pending).then(function(objects) {
      let node;
      if (nodeDef.isBone === true) {
        node = new Bone();
      } else if (objects.length > 1) {
        node = new Group();
      } else if (objects.length === 1) {
        node = objects[0];
      } else {
        node = new Object3D();
      }
      if (node !== objects[0]) {
        for (let i3 = 0, il = objects.length; i3 < il; i3++) {
          node.add(objects[i3]);
        }
      }
      if (nodeDef.name) {
        node.userData.name = nodeDef.name;
        node.name = nodeName;
      }
      assignExtrasToUserData(node, nodeDef);
      if (nodeDef.extensions)
        addUnknownExtensionsToUserData(extensions, node, nodeDef);
      if (nodeDef.matrix !== void 0) {
        const matrix3 = new Matrix4();
        matrix3.fromArray(nodeDef.matrix);
        node.applyMatrix4(matrix3);
      } else {
        if (nodeDef.translation !== void 0) {
          node.position.fromArray(nodeDef.translation);
        }
        if (nodeDef.rotation !== void 0) {
          node.quaternion.fromArray(nodeDef.rotation);
        }
        if (nodeDef.scale !== void 0) {
          node.scale.fromArray(nodeDef.scale);
        }
      }
      if (!parser.associations.has(node)) {
        parser.associations.set(node, {});
      }
      parser.associations.get(node).nodes = nodeIndex;
      return node;
    });
    return this.nodeCache[nodeIndex];
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes
   * @param {number} sceneIndex
   * @return {Promise<Group>}
   */
  loadScene(sceneIndex) {
    const extensions = this.extensions;
    const sceneDef = this.json.scenes[sceneIndex];
    const parser = this;
    const scene = new Group();
    if (sceneDef.name)
      scene.name = parser.createUniqueName(sceneDef.name);
    assignExtrasToUserData(scene, sceneDef);
    if (sceneDef.extensions)
      addUnknownExtensionsToUserData(extensions, scene, sceneDef);
    const nodeIds = sceneDef.nodes || [];
    const pending = [];
    for (let i3 = 0, il = nodeIds.length; i3 < il; i3++) {
      pending.push(parser.getDependency("node", nodeIds[i3]));
    }
    return Promise.all(pending).then(function(nodes) {
      for (let i3 = 0, il = nodes.length; i3 < il; i3++) {
        scene.add(nodes[i3]);
      }
      const reduceAssociations = (node) => {
        const reducedAssociations = /* @__PURE__ */ new Map();
        for (const [key, value] of parser.associations) {
          if (key instanceof Material || key instanceof Texture) {
            reducedAssociations.set(key, value);
          }
        }
        node.traverse((node2) => {
          const mappings = parser.associations.get(node2);
          if (mappings != null) {
            reducedAssociations.set(node2, mappings);
          }
        });
        return reducedAssociations;
      };
      parser.associations = reduceAssociations(scene);
      return scene;
    });
  }
};
function computeBounds(geometry2, primitiveDef, parser) {
  const attributes = primitiveDef.attributes;
  const box = new Box3();
  if (attributes.POSITION !== void 0) {
    const accessor = parser.json.accessors[attributes.POSITION];
    const min = accessor.min;
    const max3 = accessor.max;
    if (min !== void 0 && max3 !== void 0) {
      box.set(new Vector3(min[0], min[1], min[2]), new Vector3(max3[0], max3[1], max3[2]));
      if (accessor.normalized) {
        const boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType]);
        box.min.multiplyScalar(boxScale);
        box.max.multiplyScalar(boxScale);
      }
    } else {
      console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
      return;
    }
  } else {
    return;
  }
  const targets = primitiveDef.targets;
  if (targets !== void 0) {
    const maxDisplacement = new Vector3();
    const vector = new Vector3();
    for (let i3 = 0, il = targets.length; i3 < il; i3++) {
      const target = targets[i3];
      if (target.POSITION !== void 0) {
        const accessor = parser.json.accessors[target.POSITION];
        const min = accessor.min;
        const max3 = accessor.max;
        if (min !== void 0 && max3 !== void 0) {
          vector.setX(Math.max(Math.abs(min[0]), Math.abs(max3[0])));
          vector.setY(Math.max(Math.abs(min[1]), Math.abs(max3[1])));
          vector.setZ(Math.max(Math.abs(min[2]), Math.abs(max3[2])));
          if (accessor.normalized) {
            const boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType]);
            vector.multiplyScalar(boxScale);
          }
          maxDisplacement.max(vector);
        } else {
          console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
        }
      }
    }
    box.expandByVector(maxDisplacement);
  }
  geometry2.boundingBox = box;
  const sphere = new Sphere();
  box.getCenter(sphere.center);
  sphere.radius = box.min.distanceTo(box.max) / 2;
  geometry2.boundingSphere = sphere;
}
function addPrimitiveAttributes(geometry2, primitiveDef, parser) {
  const attributes = primitiveDef.attributes;
  const pending = [];
  function assignAttributeAccessor(accessorIndex, attributeName) {
    return parser.getDependency("accessor", accessorIndex).then(function(accessor) {
      geometry2.setAttribute(attributeName, accessor);
    });
  }
  for (const gltfAttributeName in attributes) {
    const threeAttributeName = ATTRIBUTES[gltfAttributeName] || gltfAttributeName.toLowerCase();
    if (threeAttributeName in geometry2.attributes)
      continue;
    pending.push(assignAttributeAccessor(attributes[gltfAttributeName], threeAttributeName));
  }
  if (primitiveDef.indices !== void 0 && !geometry2.index) {
    const accessor = parser.getDependency("accessor", primitiveDef.indices).then(function(accessor2) {
      geometry2.setIndex(accessor2);
    });
    pending.push(accessor);
  }
  assignExtrasToUserData(geometry2, primitiveDef);
  computeBounds(geometry2, primitiveDef, parser);
  return Promise.all(pending).then(function() {
    return primitiveDef.targets !== void 0 ? addMorphTargets(geometry2, primitiveDef.targets, parser) : geometry2;
  });
}

// node_modules/three-stdlib/webxr/OculusHandPointerModel.js
var YAXIS = new Vector3(0, 1, 0);
var ZAXIS = new Vector3(0, 0, 1);

// node_modules/three-stdlib/webxr/VRButton.js
var __defProp20 = Object.defineProperty;
var __defNormalProp20 = (obj, key, value) => key in obj ? __defProp20(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField21 = (obj, key, value) => {
  __defNormalProp20(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var _VRButton = class {
  static createButton(renderer, sessionInit = {}) {
    const button = document.createElement("button");
    function showEnterVR() {
      let currentSession = null;
      async function onSessionStarted(session) {
        session.addEventListener("end", onSessionEnded);
        await renderer.xr.setSession(session);
        button.textContent = "EXIT VR";
        currentSession = session;
      }
      function onSessionEnded() {
        currentSession.removeEventListener("end", onSessionEnded);
        button.textContent = "ENTER VR";
        currentSession = null;
      }
      button.style.display = "";
      button.style.cursor = "pointer";
      button.style.left = "calc(50% - 50px)";
      button.style.width = "100px";
      button.textContent = "ENTER VR";
      button.onmouseenter = () => {
        button.style.opacity = "1.0";
      };
      button.onmouseleave = () => {
        button.style.opacity = "0.5";
      };
      button.onclick = () => {
        var _a4;
        if (currentSession === null) {
          const optionalFeatures = [sessionInit.optionalFeatures, "local-floor", "bounded-floor", "hand-tracking"].flat().filter(Boolean);
          (_a4 = navigator.xr) == null ? void 0 : _a4.requestSession("immersive-vr", { ...sessionInit, optionalFeatures }).then(onSessionStarted);
        } else {
          currentSession.end();
        }
      };
    }
    function disableButton() {
      button.style.display = "";
      button.style.cursor = "auto";
      button.style.left = "calc(50% - 75px)";
      button.style.width = "150px";
      button.onmouseenter = null;
      button.onmouseleave = null;
      button.onclick = null;
    }
    function showWebXRNotFound() {
      disableButton();
      button.textContent = "VR NOT SUPPORTED";
    }
    function stylizeElement(element) {
      element.style.position = "absolute";
      element.style.bottom = "20px";
      element.style.padding = "12px 6px";
      element.style.border = "1px solid #fff";
      element.style.borderRadius = "4px";
      element.style.background = "rgba(0,0,0,0.1)";
      element.style.color = "#fff";
      element.style.font = "normal 13px sans-serif";
      element.style.textAlign = "center";
      element.style.opacity = "0.5";
      element.style.outline = "none";
      element.style.zIndex = "999";
    }
    if ("xr" in navigator) {
      stylizeElement(button);
      button.id = "VRButton";
      button.style.display = "none";
      navigator.xr.isSessionSupported("immersive-vr").then((supported) => {
        supported ? showEnterVR() : showWebXRNotFound();
        if (supported && _VRButton.xrSessionIsGranted) {
          button.click();
        }
      });
      return button;
    } else {
      const message = document.createElement("a");
      if (window.isSecureContext === false) {
        message.href = document.location.href.replace(/^http:/, "https:");
        message.innerHTML = "WEBXR NEEDS HTTPS";
      } else {
        message.href = "https://immersiveweb.dev/";
        message.innerHTML = "WEBXR NOT AVAILABLE";
      }
      message.style.left = "calc(50% - 90px)";
      message.style.width = "180px";
      message.style.textDecoration = "none";
      stylizeElement(message);
      return message;
    }
  }
  static registerSessionGrantedListener() {
    if ("xr" in navigator) {
      ;
      navigator.xr.addEventListener("sessiongranted", () => {
        _VRButton.xrSessionIsGranted = true;
      });
    }
  }
};
var VRButton = _VRButton;
__publicField21(VRButton, "xrSessionIsGranted", false);

// node_modules/three-stdlib/libs/MotionControllers.js
var MotionControllerConstants = {
  Handedness: {
    NONE: "none",
    LEFT: "left",
    RIGHT: "right"
  },
  ComponentState: {
    DEFAULT: "default",
    TOUCHED: "touched",
    PRESSED: "pressed"
  },
  ComponentProperty: {
    BUTTON: "button",
    X_AXIS: "xAxis",
    Y_AXIS: "yAxis",
    STATE: "state"
  },
  ComponentType: {
    TRIGGER: "trigger",
    SQUEEZE: "squeeze",
    TOUCHPAD: "touchpad",
    THUMBSTICK: "thumbstick",
    BUTTON: "button"
  },
  ButtonTouchThreshold: 0.05,
  AxisTouchThreshold: 0.1,
  VisualResponseProperty: {
    TRANSFORM: "transform",
    VISIBILITY: "visibility"
  }
};
var defaultComponentValues = {
  xAxis: 0,
  yAxis: 0,
  button: 0,
  state: MotionControllerConstants.ComponentState.DEFAULT
};

// node_modules/three-stdlib/webxr/XRHandPrimitiveModel.js
var _matrix4 = new Matrix4();
var _vector4 = new Vector3();

// node_modules/three-stdlib/geometries/RoundedBoxGeometry.js
var tempNormal = new Vector3();

// node_modules/three-stdlib/geometries/DecalGeometry.js
var DecalGeometry = class extends BufferGeometry {
  constructor(mesh, position, orientation, size2) {
    super();
    const vertices = [];
    const normals = [];
    const uvs = [];
    const plane = new Vector3();
    const projectorMatrix = new Matrix4();
    projectorMatrix.makeRotationFromEuler(orientation);
    projectorMatrix.setPosition(position);
    const projectorMatrixInverse = new Matrix4();
    projectorMatrixInverse.copy(projectorMatrix).invert();
    generate();
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
    function generate() {
      let i3;
      let decalVertices = [];
      const vertex = new Vector3();
      const normal = new Vector3();
      if (mesh.geometry.isGeometry === true) {
        console.error("THREE.DecalGeometry no longer supports THREE.Geometry. Use BufferGeometry instead.");
        return;
      }
      const geometry2 = mesh.geometry;
      const positionAttribute = geometry2.attributes.position;
      const normalAttribute = geometry2.attributes.normal;
      if (geometry2.index !== null) {
        const index = geometry2.index;
        for (i3 = 0; i3 < index.count; i3++) {
          vertex.fromBufferAttribute(positionAttribute, index.getX(i3));
          normal.fromBufferAttribute(normalAttribute, index.getX(i3));
          pushDecalVertex(decalVertices, vertex, normal);
        }
      } else {
        for (i3 = 0; i3 < positionAttribute.count; i3++) {
          vertex.fromBufferAttribute(positionAttribute, i3);
          normal.fromBufferAttribute(normalAttribute, i3);
          pushDecalVertex(decalVertices, vertex, normal);
        }
      }
      decalVertices = clipGeometry(decalVertices, plane.set(1, 0, 0));
      decalVertices = clipGeometry(decalVertices, plane.set(-1, 0, 0));
      decalVertices = clipGeometry(decalVertices, plane.set(0, 1, 0));
      decalVertices = clipGeometry(decalVertices, plane.set(0, -1, 0));
      decalVertices = clipGeometry(decalVertices, plane.set(0, 0, 1));
      decalVertices = clipGeometry(decalVertices, plane.set(0, 0, -1));
      for (i3 = 0; i3 < decalVertices.length; i3++) {
        const decalVertex = decalVertices[i3];
        uvs.push(0.5 + decalVertex.position.x / size2.x, 0.5 + decalVertex.position.y / size2.y);
        decalVertex.position.applyMatrix4(projectorMatrix);
        vertices.push(decalVertex.position.x, decalVertex.position.y, decalVertex.position.z);
        normals.push(decalVertex.normal.x, decalVertex.normal.y, decalVertex.normal.z);
      }
    }
    function pushDecalVertex(decalVertices, vertex, normal) {
      vertex.applyMatrix4(mesh.matrixWorld);
      vertex.applyMatrix4(projectorMatrixInverse);
      normal.transformDirection(mesh.matrixWorld);
      decalVertices.push(new DecalVertex(vertex.clone(), normal.clone()));
    }
    function clipGeometry(inVertices, plane2) {
      const outVertices = [];
      const s = 0.5 * Math.abs(size2.dot(plane2));
      for (let i3 = 0; i3 < inVertices.length; i3 += 3) {
        let v1Out, v2Out, v3Out, total = 0;
        let nV1, nV2, nV3, nV4;
        const d1 = inVertices[i3 + 0].position.dot(plane2) - s;
        const d2 = inVertices[i3 + 1].position.dot(plane2) - s;
        const d3 = inVertices[i3 + 2].position.dot(plane2) - s;
        v1Out = d1 > 0;
        v2Out = d2 > 0;
        v3Out = d3 > 0;
        total = (v1Out ? 1 : 0) + (v2Out ? 1 : 0) + (v3Out ? 1 : 0);
        switch (total) {
          case 0: {
            outVertices.push(inVertices[i3]);
            outVertices.push(inVertices[i3 + 1]);
            outVertices.push(inVertices[i3 + 2]);
            break;
          }
          case 1: {
            if (v1Out) {
              nV1 = inVertices[i3 + 1];
              nV2 = inVertices[i3 + 2];
              nV3 = clip(inVertices[i3], nV1, plane2, s);
              nV4 = clip(inVertices[i3], nV2, plane2, s);
            }
            if (v2Out) {
              nV1 = inVertices[i3];
              nV2 = inVertices[i3 + 2];
              nV3 = clip(inVertices[i3 + 1], nV1, plane2, s);
              nV4 = clip(inVertices[i3 + 1], nV2, plane2, s);
              outVertices.push(nV3);
              outVertices.push(nV2.clone());
              outVertices.push(nV1.clone());
              outVertices.push(nV2.clone());
              outVertices.push(nV3.clone());
              outVertices.push(nV4);
              break;
            }
            if (v3Out) {
              nV1 = inVertices[i3];
              nV2 = inVertices[i3 + 1];
              nV3 = clip(inVertices[i3 + 2], nV1, plane2, s);
              nV4 = clip(inVertices[i3 + 2], nV2, plane2, s);
            }
            outVertices.push(nV1.clone());
            outVertices.push(nV2.clone());
            outVertices.push(nV3);
            outVertices.push(nV4);
            outVertices.push(nV3.clone());
            outVertices.push(nV2.clone());
            break;
          }
          case 2: {
            if (!v1Out) {
              nV1 = inVertices[i3].clone();
              nV2 = clip(nV1, inVertices[i3 + 1], plane2, s);
              nV3 = clip(nV1, inVertices[i3 + 2], plane2, s);
              outVertices.push(nV1);
              outVertices.push(nV2);
              outVertices.push(nV3);
            }
            if (!v2Out) {
              nV1 = inVertices[i3 + 1].clone();
              nV2 = clip(nV1, inVertices[i3 + 2], plane2, s);
              nV3 = clip(nV1, inVertices[i3], plane2, s);
              outVertices.push(nV1);
              outVertices.push(nV2);
              outVertices.push(nV3);
            }
            if (!v3Out) {
              nV1 = inVertices[i3 + 2].clone();
              nV2 = clip(nV1, inVertices[i3], plane2, s);
              nV3 = clip(nV1, inVertices[i3 + 1], plane2, s);
              outVertices.push(nV1);
              outVertices.push(nV2);
              outVertices.push(nV3);
            }
            break;
          }
          case 3: {
            break;
          }
        }
      }
      return outVertices;
    }
    function clip(v02, v14, p, s) {
      const d0 = v02.position.dot(p) - s;
      const d1 = v14.position.dot(p) - s;
      const s0 = d0 / (d0 - d1);
      const v = new DecalVertex(
        new Vector3(
          v02.position.x + s0 * (v14.position.x - v02.position.x),
          v02.position.y + s0 * (v14.position.y - v02.position.y),
          v02.position.z + s0 * (v14.position.z - v02.position.z)
        ),
        new Vector3(
          v02.normal.x + s0 * (v14.normal.x - v02.normal.x),
          v02.normal.y + s0 * (v14.normal.y - v02.normal.y),
          v02.normal.z + s0 * (v14.normal.z - v02.normal.z)
        )
      );
      return v;
    }
  }
};
var DecalVertex = class {
  constructor(position, normal) {
    this.position = position;
    this.normal = normal;
  }
  clone() {
    return new this.constructor(this.position.clone(), this.normal.clone());
  }
};

// node_modules/three-stdlib/geometries/TextGeometry.js
var TextGeometry = class extends ExtrudeGeometry {
  constructor(text, parameters = {}) {
    const {
      bevelEnabled = false,
      bevelSize = 8,
      bevelThickness = 10,
      font,
      height = 50,
      size: size2 = 100,
      lineHeight = 1,
      letterSpacing = 0,
      ...rest
    } = parameters;
    if (font === void 0) {
      super();
    } else {
      const shapes = font.generateShapes(text, size2, { lineHeight, letterSpacing });
      super(shapes, { ...rest, bevelEnabled, bevelSize, bevelThickness, depth: height });
    }
    this.type = "TextGeometry";
  }
};

// node_modules/three-stdlib/csm/CSMFrustum.js
var inverseProjectionMatrix = new Matrix4();
var CSMFrustum = class {
  constructor(data) {
    data = data || {};
    this.vertices = {
      near: [new Vector3(), new Vector3(), new Vector3(), new Vector3()],
      far: [new Vector3(), new Vector3(), new Vector3(), new Vector3()]
    };
    if (data.projectionMatrix !== void 0) {
      this.setFromProjectionMatrix(data.projectionMatrix, data.maxFar || 1e4);
    }
  }
  setFromProjectionMatrix(projectionMatrix, maxFar) {
    const isOrthographic = projectionMatrix.elements[2 * 4 + 3] === 0;
    inverseProjectionMatrix.copy(projectionMatrix).invert();
    this.vertices.near[0].set(1, 1, -1);
    this.vertices.near[1].set(1, -1, -1);
    this.vertices.near[2].set(-1, -1, -1);
    this.vertices.near[3].set(-1, 1, -1);
    this.vertices.near.forEach(function(v) {
      v.applyMatrix4(inverseProjectionMatrix);
    });
    this.vertices.far[0].set(1, 1, 1);
    this.vertices.far[1].set(1, -1, 1);
    this.vertices.far[2].set(-1, -1, 1);
    this.vertices.far[3].set(-1, 1, 1);
    this.vertices.far.forEach(function(v) {
      v.applyMatrix4(inverseProjectionMatrix);
      const absZ = Math.abs(v.z);
      if (isOrthographic) {
        v.z *= Math.min(maxFar / absZ, 1);
      } else {
        v.multiplyScalar(Math.min(maxFar / absZ, 1));
      }
    });
    return this.vertices;
  }
  split(breaks, target) {
    while (breaks.length > target.length) {
      target.push(new CSMFrustum());
    }
    target.length = breaks.length;
    for (let i3 = 0; i3 < breaks.length; i3++) {
      const cascade = target[i3];
      if (i3 === 0) {
        for (let j = 0; j < 4; j++) {
          cascade.vertices.near[j].copy(this.vertices.near[j]);
        }
      } else {
        for (let j = 0; j < 4; j++) {
          cascade.vertices.near[j].lerpVectors(this.vertices.near[j], this.vertices.far[j], breaks[i3 - 1]);
        }
      }
      if (i3 === breaks.length - 1) {
        for (let j = 0; j < 4; j++) {
          cascade.vertices.far[j].copy(this.vertices.far[j]);
        }
      } else {
        for (let j = 0; j < 4; j++) {
          cascade.vertices.far[j].lerpVectors(this.vertices.near[j], this.vertices.far[j], breaks[i3]);
        }
      }
    }
  }
  toSpace(cameraMatrix, target) {
    for (let i3 = 0; i3 < 4; i3++) {
      target.vertices.near[i3].copy(this.vertices.near[i3]).applyMatrix4(cameraMatrix);
      target.vertices.far[i3].copy(this.vertices.far[i3]).applyMatrix4(cameraMatrix);
    }
  }
};

// node_modules/three-stdlib/csm/CSM.js
var _cameraToLightMatrix = new Matrix4();
var _lightSpaceFrustum = new CSMFrustum();
var _center = new Vector3();
var _bbox = new Box3();

// node_modules/three-stdlib/shaders/ACESFilmicToneMappingShader.js
var ACESFilmicToneMappingShader = {
  uniforms: {
    tDiffuse: { value: null },
    exposure: { value: 1 }
  },
  vertexShader: [
    "varying vec2 vUv;",
    "void main() {",
    "	vUv = uv;",
    "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
    "}"
  ].join("\n"),
  fragmentShader: [
    "#define saturate(a) clamp( a, 0.0, 1.0 )",
    "uniform sampler2D tDiffuse;",
    "uniform float exposure;",
    "varying vec2 vUv;",
    "vec3 RRTAndODTFit( vec3 v ) {",
    "	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;",
    "	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;",
    "	return a / b;",
    "}",
    "vec3 ACESFilmicToneMapping( vec3 color ) {",
    // sRGB => XYZ => D65_2_D60 => AP1 => RRT_SAT
    "	const mat3 ACESInputMat = mat3(",
    "		vec3( 0.59719, 0.07600, 0.02840 ),",
    // transposed from source
    "		vec3( 0.35458, 0.90834, 0.13383 ),",
    "		vec3( 0.04823, 0.01566, 0.83777 )",
    "	);",
    // ODT_SAT => XYZ => D60_2_D65 => sRGB
    "	const mat3 ACESOutputMat = mat3(",
    "		vec3(  1.60475, -0.10208, -0.00327 ),",
    // transposed from source
    "		vec3( -0.53108,  1.10813, -0.07276 ),",
    "		vec3( -0.07367, -0.00605,  1.07602 )",
    "	);",
    "	color = ACESInputMat * color;",
    // Apply RRT and ODT
    "	color = RRTAndODTFit( color );",
    "	color = ACESOutputMat * color;",
    // Clamp to [0, 1]
    "	return saturate( color );",
    "}",
    "void main() {",
    "	vec4 tex = texture2D( tDiffuse, vUv );",
    "	tex.rgb *= exposure / 0.6;",
    // pre-exposed, outside of the tone mapping function
    "	gl_FragColor = vec4( ACESFilmicToneMapping( tex.rgb ), tex.a );",
    "}"
  ].join("\n")
};

// node_modules/three-stdlib/shaders/BasicShader.js
var BasicShader = {
  uniforms: {},
  vertexShader: [
    "void main() {",
    "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
    "}"
  ].join("\n"),
  fragmentShader: ["void main() {", "	gl_FragColor = vec4( 1.0, 0.0, 0.0, 0.5 );", "}"].join("\n")
};

// node_modules/three-stdlib/shaders/BleachBypassShader.js
var BleachBypassShader = {
  uniforms: {
    tDiffuse: { value: null },
    opacity: { value: 1 }
  },
  vertexShader: [
    "varying vec2 vUv;",
    "void main() {",
    "	vUv = uv;",
    "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
    "}"
  ].join("\n"),
  fragmentShader: [
    "uniform float opacity;",
    "uniform sampler2D tDiffuse;",
    "varying vec2 vUv;",
    "void main() {",
    "	vec4 base = texture2D( tDiffuse, vUv );",
    "	vec3 lumCoeff = vec3( 0.25, 0.65, 0.1 );",
    "	float lum = dot( lumCoeff, base.rgb );",
    "	vec3 blend = vec3( lum );",
    "	float L = min( 1.0, max( 0.0, 10.0 * ( lum - 0.45 ) ) );",
    "	vec3 result1 = 2.0 * base.rgb * blend;",
    "	vec3 result2 = 1.0 - 2.0 * ( 1.0 - blend ) * ( 1.0 - base.rgb );",
    "	vec3 newColor = mix( result1, result2, L );",
    "	float A2 = opacity * base.a;",
    "	vec3 mixRGB = A2 * newColor.rgb;",
    "	mixRGB += ( ( 1.0 - A2 ) * base.rgb );",
    "	gl_FragColor = vec4( mixRGB, base.a );",
    "}"
  ].join("\n")
};

// node_modules/three-stdlib/shaders/BlendShader.js
var BlendShader = {
  uniforms: {
    tDiffuse1: { value: null },
    tDiffuse2: { value: null },
    mixRatio: { value: 0.5 },
    opacity: { value: 1 }
  },
  vertexShader: [
    "varying vec2 vUv;",
    "void main() {",
    "	vUv = uv;",
    "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
    "}"
  ].join("\n"),
  fragmentShader: [
    "uniform float opacity;",
    "uniform float mixRatio;",
    "uniform sampler2D tDiffuse1;",
    "uniform sampler2D tDiffuse2;",
    "varying vec2 vUv;",
    "void main() {",
    "	vec4 texel1 = texture2D( tDiffuse1, vUv );",
    "	vec4 texel2 = texture2D( tDiffuse2, vUv );",
    "	gl_FragColor = opacity * mix( texel1, texel2, mixRatio );",
    "}"
  ].join("\n")
};

// node_modules/three-stdlib/shaders/BrightnessContrastShader.js
var BrightnessContrastShader = {
  uniforms: {
    tDiffuse: { value: null },
    brightness: { value: 0 },
    contrast: { value: 0 }
  },
  vertexShader: [
    "varying vec2 vUv;",
    "void main() {",
    "	vUv = uv;",
    "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
    "}"
  ].join("\n"),
  fragmentShader: [
    "uniform sampler2D tDiffuse;",
    "uniform float brightness;",
    "uniform float contrast;",
    "varying vec2 vUv;",
    "void main() {",
    "	gl_FragColor = texture2D( tDiffuse, vUv );",
    "	gl_FragColor.rgb += brightness;",
    "	if (contrast > 0.0) {",
    "		gl_FragColor.rgb = (gl_FragColor.rgb - 0.5) / (1.0 - contrast) + 0.5;",
    "	} else {",
    "		gl_FragColor.rgb = (gl_FragColor.rgb - 0.5) * (1.0 + contrast) + 0.5;",
    "	}",
    "}"
  ].join("\n")
};

// node_modules/three-stdlib/shaders/ColorCorrectionShader.js
var ColorCorrectionShader = {
  uniforms: {
    tDiffuse: { value: null },
    powRGB: { value: new Vector3(2, 2, 2) },
    mulRGB: { value: new Vector3(1, 1, 1) },
    addRGB: { value: new Vector3(0, 0, 0) }
  },
  vertexShader: [
    "varying vec2 vUv;",
    "void main() {",
    "	vUv = uv;",
    "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
    "}"
  ].join("\n"),
  fragmentShader: [
    "uniform sampler2D tDiffuse;",
    "uniform vec3 powRGB;",
    "uniform vec3 mulRGB;",
    "uniform vec3 addRGB;",
    "varying vec2 vUv;",
    "void main() {",
    "	gl_FragColor = texture2D( tDiffuse, vUv );",
    "	gl_FragColor.rgb = mulRGB * pow( ( gl_FragColor.rgb + addRGB ), powRGB );",
    "}"
  ].join("\n")
};

// node_modules/three-stdlib/shaders/ColorifyShader.js
var ColorifyShader = {
  uniforms: {
    tDiffuse: { value: null },
    color: { value: new Color(16777215) }
  },
  vertexShader: [
    "varying vec2 vUv;",
    "void main() {",
    "	vUv = uv;",
    "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
    "}"
  ].join("\n"),
  fragmentShader: [
    "uniform vec3 color;",
    "uniform sampler2D tDiffuse;",
    "varying vec2 vUv;",
    "void main() {",
    "	vec4 texel = texture2D( tDiffuse, vUv );",
    "	vec3 luma = vec3( 0.299, 0.587, 0.114 );",
    "	float v = dot( texel.xyz, luma );",
    "	gl_FragColor = vec4( v * color, texel.w );",
    "}"
  ].join("\n")
};

// node_modules/three-stdlib/shaders/DOFMipMapShader.js
var DOFMipMapShader = {
  uniforms: {
    tColor: { value: null },
    tDepth: { value: null },
    focus: { value: 1 },
    maxblur: { value: 1 }
  },
  vertexShader: [
    "varying vec2 vUv;",
    "void main() {",
    "	vUv = uv;",
    "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
    "}"
  ].join("\n"),
  fragmentShader: [
    "uniform float focus;",
    "uniform float maxblur;",
    "uniform sampler2D tColor;",
    "uniform sampler2D tDepth;",
    "varying vec2 vUv;",
    "void main() {",
    "	vec4 depth = texture2D( tDepth, vUv );",
    "	float factor = depth.x - focus;",
    "	vec4 col = texture2D( tColor, vUv, 2.0 * maxblur * abs( focus - depth.x ) );",
    "	gl_FragColor = col;",
    "	gl_FragColor.a = 1.0;",
    "}"
  ].join("\n")
};

// node_modules/three-stdlib/shaders/FXAAShader.js
var FXAAShader = {
  uniforms: {
    tDiffuse: { value: null },
    resolution: { value: new Vector2(1 / 1024, 1 / 512) }
  },
  vertexShader: [
    "varying vec2 vUv;",
    "void main() {",
    "	vUv = uv;",
    "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
    "}"
  ].join("\n"),
  fragmentShader: [
    "precision highp float;",
    "",
    "uniform sampler2D tDiffuse;",
    "",
    "uniform vec2 resolution;",
    "",
    "varying vec2 vUv;",
    "",
    "// FXAA 3.11 implementation by NVIDIA, ported to WebGL by Agost Biro (biro@archilogic.com)",
    "",
    "//----------------------------------------------------------------------------------",
    "// File:        es3-keplerFXAAassetsshaders/FXAA_DefaultES.frag",
    "// SDK Version: v3.00",
    "// Email:       gameworks@nvidia.com",
    "// Site:        http://developer.nvidia.com/",
    "//",
    "// Copyright (c) 2014-2015, NVIDIA CORPORATION. All rights reserved.",
    "//",
    "// Redistribution and use in source and binary forms, with or without",
    "// modification, are permitted provided that the following conditions",
    "// are met:",
    "//  * Redistributions of source code must retain the above copyright",
    "//    notice, this list of conditions and the following disclaimer.",
    "//  * Redistributions in binary form must reproduce the above copyright",
    "//    notice, this list of conditions and the following disclaimer in the",
    "//    documentation and/or other materials provided with the distribution.",
    "//  * Neither the name of NVIDIA CORPORATION nor the names of its",
    "//    contributors may be used to endorse or promote products derived",
    "//    from this software without specific prior written permission.",
    "//",
    "// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ``AS IS'' AND ANY",
    "// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE",
    "// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR",
    "// PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR",
    "// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,",
    "// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,",
    "// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR",
    "// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY",
    "// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT",
    "// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE",
    "// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.",
    "//",
    "//----------------------------------------------------------------------------------",
    "",
    "#define FXAA_PC 1",
    "#define FXAA_GLSL_100 1",
    "#define FXAA_QUALITY_PRESET 12",
    "",
    "#define FXAA_GREEN_AS_LUMA 1",
    "",
    "/*--------------------------------------------------------------------------*/",
    "#ifndef FXAA_PC_CONSOLE",
    "    //",
    "    // The console algorithm for PC is included",
    "    // for developers targeting really low spec machines.",
    "    // Likely better to just run FXAA_PC, and use a really low preset.",
    "    //",
    "    #define FXAA_PC_CONSOLE 0",
    "#endif",
    "/*--------------------------------------------------------------------------*/",
    "#ifndef FXAA_GLSL_120",
    "    #define FXAA_GLSL_120 0",
    "#endif",
    "/*--------------------------------------------------------------------------*/",
    "#ifndef FXAA_GLSL_130",
    "    #define FXAA_GLSL_130 0",
    "#endif",
    "/*--------------------------------------------------------------------------*/",
    "#ifndef FXAA_HLSL_3",
    "    #define FXAA_HLSL_3 0",
    "#endif",
    "/*--------------------------------------------------------------------------*/",
    "#ifndef FXAA_HLSL_4",
    "    #define FXAA_HLSL_4 0",
    "#endif",
    "/*--------------------------------------------------------------------------*/",
    "#ifndef FXAA_HLSL_5",
    "    #define FXAA_HLSL_5 0",
    "#endif",
    "/*==========================================================================*/",
    "#ifndef FXAA_GREEN_AS_LUMA",
    "    //",
    "    // For those using non-linear color,",
    "    // and either not able to get luma in alpha, or not wanting to,",
    "    // this enables FXAA to run using green as a proxy for luma.",
    "    // So with this enabled, no need to pack luma in alpha.",
    "    //",
    "    // This will turn off AA on anything which lacks some amount of green.",
    "    // Pure red and blue or combination of only R and B, will get no AA.",
    "    //",
    "    // Might want to lower the settings for both,",
    "    //    fxaaConsoleEdgeThresholdMin",
    "    //    fxaaQualityEdgeThresholdMin",
    "    // In order to insure AA does not get turned off on colors",
    "    // which contain a minor amount of green.",
    "    //",
    "    // 1 = On.",
    "    // 0 = Off.",
    "    //",
    "    #define FXAA_GREEN_AS_LUMA 0",
    "#endif",
    "/*--------------------------------------------------------------------------*/",
    "#ifndef FXAA_EARLY_EXIT",
    "    //",
    "    // Controls algorithm's early exit path.",
    "    // On PS3 turning this ON adds 2 cycles to the shader.",
    "    // On 360 turning this OFF adds 10ths of a millisecond to the shader.",
    "    // Turning this off on console will result in a more blurry image.",
    "    // So this defaults to on.",
    "    //",
    "    // 1 = On.",
    "    // 0 = Off.",
    "    //",
    "    #define FXAA_EARLY_EXIT 1",
    "#endif",
    "/*--------------------------------------------------------------------------*/",
    "#ifndef FXAA_DISCARD",
    "    //",
    "    // Only valid for PC OpenGL currently.",
    "    // Probably will not work when FXAA_GREEN_AS_LUMA = 1.",
    "    //",
    "    // 1 = Use discard on pixels which don't need AA.",
    "    //     For APIs which enable concurrent TEX+ROP from same surface.",
    "    // 0 = Return unchanged color on pixels which don't need AA.",
    "    //",
    "    #define FXAA_DISCARD 0",
    "#endif",
    "/*--------------------------------------------------------------------------*/",
    "#ifndef FXAA_FAST_PIXEL_OFFSET",
    "    //",
    "    // Used for GLSL 120 only.",
    "    //",
    "    // 1 = GL API supports fast pixel offsets",
    "    // 0 = do not use fast pixel offsets",
    "    //",
    "    #ifdef GL_EXT_gpu_shader4",
    "        #define FXAA_FAST_PIXEL_OFFSET 1",
    "    #endif",
    "    #ifdef GL_NV_gpu_shader5",
    "        #define FXAA_FAST_PIXEL_OFFSET 1",
    "    #endif",
    "    #ifdef GL_ARB_gpu_shader5",
    "        #define FXAA_FAST_PIXEL_OFFSET 1",
    "    #endif",
    "    #ifndef FXAA_FAST_PIXEL_OFFSET",
    "        #define FXAA_FAST_PIXEL_OFFSET 0",
    "    #endif",
    "#endif",
    "/*--------------------------------------------------------------------------*/",
    "#ifndef FXAA_GATHER4_ALPHA",
    "    //",
    "    // 1 = API supports gather4 on alpha channel.",
    "    // 0 = API does not support gather4 on alpha channel.",
    "    //",
    "    #if (FXAA_HLSL_5 == 1)",
    "        #define FXAA_GATHER4_ALPHA 1",
    "    #endif",
    "    #ifdef GL_ARB_gpu_shader5",
    "        #define FXAA_GATHER4_ALPHA 1",
    "    #endif",
    "    #ifdef GL_NV_gpu_shader5",
    "        #define FXAA_GATHER4_ALPHA 1",
    "    #endif",
    "    #ifndef FXAA_GATHER4_ALPHA",
    "        #define FXAA_GATHER4_ALPHA 0",
    "    #endif",
    "#endif",
    "",
    "",
    "/*============================================================================",
    "                        FXAA QUALITY - TUNING KNOBS",
    "------------------------------------------------------------------------------",
    "NOTE the other tuning knobs are now in the shader function inputs!",
    "============================================================================*/",
    "#ifndef FXAA_QUALITY_PRESET",
    "    //",
    "    // Choose the quality preset.",
    "    // This needs to be compiled into the shader as it effects code.",
    "    // Best option to include multiple presets is to",
    "    // in each shader define the preset, then include this file.",
    "    //",
    "    // OPTIONS",
    "    // -----------------------------------------------------------------------",
    "    // 10 to 15 - default medium dither (10=fastest, 15=highest quality)",
    "    // 20 to 29 - less dither, more expensive (20=fastest, 29=highest quality)",
    "    // 39       - no dither, very expensive",
    "    //",
    "    // NOTES",
    "    // -----------------------------------------------------------------------",
    "    // 12 = slightly faster then FXAA 3.9 and higher edge quality (default)",
    "    // 13 = about same speed as FXAA 3.9 and better than 12",
    "    // 23 = closest to FXAA 3.9 visually and performance wise",
    "    //  _ = the lowest digit is directly related to performance",
    "    // _  = the highest digit is directly related to style",
    "    //",
    "    #define FXAA_QUALITY_PRESET 12",
    "#endif",
    "",
    "",
    "/*============================================================================",
    "",
    "                           FXAA QUALITY - PRESETS",
    "",
    "============================================================================*/",
    "",
    "/*============================================================================",
    "                     FXAA QUALITY - MEDIUM DITHER PRESETS",
    "============================================================================*/",
    "#if (FXAA_QUALITY_PRESET == 10)",
    "    #define FXAA_QUALITY_PS 3",
    "    #define FXAA_QUALITY_P0 1.5",
    "    #define FXAA_QUALITY_P1 3.0",
    "    #define FXAA_QUALITY_P2 12.0",
    "#endif",
    "/*--------------------------------------------------------------------------*/",
    "#if (FXAA_QUALITY_PRESET == 11)",
    "    #define FXAA_QUALITY_PS 4",
    "    #define FXAA_QUALITY_P0 1.0",
    "    #define FXAA_QUALITY_P1 1.5",
    "    #define FXAA_QUALITY_P2 3.0",
    "    #define FXAA_QUALITY_P3 12.0",
    "#endif",
    "/*--------------------------------------------------------------------------*/",
    "#if (FXAA_QUALITY_PRESET == 12)",
    "    #define FXAA_QUALITY_PS 5",
    "    #define FXAA_QUALITY_P0 1.0",
    "    #define FXAA_QUALITY_P1 1.5",
    "    #define FXAA_QUALITY_P2 2.0",
    "    #define FXAA_QUALITY_P3 4.0",
    "    #define FXAA_QUALITY_P4 12.0",
    "#endif",
    "/*--------------------------------------------------------------------------*/",
    "#if (FXAA_QUALITY_PRESET == 13)",
    "    #define FXAA_QUALITY_PS 6",
    "    #define FXAA_QUALITY_P0 1.0",
    "    #define FXAA_QUALITY_P1 1.5",
    "    #define FXAA_QUALITY_P2 2.0",
    "    #define FXAA_QUALITY_P3 2.0",
    "    #define FXAA_QUALITY_P4 4.0",
    "    #define FXAA_QUALITY_P5 12.0",
    "#endif",
    "/*--------------------------------------------------------------------------*/",
    "#if (FXAA_QUALITY_PRESET == 14)",
    "    #define FXAA_QUALITY_PS 7",
    "    #define FXAA_QUALITY_P0 1.0",
    "    #define FXAA_QUALITY_P1 1.5",
    "    #define FXAA_QUALITY_P2 2.0",
    "    #define FXAA_QUALITY_P3 2.0",
    "    #define FXAA_QUALITY_P4 2.0",
    "    #define FXAA_QUALITY_P5 4.0",
    "    #define FXAA_QUALITY_P6 12.0",
    "#endif",
    "/*--------------------------------------------------------------------------*/",
    "#if (FXAA_QUALITY_PRESET == 15)",
    "    #define FXAA_QUALITY_PS 8",
    "    #define FXAA_QUALITY_P0 1.0",
    "    #define FXAA_QUALITY_P1 1.5",
    "    #define FXAA_QUALITY_P2 2.0",
    "    #define FXAA_QUALITY_P3 2.0",
    "    #define FXAA_QUALITY_P4 2.0",
    "    #define FXAA_QUALITY_P5 2.0",
    "    #define FXAA_QUALITY_P6 4.0",
    "    #define FXAA_QUALITY_P7 12.0",
    "#endif",
    "",
    "/*============================================================================",
    "                     FXAA QUALITY - LOW DITHER PRESETS",
    "============================================================================*/",
    "#if (FXAA_QUALITY_PRESET == 20)",
    "    #define FXAA_QUALITY_PS 3",
    "    #define FXAA_QUALITY_P0 1.5",
    "    #define FXAA_QUALITY_P1 2.0",
    "    #define FXAA_QUALITY_P2 8.0",
    "#endif",
    "/*--------------------------------------------------------------------------*/",
    "#if (FXAA_QUALITY_PRESET == 21)",
    "    #define FXAA_QUALITY_PS 4",
    "    #define FXAA_QUALITY_P0 1.0",
    "    #define FXAA_QUALITY_P1 1.5",
    "    #define FXAA_QUALITY_P2 2.0",
    "    #define FXAA_QUALITY_P3 8.0",
    "#endif",
    "/*--------------------------------------------------------------------------*/",
    "#if (FXAA_QUALITY_PRESET == 22)",
    "    #define FXAA_QUALITY_PS 5",
    "    #define FXAA_QUALITY_P0 1.0",
    "    #define FXAA_QUALITY_P1 1.5",
    "    #define FXAA_QUALITY_P2 2.0",
    "    #define FXAA_QUALITY_P3 2.0",
    "    #define FXAA_QUALITY_P4 8.0",
    "#endif",
    "/*--------------------------------------------------------------------------*/",
    "#if (FXAA_QUALITY_PRESET == 23)",
    "    #define FXAA_QUALITY_PS 6",
    "    #define FXAA_QUALITY_P0 1.0",
    "    #define FXAA_QUALITY_P1 1.5",
    "    #define FXAA_QUALITY_P2 2.0",
    "    #define FXAA_QUALITY_P3 2.0",
    "    #define FXAA_QUALITY_P4 2.0",
    "    #define FXAA_QUALITY_P5 8.0",
    "#endif",
    "/*--------------------------------------------------------------------------*/",
    "#if (FXAA_QUALITY_PRESET == 24)",
    "    #define FXAA_QUALITY_PS 7",
    "    #define FXAA_QUALITY_P0 1.0",
    "    #define FXAA_QUALITY_P1 1.5",
    "    #define FXAA_QUALITY_P2 2.0",
    "    #define FXAA_QUALITY_P3 2.0",
    "    #define FXAA_QUALITY_P4 2.0",
    "    #define FXAA_QUALITY_P5 3.0",
    "    #define FXAA_QUALITY_P6 8.0",
    "#endif",
    "/*--------------------------------------------------------------------------*/",
    "#if (FXAA_QUALITY_PRESET == 25)",
    "    #define FXAA_QUALITY_PS 8",
    "    #define FXAA_QUALITY_P0 1.0",
    "    #define FXAA_QUALITY_P1 1.5",
    "    #define FXAA_QUALITY_P2 2.0",
    "    #define FXAA_QUALITY_P3 2.0",
    "    #define FXAA_QUALITY_P4 2.0",
    "    #define FXAA_QUALITY_P5 2.0",
    "    #define FXAA_QUALITY_P6 4.0",
    "    #define FXAA_QUALITY_P7 8.0",
    "#endif",
    "/*--------------------------------------------------------------------------*/",
    "#if (FXAA_QUALITY_PRESET == 26)",
    "    #define FXAA_QUALITY_PS 9",
    "    #define FXAA_QUALITY_P0 1.0",
    "    #define FXAA_QUALITY_P1 1.5",
    "    #define FXAA_QUALITY_P2 2.0",
    "    #define FXAA_QUALITY_P3 2.0",
    "    #define FXAA_QUALITY_P4 2.0",
    "    #define FXAA_QUALITY_P5 2.0",
    "    #define FXAA_QUALITY_P6 2.0",
    "    #define FXAA_QUALITY_P7 4.0",
    "    #define FXAA_QUALITY_P8 8.0",
    "#endif",
    "/*--------------------------------------------------------------------------*/",
    "#if (FXAA_QUALITY_PRESET == 27)",
    "    #define FXAA_QUALITY_PS 10",
    "    #define FXAA_QUALITY_P0 1.0",
    "    #define FXAA_QUALITY_P1 1.5",
    "    #define FXAA_QUALITY_P2 2.0",
    "    #define FXAA_QUALITY_P3 2.0",
    "    #define FXAA_QUALITY_P4 2.0",
    "    #define FXAA_QUALITY_P5 2.0",
    "    #define FXAA_QUALITY_P6 2.0",
    "    #define FXAA_QUALITY_P7 2.0",
    "    #define FXAA_QUALITY_P8 4.0",
    "    #define FXAA_QUALITY_P9 8.0",
    "#endif",
    "/*--------------------------------------------------------------------------*/",
    "#if (FXAA_QUALITY_PRESET == 28)",
    "    #define FXAA_QUALITY_PS 11",
    "    #define FXAA_QUALITY_P0 1.0",
    "    #define FXAA_QUALITY_P1 1.5",
    "    #define FXAA_QUALITY_P2 2.0",
    "    #define FXAA_QUALITY_P3 2.0",
    "    #define FXAA_QUALITY_P4 2.0",
    "    #define FXAA_QUALITY_P5 2.0",
    "    #define FXAA_QUALITY_P6 2.0",
    "    #define FXAA_QUALITY_P7 2.0",
    "    #define FXAA_QUALITY_P8 2.0",
    "    #define FXAA_QUALITY_P9 4.0",
    "    #define FXAA_QUALITY_P10 8.0",
    "#endif",
    "/*--------------------------------------------------------------------------*/",
    "#if (FXAA_QUALITY_PRESET == 29)",
    "    #define FXAA_QUALITY_PS 12",
    "    #define FXAA_QUALITY_P0 1.0",
    "    #define FXAA_QUALITY_P1 1.5",
    "    #define FXAA_QUALITY_P2 2.0",
    "    #define FXAA_QUALITY_P3 2.0",
    "    #define FXAA_QUALITY_P4 2.0",
    "    #define FXAA_QUALITY_P5 2.0",
    "    #define FXAA_QUALITY_P6 2.0",
    "    #define FXAA_QUALITY_P7 2.0",
    "    #define FXAA_QUALITY_P8 2.0",
    "    #define FXAA_QUALITY_P9 2.0",
    "    #define FXAA_QUALITY_P10 4.0",
    "    #define FXAA_QUALITY_P11 8.0",
    "#endif",
    "",
    "/*============================================================================",
    "                     FXAA QUALITY - EXTREME QUALITY",
    "============================================================================*/",
    "#if (FXAA_QUALITY_PRESET == 39)",
    "    #define FXAA_QUALITY_PS 12",
    "    #define FXAA_QUALITY_P0 1.0",
    "    #define FXAA_QUALITY_P1 1.0",
    "    #define FXAA_QUALITY_P2 1.0",
    "    #define FXAA_QUALITY_P3 1.0",
    "    #define FXAA_QUALITY_P4 1.0",
    "    #define FXAA_QUALITY_P5 1.5",
    "    #define FXAA_QUALITY_P6 2.0",
    "    #define FXAA_QUALITY_P7 2.0",
    "    #define FXAA_QUALITY_P8 2.0",
    "    #define FXAA_QUALITY_P9 2.0",
    "    #define FXAA_QUALITY_P10 4.0",
    "    #define FXAA_QUALITY_P11 8.0",
    "#endif",
    "",
    "",
    "",
    "/*============================================================================",
    "",
    "                                API PORTING",
    "",
    "============================================================================*/",
    "#if (FXAA_GLSL_100 == 1) || (FXAA_GLSL_120 == 1) || (FXAA_GLSL_130 == 1)",
    "    #define FxaaBool bool",
    "    #define FxaaDiscard discard",
    "    #define FxaaFloat float",
    "    #define FxaaFloat2 vec2",
    "    #define FxaaFloat3 vec3",
    "    #define FxaaFloat4 vec4",
    "    #define FxaaHalf float",
    "    #define FxaaHalf2 vec2",
    "    #define FxaaHalf3 vec3",
    "    #define FxaaHalf4 vec4",
    "    #define FxaaInt2 ivec2",
    "    #define FxaaSat(x) clamp(x, 0.0, 1.0)",
    "    #define FxaaTex sampler2D",
    "#else",
    "    #define FxaaBool bool",
    "    #define FxaaDiscard clip(-1)",
    "    #define FxaaFloat float",
    "    #define FxaaFloat2 float2",
    "    #define FxaaFloat3 float3",
    "    #define FxaaFloat4 float4",
    "    #define FxaaHalf half",
    "    #define FxaaHalf2 half2",
    "    #define FxaaHalf3 half3",
    "    #define FxaaHalf4 half4",
    "    #define FxaaSat(x) saturate(x)",
    "#endif",
    "/*--------------------------------------------------------------------------*/",
    "#if (FXAA_GLSL_100 == 1)",
    "  #define FxaaTexTop(t, p) texture2D(t, p, 0.0)",
    "  #define FxaaTexOff(t, p, o, r) texture2D(t, p + (o * r), 0.0)",
    "#endif",
    "/*--------------------------------------------------------------------------*/",
    "#if (FXAA_GLSL_120 == 1)",
    "    // Requires,",
    "    //  #version 120",
    "    // And at least,",
    "    //  #extension GL_EXT_gpu_shader4 : enable",
    "    //  (or set FXAA_FAST_PIXEL_OFFSET 1 to work like DX9)",
    "    #define FxaaTexTop(t, p) texture2DLod(t, p, 0.0)",
    "    #if (FXAA_FAST_PIXEL_OFFSET == 1)",
    "        #define FxaaTexOff(t, p, o, r) texture2DLodOffset(t, p, 0.0, o)",
    "    #else",
    "        #define FxaaTexOff(t, p, o, r) texture2DLod(t, p + (o * r), 0.0)",
    "    #endif",
    "    #if (FXAA_GATHER4_ALPHA == 1)",
    "        // use #extension GL_ARB_gpu_shader5 : enable",
    "        #define FxaaTexAlpha4(t, p) textureGather(t, p, 3)",
    "        #define FxaaTexOffAlpha4(t, p, o) textureGatherOffset(t, p, o, 3)",
    "        #define FxaaTexGreen4(t, p) textureGather(t, p, 1)",
    "        #define FxaaTexOffGreen4(t, p, o) textureGatherOffset(t, p, o, 1)",
    "    #endif",
    "#endif",
    "/*--------------------------------------------------------------------------*/",
    "#if (FXAA_GLSL_130 == 1)",
    '    // Requires "#version 130" or better',
    "    #define FxaaTexTop(t, p) textureLod(t, p, 0.0)",
    "    #define FxaaTexOff(t, p, o, r) textureLodOffset(t, p, 0.0, o)",
    "    #if (FXAA_GATHER4_ALPHA == 1)",
    "        // use #extension GL_ARB_gpu_shader5 : enable",
    "        #define FxaaTexAlpha4(t, p) textureGather(t, p, 3)",
    "        #define FxaaTexOffAlpha4(t, p, o) textureGatherOffset(t, p, o, 3)",
    "        #define FxaaTexGreen4(t, p) textureGather(t, p, 1)",
    "        #define FxaaTexOffGreen4(t, p, o) textureGatherOffset(t, p, o, 1)",
    "    #endif",
    "#endif",
    "/*--------------------------------------------------------------------------*/",
    "#if (FXAA_HLSL_3 == 1)",
    "    #define FxaaInt2 float2",
    "    #define FxaaTex sampler2D",
    "    #define FxaaTexTop(t, p) tex2Dlod(t, float4(p, 0.0, 0.0))",
    "    #define FxaaTexOff(t, p, o, r) tex2Dlod(t, float4(p + (o * r), 0, 0))",
    "#endif",
    "/*--------------------------------------------------------------------------*/",
    "#if (FXAA_HLSL_4 == 1)",
    "    #define FxaaInt2 int2",
    "    struct FxaaTex { SamplerState smpl; Texture2D tex; };",
    "    #define FxaaTexTop(t, p) t.tex.SampleLevel(t.smpl, p, 0.0)",
    "    #define FxaaTexOff(t, p, o, r) t.tex.SampleLevel(t.smpl, p, 0.0, o)",
    "#endif",
    "/*--------------------------------------------------------------------------*/",
    "#if (FXAA_HLSL_5 == 1)",
    "    #define FxaaInt2 int2",
    "    struct FxaaTex { SamplerState smpl; Texture2D tex; };",
    "    #define FxaaTexTop(t, p) t.tex.SampleLevel(t.smpl, p, 0.0)",
    "    #define FxaaTexOff(t, p, o, r) t.tex.SampleLevel(t.smpl, p, 0.0, o)",
    "    #define FxaaTexAlpha4(t, p) t.tex.GatherAlpha(t.smpl, p)",
    "    #define FxaaTexOffAlpha4(t, p, o) t.tex.GatherAlpha(t.smpl, p, o)",
    "    #define FxaaTexGreen4(t, p) t.tex.GatherGreen(t.smpl, p)",
    "    #define FxaaTexOffGreen4(t, p, o) t.tex.GatherGreen(t.smpl, p, o)",
    "#endif",
    "",
    "",
    "/*============================================================================",
    "                   GREEN AS LUMA OPTION SUPPORT FUNCTION",
    "============================================================================*/",
    "#if (FXAA_GREEN_AS_LUMA == 0)",
    "    FxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.w; }",
    "#else",
    "    FxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.y; }",
    "#endif",
    "",
    "",
    "",
    "",
    "/*============================================================================",
    "",
    "                             FXAA3 QUALITY - PC",
    "",
    "============================================================================*/",
    "#if (FXAA_PC == 1)",
    "/*--------------------------------------------------------------------------*/",
    "FxaaFloat4 FxaaPixelShader(",
    "    //",
    "    // Use noperspective interpolation here (turn off perspective interpolation).",
    "    // {xy} = center of pixel",
    "    FxaaFloat2 pos,",
    "    //",
    "    // Used only for FXAA Console, and not used on the 360 version.",
    "    // Use noperspective interpolation here (turn off perspective interpolation).",
    "    // {xy_} = upper left of pixel",
    "    // {_zw} = lower right of pixel",
    "    FxaaFloat4 fxaaConsolePosPos,",
    "    //",
    "    // Input color texture.",
    "    // {rgb_} = color in linear or perceptual color space",
    "    // if (FXAA_GREEN_AS_LUMA == 0)",
    "    //     {__a} = luma in perceptual color space (not linear)",
    "    FxaaTex tex,",
    "    //",
    "    // Only used on the optimized 360 version of FXAA Console.",
    '    // For everything but 360, just use the same input here as for "tex".',
    "    // For 360, same texture, just alias with a 2nd sampler.",
    "    // This sampler needs to have an exponent bias of -1.",
    "    FxaaTex fxaaConsole360TexExpBiasNegOne,",
    "    //",
    "    // Only used on the optimized 360 version of FXAA Console.",
    '    // For everything but 360, just use the same input here as for "tex".',
    "    // For 360, same texture, just alias with a 3nd sampler.",
    "    // This sampler needs to have an exponent bias of -2.",
    "    FxaaTex fxaaConsole360TexExpBiasNegTwo,",
    "    //",
    "    // Only used on FXAA Quality.",
    "    // This must be from a constant/uniform.",
    "    // {x_} = 1.0/screenWidthInPixels",
    "    // {_y} = 1.0/screenHeightInPixels",
    "    FxaaFloat2 fxaaQualityRcpFrame,",
    "    //",
    "    // Only used on FXAA Console.",
    "    // This must be from a constant/uniform.",
    "    // This effects sub-pixel AA quality and inversely sharpness.",
    "    //   Where N ranges between,",
    "    //     N = 0.50 (default)",
    "    //     N = 0.33 (sharper)",
    "    // {x__} = -N/screenWidthInPixels",
    "    // {_y_} = -N/screenHeightInPixels",
    "    // {_z_} =  N/screenWidthInPixels",
    "    // {__w} =  N/screenHeightInPixels",
    "    FxaaFloat4 fxaaConsoleRcpFrameOpt,",
    "    //",
    "    // Only used on FXAA Console.",
    "    // Not used on 360, but used on PS3 and PC.",
    "    // This must be from a constant/uniform.",
    "    // {x__} = -2.0/screenWidthInPixels",
    "    // {_y_} = -2.0/screenHeightInPixels",
    "    // {_z_} =  2.0/screenWidthInPixels",
    "    // {__w} =  2.0/screenHeightInPixels",
    "    FxaaFloat4 fxaaConsoleRcpFrameOpt2,",
    "    //",
    "    // Only used on FXAA Console.",
    "    // Only used on 360 in place of fxaaConsoleRcpFrameOpt2.",
    "    // This must be from a constant/uniform.",
    "    // {x__} =  8.0/screenWidthInPixels",
    "    // {_y_} =  8.0/screenHeightInPixels",
    "    // {_z_} = -4.0/screenWidthInPixels",
    "    // {__w} = -4.0/screenHeightInPixels",
    "    FxaaFloat4 fxaaConsole360RcpFrameOpt2,",
    "    //",
    "    // Only used on FXAA Quality.",
    "    // This used to be the FXAA_QUALITY_SUBPIX define.",
    "    // It is here now to allow easier tuning.",
    "    // Choose the amount of sub-pixel aliasing removal.",
    "    // This can effect sharpness.",
    "    //   1.00 - upper limit (softer)",
    "    //   0.75 - default amount of filtering",
    "    //   0.50 - lower limit (sharper, less sub-pixel aliasing removal)",
    "    //   0.25 - almost off",
    "    //   0.00 - completely off",
    "    FxaaFloat fxaaQualitySubpix,",
    "    //",
    "    // Only used on FXAA Quality.",
    "    // This used to be the FXAA_QUALITY_EDGE_THRESHOLD define.",
    "    // It is here now to allow easier tuning.",
    "    // The minimum amount of local contrast required to apply algorithm.",
    "    //   0.333 - too little (faster)",
    "    //   0.250 - low quality",
    "    //   0.166 - default",
    "    //   0.125 - high quality",
    "    //   0.063 - overkill (slower)",
    "    FxaaFloat fxaaQualityEdgeThreshold,",
    "    //",
    "    // Only used on FXAA Quality.",
    "    // This used to be the FXAA_QUALITY_EDGE_THRESHOLD_MIN define.",
    "    // It is here now to allow easier tuning.",
    "    // Trims the algorithm from processing darks.",
    "    //   0.0833 - upper limit (default, the start of visible unfiltered edges)",
    "    //   0.0625 - high quality (faster)",
    "    //   0.0312 - visible limit (slower)",
    "    // Special notes when using FXAA_GREEN_AS_LUMA,",
    "    //   Likely want to set this to zero.",
    "    //   As colors that are mostly not-green",
    "    //   will appear very dark in the green channel!",
    "    //   Tune by looking at mostly non-green content,",
    "    //   then start at zero and increase until aliasing is a problem.",
    "    FxaaFloat fxaaQualityEdgeThresholdMin,",
    "    //",
    "    // Only used on FXAA Console.",
    "    // This used to be the FXAA_CONSOLE_EDGE_SHARPNESS define.",
    "    // It is here now to allow easier tuning.",
    "    // This does not effect PS3, as this needs to be compiled in.",
    "    //   Use FXAA_CONSOLE_PS3_EDGE_SHARPNESS for PS3.",
    "    //   Due to the PS3 being ALU bound,",
    "    //   there are only three safe values here: 2 and 4 and 8.",
    "    //   These options use the shaders ability to a free *|/ by 2|4|8.",
    "    // For all other platforms can be a non-power of two.",
    "    //   8.0 is sharper (default!!!)",
    "    //   4.0 is softer",
    "    //   2.0 is really soft (good only for vector graphics inputs)",
    "    FxaaFloat fxaaConsoleEdgeSharpness,",
    "    //",
    "    // Only used on FXAA Console.",
    "    // This used to be the FXAA_CONSOLE_EDGE_THRESHOLD define.",
    "    // It is here now to allow easier tuning.",
    "    // This does not effect PS3, as this needs to be compiled in.",
    "    //   Use FXAA_CONSOLE_PS3_EDGE_THRESHOLD for PS3.",
    "    //   Due to the PS3 being ALU bound,",
    "    //   there are only two safe values here: 1/4 and 1/8.",
    "    //   These options use the shaders ability to a free *|/ by 2|4|8.",
    "    // The console setting has a different mapping than the quality setting.",
    "    // Other platforms can use other values.",
    "    //   0.125 leaves less aliasing, but is softer (default!!!)",
    "    //   0.25 leaves more aliasing, and is sharper",
    "    FxaaFloat fxaaConsoleEdgeThreshold,",
    "    //",
    "    // Only used on FXAA Console.",
    "    // This used to be the FXAA_CONSOLE_EDGE_THRESHOLD_MIN define.",
    "    // It is here now to allow easier tuning.",
    "    // Trims the algorithm from processing darks.",
    "    // The console setting has a different mapping than the quality setting.",
    "    // This only applies when FXAA_EARLY_EXIT is 1.",
    "    // This does not apply to PS3,",
    "    // PS3 was simplified to avoid more shader instructions.",
    "    //   0.06 - faster but more aliasing in darks",
    "    //   0.05 - default",
    "    //   0.04 - slower and less aliasing in darks",
    "    // Special notes when using FXAA_GREEN_AS_LUMA,",
    "    //   Likely want to set this to zero.",
    "    //   As colors that are mostly not-green",
    "    //   will appear very dark in the green channel!",
    "    //   Tune by looking at mostly non-green content,",
    "    //   then start at zero and increase until aliasing is a problem.",
    "    FxaaFloat fxaaConsoleEdgeThresholdMin,",
    "    //",
    "    // Extra constants for 360 FXAA Console only.",
    "    // Use zeros or anything else for other platforms.",
    "    // These must be in physical constant registers and NOT immediates.",
    "    // Immediates will result in compiler un-optimizing.",
    "    // {xyzw} = float4(1.0, -1.0, 0.25, -0.25)",
    "    FxaaFloat4 fxaaConsole360ConstDir",
    ") {",
    "/*--------------------------------------------------------------------------*/",
    "    FxaaFloat2 posM;",
    "    posM.x = pos.x;",
    "    posM.y = pos.y;",
    "    #if (FXAA_GATHER4_ALPHA == 1)",
    "        #if (FXAA_DISCARD == 0)",
    "            FxaaFloat4 rgbyM = FxaaTexTop(tex, posM);",
    "            #if (FXAA_GREEN_AS_LUMA == 0)",
    "                #define lumaM rgbyM.w",
    "            #else",
    "                #define lumaM rgbyM.y",
    "            #endif",
    "        #endif",
    "        #if (FXAA_GREEN_AS_LUMA == 0)",
    "            FxaaFloat4 luma4A = FxaaTexAlpha4(tex, posM);",
    "            FxaaFloat4 luma4B = FxaaTexOffAlpha4(tex, posM, FxaaInt2(-1, -1));",
    "        #else",
    "            FxaaFloat4 luma4A = FxaaTexGreen4(tex, posM);",
    "            FxaaFloat4 luma4B = FxaaTexOffGreen4(tex, posM, FxaaInt2(-1, -1));",
    "        #endif",
    "        #if (FXAA_DISCARD == 1)",
    "            #define lumaM luma4A.w",
    "        #endif",
    "        #define lumaE luma4A.z",
    "        #define lumaS luma4A.x",
    "        #define lumaSE luma4A.y",
    "        #define lumaNW luma4B.w",
    "        #define lumaN luma4B.z",
    "        #define lumaW luma4B.x",
    "    #else",
    "        FxaaFloat4 rgbyM = FxaaTexTop(tex, posM);",
    "        #if (FXAA_GREEN_AS_LUMA == 0)",
    "            #define lumaM rgbyM.w",
    "        #else",
    "            #define lumaM rgbyM.y",
    "        #endif",
    "        #if (FXAA_GLSL_100 == 1)",
    "          FxaaFloat lumaS = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 0.0, 1.0), fxaaQualityRcpFrame.xy));",
    "          FxaaFloat lumaE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0, 0.0), fxaaQualityRcpFrame.xy));",
    "          FxaaFloat lumaN = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 0.0,-1.0), fxaaQualityRcpFrame.xy));",
    "          FxaaFloat lumaW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0, 0.0), fxaaQualityRcpFrame.xy));",
    "        #else",
    "          FxaaFloat lumaS = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 0, 1), fxaaQualityRcpFrame.xy));",
    "          FxaaFloat lumaE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1, 0), fxaaQualityRcpFrame.xy));",
    "          FxaaFloat lumaN = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 0,-1), fxaaQualityRcpFrame.xy));",
    "          FxaaFloat lumaW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 0), fxaaQualityRcpFrame.xy));",
    "        #endif",
    "    #endif",
    "/*--------------------------------------------------------------------------*/",
    "    FxaaFloat maxSM = max(lumaS, lumaM);",
    "    FxaaFloat minSM = min(lumaS, lumaM);",
    "    FxaaFloat maxESM = max(lumaE, maxSM);",
    "    FxaaFloat minESM = min(lumaE, minSM);",
    "    FxaaFloat maxWN = max(lumaN, lumaW);",
    "    FxaaFloat minWN = min(lumaN, lumaW);",
    "    FxaaFloat rangeMax = max(maxWN, maxESM);",
    "    FxaaFloat rangeMin = min(minWN, minESM);",
    "    FxaaFloat rangeMaxScaled = rangeMax * fxaaQualityEdgeThreshold;",
    "    FxaaFloat range = rangeMax - rangeMin;",
    "    FxaaFloat rangeMaxClamped = max(fxaaQualityEdgeThresholdMin, rangeMaxScaled);",
    "    FxaaBool earlyExit = range < rangeMaxClamped;",
    "/*--------------------------------------------------------------------------*/",
    "    if(earlyExit)",
    "        #if (FXAA_DISCARD == 1)",
    "            FxaaDiscard;",
    "        #else",
    "            return rgbyM;",
    "        #endif",
    "/*--------------------------------------------------------------------------*/",
    "    #if (FXAA_GATHER4_ALPHA == 0)",
    "        #if (FXAA_GLSL_100 == 1)",
    "          FxaaFloat lumaNW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0,-1.0), fxaaQualityRcpFrame.xy));",
    "          FxaaFloat lumaSE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0, 1.0), fxaaQualityRcpFrame.xy));",
    "          FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0,-1.0), fxaaQualityRcpFrame.xy));",
    "          FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0, 1.0), fxaaQualityRcpFrame.xy));",
    "        #else",
    "          FxaaFloat lumaNW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1,-1), fxaaQualityRcpFrame.xy));",
    "          FxaaFloat lumaSE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1, 1), fxaaQualityRcpFrame.xy));",
    "          FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1,-1), fxaaQualityRcpFrame.xy));",
    "          FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));",
    "        #endif",
    "    #else",
    "        FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(1, -1), fxaaQualityRcpFrame.xy));",
    "        FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));",
    "    #endif",
    "/*--------------------------------------------------------------------------*/",
    "    FxaaFloat lumaNS = lumaN + lumaS;",
    "    FxaaFloat lumaWE = lumaW + lumaE;",
    "    FxaaFloat subpixRcpRange = 1.0/range;",
    "    FxaaFloat subpixNSWE = lumaNS + lumaWE;",
    "    FxaaFloat edgeHorz1 = (-2.0 * lumaM) + lumaNS;",
    "    FxaaFloat edgeVert1 = (-2.0 * lumaM) + lumaWE;",
    "/*--------------------------------------------------------------------------*/",
    "    FxaaFloat lumaNESE = lumaNE + lumaSE;",
    "    FxaaFloat lumaNWNE = lumaNW + lumaNE;",
    "    FxaaFloat edgeHorz2 = (-2.0 * lumaE) + lumaNESE;",
    "    FxaaFloat edgeVert2 = (-2.0 * lumaN) + lumaNWNE;",
    "/*--------------------------------------------------------------------------*/",
    "    FxaaFloat lumaNWSW = lumaNW + lumaSW;",
    "    FxaaFloat lumaSWSE = lumaSW + lumaSE;",
    "    FxaaFloat edgeHorz4 = (abs(edgeHorz1) * 2.0) + abs(edgeHorz2);",
    "    FxaaFloat edgeVert4 = (abs(edgeVert1) * 2.0) + abs(edgeVert2);",
    "    FxaaFloat edgeHorz3 = (-2.0 * lumaW) + lumaNWSW;",
    "    FxaaFloat edgeVert3 = (-2.0 * lumaS) + lumaSWSE;",
    "    FxaaFloat edgeHorz = abs(edgeHorz3) + edgeHorz4;",
    "    FxaaFloat edgeVert = abs(edgeVert3) + edgeVert4;",
    "/*--------------------------------------------------------------------------*/",
    "    FxaaFloat subpixNWSWNESE = lumaNWSW + lumaNESE;",
    "    FxaaFloat lengthSign = fxaaQualityRcpFrame.x;",
    "    FxaaBool horzSpan = edgeHorz >= edgeVert;",
    "    FxaaFloat subpixA = subpixNSWE * 2.0 + subpixNWSWNESE;",
    "/*--------------------------------------------------------------------------*/",
    "    if(!horzSpan) lumaN = lumaW;",
    "    if(!horzSpan) lumaS = lumaE;",
    "    if(horzSpan) lengthSign = fxaaQualityRcpFrame.y;",
    "    FxaaFloat subpixB = (subpixA * (1.0/12.0)) - lumaM;",
    "/*--------------------------------------------------------------------------*/",
    "    FxaaFloat gradientN = lumaN - lumaM;",
    "    FxaaFloat gradientS = lumaS - lumaM;",
    "    FxaaFloat lumaNN = lumaN + lumaM;",
    "    FxaaFloat lumaSS = lumaS + lumaM;",
    "    FxaaBool pairN = abs(gradientN) >= abs(gradientS);",
    "    FxaaFloat gradient = max(abs(gradientN), abs(gradientS));",
    "    if(pairN) lengthSign = -lengthSign;",
    "    FxaaFloat subpixC = FxaaSat(abs(subpixB) * subpixRcpRange);",
    "/*--------------------------------------------------------------------------*/",
    "    FxaaFloat2 posB;",
    "    posB.x = posM.x;",
    "    posB.y = posM.y;",
    "    FxaaFloat2 offNP;",
    "    offNP.x = (!horzSpan) ? 0.0 : fxaaQualityRcpFrame.x;",
    "    offNP.y = ( horzSpan) ? 0.0 : fxaaQualityRcpFrame.y;",
    "    if(!horzSpan) posB.x += lengthSign * 0.5;",
    "    if( horzSpan) posB.y += lengthSign * 0.5;",
    "/*--------------------------------------------------------------------------*/",
    "    FxaaFloat2 posN;",
    "    posN.x = posB.x - offNP.x * FXAA_QUALITY_P0;",
    "    posN.y = posB.y - offNP.y * FXAA_QUALITY_P0;",
    "    FxaaFloat2 posP;",
    "    posP.x = posB.x + offNP.x * FXAA_QUALITY_P0;",
    "    posP.y = posB.y + offNP.y * FXAA_QUALITY_P0;",
    "    FxaaFloat subpixD = ((-2.0)*subpixC) + 3.0;",
    "    FxaaFloat lumaEndN = FxaaLuma(FxaaTexTop(tex, posN));",
    "    FxaaFloat subpixE = subpixC * subpixC;",
    "    FxaaFloat lumaEndP = FxaaLuma(FxaaTexTop(tex, posP));",
    "/*--------------------------------------------------------------------------*/",
    "    if(!pairN) lumaNN = lumaSS;",
    "    FxaaFloat gradientScaled = gradient * 1.0/4.0;",
    "    FxaaFloat lumaMM = lumaM - lumaNN * 0.5;",
    "    FxaaFloat subpixF = subpixD * subpixE;",
    "    FxaaBool lumaMLTZero = lumaMM < 0.0;",
    "/*--------------------------------------------------------------------------*/",
    "    lumaEndN -= lumaNN * 0.5;",
    "    lumaEndP -= lumaNN * 0.5;",
    "    FxaaBool doneN = abs(lumaEndN) >= gradientScaled;",
    "    FxaaBool doneP = abs(lumaEndP) >= gradientScaled;",
    "    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P1;",
    "    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P1;",
    "    FxaaBool doneNP = (!doneN) || (!doneP);",
    "    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P1;",
    "    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P1;",
    "/*--------------------------------------------------------------------------*/",
    "    if(doneNP) {",
    "        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));",
    "        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));",
    "        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;",
    "        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;",
    "        doneN = abs(lumaEndN) >= gradientScaled;",
    "        doneP = abs(lumaEndP) >= gradientScaled;",
    "        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P2;",
    "        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P2;",
    "        doneNP = (!doneN) || (!doneP);",
    "        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P2;",
    "        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P2;",
    "/*--------------------------------------------------------------------------*/",
    "        #if (FXAA_QUALITY_PS > 3)",
    "        if(doneNP) {",
    "            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));",
    "            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));",
    "            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;",
    "            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;",
    "            doneN = abs(lumaEndN) >= gradientScaled;",
    "            doneP = abs(lumaEndP) >= gradientScaled;",
    "            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P3;",
    "            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P3;",
    "            doneNP = (!doneN) || (!doneP);",
    "            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P3;",
    "            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P3;",
    "/*--------------------------------------------------------------------------*/",
    "            #if (FXAA_QUALITY_PS > 4)",
    "            if(doneNP) {",
    "                if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));",
    "                if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));",
    "                if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;",
    "                if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;",
    "                doneN = abs(lumaEndN) >= gradientScaled;",
    "                doneP = abs(lumaEndP) >= gradientScaled;",
    "                if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P4;",
    "                if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P4;",
    "                doneNP = (!doneN) || (!doneP);",
    "                if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P4;",
    "                if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P4;",
    "/*--------------------------------------------------------------------------*/",
    "                #if (FXAA_QUALITY_PS > 5)",
    "                if(doneNP) {",
    "                    if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));",
    "                    if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));",
    "                    if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;",
    "                    if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;",
    "                    doneN = abs(lumaEndN) >= gradientScaled;",
    "                    doneP = abs(lumaEndP) >= gradientScaled;",
    "                    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P5;",
    "                    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P5;",
    "                    doneNP = (!doneN) || (!doneP);",
    "                    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P5;",
    "                    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P5;",
    "/*--------------------------------------------------------------------------*/",
    "                    #if (FXAA_QUALITY_PS > 6)",
    "                    if(doneNP) {",
    "                        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));",
    "                        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));",
    "                        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;",
    "                        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;",
    "                        doneN = abs(lumaEndN) >= gradientScaled;",
    "                        doneP = abs(lumaEndP) >= gradientScaled;",
    "                        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P6;",
    "                        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P6;",
    "                        doneNP = (!doneN) || (!doneP);",
    "                        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P6;",
    "                        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P6;",
    "/*--------------------------------------------------------------------------*/",
    "                        #if (FXAA_QUALITY_PS > 7)",
    "                        if(doneNP) {",
    "                            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));",
    "                            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));",
    "                            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;",
    "                            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;",
    "                            doneN = abs(lumaEndN) >= gradientScaled;",
    "                            doneP = abs(lumaEndP) >= gradientScaled;",
    "                            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P7;",
    "                            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P7;",
    "                            doneNP = (!doneN) || (!doneP);",
    "                            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P7;",
    "                            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P7;",
    "/*--------------------------------------------------------------------------*/",
    "    #if (FXAA_QUALITY_PS > 8)",
    "    if(doneNP) {",
    "        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));",
    "        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));",
    "        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;",
    "        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;",
    "        doneN = abs(lumaEndN) >= gradientScaled;",
    "        doneP = abs(lumaEndP) >= gradientScaled;",
    "        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P8;",
    "        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P8;",
    "        doneNP = (!doneN) || (!doneP);",
    "        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P8;",
    "        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P8;",
    "/*--------------------------------------------------------------------------*/",
    "        #if (FXAA_QUALITY_PS > 9)",
    "        if(doneNP) {",
    "            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));",
    "            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));",
    "            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;",
    "            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;",
    "            doneN = abs(lumaEndN) >= gradientScaled;",
    "            doneP = abs(lumaEndP) >= gradientScaled;",
    "            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P9;",
    "            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P9;",
    "            doneNP = (!doneN) || (!doneP);",
    "            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P9;",
    "            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P9;",
    "/*--------------------------------------------------------------------------*/",
    "            #if (FXAA_QUALITY_PS > 10)",
    "            if(doneNP) {",
    "                if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));",
    "                if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));",
    "                if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;",
    "                if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;",
    "                doneN = abs(lumaEndN) >= gradientScaled;",
    "                doneP = abs(lumaEndP) >= gradientScaled;",
    "                if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P10;",
    "                if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P10;",
    "                doneNP = (!doneN) || (!doneP);",
    "                if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P10;",
    "                if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P10;",
    "/*--------------------------------------------------------------------------*/",
    "                #if (FXAA_QUALITY_PS > 11)",
    "                if(doneNP) {",
    "                    if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));",
    "                    if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));",
    "                    if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;",
    "                    if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;",
    "                    doneN = abs(lumaEndN) >= gradientScaled;",
    "                    doneP = abs(lumaEndP) >= gradientScaled;",
    "                    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P11;",
    "                    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P11;",
    "                    doneNP = (!doneN) || (!doneP);",
    "                    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P11;",
    "                    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P11;",
    "/*--------------------------------------------------------------------------*/",
    "                    #if (FXAA_QUALITY_PS > 12)",
    "                    if(doneNP) {",
    "                        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));",
    "                        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));",
    "                        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;",
    "                        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;",
    "                        doneN = abs(lumaEndN) >= gradientScaled;",
    "                        doneP = abs(lumaEndP) >= gradientScaled;",
    "                        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P12;",
    "                        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P12;",
    "                        doneNP = (!doneN) || (!doneP);",
    "                        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P12;",
    "                        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P12;",
    "/*--------------------------------------------------------------------------*/",
    "                    }",
    "                    #endif",
    "/*--------------------------------------------------------------------------*/",
    "                }",
    "                #endif",
    "/*--------------------------------------------------------------------------*/",
    "            }",
    "            #endif",
    "/*--------------------------------------------------------------------------*/",
    "        }",
    "        #endif",
    "/*--------------------------------------------------------------------------*/",
    "    }",
    "    #endif",
    "/*--------------------------------------------------------------------------*/",
    "                        }",
    "                        #endif",
    "/*--------------------------------------------------------------------------*/",
    "                    }",
    "                    #endif",
    "/*--------------------------------------------------------------------------*/",
    "                }",
    "                #endif",
    "/*--------------------------------------------------------------------------*/",
    "            }",
    "            #endif",
    "/*--------------------------------------------------------------------------*/",
    "        }",
    "        #endif",
    "/*--------------------------------------------------------------------------*/",
    "    }",
    "/*--------------------------------------------------------------------------*/",
    "    FxaaFloat dstN = posM.x - posN.x;",
    "    FxaaFloat dstP = posP.x - posM.x;",
    "    if(!horzSpan) dstN = posM.y - posN.y;",
    "    if(!horzSpan) dstP = posP.y - posM.y;",
    "/*--------------------------------------------------------------------------*/",
    "    FxaaBool goodSpanN = (lumaEndN < 0.0) != lumaMLTZero;",
    "    FxaaFloat spanLength = (dstP + dstN);",
    "    FxaaBool goodSpanP = (lumaEndP < 0.0) != lumaMLTZero;",
    "    FxaaFloat spanLengthRcp = 1.0/spanLength;",
    "/*--------------------------------------------------------------------------*/",
    "    FxaaBool directionN = dstN < dstP;",
    "    FxaaFloat dst = min(dstN, dstP);",
    "    FxaaBool goodSpan = directionN ? goodSpanN : goodSpanP;",
    "    FxaaFloat subpixG = subpixF * subpixF;",
    "    FxaaFloat pixelOffset = (dst * (-spanLengthRcp)) + 0.5;",
    "    FxaaFloat subpixH = subpixG * fxaaQualitySubpix;",
    "/*--------------------------------------------------------------------------*/",
    "    FxaaFloat pixelOffsetGood = goodSpan ? pixelOffset : 0.0;",
    "    FxaaFloat pixelOffsetSubpix = max(pixelOffsetGood, subpixH);",
    "    if(!horzSpan) posM.x += pixelOffsetSubpix * lengthSign;",
    "    if( horzSpan) posM.y += pixelOffsetSubpix * lengthSign;",
    "    #if (FXAA_DISCARD == 1)",
    "        return FxaaTexTop(tex, posM);",
    "    #else",
    "        return FxaaFloat4(FxaaTexTop(tex, posM).xyz, lumaM);",
    "    #endif",
    "}",
    "/*==========================================================================*/",
    "#endif",
    "",
    "void main() {",
    "  gl_FragColor = FxaaPixelShader(",
    "    vUv,",
    "    vec4(0.0),",
    "    tDiffuse,",
    "    tDiffuse,",
    "    tDiffuse,",
    "    resolution,",
    "    vec4(0.0),",
    "    vec4(0.0),",
    "    vec4(0.0),",
    "    0.75,",
    "    0.166,",
    "    0.0833,",
    "    0.0,",
    "    0.0,",
    "    0.0,",
    "    vec4(0.0)",
    "  );",
    "",
    "  // TODO avoid querying texture twice for same texel",
    "  gl_FragColor.a = texture2D(tDiffuse, vUv).a;",
    "}"
  ].join("\n")
};

// node_modules/three-stdlib/shaders/FocusShader.js
var FocusShader = {
  uniforms: {
    tDiffuse: { value: null },
    screenWidth: { value: 1024 },
    screenHeight: { value: 1024 },
    sampleDistance: { value: 0.94 },
    waveFactor: { value: 125e-5 }
  },
  vertexShader: [
    "varying vec2 vUv;",
    "void main() {",
    "	vUv = uv;",
    "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
    "}"
  ].join("\n"),
  fragmentShader: [
    "uniform float screenWidth;",
    "uniform float screenHeight;",
    "uniform float sampleDistance;",
    "uniform float waveFactor;",
    "uniform sampler2D tDiffuse;",
    "varying vec2 vUv;",
    "void main() {",
    "	vec4 color, org, tmp, add;",
    "	float sample_dist, f;",
    "	vec2 vin;",
    "	vec2 uv = vUv;",
    "	add = color = org = texture2D( tDiffuse, uv );",
    "	vin = ( uv - vec2( 0.5 ) ) * vec2( 1.4 );",
    "	sample_dist = dot( vin, vin ) * 2.0;",
    "	f = ( waveFactor * 100.0 + sample_dist ) * sampleDistance * 4.0;",
    "	vec2 sampleSize = vec2(  1.0 / screenWidth, 1.0 / screenHeight ) * vec2( f );",
    "	add += tmp = texture2D( tDiffuse, uv + vec2( 0.111964, 0.993712 ) * sampleSize );",
    "	if( tmp.b < color.b ) color = tmp;",
    "	add += tmp = texture2D( tDiffuse, uv + vec2( 0.846724, 0.532032 ) * sampleSize );",
    "	if( tmp.b < color.b ) color = tmp;",
    "	add += tmp = texture2D( tDiffuse, uv + vec2( 0.943883, -0.330279 ) * sampleSize );",
    "	if( tmp.b < color.b ) color = tmp;",
    "	add += tmp = texture2D( tDiffuse, uv + vec2( 0.330279, -0.943883 ) * sampleSize );",
    "	if( tmp.b < color.b ) color = tmp;",
    "	add += tmp = texture2D( tDiffuse, uv + vec2( -0.532032, -0.846724 ) * sampleSize );",
    "	if( tmp.b < color.b ) color = tmp;",
    "	add += tmp = texture2D( tDiffuse, uv + vec2( -0.993712, -0.111964 ) * sampleSize );",
    "	if( tmp.b < color.b ) color = tmp;",
    "	add += tmp = texture2D( tDiffuse, uv + vec2( -0.707107, 0.707107 ) * sampleSize );",
    "	if( tmp.b < color.b ) color = tmp;",
    "	color = color * vec4( 2.0 ) - ( add / vec4( 8.0 ) );",
    "	color = color + ( add / vec4( 8.0 ) - color ) * ( vec4( 1.0 ) - vec4( sample_dist * 0.5 ) );",
    "	gl_FragColor = vec4( color.rgb * color.rgb * vec3( 0.95 ) + color.rgb, 1.0 );",
    "}"
  ].join("\n")
};

// node_modules/three-stdlib/shaders/FreiChenShader.js
var FreiChenShader = {
  uniforms: {
    tDiffuse: { value: null },
    aspect: { value: new Vector2(512, 512) }
  },
  vertexShader: [
    "varying vec2 vUv;",
    "void main() {",
    "	vUv = uv;",
    "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
    "}"
  ].join("\n"),
  fragmentShader: [
    "uniform sampler2D tDiffuse;",
    "varying vec2 vUv;",
    "uniform vec2 aspect;",
    "vec2 texel = vec2(1.0 / aspect.x, 1.0 / aspect.y);",
    "mat3 G[9];",
    // hard coded matrix values!!!! as suggested in https://github.com/neilmendoza/ofxPostProcessing/blob/master/src/EdgePass.cpp#L45
    "const mat3 g0 = mat3( 0.3535533845424652, 0, -0.3535533845424652, 0.5, 0, -0.5, 0.3535533845424652, 0, -0.3535533845424652 );",
    "const mat3 g1 = mat3( 0.3535533845424652, 0.5, 0.3535533845424652, 0, 0, 0, -0.3535533845424652, -0.5, -0.3535533845424652 );",
    "const mat3 g2 = mat3( 0, 0.3535533845424652, -0.5, -0.3535533845424652, 0, 0.3535533845424652, 0.5, -0.3535533845424652, 0 );",
    "const mat3 g3 = mat3( 0.5, -0.3535533845424652, 0, -0.3535533845424652, 0, 0.3535533845424652, 0, 0.3535533845424652, -0.5 );",
    "const mat3 g4 = mat3( 0, -0.5, 0, 0.5, 0, 0.5, 0, -0.5, 0 );",
    "const mat3 g5 = mat3( -0.5, 0, 0.5, 0, 0, 0, 0.5, 0, -0.5 );",
    "const mat3 g6 = mat3( 0.1666666716337204, -0.3333333432674408, 0.1666666716337204, -0.3333333432674408, 0.6666666865348816, -0.3333333432674408, 0.1666666716337204, -0.3333333432674408, 0.1666666716337204 );",
    "const mat3 g7 = mat3( -0.3333333432674408, 0.1666666716337204, -0.3333333432674408, 0.1666666716337204, 0.6666666865348816, 0.1666666716337204, -0.3333333432674408, 0.1666666716337204, -0.3333333432674408 );",
    "const mat3 g8 = mat3( 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408 );",
    "void main(void)",
    "{",
    "	G[0] = g0,",
    "	G[1] = g1,",
    "	G[2] = g2,",
    "	G[3] = g3,",
    "	G[4] = g4,",
    "	G[5] = g5,",
    "	G[6] = g6,",
    "	G[7] = g7,",
    "	G[8] = g8;",
    "	mat3 I;",
    "	float cnv[9];",
    "	vec3 sample;",
    /* fetch the 3x3 neighbourhood and use the RGB vector's length as intensity value */
    "	for (float i=0.0; i<3.0; i++) {",
    "		for (float j=0.0; j<3.0; j++) {",
    "			sample = texture2D(tDiffuse, vUv + texel * vec2(i-1.0,j-1.0) ).rgb;",
    "			I[int(i)][int(j)] = length(sample);",
    "		}",
    "	}",
    /* calculate the convolution values for all the masks */
    "	for (int i=0; i<9; i++) {",
    "		float dp3 = dot(G[i][0], I[0]) + dot(G[i][1], I[1]) + dot(G[i][2], I[2]);",
    "		cnv[i] = dp3 * dp3;",
    "	}",
    "	float M = (cnv[0] + cnv[1]) + (cnv[2] + cnv[3]);",
    "	float S = (cnv[4] + cnv[5]) + (cnv[6] + cnv[7]) + (cnv[8] + M);",
    "	gl_FragColor = vec4(vec3(sqrt(M/S)), 1.0);",
    "}"
  ].join("\n")
};

// node_modules/three-stdlib/shaders/FresnelShader.js
var FresnelShader = {
  uniforms: {
    mRefractionRatio: { value: 1.02 },
    mFresnelBias: { value: 0.1 },
    mFresnelPower: { value: 2 },
    mFresnelScale: { value: 1 },
    tCube: { value: null }
  },
  vertexShader: [
    "uniform float mRefractionRatio;",
    "uniform float mFresnelBias;",
    "uniform float mFresnelScale;",
    "uniform float mFresnelPower;",
    "varying vec3 vReflect;",
    "varying vec3 vRefract[3];",
    "varying float vReflectionFactor;",
    "void main() {",
    "	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );",
    "	vec4 worldPosition = modelMatrix * vec4( position, 1.0 );",
    "	vec3 worldNormal = normalize( mat3( modelMatrix[0].xyz, modelMatrix[1].xyz, modelMatrix[2].xyz ) * normal );",
    "	vec3 I = worldPosition.xyz - cameraPosition;",
    "	vReflect = reflect( I, worldNormal );",
    "	vRefract[0] = refract( normalize( I ), worldNormal, mRefractionRatio );",
    "	vRefract[1] = refract( normalize( I ), worldNormal, mRefractionRatio * 0.99 );",
    "	vRefract[2] = refract( normalize( I ), worldNormal, mRefractionRatio * 0.98 );",
    "	vReflectionFactor = mFresnelBias + mFresnelScale * pow( 1.0 + dot( normalize( I ), worldNormal ), mFresnelPower );",
    "	gl_Position = projectionMatrix * mvPosition;",
    "}"
  ].join("\n"),
  fragmentShader: [
    "uniform samplerCube tCube;",
    "varying vec3 vReflect;",
    "varying vec3 vRefract[3];",
    "varying float vReflectionFactor;",
    "void main() {",
    "	vec4 reflectedColor = textureCube( tCube, vec3( -vReflect.x, vReflect.yz ) );",
    "	vec4 refractedColor = vec4( 1.0 );",
    "	refractedColor.r = textureCube( tCube, vec3( -vRefract[0].x, vRefract[0].yz ) ).r;",
    "	refractedColor.g = textureCube( tCube, vec3( -vRefract[1].x, vRefract[1].yz ) ).g;",
    "	refractedColor.b = textureCube( tCube, vec3( -vRefract[2].x, vRefract[2].yz ) ).b;",
    "	gl_FragColor = mix( refractedColor, reflectedColor, clamp( vReflectionFactor, 0.0, 1.0 ) );",
    "}"
  ].join("\n")
};

// node_modules/three-stdlib/shaders/GammaCorrectionShader.js
var GammaCorrectionShader = {
  uniforms: {
    tDiffuse: { value: null }
  },
  vertexShader: [
    "varying vec2 vUv;",
    "void main() {",
    "	vUv = uv;",
    "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
    "}"
  ].join("\n"),
  fragmentShader: [
    "uniform sampler2D tDiffuse;",
    "varying vec2 vUv;",
    "void main() {",
    "	vec4 tex = texture2D( tDiffuse, vUv );",
    "	gl_FragColor = LinearTosRGB( tex );",
    "}"
  ].join("\n")
};

// node_modules/three-stdlib/shaders/GodRaysShader.js
var GodRaysDepthMaskShader = {
  uniforms: {
    tInput: {
      value: null
    }
  },
  vertexShader: [
    "varying vec2 vUv;",
    "void main() {",
    " vUv = uv;",
    " gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
    "}"
  ].join("\n"),
  fragmentShader: [
    "varying vec2 vUv;",
    "uniform sampler2D tInput;",
    "void main() {",
    "	gl_FragColor = vec4( 1.0 ) - texture2D( tInput, vUv );",
    "}"
  ].join("\n")
};
var GodRaysGenerateShader = {
  uniforms: {
    tInput: {
      value: null
    },
    fStepSize: {
      value: 1
    },
    vSunPositionScreenSpace: {
      value: new Vector3()
    }
  },
  vertexShader: [
    "varying vec2 vUv;",
    "void main() {",
    " vUv = uv;",
    " gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
    "}"
  ].join("\n"),
  fragmentShader: [
    "#define TAPS_PER_PASS 6.0",
    "varying vec2 vUv;",
    "uniform sampler2D tInput;",
    "uniform vec3 vSunPositionScreenSpace;",
    "uniform float fStepSize;",
    // filter step size
    "void main() {",
    // delta from current pixel to "sun" position
    "	vec2 delta = vSunPositionScreenSpace.xy - vUv;",
    "	float dist = length( delta );",
    // Step vector (uv space)
    "	vec2 stepv = fStepSize * delta / dist;",
    // Number of iterations between pixel and sun
    "	float iters = dist/fStepSize;",
    "	vec2 uv = vUv.xy;",
    "	float col = 0.0;",
    // This breaks ANGLE in Chrome 22
    //	- see http://code.google.com/p/chromium/issues/detail?id=153105
    /*
    		// Unrolling didnt do much on my hardware (ATI Mobility Radeon 3450),
    		// so i've just left the loop
    
    		"for ( float i = 0.0; i < TAPS_PER_PASS; i += 1.0 ) {",
    
    		// Accumulate samples, making sure we dont walk past the light source.
    
    		// The check for uv.y < 1 would not be necessary with "border" UV wrap
    		// mode, with a black border color. I don't think this is currently
    		// exposed by three.js. As a result there might be artifacts when the
    		// sun is to the left, right or bottom of screen as these cases are
    		// not specifically handled.
    
    		"	col += ( i <= iters && uv.y < 1.0 ? texture2D( tInput, uv ).r : 0.0 );",
    		"	uv += stepv;",
    
    		"}",
    		*/
    // Unrolling loop manually makes it work in ANGLE
    "	float f = min( 1.0, max( vSunPositionScreenSpace.z / 1000.0, 0.0 ) );",
    // used to fade out godrays
    "	if ( 0.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;",
    "	uv += stepv;",
    "	if ( 1.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;",
    "	uv += stepv;",
    "	if ( 2.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;",
    "	uv += stepv;",
    "	if ( 3.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;",
    "	uv += stepv;",
    "	if ( 4.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;",
    "	uv += stepv;",
    "	if ( 5.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;",
    "	uv += stepv;",
    // Should technically be dividing by 'iters', but 'TAPS_PER_PASS' smooths out
    // objectionable artifacts, in particular near the sun position. The side
    // effect is that the result is darker than it should be around the sun, as
    // TAPS_PER_PASS is greater than the number of samples actually accumulated.
    // When the result is inverted (in the shader 'godrays_combine', this produces
    // a slight bright spot at the position of the sun, even when it is occluded.
    "	gl_FragColor = vec4( col/TAPS_PER_PASS );",
    "	gl_FragColor.a = 1.0;",
    "}"
  ].join("\n")
};
var GodRaysCombineShader = {
  uniforms: {
    tColors: {
      value: null
    },
    tGodRays: {
      value: null
    },
    fGodRayIntensity: {
      value: 0.69
    }
  },
  vertexShader: [
    "varying vec2 vUv;",
    "void main() {",
    "	vUv = uv;",
    "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
    "}"
  ].join("\n"),
  fragmentShader: [
    "varying vec2 vUv;",
    "uniform sampler2D tColors;",
    "uniform sampler2D tGodRays;",
    "uniform float fGodRayIntensity;",
    "void main() {",
    // Since THREE.MeshDepthMaterial renders foreground objects white and background
    // objects black, the god-rays will be white streaks. Therefore value is inverted
    // before being combined with tColors
    "	gl_FragColor = texture2D( tColors, vUv ) + fGodRayIntensity * vec4( 1.0 - texture2D( tGodRays, vUv ).r );",
    "	gl_FragColor.a = 1.0;",
    "}"
  ].join("\n")
};
var GodRaysFakeSunShader = {
  uniforms: {
    vSunPositionScreenSpace: {
      value: new Vector3()
    },
    fAspect: {
      value: 1
    },
    sunColor: {
      value: new Color(16772608)
    },
    bgColor: {
      value: new Color(0)
    }
  },
  vertexShader: [
    "varying vec2 vUv;",
    "void main() {",
    "	vUv = uv;",
    "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
    "}"
  ].join("\n"),
  fragmentShader: [
    "varying vec2 vUv;",
    "uniform vec3 vSunPositionScreenSpace;",
    "uniform float fAspect;",
    "uniform vec3 sunColor;",
    "uniform vec3 bgColor;",
    "void main() {",
    "	vec2 diff = vUv - vSunPositionScreenSpace.xy;",
    // Correct for aspect ratio
    "	diff.x *= fAspect;",
    "	float prop = clamp( length( diff ) / 0.5, 0.0, 1.0 );",
    "	prop = 0.35 * pow( 1.0 - prop, 3.0 );",
    "	gl_FragColor.xyz = ( vSunPositionScreenSpace.z > 0.0 ) ? mix( sunColor, bgColor, 1.0 - prop ) : bgColor;",
    "	gl_FragColor.w = 1.0;",
    "}"
  ].join("\n")
};

// node_modules/three-stdlib/shaders/HorizontalBlurShader.js
var HorizontalBlurShader = {
  uniforms: {
    tDiffuse: { value: null },
    h: { value: 1 / 512 }
  },
  vertexShader: (
    /* glsl */
    `
      varying vec2 vUv;

      void main() {

        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

      }
  `
  ),
  fragmentShader: (
    /* glsl */
    `
    uniform sampler2D tDiffuse;
    uniform float h;

    varying vec2 vUv;

    void main() {

    	vec4 sum = vec4( 0.0 );

    	sum += texture2D( tDiffuse, vec2( vUv.x - 4.0 * h, vUv.y ) ) * 0.051;
    	sum += texture2D( tDiffuse, vec2( vUv.x - 3.0 * h, vUv.y ) ) * 0.0918;
    	sum += texture2D( tDiffuse, vec2( vUv.x - 2.0 * h, vUv.y ) ) * 0.12245;
    	sum += texture2D( tDiffuse, vec2( vUv.x - 1.0 * h, vUv.y ) ) * 0.1531;
    	sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;
    	sum += texture2D( tDiffuse, vec2( vUv.x + 1.0 * h, vUv.y ) ) * 0.1531;
    	sum += texture2D( tDiffuse, vec2( vUv.x + 2.0 * h, vUv.y ) ) * 0.12245;
    	sum += texture2D( tDiffuse, vec2( vUv.x + 3.0 * h, vUv.y ) ) * 0.0918;
    	sum += texture2D( tDiffuse, vec2( vUv.x + 4.0 * h, vUv.y ) ) * 0.051;

    	gl_FragColor = sum;

    }
  `
  )
};

// node_modules/three-stdlib/shaders/HorizontalTiltShiftShader.js
var HorizontalTiltShiftShader = {
  uniforms: {
    tDiffuse: { value: null },
    h: { value: 1 / 512 },
    r: { value: 0.35 }
  },
  vertexShader: [
    "varying vec2 vUv;",
    "void main() {",
    "	vUv = uv;",
    "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
    "}"
  ].join("\n"),
  fragmentShader: [
    "uniform sampler2D tDiffuse;",
    "uniform float h;",
    "uniform float r;",
    "varying vec2 vUv;",
    "void main() {",
    "	vec4 sum = vec4( 0.0 );",
    "	float hh = h * abs( r - vUv.y );",
    "	sum += texture2D( tDiffuse, vec2( vUv.x - 4.0 * hh, vUv.y ) ) * 0.051;",
    "	sum += texture2D( tDiffuse, vec2( vUv.x - 3.0 * hh, vUv.y ) ) * 0.0918;",
    "	sum += texture2D( tDiffuse, vec2( vUv.x - 2.0 * hh, vUv.y ) ) * 0.12245;",
    "	sum += texture2D( tDiffuse, vec2( vUv.x - 1.0 * hh, vUv.y ) ) * 0.1531;",
    "	sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;",
    "	sum += texture2D( tDiffuse, vec2( vUv.x + 1.0 * hh, vUv.y ) ) * 0.1531;",
    "	sum += texture2D( tDiffuse, vec2( vUv.x + 2.0 * hh, vUv.y ) ) * 0.12245;",
    "	sum += texture2D( tDiffuse, vec2( vUv.x + 3.0 * hh, vUv.y ) ) * 0.0918;",
    "	sum += texture2D( tDiffuse, vec2( vUv.x + 4.0 * hh, vUv.y ) ) * 0.051;",
    "	gl_FragColor = sum;",
    "}"
  ].join("\n")
};

// node_modules/three-stdlib/shaders/HueSaturationShader.js
var HueSaturationShader = {
  uniforms: {
    tDiffuse: { value: null },
    hue: { value: 0 },
    saturation: { value: 0 }
  },
  vertexShader: [
    "varying vec2 vUv;",
    "void main() {",
    "	vUv = uv;",
    "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
    "}"
  ].join("\n"),
  fragmentShader: [
    "uniform sampler2D tDiffuse;",
    "uniform float hue;",
    "uniform float saturation;",
    "varying vec2 vUv;",
    "void main() {",
    "	gl_FragColor = texture2D( tDiffuse, vUv );",
    // hue
    "	float angle = hue * 3.14159265;",
    "	float s = sin(angle), c = cos(angle);",
    "	vec3 weights = (vec3(2.0 * c, -sqrt(3.0) * s - c, sqrt(3.0) * s - c) + 1.0) / 3.0;",
    "	float len = length(gl_FragColor.rgb);",
    "	gl_FragColor.rgb = vec3(",
    "		dot(gl_FragColor.rgb, weights.xyz),",
    "		dot(gl_FragColor.rgb, weights.zxy),",
    "		dot(gl_FragColor.rgb, weights.yzx)",
    "	);",
    // saturation
    "	float average = (gl_FragColor.r + gl_FragColor.g + gl_FragColor.b) / 3.0;",
    "	if (saturation > 0.0) {",
    "		gl_FragColor.rgb += (average - gl_FragColor.rgb) * (1.0 - 1.0 / (1.001 - saturation));",
    "	} else {",
    "		gl_FragColor.rgb += (average - gl_FragColor.rgb) * (-saturation);",
    "	}",
    "}"
  ].join("\n")
};

// node_modules/three-stdlib/shaders/KaleidoShader.js
var KaleidoShader = {
  uniforms: {
    tDiffuse: { value: null },
    sides: { value: 6 },
    angle: { value: 0 }
  },
  vertexShader: [
    "varying vec2 vUv;",
    "void main() {",
    "	vUv = uv;",
    "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
    "}"
  ].join("\n"),
  fragmentShader: [
    "uniform sampler2D tDiffuse;",
    "uniform float sides;",
    "uniform float angle;",
    "varying vec2 vUv;",
    "void main() {",
    "	vec2 p = vUv - 0.5;",
    "	float r = length(p);",
    "	float a = atan(p.y, p.x) + angle;",
    "	float tau = 2. * 3.1416 ;",
    "	a = mod(a, tau/sides);",
    "	a = abs(a - tau/sides/2.) ;",
    "	p = r * vec2(cos(a), sin(a));",
    "	vec4 color = texture2D(tDiffuse, p + 0.5);",
    "	gl_FragColor = color;",
    "}"
  ].join("\n")
};

// node_modules/three-stdlib/shaders/MirrorShader.js
var MirrorShader = {
  uniforms: {
    tDiffuse: { value: null },
    side: { value: 1 }
  },
  vertexShader: [
    "varying vec2 vUv;",
    "void main() {",
    "	vUv = uv;",
    "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
    "}"
  ].join("\n"),
  fragmentShader: [
    "uniform sampler2D tDiffuse;",
    "uniform int side;",
    "varying vec2 vUv;",
    "void main() {",
    "	vec2 p = vUv;",
    "	if (side == 0){",
    "		if (p.x > 0.5) p.x = 1.0 - p.x;",
    "	}else if (side == 1){",
    "		if (p.x < 0.5) p.x = 1.0 - p.x;",
    "	}else if (side == 2){",
    "		if (p.y < 0.5) p.y = 1.0 - p.y;",
    "	}else if (side == 3){",
    "		if (p.y > 0.5) p.y = 1.0 - p.y;",
    "	} ",
    "	vec4 color = texture2D(tDiffuse, p);",
    "	gl_FragColor = color;",
    "}"
  ].join("\n")
};

// node_modules/three-stdlib/shaders/NormalMapShader.js
var NormalMapShader = {
  uniforms: {
    heightMap: { value: null },
    resolution: { value: new Vector2(512, 512) },
    scale: { value: new Vector2(1, 1) },
    height: { value: 0.05 }
  },
  vertexShader: [
    "varying vec2 vUv;",
    "void main() {",
    "	vUv = uv;",
    "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
    "}"
  ].join("\n"),
  fragmentShader: [
    "uniform float height;",
    "uniform vec2 resolution;",
    "uniform sampler2D heightMap;",
    "varying vec2 vUv;",
    "void main() {",
    "	float val = texture2D( heightMap, vUv ).x;",
    "	float valU = texture2D( heightMap, vUv + vec2( 1.0 / resolution.x, 0.0 ) ).x;",
    "	float valV = texture2D( heightMap, vUv + vec2( 0.0, 1.0 / resolution.y ) ).x;",
    "	gl_FragColor = vec4( ( 0.5 * normalize( vec3( val - valU, val - valV, height  ) ) + 0.5 ), 1.0 );",
    "}"
  ].join("\n")
};

// node_modules/three-stdlib/shaders/ParallaxShader.js
var ParallaxShader = {
  // Ordered from fastest to best quality.
  modes: {
    none: "NO_PARALLAX",
    basic: "USE_BASIC_PARALLAX",
    steep: "USE_STEEP_PARALLAX",
    occlusion: "USE_OCLUSION_PARALLAX",
    // a.k.a. POM
    relief: "USE_RELIEF_PARALLAX"
  },
  uniforms: {
    bumpMap: { value: null },
    map: { value: null },
    parallaxScale: { value: null },
    parallaxMinLayers: { value: null },
    parallaxMaxLayers: { value: null }
  },
  vertexShader: [
    "varying vec2 vUv;",
    "varying vec3 vViewPosition;",
    "varying vec3 vNormal;",
    "void main() {",
    "	vUv = uv;",
    "	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );",
    "	vViewPosition = -mvPosition.xyz;",
    "	vNormal = normalize( normalMatrix * normal );",
    "	gl_Position = projectionMatrix * mvPosition;",
    "}"
  ].join("\n"),
  fragmentShader: [
    "uniform sampler2D bumpMap;",
    "uniform sampler2D map;",
    "uniform float parallaxScale;",
    "uniform float parallaxMinLayers;",
    "uniform float parallaxMaxLayers;",
    "varying vec2 vUv;",
    "varying vec3 vViewPosition;",
    "varying vec3 vNormal;",
    "#ifdef USE_BASIC_PARALLAX",
    "	vec2 parallaxMap( in vec3 V ) {",
    "		float initialHeight = texture2D( bumpMap, vUv ).r;",
    // No Offset Limitting: messy, floating output at grazing angles.
    //"vec2 texCoordOffset = parallaxScale * V.xy / V.z * initialHeight;",
    // Offset Limiting
    "		vec2 texCoordOffset = parallaxScale * V.xy * initialHeight;",
    "		return vUv - texCoordOffset;",
    "	}",
    "#else",
    "	vec2 parallaxMap( in vec3 V ) {",
    // Determine number of layers from angle between V and N
    "		float numLayers = mix( parallaxMaxLayers, parallaxMinLayers, abs( dot( vec3( 0.0, 0.0, 1.0 ), V ) ) );",
    "		float layerHeight = 1.0 / numLayers;",
    "		float currentLayerHeight = 0.0;",
    // Shift of texture coordinates for each iteration
    "		vec2 dtex = parallaxScale * V.xy / V.z / numLayers;",
    "		vec2 currentTextureCoords = vUv;",
    "		float heightFromTexture = texture2D( bumpMap, currentTextureCoords ).r;",
    // while ( heightFromTexture > currentLayerHeight )
    // Infinite loops are not well supported. Do a "large" finite
    // loop, but not too large, as it slows down some compilers.
    "		for ( int i = 0; i < 30; i += 1 ) {",
    "			if ( heightFromTexture <= currentLayerHeight ) {",
    "				break;",
    "			}",
    "			currentLayerHeight += layerHeight;",
    // Shift texture coordinates along vector V
    "			currentTextureCoords -= dtex;",
    "			heightFromTexture = texture2D( bumpMap, currentTextureCoords ).r;",
    "		}",
    "		#ifdef USE_STEEP_PARALLAX",
    "			return currentTextureCoords;",
    "		#elif defined( USE_RELIEF_PARALLAX )",
    "			vec2 deltaTexCoord = dtex / 2.0;",
    "			float deltaHeight = layerHeight / 2.0;",
    // Return to the mid point of previous layer
    "			currentTextureCoords += deltaTexCoord;",
    "			currentLayerHeight -= deltaHeight;",
    // Binary search to increase precision of Steep Parallax Mapping
    "			const int numSearches = 5;",
    "			for ( int i = 0; i < numSearches; i += 1 ) {",
    "				deltaTexCoord /= 2.0;",
    "				deltaHeight /= 2.0;",
    "				heightFromTexture = texture2D( bumpMap, currentTextureCoords ).r;",
    // Shift along or against vector V
    "				if( heightFromTexture > currentLayerHeight ) {",
    // Below the surface
    "					currentTextureCoords -= deltaTexCoord;",
    "					currentLayerHeight += deltaHeight;",
    "				} else {",
    // above the surface
    "					currentTextureCoords += deltaTexCoord;",
    "					currentLayerHeight -= deltaHeight;",
    "				}",
    "			}",
    "			return currentTextureCoords;",
    "		#elif defined( USE_OCLUSION_PARALLAX )",
    "			vec2 prevTCoords = currentTextureCoords + dtex;",
    // Heights for linear interpolation
    "			float nextH = heightFromTexture - currentLayerHeight;",
    "			float prevH = texture2D( bumpMap, prevTCoords ).r - currentLayerHeight + layerHeight;",
    // Proportions for linear interpolation
    "			float weight = nextH / ( nextH - prevH );",
    // Interpolation of texture coordinates
    "			return prevTCoords * weight + currentTextureCoords * ( 1.0 - weight );",
    "		#else",
    // NO_PARALLAX
    "			return vUv;",
    "		#endif",
    "	}",
    "#endif",
    "vec2 perturbUv( vec3 surfPosition, vec3 surfNormal, vec3 viewPosition ) {",
    "	vec2 texDx = dFdx( vUv );",
    "	vec2 texDy = dFdy( vUv );",
    "	vec3 vSigmaX = dFdx( surfPosition );",
    "	vec3 vSigmaY = dFdy( surfPosition );",
    "	vec3 vR1 = cross( vSigmaY, surfNormal );",
    "	vec3 vR2 = cross( surfNormal, vSigmaX );",
    "	float fDet = dot( vSigmaX, vR1 );",
    "	vec2 vProjVscr = ( 1.0 / fDet ) * vec2( dot( vR1, viewPosition ), dot( vR2, viewPosition ) );",
    "	vec3 vProjVtex;",
    "	vProjVtex.xy = texDx * vProjVscr.x + texDy * vProjVscr.y;",
    "	vProjVtex.z = dot( surfNormal, viewPosition );",
    "	return parallaxMap( vProjVtex );",
    "}",
    "void main() {",
    "	vec2 mapUv = perturbUv( -vViewPosition, normalize( vNormal ), normalize( vViewPosition ) );",
    "	gl_FragColor = texture2D( map, mapUv );",
    "}"
  ].join("\n")
};

// node_modules/three-stdlib/shaders/PixelShader.js
var PixelShader = {
  uniforms: {
    tDiffuse: { value: null },
    resolution: { value: null },
    pixelSize: { value: 1 }
  },
  vertexShader: [
    "varying highp vec2 vUv;",
    "void main() {",
    "vUv = uv;",
    "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
    "}"
  ].join("\n"),
  fragmentShader: [
    "uniform sampler2D tDiffuse;",
    "uniform float pixelSize;",
    "uniform vec2 resolution;",
    "varying highp vec2 vUv;",
    "void main(){",
    "vec2 dxy = pixelSize / resolution;",
    "vec2 coord = dxy * floor( vUv / dxy );",
    "gl_FragColor = texture2D(tDiffuse, coord);",
    "}"
  ].join("\n")
};

// node_modules/three-stdlib/shaders/RGBShiftShader.js
var RGBShiftShader = {
  uniforms: {
    tDiffuse: { value: null },
    amount: { value: 5e-3 },
    angle: { value: 0 }
  },
  vertexShader: [
    "varying vec2 vUv;",
    "void main() {",
    "	vUv = uv;",
    "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
    "}"
  ].join("\n"),
  fragmentShader: [
    "uniform sampler2D tDiffuse;",
    "uniform float amount;",
    "uniform float angle;",
    "varying vec2 vUv;",
    "void main() {",
    "	vec2 offset = amount * vec2( cos(angle), sin(angle));",
    "	vec4 cr = texture2D(tDiffuse, vUv + offset);",
    "	vec4 cga = texture2D(tDiffuse, vUv);",
    "	vec4 cb = texture2D(tDiffuse, vUv - offset);",
    "	gl_FragColor = vec4(cr.r, cga.g, cb.b, cga.a);",
    "}"
  ].join("\n")
};

// node_modules/three-stdlib/shaders/SepiaShader.js
var SepiaShader = {
  uniforms: {
    tDiffuse: { value: null },
    amount: { value: 1 }
  },
  vertexShader: [
    "varying vec2 vUv;",
    "void main() {",
    "	vUv = uv;",
    "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
    "}"
  ].join("\n"),
  fragmentShader: [
    "uniform float amount;",
    "uniform sampler2D tDiffuse;",
    "varying vec2 vUv;",
    "void main() {",
    "	vec4 color = texture2D( tDiffuse, vUv );",
    "	vec3 c = color.rgb;",
    "	color.r = dot( c, vec3( 1.0 - 0.607 * amount, 0.769 * amount, 0.189 * amount ) );",
    "	color.g = dot( c, vec3( 0.349 * amount, 1.0 - 0.314 * amount, 0.168 * amount ) );",
    "	color.b = dot( c, vec3( 0.272 * amount, 0.534 * amount, 1.0 - 0.869 * amount ) );",
    "	gl_FragColor = vec4( min( vec3( 1.0 ), color.rgb ), color.a );",
    "}"
  ].join("\n")
};

// node_modules/three-stdlib/shaders/SobelOperatorShader.js
var SobelOperatorShader = {
  uniforms: {
    tDiffuse: { value: null },
    resolution: { value: new Vector2() }
  },
  vertexShader: [
    "varying vec2 vUv;",
    "void main() {",
    "	vUv = uv;",
    "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
    "}"
  ].join("\n"),
  fragmentShader: [
    "uniform sampler2D tDiffuse;",
    "uniform vec2 resolution;",
    "varying vec2 vUv;",
    "void main() {",
    "	vec2 texel = vec2( 1.0 / resolution.x, 1.0 / resolution.y );",
    // kernel definition (in glsl matrices are filled in column-major order)
    "	const mat3 Gx = mat3( -1, -2, -1, 0, 0, 0, 1, 2, 1 );",
    // x direction kernel
    "	const mat3 Gy = mat3( -1, 0, 1, -2, 0, 2, -1, 0, 1 );",
    // y direction kernel
    // fetch the 3x3 neighbourhood of a fragment
    // first column
    "	float tx0y0 = texture2D( tDiffuse, vUv + texel * vec2( -1, -1 ) ).r;",
    "	float tx0y1 = texture2D( tDiffuse, vUv + texel * vec2( -1,  0 ) ).r;",
    "	float tx0y2 = texture2D( tDiffuse, vUv + texel * vec2( -1,  1 ) ).r;",
    // second column
    "	float tx1y0 = texture2D( tDiffuse, vUv + texel * vec2(  0, -1 ) ).r;",
    "	float tx1y1 = texture2D( tDiffuse, vUv + texel * vec2(  0,  0 ) ).r;",
    "	float tx1y2 = texture2D( tDiffuse, vUv + texel * vec2(  0,  1 ) ).r;",
    // third column
    "	float tx2y0 = texture2D( tDiffuse, vUv + texel * vec2(  1, -1 ) ).r;",
    "	float tx2y1 = texture2D( tDiffuse, vUv + texel * vec2(  1,  0 ) ).r;",
    "	float tx2y2 = texture2D( tDiffuse, vUv + texel * vec2(  1,  1 ) ).r;",
    // gradient value in x direction
    "	float valueGx = Gx[0][0] * tx0y0 + Gx[1][0] * tx1y0 + Gx[2][0] * tx2y0 + ",
    "		Gx[0][1] * tx0y1 + Gx[1][1] * tx1y1 + Gx[2][1] * tx2y1 + ",
    "		Gx[0][2] * tx0y2 + Gx[1][2] * tx1y2 + Gx[2][2] * tx2y2; ",
    // gradient value in y direction
    "	float valueGy = Gy[0][0] * tx0y0 + Gy[1][0] * tx1y0 + Gy[2][0] * tx2y0 + ",
    "		Gy[0][1] * tx0y1 + Gy[1][1] * tx1y1 + Gy[2][1] * tx2y1 + ",
    "		Gy[0][2] * tx0y2 + Gy[1][2] * tx1y2 + Gy[2][2] * tx2y2; ",
    // magnitute of the total gradient
    "	float G = sqrt( ( valueGx * valueGx ) + ( valueGy * valueGy ) );",
    "	gl_FragColor = vec4( vec3( G ), 1 );",
    "}"
  ].join("\n")
};

// node_modules/three-stdlib/shaders/TechnicolorShader.js
var TechnicolorShader = {
  uniforms: {
    tDiffuse: { value: null }
  },
  vertexShader: [
    "varying vec2 vUv;",
    "void main() {",
    "	vUv = uv;",
    "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
    "}"
  ].join("\n"),
  fragmentShader: [
    "uniform sampler2D tDiffuse;",
    "varying vec2 vUv;",
    "void main() {",
    "	vec4 tex = texture2D( tDiffuse, vec2( vUv.x, vUv.y ) );",
    "	vec4 newTex = vec4(tex.r, (tex.g + tex.b) * .5, (tex.g + tex.b) * .5, 1.0);",
    "	gl_FragColor = newTex;",
    "}"
  ].join("\n")
};

// node_modules/three-stdlib/shaders/ToonShader.js
var ToonShader1 = {
  uniforms: {
    uDirLightPos: { value: new Vector3() },
    uDirLightColor: { value: new Color(15658734) },
    uAmbientLightColor: { value: new Color(328965) },
    uBaseColor: { value: new Color(16777215) }
  },
  vertexShader: [
    "varying vec3 vNormal;",
    "varying vec3 vRefract;",
    "void main() {",
    "	vec4 worldPosition = modelMatrix * vec4( position, 1.0 );",
    "	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );",
    "	vec3 worldNormal = normalize ( mat3( modelMatrix[0].xyz, modelMatrix[1].xyz, modelMatrix[2].xyz ) * normal );",
    "	vNormal = normalize( normalMatrix * normal );",
    "	vec3 I = worldPosition.xyz - cameraPosition;",
    "	vRefract = refract( normalize( I ), worldNormal, 1.02 );",
    "	gl_Position = projectionMatrix * mvPosition;",
    "}"
  ].join("\n"),
  fragmentShader: [
    "uniform vec3 uBaseColor;",
    "uniform vec3 uDirLightPos;",
    "uniform vec3 uDirLightColor;",
    "uniform vec3 uAmbientLightColor;",
    "varying vec3 vNormal;",
    "varying vec3 vRefract;",
    "void main() {",
    "	float directionalLightWeighting = max( dot( normalize( vNormal ), uDirLightPos ), 0.0);",
    "	vec3 lightWeighting = uAmbientLightColor + uDirLightColor * directionalLightWeighting;",
    "	float intensity = smoothstep( - 0.5, 1.0, pow( length(lightWeighting), 20.0 ) );",
    "	intensity += length(lightWeighting) * 0.2;",
    "	float cameraWeighting = dot( normalize( vNormal ), vRefract );",
    "	intensity += pow( 1.0 - length( cameraWeighting ), 6.0 );",
    "	intensity = intensity * 0.2 + 0.3;",
    "	if ( intensity < 0.50 ) {",
    "		gl_FragColor = vec4( 2.0 * intensity * uBaseColor, 1.0 );",
    "	} else {",
    "		gl_FragColor = vec4( 1.0 - 2.0 * ( 1.0 - intensity ) * ( 1.0 - uBaseColor ), 1.0 );",
    "}",
    "}"
  ].join("\n")
};
var ToonShader2 = {
  uniforms: {
    uDirLightPos: { value: new Vector3() },
    uDirLightColor: { value: new Color(15658734) },
    uAmbientLightColor: { value: new Color(328965) },
    uBaseColor: { value: new Color(15658734) },
    uLineColor1: { value: new Color(8421504) },
    uLineColor2: { value: new Color(0) },
    uLineColor3: { value: new Color(0) },
    uLineColor4: { value: new Color(0) }
  },
  vertexShader: [
    "varying vec3 vNormal;",
    "void main() {",
    "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
    "	vNormal = normalize( normalMatrix * normal );",
    "}"
  ].join("\n"),
  fragmentShader: [
    "uniform vec3 uBaseColor;",
    "uniform vec3 uLineColor1;",
    "uniform vec3 uLineColor2;",
    "uniform vec3 uLineColor3;",
    "uniform vec3 uLineColor4;",
    "uniform vec3 uDirLightPos;",
    "uniform vec3 uDirLightColor;",
    "uniform vec3 uAmbientLightColor;",
    "varying vec3 vNormal;",
    "void main() {",
    "	float camera = max( dot( normalize( vNormal ), vec3( 0.0, 0.0, 1.0 ) ), 0.4);",
    "	float light = max( dot( normalize( vNormal ), uDirLightPos ), 0.0);",
    "	gl_FragColor = vec4( uBaseColor, 1.0 );",
    "	if ( length(uAmbientLightColor + uDirLightColor * light) < 1.00 ) {",
    "		gl_FragColor *= vec4( uLineColor1, 1.0 );",
    "	}",
    "	if ( length(uAmbientLightColor + uDirLightColor * camera) < 0.50 ) {",
    "		gl_FragColor *= vec4( uLineColor2, 1.0 );",
    "	}",
    "}"
  ].join("\n")
};
var ToonShaderHatching = {
  uniforms: {
    uDirLightPos: { value: new Vector3() },
    uDirLightColor: { value: new Color(15658734) },
    uAmbientLightColor: { value: new Color(328965) },
    uBaseColor: { value: new Color(16777215) },
    uLineColor1: { value: new Color(0) },
    uLineColor2: { value: new Color(0) },
    uLineColor3: { value: new Color(0) },
    uLineColor4: { value: new Color(0) }
  },
  vertexShader: [
    "varying vec3 vNormal;",
    "void main() {",
    "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
    "	vNormal = normalize( normalMatrix * normal );",
    "}"
  ].join("\n"),
  fragmentShader: [
    "uniform vec3 uBaseColor;",
    "uniform vec3 uLineColor1;",
    "uniform vec3 uLineColor2;",
    "uniform vec3 uLineColor3;",
    "uniform vec3 uLineColor4;",
    "uniform vec3 uDirLightPos;",
    "uniform vec3 uDirLightColor;",
    "uniform vec3 uAmbientLightColor;",
    "varying vec3 vNormal;",
    "void main() {",
    "	float directionalLightWeighting = max( dot( normalize(vNormal), uDirLightPos ), 0.0);",
    "	vec3 lightWeighting = uAmbientLightColor + uDirLightColor * directionalLightWeighting;",
    "	gl_FragColor = vec4( uBaseColor, 1.0 );",
    "	if ( length(lightWeighting) < 1.00 ) {",
    "		if ( mod(gl_FragCoord.x + gl_FragCoord.y, 10.0) == 0.0) {",
    "			gl_FragColor = vec4( uLineColor1, 1.0 );",
    "		}",
    "	}",
    "	if ( length(lightWeighting) < 0.75 ) {",
    "		if (mod(gl_FragCoord.x - gl_FragCoord.y, 10.0) == 0.0) {",
    "			gl_FragColor = vec4( uLineColor2, 1.0 );",
    "		}",
    "	}",
    "	if ( length(lightWeighting) < 0.50 ) {",
    "		if (mod(gl_FragCoord.x + gl_FragCoord.y - 5.0, 10.0) == 0.0) {",
    "			gl_FragColor = vec4( uLineColor3, 1.0 );",
    "		}",
    "	}",
    "	if ( length(lightWeighting) < 0.3465 ) {",
    "		if (mod(gl_FragCoord.x - gl_FragCoord.y - 5.0, 10.0) == 0.0) {",
    "			gl_FragColor = vec4( uLineColor4, 1.0 );",
    "	}",
    "	}",
    "}"
  ].join("\n")
};
var ToonShaderDotted = {
  uniforms: {
    uDirLightPos: { value: new Vector3() },
    uDirLightColor: { value: new Color(15658734) },
    uAmbientLightColor: { value: new Color(328965) },
    uBaseColor: { value: new Color(16777215) },
    uLineColor1: { value: new Color(0) }
  },
  vertexShader: [
    "varying vec3 vNormal;",
    "void main() {",
    "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
    "	vNormal = normalize( normalMatrix * normal );",
    "}"
  ].join("\n"),
  fragmentShader: [
    "uniform vec3 uBaseColor;",
    "uniform vec3 uLineColor1;",
    "uniform vec3 uLineColor2;",
    "uniform vec3 uLineColor3;",
    "uniform vec3 uLineColor4;",
    "uniform vec3 uDirLightPos;",
    "uniform vec3 uDirLightColor;",
    "uniform vec3 uAmbientLightColor;",
    "varying vec3 vNormal;",
    "void main() {",
    "float directionalLightWeighting = max( dot( normalize(vNormal), uDirLightPos ), 0.0);",
    "vec3 lightWeighting = uAmbientLightColor + uDirLightColor * directionalLightWeighting;",
    "gl_FragColor = vec4( uBaseColor, 1.0 );",
    "if ( length(lightWeighting) < 1.00 ) {",
    "		if ( ( mod(gl_FragCoord.x, 4.001) + mod(gl_FragCoord.y, 4.0) ) > 6.00 ) {",
    "			gl_FragColor = vec4( uLineColor1, 1.0 );",
    "		}",
    "	}",
    "	if ( length(lightWeighting) < 0.50 ) {",
    "		if ( ( mod(gl_FragCoord.x + 2.0, 4.001) + mod(gl_FragCoord.y + 2.0, 4.0) ) > 6.00 ) {",
    "			gl_FragColor = vec4( uLineColor1, 1.0 );",
    "		}",
    "	}",
    "}"
  ].join("\n")
};

// node_modules/three-stdlib/shaders/TriangleBlurShader.js
var TriangleBlurShader = {
  uniforms: {
    texture: { value: null },
    delta: { value: new Vector2(1, 1) }
  },
  vertexShader: [
    "varying vec2 vUv;",
    "void main() {",
    "	vUv = uv;",
    "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
    "}"
  ].join("\n"),
  fragmentShader: [
    "#include <common>",
    "#define ITERATIONS 10.0",
    "uniform sampler2D texture;",
    "uniform vec2 delta;",
    "varying vec2 vUv;",
    "void main() {",
    "	vec4 color = vec4( 0.0 );",
    "	float total = 0.0;",
    // randomize the lookup values to hide the fixed number of samples
    "	float offset = rand( vUv );",
    "	for ( float t = -ITERATIONS; t <= ITERATIONS; t ++ ) {",
    "		float percent = ( t + offset - 0.5 ) / ITERATIONS;",
    "		float weight = 1.0 - abs( percent );",
    "		color += texture2D( texture, vUv + delta * percent ) * weight;",
    "		total += weight;",
    "	}",
    "	gl_FragColor = color / total;",
    "}"
  ].join("\n")
};

// node_modules/three-stdlib/shaders/VerticalBlurShader.js
var VerticalBlurShader = {
  uniforms: {
    tDiffuse: { value: null },
    v: { value: 1 / 512 }
  },
  vertexShader: (
    /* glsl */
    `
    varying vec2 vUv;

    void main() {

      vUv = uv;
      gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

    }
  `
  ),
  fragmentShader: (
    /* glsl */
    `

  uniform sampler2D tDiffuse;
  uniform float v;

  varying vec2 vUv;

  void main() {

    vec4 sum = vec4( 0.0 );

    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 4.0 * v ) ) * 0.051;
    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 3.0 * v ) ) * 0.0918;
    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 2.0 * v ) ) * 0.12245;
    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 1.0 * v ) ) * 0.1531;
    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;
    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 1.0 * v ) ) * 0.1531;
    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 2.0 * v ) ) * 0.12245;
    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 3.0 * v ) ) * 0.0918;
    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 4.0 * v ) ) * 0.051;

    gl_FragColor = sum;

  }
  `
  )
};

// node_modules/three-stdlib/shaders/VerticalTiltShiftShader.js
var VerticalTiltShiftShader = {
  uniforms: {
    tDiffuse: { value: null },
    v: { value: 1 / 512 },
    r: { value: 0.35 }
  },
  vertexShader: [
    "varying vec2 vUv;",
    "void main() {",
    "	vUv = uv;",
    "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
    "}"
  ].join("\n"),
  fragmentShader: [
    "uniform sampler2D tDiffuse;",
    "uniform float v;",
    "uniform float r;",
    "varying vec2 vUv;",
    "void main() {",
    "	vec4 sum = vec4( 0.0 );",
    "	float vv = v * abs( r - vUv.y );",
    "	sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 4.0 * vv ) ) * 0.051;",
    "	sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 3.0 * vv ) ) * 0.0918;",
    "	sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 2.0 * vv ) ) * 0.12245;",
    "	sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 1.0 * vv ) ) * 0.1531;",
    "	sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;",
    "	sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 1.0 * vv ) ) * 0.1531;",
    "	sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 2.0 * vv ) ) * 0.12245;",
    "	sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 3.0 * vv ) ) * 0.0918;",
    "	sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 4.0 * vv ) ) * 0.051;",
    "	gl_FragColor = sum;",
    "}"
  ].join("\n")
};

// node_modules/three-stdlib/shaders/VignetteShader.js
var VignetteShader = {
  uniforms: {
    tDiffuse: { value: null },
    offset: { value: 1 },
    darkness: { value: 1 }
  },
  vertexShader: [
    "varying vec2 vUv;",
    "void main() {",
    "	vUv = uv;",
    "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
    "}"
  ].join("\n"),
  fragmentShader: [
    "uniform float offset;",
    "uniform float darkness;",
    "uniform sampler2D tDiffuse;",
    "varying vec2 vUv;",
    "void main() {",
    // Eskil's vignette
    "	vec4 texel = texture2D( tDiffuse, vUv );",
    "	vec2 uv = ( vUv - vec2( 0.5 ) ) * vec2( offset );",
    "	gl_FragColor = vec4( mix( texel.rgb, vec3( 1.0 - darkness ), dot( uv, uv ) ), texel.a );",
    /*
    		// alternative version from glfx.js
    		// this one makes more "dusty" look (as opposed to "burned")
    
    		"	vec4 color = texture2D( tDiffuse, vUv );",
    		"	float dist = distance( vUv, vec2( 0.5 ) );",
    		"	color.rgb *= smoothstep( 0.8, offset * 0.799, dist *( darkness + offset ) );",
    		"	gl_FragColor = color;",
    		*/
    "}"
  ].join("\n")
};

// node_modules/three-stdlib/shaders/VolumeShader.js
var VolumeRenderShader1 = {
  uniforms: {
    u_size: { value: new Vector3(1, 1, 1) },
    u_renderstyle: { value: 0 },
    u_renderthreshold: { value: 0.5 },
    u_clim: { value: new Vector2(1, 1) },
    u_data: { value: null },
    u_cmdata: { value: null }
  },
  vertexShader: [
    "		varying vec4 v_nearpos;",
    "		varying vec4 v_farpos;",
    "		varying vec3 v_position;",
    "		void main() {",
    // Prepare transforms to map to "camera view". See also:
    // https://threejs.org/docs/#api/renderers/webgl/WebGLProgram
    "				mat4 viewtransformf = modelViewMatrix;",
    "				mat4 viewtransformi = inverse(modelViewMatrix);",
    // Project local vertex coordinate to camera position. Then do a step
    // backward (in cam coords) to the near clipping plane, and project back. Do
    // the same for the far clipping plane. This gives us all the information we
    // need to calculate the ray and truncate it to the viewing cone.
    "				vec4 position4 = vec4(position, 1.0);",
    "				vec4 pos_in_cam = viewtransformf * position4;",
    // Intersection of ray and near clipping plane (z = -1 in clip coords)
    "				pos_in_cam.z = -pos_in_cam.w;",
    "				v_nearpos = viewtransformi * pos_in_cam;",
    // Intersection of ray and far clipping plane (z = +1 in clip coords)
    "				pos_in_cam.z = pos_in_cam.w;",
    "				v_farpos = viewtransformi * pos_in_cam;",
    // Set varyings and output pos
    "				v_position = position;",
    "				gl_Position = projectionMatrix * viewMatrix * modelMatrix * position4;",
    "		}"
  ].join("\n"),
  fragmentShader: [
    "		precision highp float;",
    "		precision mediump sampler3D;",
    "		uniform vec3 u_size;",
    "		uniform int u_renderstyle;",
    "		uniform float u_renderthreshold;",
    "		uniform vec2 u_clim;",
    "		uniform sampler3D u_data;",
    "		uniform sampler2D u_cmdata;",
    "		varying vec3 v_position;",
    "		varying vec4 v_nearpos;",
    "		varying vec4 v_farpos;",
    // The maximum distance through our rendering volume is sqrt(3).
    "		const int MAX_STEPS = 887;	// 887 for 512^3, 1774 for 1024^3",
    "		const int REFINEMENT_STEPS = 4;",
    "		const float relative_step_size = 1.0;",
    "		const vec4 ambient_color = vec4(0.2, 0.4, 0.2, 1.0);",
    "		const vec4 diffuse_color = vec4(0.8, 0.2, 0.2, 1.0);",
    "		const vec4 specular_color = vec4(1.0, 1.0, 1.0, 1.0);",
    "		const float shininess = 40.0;",
    "		void cast_mip(vec3 start_loc, vec3 step, int nsteps, vec3 view_ray);",
    "		void cast_iso(vec3 start_loc, vec3 step, int nsteps, vec3 view_ray);",
    "		float sample1(vec3 texcoords);",
    "		vec4 apply_colormap(float val);",
    "		vec4 add_lighting(float val, vec3 loc, vec3 step, vec3 view_ray);",
    "		void main() {",
    // Normalize clipping plane info
    "				vec3 farpos = v_farpos.xyz / v_farpos.w;",
    "				vec3 nearpos = v_nearpos.xyz / v_nearpos.w;",
    // Calculate unit vector pointing in the view direction through this fragment.
    "				vec3 view_ray = normalize(nearpos.xyz - farpos.xyz);",
    // Compute the (negative) distance to the front surface or near clipping plane.
    // v_position is the back face of the cuboid, so the initial distance calculated in the dot
    // product below is the distance from near clip plane to the back of the cuboid
    "				float distance = dot(nearpos - v_position, view_ray);",
    "				distance = max(distance, min((-0.5 - v_position.x) / view_ray.x,",
    "																		(u_size.x - 0.5 - v_position.x) / view_ray.x));",
    "				distance = max(distance, min((-0.5 - v_position.y) / view_ray.y,",
    "																		(u_size.y - 0.5 - v_position.y) / view_ray.y));",
    "				distance = max(distance, min((-0.5 - v_position.z) / view_ray.z,",
    "																		(u_size.z - 0.5 - v_position.z) / view_ray.z));",
    // Now we have the starting position on the front surface
    "				vec3 front = v_position + view_ray * distance;",
    // Decide how many steps to take
    "				int nsteps = int(-distance / relative_step_size + 0.5);",
    "				if ( nsteps < 1 )",
    "						discard;",
    // Get starting location and step vector in texture coordinates
    "				vec3 step = ((v_position - front) / u_size) / float(nsteps);",
    "				vec3 start_loc = front / u_size;",
    // For testing: show the number of steps. This helps to establish
    // whether the rays are correctly oriented
    //'gl_FragColor = vec4(0.0, float(nsteps) / 1.0 / u_size.x, 1.0, 1.0);',
    //'return;',
    "				if (u_renderstyle == 0)",
    "						cast_mip(start_loc, step, nsteps, view_ray);",
    "				else if (u_renderstyle == 1)",
    "						cast_iso(start_loc, step, nsteps, view_ray);",
    "				if (gl_FragColor.a < 0.05)",
    "						discard;",
    "		}",
    "		float sample1(vec3 texcoords) {",
    "				/* Sample float value from a 3D texture. Assumes intensity data. */",
    "				return texture(u_data, texcoords.xyz).r;",
    "		}",
    "		vec4 apply_colormap(float val) {",
    "				val = (val - u_clim[0]) / (u_clim[1] - u_clim[0]);",
    "				return texture2D(u_cmdata, vec2(val, 0.5));",
    "		}",
    "		void cast_mip(vec3 start_loc, vec3 step, int nsteps, vec3 view_ray) {",
    "				float max_val = -1e6;",
    "				int max_i = 100;",
    "				vec3 loc = start_loc;",
    // Enter the raycasting loop. In WebGL 1 the loop index cannot be compared with
    // non-constant expression. So we use a hard-coded max, and an additional condition
    // inside the loop.
    "				for (int iter=0; iter<MAX_STEPS; iter++) {",
    "						if (iter >= nsteps)",
    "								break;",
    // Sample from the 3D texture
    "						float val = sample1(loc);",
    // Apply MIP operation
    "						if (val > max_val) {",
    "								max_val = val;",
    "								max_i = iter;",
    "						}",
    // Advance location deeper into the volume
    "						loc += step;",
    "				}",
    // Refine location, gives crispier images
    "				vec3 iloc = start_loc + step * (float(max_i) - 0.5);",
    "				vec3 istep = step / float(REFINEMENT_STEPS);",
    "				for (int i=0; i<REFINEMENT_STEPS; i++) {",
    "						max_val = max(max_val, sample1(iloc));",
    "						iloc += istep;",
    "				}",
    // Resolve final color
    "				gl_FragColor = apply_colormap(max_val);",
    "		}",
    "		void cast_iso(vec3 start_loc, vec3 step, int nsteps, vec3 view_ray) {",
    "				gl_FragColor = vec4(0.0);	// init transparent",
    "				vec4 color3 = vec4(0.0);	// final color",
    "				vec3 dstep = 1.5 / u_size;	// step to sample derivative",
    "				vec3 loc = start_loc;",
    "				float low_threshold = u_renderthreshold - 0.02 * (u_clim[1] - u_clim[0]);",
    // Enter the raycasting loop. In WebGL 1 the loop index cannot be compared with
    // non-constant expression. So we use a hard-coded max, and an additional condition
    // inside the loop.
    "				for (int iter=0; iter<MAX_STEPS; iter++) {",
    "						if (iter >= nsteps)",
    "								break;",
    // Sample from the 3D texture
    "						float val = sample1(loc);",
    "						if (val > low_threshold) {",
    // Take the last interval in smaller steps
    "								vec3 iloc = loc - 0.5 * step;",
    "								vec3 istep = step / float(REFINEMENT_STEPS);",
    "								for (int i=0; i<REFINEMENT_STEPS; i++) {",
    "										val = sample1(iloc);",
    "										if (val > u_renderthreshold) {",
    "												gl_FragColor = add_lighting(val, iloc, dstep, view_ray);",
    "												return;",
    "										}",
    "										iloc += istep;",
    "								}",
    "						}",
    // Advance location deeper into the volume
    "						loc += step;",
    "				}",
    "		}",
    "		vec4 add_lighting(float val, vec3 loc, vec3 step, vec3 view_ray)",
    "		{",
    // Calculate color by incorporating lighting
    // View direction
    "				vec3 V = normalize(view_ray);",
    // calculate normal vector from gradient
    "				vec3 N;",
    "				float val1, val2;",
    "				val1 = sample1(loc + vec3(-step[0], 0.0, 0.0));",
    "				val2 = sample1(loc + vec3(+step[0], 0.0, 0.0));",
    "				N[0] = val1 - val2;",
    "				val = max(max(val1, val2), val);",
    "				val1 = sample1(loc + vec3(0.0, -step[1], 0.0));",
    "				val2 = sample1(loc + vec3(0.0, +step[1], 0.0));",
    "				N[1] = val1 - val2;",
    "				val = max(max(val1, val2), val);",
    "				val1 = sample1(loc + vec3(0.0, 0.0, -step[2]));",
    "				val2 = sample1(loc + vec3(0.0, 0.0, +step[2]));",
    "				N[2] = val1 - val2;",
    "				val = max(max(val1, val2), val);",
    "				float gm = length(N); // gradient magnitude",
    "				N = normalize(N);",
    // Flip normal so it points towards viewer
    "				float Nselect = float(dot(N, V) > 0.0);",
    "				N = (2.0 * Nselect - 1.0) * N;	// ==	Nselect * N - (1.0-Nselect)*N;",
    // Init colors
    "				vec4 ambient_color = vec4(0.0, 0.0, 0.0, 0.0);",
    "				vec4 diffuse_color = vec4(0.0, 0.0, 0.0, 0.0);",
    "				vec4 specular_color = vec4(0.0, 0.0, 0.0, 0.0);",
    // note: could allow multiple lights
    "				for (int i=0; i<1; i++)",
    "				{",
    // Get light direction (make sure to prevent zero devision)
    "						vec3 L = normalize(view_ray);	//lightDirs[i];",
    "						float lightEnabled = float( length(L) > 0.0 );",
    "						L = normalize(L + (1.0 - lightEnabled));",
    // Calculate lighting properties
    "						float lambertTerm = clamp(dot(N, L), 0.0, 1.0);",
    "						vec3 H = normalize(L+V); // Halfway vector",
    "						float specularTerm = pow(max(dot(H, N), 0.0), shininess);",
    // Calculate mask
    "						float mask1 = lightEnabled;",
    // Calculate colors
    "						ambient_color +=	mask1 * ambient_color;	// * gl_LightSource[i].ambient;",
    "						diffuse_color +=	mask1 * lambertTerm;",
    "						specular_color += mask1 * specularTerm * specular_color;",
    "				}",
    // Calculate final color by componing different components
    "				vec4 final_color;",
    "				vec4 color = apply_colormap(val);",
    "				final_color = color * (ambient_color + diffuse_color) + specular_color;",
    "				final_color.a = color.a;",
    "				return final_color;",
    "		}"
  ].join("\n")
};

// node_modules/three-stdlib/shaders/WaterRefractionShader.js
var WaterRefractionShader = {
  uniforms: {
    color: {
      value: null
    },
    time: {
      value: 0
    },
    tDiffuse: {
      value: null
    },
    tDudv: {
      value: null
    },
    textureMatrix: {
      value: null
    }
  },
  vertexShader: [
    "uniform mat4 textureMatrix;",
    "varying vec2 vUv;",
    "varying vec4 vUvRefraction;",
    "void main() {",
    "	vUv = uv;",
    "	vUvRefraction = textureMatrix * vec4( position, 1.0 );",
    "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
    "}"
  ].join("\n"),
  fragmentShader: [
    "uniform vec3 color;",
    "uniform float time;",
    "uniform sampler2D tDiffuse;",
    "uniform sampler2D tDudv;",
    "varying vec2 vUv;",
    "varying vec4 vUvRefraction;",
    "float blendOverlay( float base, float blend ) {",
    "	return( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );",
    "}",
    "vec3 blendOverlay( vec3 base, vec3 blend ) {",
    "	return vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ),blendOverlay( base.b, blend.b ) );",
    "}",
    "void main() {",
    " float waveStrength = 0.1;",
    " float waveSpeed = 0.03;",
    // simple distortion (ripple) via dudv map (see https://www.youtube.com/watch?v=6B7IF6GOu7s)
    "	vec2 distortedUv = texture2D( tDudv, vec2( vUv.x + time * waveSpeed, vUv.y ) ).rg * waveStrength;",
    "	distortedUv = vUv.xy + vec2( distortedUv.x, distortedUv.y + time * waveSpeed );",
    "	vec2 distortion = ( texture2D( tDudv, distortedUv ).rg * 2.0 - 1.0 ) * waveStrength;",
    // new uv coords
    " vec4 uv = vec4( vUvRefraction );",
    " uv.xy += distortion;",
    "	vec4 base = texture2DProj( tDiffuse, uv );",
    "	gl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );",
    "}"
  ].join("\n")
};

// node_modules/three-stdlib/interactive/InteractiveGroup.js
var _pointer = new Vector2();

// node_modules/three-stdlib/interactive/SelectionBox.js
var frustum = new Frustum();
var center = new Vector3();
var tmpPoint = new Vector3();
var vecNear = new Vector3();
var vecTopLeft = new Vector3();
var vecTopRight = new Vector3();
var vecDownRight = new Vector3();
var vecDownLeft = new Vector3();
var vecFarTopLeft = new Vector3();
var vecFarTopRight = new Vector3();
var vecFarDownRight = new Vector3();
var vecFarDownLeft = new Vector3();
var vectemp1 = new Vector3();
var vectemp2 = new Vector3();
var vectemp3 = new Vector3();

// node_modules/three-stdlib/curves/NURBSUtils.js
function findSpan(p, u, U) {
  const n = U.length - p - 1;
  if (u >= U[n]) {
    return n - 1;
  }
  if (u <= U[p]) {
    return p;
  }
  let low = p;
  let high = n;
  let mid = Math.floor((low + high) / 2);
  while (u < U[mid] || u >= U[mid + 1]) {
    if (u < U[mid]) {
      high = mid;
    } else {
      low = mid;
    }
    mid = Math.floor((low + high) / 2);
  }
  return mid;
}
function calcBasisFunctions(span, u, p, U) {
  const N = [];
  const left = [];
  const right = [];
  N[0] = 1;
  for (let j = 1; j <= p; ++j) {
    left[j] = u - U[span + 1 - j];
    right[j] = U[span + j] - u;
    let saved = 0;
    for (let r = 0; r < j; ++r) {
      const rv = right[r + 1];
      const lv = left[j - r];
      const temp = N[r] / (rv + lv);
      N[r] = saved + rv * temp;
      saved = lv * temp;
    }
    N[j] = saved;
  }
  return N;
}
function calcBSplinePoint(p, U, P, u) {
  const span = findSpan(p, u, U);
  const N = calcBasisFunctions(span, u, p, U);
  const C2 = new Vector4(0, 0, 0, 0);
  for (let j = 0; j <= p; ++j) {
    const point = P[span - p + j];
    const Nj = N[j];
    const wNj = point.w * Nj;
    C2.x += point.x * wNj;
    C2.y += point.y * wNj;
    C2.z += point.z * wNj;
    C2.w += point.w * Nj;
  }
  return C2;
}
function calcBasisFunctionDerivatives(span, u, p, n, U) {
  const zeroArr = [];
  for (let i3 = 0; i3 <= p; ++i3)
    zeroArr[i3] = 0;
  const ders = [];
  for (let i3 = 0; i3 <= n; ++i3)
    ders[i3] = zeroArr.slice(0);
  const ndu = [];
  for (let i3 = 0; i3 <= p; ++i3)
    ndu[i3] = zeroArr.slice(0);
  ndu[0][0] = 1;
  const left = zeroArr.slice(0);
  const right = zeroArr.slice(0);
  for (let j = 1; j <= p; ++j) {
    left[j] = u - U[span + 1 - j];
    right[j] = U[span + j] - u;
    let saved = 0;
    for (let r2 = 0; r2 < j; ++r2) {
      const rv = right[r2 + 1];
      const lv = left[j - r2];
      ndu[j][r2] = rv + lv;
      const temp = ndu[r2][j - 1] / ndu[j][r2];
      ndu[r2][j] = saved + rv * temp;
      saved = lv * temp;
    }
    ndu[j][j] = saved;
  }
  for (let j = 0; j <= p; ++j) {
    ders[0][j] = ndu[j][p];
  }
  for (let r2 = 0; r2 <= p; ++r2) {
    let s1 = 0;
    let s2 = 1;
    const a4 = [];
    for (let i3 = 0; i3 <= p; ++i3) {
      a4[i3] = zeroArr.slice(0);
    }
    a4[0][0] = 1;
    for (let k = 1; k <= n; ++k) {
      let d = 0;
      const rk = r2 - k;
      const pk = p - k;
      if (r2 >= k) {
        a4[s2][0] = a4[s1][0] / ndu[pk + 1][rk];
        d = a4[s2][0] * ndu[rk][pk];
      }
      const j1 = rk >= -1 ? 1 : -rk;
      const j2 = r2 - 1 <= pk ? k - 1 : p - r2;
      for (let j3 = j1; j3 <= j2; ++j3) {
        a4[s2][j3] = (a4[s1][j3] - a4[s1][j3 - 1]) / ndu[pk + 1][rk + j3];
        d += a4[s2][j3] * ndu[rk + j3][pk];
      }
      if (r2 <= pk) {
        a4[s2][k] = -a4[s1][k - 1] / ndu[pk + 1][r2];
        d += a4[s2][k] * ndu[r2][pk];
      }
      ders[k][r2] = d;
      const j = s1;
      s1 = s2;
      s2 = j;
    }
  }
  let r = p;
  for (let k = 1; k <= n; ++k) {
    for (let j = 0; j <= p; ++j) {
      ders[k][j] *= r;
    }
    r *= p - k;
  }
  return ders;
}
function calcBSplineDerivatives(p, U, P, u, nd) {
  const du = nd < p ? nd : p;
  const CK = [];
  const span = findSpan(p, u, U);
  const nders = calcBasisFunctionDerivatives(span, u, p, du, U);
  const Pw = [];
  for (let i3 = 0; i3 < P.length; ++i3) {
    const point = P[i3].clone();
    const w = point.w;
    point.x *= w;
    point.y *= w;
    point.z *= w;
    Pw[i3] = point;
  }
  for (let k = 0; k <= du; ++k) {
    const point = Pw[span - p].clone().multiplyScalar(nders[k][0]);
    for (let j = 1; j <= p; ++j) {
      point.add(Pw[span - p + j].clone().multiplyScalar(nders[k][j]));
    }
    CK[k] = point;
  }
  for (let k = du + 1; k <= nd + 1; ++k) {
    CK[k] = new Vector4(0, 0, 0);
  }
  return CK;
}
function calcKoverI(k, i3) {
  let nom = 1;
  for (let j = 2; j <= k; ++j) {
    nom *= j;
  }
  let denom = 1;
  for (let j = 2; j <= i3; ++j) {
    denom *= j;
  }
  for (let j = 2; j <= k - i3; ++j) {
    denom *= j;
  }
  return nom / denom;
}
function calcRationalCurveDerivatives(Pders) {
  const nd = Pders.length;
  const Aders = [];
  const wders = [];
  for (let i3 = 0; i3 < nd; ++i3) {
    const point = Pders[i3];
    Aders[i3] = new Vector3(point.x, point.y, point.z);
    wders[i3] = point.w;
  }
  const CK = [];
  for (let k = 0; k < nd; ++k) {
    const v = Aders[k].clone();
    for (let i3 = 1; i3 <= k; ++i3) {
      v.sub(CK[k - i3].clone().multiplyScalar(calcKoverI(k, i3) * wders[i3]));
    }
    CK[k] = v.divideScalar(wders[0]);
  }
  return CK;
}
function calcNURBSDerivatives(p, U, P, u, nd) {
  const Pders = calcBSplineDerivatives(p, U, P, u, nd);
  return calcRationalCurveDerivatives(Pders);
}

// node_modules/three-stdlib/curves/NURBSCurve.js
var NURBSCurve = class extends Curve {
  constructor(degree, knots, controlPoints, startKnot, endKnot) {
    super();
    this.degree = degree;
    this.knots = knots;
    this.controlPoints = [];
    this.startKnot = startKnot || 0;
    this.endKnot = endKnot || this.knots.length - 1;
    for (let i3 = 0; i3 < controlPoints.length; ++i3) {
      const point = controlPoints[i3];
      this.controlPoints[i3] = new Vector4(point.x, point.y, point.z, point.w);
    }
  }
  getPoint(t2, optionalTarget) {
    const point = optionalTarget || new Vector3();
    const u = this.knots[this.startKnot] + t2 * (this.knots[this.endKnot] - this.knots[this.startKnot]);
    const hpoint = calcBSplinePoint(this.degree, this.knots, this.controlPoints, u);
    if (hpoint.w != 1) {
      hpoint.divideScalar(hpoint.w);
    }
    return point.set(hpoint.x, hpoint.y, hpoint.z);
  }
  getTangent(t2, optionalTarget) {
    const tangent = optionalTarget || new Vector3();
    const u = this.knots[0] + t2 * (this.knots[this.knots.length - 1] - this.knots[0]);
    const ders = calcNURBSDerivatives(this.degree, this.knots, this.controlPoints, u, 1);
    tangent.copy(ders[1]).normalize();
    return tangent;
  }
};

// node_modules/three-stdlib/loaders/FBXLoader.js
var fbxTree;
var connections;
var sceneGraph;
var FBXLoader = class extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(url, onLoad, onProgress, onError) {
    const scope = this;
    const path = scope.path === "" ? LoaderUtils.extractUrlBase(url) : scope.path;
    const loader = new FileLoader(this.manager);
    loader.setPath(scope.path);
    loader.setResponseType("arraybuffer");
    loader.setRequestHeader(scope.requestHeader);
    loader.setWithCredentials(scope.withCredentials);
    loader.load(
      url,
      function(buffer) {
        try {
          onLoad(scope.parse(buffer, path));
        } catch (e) {
          if (onError) {
            onError(e);
          } else {
            console.error(e);
          }
          scope.manager.itemError(url);
        }
      },
      onProgress,
      onError
    );
  }
  parse(FBXBuffer, path) {
    if (isFbxFormatBinary(FBXBuffer)) {
      fbxTree = new BinaryParser().parse(FBXBuffer);
    } else {
      const FBXText = convertArrayBufferToString(FBXBuffer);
      if (!isFbxFormatASCII(FBXText)) {
        throw new Error("THREE.FBXLoader: Unknown format.");
      }
      if (getFbxVersion(FBXText) < 7e3) {
        throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: " + getFbxVersion(FBXText));
      }
      fbxTree = new TextParser().parse(FBXText);
    }
    const textureLoader = new TextureLoader(this.manager).setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin);
    return new FBXTreeParser(textureLoader, this.manager).parse(fbxTree);
  }
};
var FBXTreeParser = class {
  constructor(textureLoader, manager) {
    this.textureLoader = textureLoader;
    this.manager = manager;
  }
  parse() {
    connections = this.parseConnections();
    const images = this.parseImages();
    const textures = this.parseTextures(images);
    const materials = this.parseMaterials(textures);
    const deformers = this.parseDeformers();
    const geometryMap = new GeometryParser().parse(deformers);
    this.parseScene(deformers, geometryMap, materials);
    return sceneGraph;
  }
  // Parses FBXTree.Connections which holds parent-child connections between objects (e.g. material -> texture, model->geometry )
  // and details the connection type
  parseConnections() {
    const connectionMap = /* @__PURE__ */ new Map();
    if ("Connections" in fbxTree) {
      const rawConnections = fbxTree.Connections.connections;
      rawConnections.forEach(function(rawConnection) {
        const fromID = rawConnection[0];
        const toID = rawConnection[1];
        const relationship = rawConnection[2];
        if (!connectionMap.has(fromID)) {
          connectionMap.set(fromID, {
            parents: [],
            children: []
          });
        }
        const parentRelationship = { ID: toID, relationship };
        connectionMap.get(fromID).parents.push(parentRelationship);
        if (!connectionMap.has(toID)) {
          connectionMap.set(toID, {
            parents: [],
            children: []
          });
        }
        const childRelationship = { ID: fromID, relationship };
        connectionMap.get(toID).children.push(childRelationship);
      });
    }
    return connectionMap;
  }
  // Parse FBXTree.Objects.Video for embedded image data
  // These images are connected to textures in FBXTree.Objects.Textures
  // via FBXTree.Connections.
  parseImages() {
    const images = {};
    const blobs = {};
    if ("Video" in fbxTree.Objects) {
      const videoNodes = fbxTree.Objects.Video;
      for (const nodeID in videoNodes) {
        const videoNode = videoNodes[nodeID];
        const id = parseInt(nodeID);
        images[id] = videoNode.RelativeFilename || videoNode.Filename;
        if ("Content" in videoNode) {
          const arrayBufferContent = videoNode.Content instanceof ArrayBuffer && videoNode.Content.byteLength > 0;
          const base64Content = typeof videoNode.Content === "string" && videoNode.Content !== "";
          if (arrayBufferContent || base64Content) {
            const image = this.parseImage(videoNodes[nodeID]);
            blobs[videoNode.RelativeFilename || videoNode.Filename] = image;
          }
        }
      }
    }
    for (const id in images) {
      const filename = images[id];
      if (blobs[filename] !== void 0)
        images[id] = blobs[filename];
      else
        images[id] = images[id].split("\\").pop();
    }
    return images;
  }
  // Parse embedded image data in FBXTree.Video.Content
  parseImage(videoNode) {
    const content = videoNode.Content;
    const fileName = videoNode.RelativeFilename || videoNode.Filename;
    const extension = fileName.slice(fileName.lastIndexOf(".") + 1).toLowerCase();
    let type;
    switch (extension) {
      case "bmp":
        type = "image/bmp";
        break;
      case "jpg":
      case "jpeg":
        type = "image/jpeg";
        break;
      case "png":
        type = "image/png";
        break;
      case "tif":
        type = "image/tiff";
        break;
      case "tga":
        if (this.manager.getHandler(".tga") === null) {
          console.warn("FBXLoader: TGA loader not found, skipping ", fileName);
        }
        type = "image/tga";
        break;
      default:
        console.warn('FBXLoader: Image type "' + extension + '" is not supported.');
        return;
    }
    if (typeof content === "string") {
      return "data:" + type + ";base64," + content;
    } else {
      const array = new Uint8Array(content);
      return window.URL.createObjectURL(new Blob([array], { type }));
    }
  }
  // Parse nodes in FBXTree.Objects.Texture
  // These contain details such as UV scaling, cropping, rotation etc and are connected
  // to images in FBXTree.Objects.Video
  parseTextures(images) {
    const textureMap = /* @__PURE__ */ new Map();
    if ("Texture" in fbxTree.Objects) {
      const textureNodes = fbxTree.Objects.Texture;
      for (const nodeID in textureNodes) {
        const texture = this.parseTexture(textureNodes[nodeID], images);
        textureMap.set(parseInt(nodeID), texture);
      }
    }
    return textureMap;
  }
  // Parse individual node in FBXTree.Objects.Texture
  parseTexture(textureNode, images) {
    const texture = this.loadTexture(textureNode, images);
    texture.ID = textureNode.id;
    texture.name = textureNode.attrName;
    const wrapModeU = textureNode.WrapModeU;
    const wrapModeV = textureNode.WrapModeV;
    const valueU = wrapModeU !== void 0 ? wrapModeU.value : 0;
    const valueV = wrapModeV !== void 0 ? wrapModeV.value : 0;
    texture.wrapS = valueU === 0 ? RepeatWrapping : ClampToEdgeWrapping;
    texture.wrapT = valueV === 0 ? RepeatWrapping : ClampToEdgeWrapping;
    if ("Scaling" in textureNode) {
      const values = textureNode.Scaling.value;
      texture.repeat.x = values[0];
      texture.repeat.y = values[1];
    }
    return texture;
  }
  // load a texture specified as a blob or data URI, or via an external URL using TextureLoader
  loadTexture(textureNode, images) {
    let fileName;
    const currentPath = this.textureLoader.path;
    const children = connections.get(textureNode.id).children;
    if (children !== void 0 && children.length > 0 && images[children[0].ID] !== void 0) {
      fileName = images[children[0].ID];
      if (fileName.indexOf("blob:") === 0 || fileName.indexOf("data:") === 0) {
        this.textureLoader.setPath(void 0);
      }
    }
    let texture;
    const extension = textureNode.FileName.slice(-3).toLowerCase();
    if (extension === "tga") {
      const loader = this.manager.getHandler(".tga");
      if (loader === null) {
        console.warn("FBXLoader: TGA loader not found, creating placeholder texture for", textureNode.RelativeFilename);
        texture = new Texture();
      } else {
        loader.setPath(this.textureLoader.path);
        texture = loader.load(fileName);
      }
    } else if (extension === "psd") {
      console.warn(
        "FBXLoader: PSD textures are not supported, creating placeholder texture for",
        textureNode.RelativeFilename
      );
      texture = new Texture();
    } else {
      texture = this.textureLoader.load(fileName);
    }
    this.textureLoader.setPath(currentPath);
    return texture;
  }
  // Parse nodes in FBXTree.Objects.Material
  parseMaterials(textureMap) {
    const materialMap = /* @__PURE__ */ new Map();
    if ("Material" in fbxTree.Objects) {
      const materialNodes = fbxTree.Objects.Material;
      for (const nodeID in materialNodes) {
        const material2 = this.parseMaterial(materialNodes[nodeID], textureMap);
        if (material2 !== null)
          materialMap.set(parseInt(nodeID), material2);
      }
    }
    return materialMap;
  }
  // Parse single node in FBXTree.Objects.Material
  // Materials are connected to texture maps in FBXTree.Objects.Textures
  // FBX format currently only supports Lambert and Phong shading models
  parseMaterial(materialNode, textureMap) {
    const ID = materialNode.id;
    const name = materialNode.attrName;
    let type = materialNode.ShadingModel;
    if (typeof type === "object") {
      type = type.value;
    }
    if (!connections.has(ID))
      return null;
    const parameters = this.parseParameters(materialNode, textureMap, ID);
    let material2;
    switch (type.toLowerCase()) {
      case "phong":
        material2 = new MeshPhongMaterial();
        break;
      case "lambert":
        material2 = new MeshLambertMaterial();
        break;
      default:
        console.warn('THREE.FBXLoader: unknown material type "%s". Defaulting to MeshPhongMaterial.', type);
        material2 = new MeshPhongMaterial();
        break;
    }
    material2.setValues(parameters);
    material2.name = name;
    return material2;
  }
  // Parse FBX material and return parameters suitable for a three.js material
  // Also parse the texture map and return any textures associated with the material
  parseParameters(materialNode, textureMap, ID) {
    const parameters = {};
    if (materialNode.BumpFactor) {
      parameters.bumpScale = materialNode.BumpFactor.value;
    }
    if (materialNode.Diffuse) {
      parameters.color = new Color().fromArray(materialNode.Diffuse.value);
    } else if (materialNode.DiffuseColor && (materialNode.DiffuseColor.type === "Color" || materialNode.DiffuseColor.type === "ColorRGB")) {
      parameters.color = new Color().fromArray(materialNode.DiffuseColor.value);
    }
    if (materialNode.DisplacementFactor) {
      parameters.displacementScale = materialNode.DisplacementFactor.value;
    }
    if (materialNode.Emissive) {
      parameters.emissive = new Color().fromArray(materialNode.Emissive.value);
    } else if (materialNode.EmissiveColor && (materialNode.EmissiveColor.type === "Color" || materialNode.EmissiveColor.type === "ColorRGB")) {
      parameters.emissive = new Color().fromArray(materialNode.EmissiveColor.value);
    }
    if (materialNode.EmissiveFactor) {
      parameters.emissiveIntensity = parseFloat(materialNode.EmissiveFactor.value);
    }
    if (materialNode.Opacity) {
      parameters.opacity = parseFloat(materialNode.Opacity.value);
    }
    if (parameters.opacity < 1) {
      parameters.transparent = true;
    }
    if (materialNode.ReflectionFactor) {
      parameters.reflectivity = materialNode.ReflectionFactor.value;
    }
    if (materialNode.Shininess) {
      parameters.shininess = materialNode.Shininess.value;
    }
    if (materialNode.Specular) {
      parameters.specular = new Color().fromArray(materialNode.Specular.value);
    } else if (materialNode.SpecularColor && materialNode.SpecularColor.type === "Color") {
      parameters.specular = new Color().fromArray(materialNode.SpecularColor.value);
    }
    const scope = this;
    connections.get(ID).children.forEach(function(child) {
      const type = child.relationship;
      switch (type) {
        case "Bump":
          parameters.bumpMap = scope.getTexture(textureMap, child.ID);
          break;
        case "Maya|TEX_ao_map":
          parameters.aoMap = scope.getTexture(textureMap, child.ID);
          break;
        case "DiffuseColor":
        case "Maya|TEX_color_map":
          parameters.map = scope.getTexture(textureMap, child.ID);
          if (parameters.map !== void 0) {
            if ("colorSpace" in parameters.map)
              parameters.map.colorSpace = "srgb";
            else
              parameters.map.encoding = 3001;
          }
          break;
        case "DisplacementColor":
          parameters.displacementMap = scope.getTexture(textureMap, child.ID);
          break;
        case "EmissiveColor":
          parameters.emissiveMap = scope.getTexture(textureMap, child.ID);
          if (parameters.emissiveMap !== void 0) {
            if ("colorSpace" in parameters.emissiveMap)
              parameters.emissiveMap.colorSpace = "srgb";
            else
              parameters.emissiveMap.encoding = 3001;
          }
          break;
        case "NormalMap":
        case "Maya|TEX_normal_map":
          parameters.normalMap = scope.getTexture(textureMap, child.ID);
          break;
        case "ReflectionColor":
          parameters.envMap = scope.getTexture(textureMap, child.ID);
          if (parameters.envMap !== void 0) {
            parameters.envMap.mapping = EquirectangularReflectionMapping;
            if ("colorSpace" in parameters.envMap)
              parameters.envMap.colorSpace = "srgb";
            else
              parameters.envMap.encoding = 3001;
          }
          break;
        case "SpecularColor":
          parameters.specularMap = scope.getTexture(textureMap, child.ID);
          if (parameters.specularMap !== void 0) {
            if ("colorSpace" in parameters.specularMap)
              parameters.specularMap.colorSpace = "srgb";
            else
              parameters.specularMap.encoding = 3001;
          }
          break;
        case "TransparentColor":
        case "TransparencyFactor":
          parameters.alphaMap = scope.getTexture(textureMap, child.ID);
          parameters.transparent = true;
          break;
        case "AmbientColor":
        case "ShininessExponent":
        case "SpecularFactor":
        case "VectorDisplacementColor":
        default:
          console.warn("THREE.FBXLoader: %s map is not supported in three.js, skipping texture.", type);
          break;
      }
    });
    return parameters;
  }
  // get a texture from the textureMap for use by a material.
  getTexture(textureMap, id) {
    if ("LayeredTexture" in fbxTree.Objects && id in fbxTree.Objects.LayeredTexture) {
      console.warn("THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer.");
      id = connections.get(id).children[0].ID;
    }
    return textureMap.get(id);
  }
  // Parse nodes in FBXTree.Objects.Deformer
  // Deformer node can contain skinning or Vertex Cache animation data, however only skinning is supported here
  // Generates map of Skeleton-like objects for use later when generating and binding skeletons.
  parseDeformers() {
    const skeletons = {};
    const morphTargets = {};
    if ("Deformer" in fbxTree.Objects) {
      const DeformerNodes = fbxTree.Objects.Deformer;
      for (const nodeID in DeformerNodes) {
        const deformerNode = DeformerNodes[nodeID];
        const relationships = connections.get(parseInt(nodeID));
        if (deformerNode.attrType === "Skin") {
          const skeleton = this.parseSkeleton(relationships, DeformerNodes);
          skeleton.ID = nodeID;
          if (relationships.parents.length > 1) {
            console.warn("THREE.FBXLoader: skeleton attached to more than one geometry is not supported.");
          }
          skeleton.geometryID = relationships.parents[0].ID;
          skeletons[nodeID] = skeleton;
        } else if (deformerNode.attrType === "BlendShape") {
          const morphTarget = {
            id: nodeID
          };
          morphTarget.rawTargets = this.parseMorphTargets(relationships, DeformerNodes);
          morphTarget.id = nodeID;
          if (relationships.parents.length > 1) {
            console.warn("THREE.FBXLoader: morph target attached to more than one geometry is not supported.");
          }
          morphTargets[nodeID] = morphTarget;
        }
      }
    }
    return {
      skeletons,
      morphTargets
    };
  }
  // Parse single nodes in FBXTree.Objects.Deformer
  // The top level skeleton node has type 'Skin' and sub nodes have type 'Cluster'
  // Each skin node represents a skeleton and each cluster node represents a bone
  parseSkeleton(relationships, deformerNodes) {
    const rawBones = [];
    relationships.children.forEach(function(child) {
      const boneNode = deformerNodes[child.ID];
      if (boneNode.attrType !== "Cluster")
        return;
      const rawBone = {
        ID: child.ID,
        indices: [],
        weights: [],
        transformLink: new Matrix4().fromArray(boneNode.TransformLink.a)
        // transform: new Matrix4().fromArray( boneNode.Transform.a ),
        // linkMode: boneNode.Mode,
      };
      if ("Indexes" in boneNode) {
        rawBone.indices = boneNode.Indexes.a;
        rawBone.weights = boneNode.Weights.a;
      }
      rawBones.push(rawBone);
    });
    return {
      rawBones,
      bones: []
    };
  }
  // The top level morph deformer node has type "BlendShape" and sub nodes have type "BlendShapeChannel"
  parseMorphTargets(relationships, deformerNodes) {
    const rawMorphTargets = [];
    for (let i3 = 0; i3 < relationships.children.length; i3++) {
      const child = relationships.children[i3];
      const morphTargetNode = deformerNodes[child.ID];
      const rawMorphTarget = {
        name: morphTargetNode.attrName,
        initialWeight: morphTargetNode.DeformPercent,
        id: morphTargetNode.id,
        fullWeights: morphTargetNode.FullWeights.a
      };
      if (morphTargetNode.attrType !== "BlendShapeChannel")
        return;
      rawMorphTarget.geoID = connections.get(parseInt(child.ID)).children.filter(function(child2) {
        return child2.relationship === void 0;
      })[0].ID;
      rawMorphTargets.push(rawMorphTarget);
    }
    return rawMorphTargets;
  }
  // create the main Group() to be returned by the loader
  parseScene(deformers, geometryMap, materialMap) {
    sceneGraph = new Group();
    const modelMap = this.parseModels(deformers.skeletons, geometryMap, materialMap);
    const modelNodes = fbxTree.Objects.Model;
    const scope = this;
    modelMap.forEach(function(model) {
      const modelNode = modelNodes[model.ID];
      scope.setLookAtProperties(model, modelNode);
      const parentConnections = connections.get(model.ID).parents;
      parentConnections.forEach(function(connection) {
        const parent = modelMap.get(connection.ID);
        if (parent !== void 0)
          parent.add(model);
      });
      if (model.parent === null) {
        sceneGraph.add(model);
      }
    });
    this.bindSkeleton(deformers.skeletons, geometryMap, modelMap);
    this.createAmbientLight();
    sceneGraph.traverse(function(node) {
      if (node.userData.transformData) {
        if (node.parent) {
          node.userData.transformData.parentMatrix = node.parent.matrix;
          node.userData.transformData.parentMatrixWorld = node.parent.matrixWorld;
        }
        const transform = generateTransform(node.userData.transformData);
        node.applyMatrix4(transform);
        node.updateWorldMatrix();
      }
    });
    const animations = new AnimationParser().parse();
    if (sceneGraph.children.length === 1 && sceneGraph.children[0].isGroup) {
      sceneGraph.children[0].animations = animations;
      sceneGraph = sceneGraph.children[0];
    }
    sceneGraph.animations = animations;
  }
  // parse nodes in FBXTree.Objects.Model
  parseModels(skeletons, geometryMap, materialMap) {
    const modelMap = /* @__PURE__ */ new Map();
    const modelNodes = fbxTree.Objects.Model;
    for (const nodeID in modelNodes) {
      const id = parseInt(nodeID);
      const node = modelNodes[nodeID];
      const relationships = connections.get(id);
      let model = this.buildSkeleton(relationships, skeletons, id, node.attrName);
      if (!model) {
        switch (node.attrType) {
          case "Camera":
            model = this.createCamera(relationships);
            break;
          case "Light":
            model = this.createLight(relationships);
            break;
          case "Mesh":
            model = this.createMesh(relationships, geometryMap, materialMap);
            break;
          case "NurbsCurve":
            model = this.createCurve(relationships, geometryMap);
            break;
          case "LimbNode":
          case "Root":
            model = new Bone();
            break;
          case "Null":
          default:
            model = new Group();
            break;
        }
        model.name = node.attrName ? PropertyBinding.sanitizeNodeName(node.attrName) : "";
        model.ID = id;
      }
      this.getTransformData(model, node);
      modelMap.set(id, model);
    }
    return modelMap;
  }
  buildSkeleton(relationships, skeletons, id, name) {
    let bone = null;
    relationships.parents.forEach(function(parent) {
      for (const ID in skeletons) {
        const skeleton = skeletons[ID];
        skeleton.rawBones.forEach(function(rawBone, i3) {
          if (rawBone.ID === parent.ID) {
            const subBone = bone;
            bone = new Bone();
            bone.matrixWorld.copy(rawBone.transformLink);
            bone.name = name ? PropertyBinding.sanitizeNodeName(name) : "";
            bone.ID = id;
            skeleton.bones[i3] = bone;
            if (subBone !== null) {
              bone.add(subBone);
            }
          }
        });
      }
    });
    return bone;
  }
  // create a PerspectiveCamera or OrthographicCamera
  createCamera(relationships) {
    let model;
    let cameraAttribute;
    relationships.children.forEach(function(child) {
      const attr = fbxTree.Objects.NodeAttribute[child.ID];
      if (attr !== void 0) {
        cameraAttribute = attr;
      }
    });
    if (cameraAttribute === void 0) {
      model = new Object3D();
    } else {
      let type = 0;
      if (cameraAttribute.CameraProjectionType !== void 0 && cameraAttribute.CameraProjectionType.value === 1) {
        type = 1;
      }
      let nearClippingPlane = 1;
      if (cameraAttribute.NearPlane !== void 0) {
        nearClippingPlane = cameraAttribute.NearPlane.value / 1e3;
      }
      let farClippingPlane = 1e3;
      if (cameraAttribute.FarPlane !== void 0) {
        farClippingPlane = cameraAttribute.FarPlane.value / 1e3;
      }
      let width = window.innerWidth;
      let height = window.innerHeight;
      if (cameraAttribute.AspectWidth !== void 0 && cameraAttribute.AspectHeight !== void 0) {
        width = cameraAttribute.AspectWidth.value;
        height = cameraAttribute.AspectHeight.value;
      }
      const aspect = width / height;
      let fov = 45;
      if (cameraAttribute.FieldOfView !== void 0) {
        fov = cameraAttribute.FieldOfView.value;
      }
      const focalLength = cameraAttribute.FocalLength ? cameraAttribute.FocalLength.value : null;
      switch (type) {
        case 0:
          model = new PerspectiveCamera(fov, aspect, nearClippingPlane, farClippingPlane);
          if (focalLength !== null)
            model.setFocalLength(focalLength);
          break;
        case 1:
          model = new OrthographicCamera(
            -width / 2,
            width / 2,
            height / 2,
            -height / 2,
            nearClippingPlane,
            farClippingPlane
          );
          break;
        default:
          console.warn("THREE.FBXLoader: Unknown camera type " + type + ".");
          model = new Object3D();
          break;
      }
    }
    return model;
  }
  // Create a DirectionalLight, PointLight or SpotLight
  createLight(relationships) {
    let model;
    let lightAttribute;
    relationships.children.forEach(function(child) {
      const attr = fbxTree.Objects.NodeAttribute[child.ID];
      if (attr !== void 0) {
        lightAttribute = attr;
      }
    });
    if (lightAttribute === void 0) {
      model = new Object3D();
    } else {
      let type;
      if (lightAttribute.LightType === void 0) {
        type = 0;
      } else {
        type = lightAttribute.LightType.value;
      }
      let color = 16777215;
      if (lightAttribute.Color !== void 0) {
        color = new Color().fromArray(lightAttribute.Color.value);
      }
      let intensity = lightAttribute.Intensity === void 0 ? 1 : lightAttribute.Intensity.value / 100;
      if (lightAttribute.CastLightOnObject !== void 0 && lightAttribute.CastLightOnObject.value === 0) {
        intensity = 0;
      }
      let distance2 = 0;
      if (lightAttribute.FarAttenuationEnd !== void 0) {
        if (lightAttribute.EnableFarAttenuation !== void 0 && lightAttribute.EnableFarAttenuation.value === 0) {
          distance2 = 0;
        } else {
          distance2 = lightAttribute.FarAttenuationEnd.value;
        }
      }
      const decay = 1;
      switch (type) {
        case 0:
          model = new PointLight(color, intensity, distance2, decay);
          break;
        case 1:
          model = new DirectionalLight(color, intensity);
          break;
        case 2:
          let angle2 = Math.PI / 3;
          if (lightAttribute.InnerAngle !== void 0) {
            angle2 = MathUtils.degToRad(lightAttribute.InnerAngle.value);
          }
          let penumbra = 0;
          if (lightAttribute.OuterAngle !== void 0) {
            penumbra = MathUtils.degToRad(lightAttribute.OuterAngle.value);
            penumbra = Math.max(penumbra, 1);
          }
          model = new SpotLight(color, intensity, distance2, angle2, penumbra, decay);
          break;
        default:
          console.warn(
            "THREE.FBXLoader: Unknown light type " + lightAttribute.LightType.value + ", defaulting to a PointLight."
          );
          model = new PointLight(color, intensity);
          break;
      }
      if (lightAttribute.CastShadows !== void 0 && lightAttribute.CastShadows.value === 1) {
        model.castShadow = true;
      }
    }
    return model;
  }
  createMesh(relationships, geometryMap, materialMap) {
    let model;
    let geometry2 = null;
    let material2 = null;
    const materials = [];
    relationships.children.forEach(function(child) {
      if (geometryMap.has(child.ID)) {
        geometry2 = geometryMap.get(child.ID);
      }
      if (materialMap.has(child.ID)) {
        materials.push(materialMap.get(child.ID));
      }
    });
    if (materials.length > 1) {
      material2 = materials;
    } else if (materials.length > 0) {
      material2 = materials[0];
    } else {
      material2 = new MeshPhongMaterial({ color: 13421772 });
      materials.push(material2);
    }
    if ("color" in geometry2.attributes) {
      materials.forEach(function(material22) {
        material22.vertexColors = true;
      });
    }
    if (geometry2.FBX_Deformer) {
      model = new SkinnedMesh(geometry2, material2);
      model.normalizeSkinWeights();
    } else {
      model = new Mesh(geometry2, material2);
    }
    return model;
  }
  createCurve(relationships, geometryMap) {
    const geometry2 = relationships.children.reduce(function(geo, child) {
      if (geometryMap.has(child.ID))
        geo = geometryMap.get(child.ID);
      return geo;
    }, null);
    const material2 = new LineBasicMaterial({ color: 3342591, linewidth: 1 });
    return new Line(geometry2, material2);
  }
  // parse the model node for transform data
  getTransformData(model, modelNode) {
    const transformData = {};
    if ("InheritType" in modelNode)
      transformData.inheritType = parseInt(modelNode.InheritType.value);
    if ("RotationOrder" in modelNode)
      transformData.eulerOrder = getEulerOrder(modelNode.RotationOrder.value);
    else
      transformData.eulerOrder = "ZYX";
    if ("Lcl_Translation" in modelNode)
      transformData.translation = modelNode.Lcl_Translation.value;
    if ("PreRotation" in modelNode)
      transformData.preRotation = modelNode.PreRotation.value;
    if ("Lcl_Rotation" in modelNode)
      transformData.rotation = modelNode.Lcl_Rotation.value;
    if ("PostRotation" in modelNode)
      transformData.postRotation = modelNode.PostRotation.value;
    if ("Lcl_Scaling" in modelNode)
      transformData.scale = modelNode.Lcl_Scaling.value;
    if ("ScalingOffset" in modelNode)
      transformData.scalingOffset = modelNode.ScalingOffset.value;
    if ("ScalingPivot" in modelNode)
      transformData.scalingPivot = modelNode.ScalingPivot.value;
    if ("RotationOffset" in modelNode)
      transformData.rotationOffset = modelNode.RotationOffset.value;
    if ("RotationPivot" in modelNode)
      transformData.rotationPivot = modelNode.RotationPivot.value;
    model.userData.transformData = transformData;
  }
  setLookAtProperties(model, modelNode) {
    if ("LookAtProperty" in modelNode) {
      const children = connections.get(model.ID).children;
      children.forEach(function(child) {
        if (child.relationship === "LookAtProperty") {
          const lookAtTarget = fbxTree.Objects.Model[child.ID];
          if ("Lcl_Translation" in lookAtTarget) {
            const pos = lookAtTarget.Lcl_Translation.value;
            if (model.target !== void 0) {
              model.target.position.fromArray(pos);
              sceneGraph.add(model.target);
            } else {
              model.lookAt(new Vector3().fromArray(pos));
            }
          }
        }
      });
    }
  }
  bindSkeleton(skeletons, geometryMap, modelMap) {
    const bindMatrices = this.parsePoseNodes();
    for (const ID in skeletons) {
      const skeleton = skeletons[ID];
      const parents = connections.get(parseInt(skeleton.ID)).parents;
      parents.forEach(function(parent) {
        if (geometryMap.has(parent.ID)) {
          const geoID = parent.ID;
          const geoRelationships = connections.get(geoID);
          geoRelationships.parents.forEach(function(geoConnParent) {
            if (modelMap.has(geoConnParent.ID)) {
              const model = modelMap.get(geoConnParent.ID);
              model.bind(new Skeleton(skeleton.bones), bindMatrices[geoConnParent.ID]);
            }
          });
        }
      });
    }
  }
  parsePoseNodes() {
    const bindMatrices = {};
    if ("Pose" in fbxTree.Objects) {
      const BindPoseNode = fbxTree.Objects.Pose;
      for (const nodeID in BindPoseNode) {
        if (BindPoseNode[nodeID].attrType === "BindPose" && BindPoseNode[nodeID].NbPoseNodes > 0) {
          const poseNodes = BindPoseNode[nodeID].PoseNode;
          if (Array.isArray(poseNodes)) {
            poseNodes.forEach(function(poseNode) {
              bindMatrices[poseNode.Node] = new Matrix4().fromArray(poseNode.Matrix.a);
            });
          } else {
            bindMatrices[poseNodes.Node] = new Matrix4().fromArray(poseNodes.Matrix.a);
          }
        }
      }
    }
    return bindMatrices;
  }
  // Parse ambient color in FBXTree.GlobalSettings - if it's not set to black (default), create an ambient light
  createAmbientLight() {
    if ("GlobalSettings" in fbxTree && "AmbientColor" in fbxTree.GlobalSettings) {
      const ambientColor = fbxTree.GlobalSettings.AmbientColor.value;
      const r = ambientColor[0];
      const g2 = ambientColor[1];
      const b5 = ambientColor[2];
      if (r !== 0 || g2 !== 0 || b5 !== 0) {
        const color = new Color(r, g2, b5);
        sceneGraph.add(new AmbientLight(color, 1));
      }
    }
  }
};
var GeometryParser = class {
  // Parse nodes in FBXTree.Objects.Geometry
  parse(deformers) {
    const geometryMap = /* @__PURE__ */ new Map();
    if ("Geometry" in fbxTree.Objects) {
      const geoNodes = fbxTree.Objects.Geometry;
      for (const nodeID in geoNodes) {
        const relationships = connections.get(parseInt(nodeID));
        const geo = this.parseGeometry(relationships, geoNodes[nodeID], deformers);
        geometryMap.set(parseInt(nodeID), geo);
      }
    }
    return geometryMap;
  }
  // Parse single node in FBXTree.Objects.Geometry
  parseGeometry(relationships, geoNode, deformers) {
    switch (geoNode.attrType) {
      case "Mesh":
        return this.parseMeshGeometry(relationships, geoNode, deformers);
        break;
      case "NurbsCurve":
        return this.parseNurbsGeometry(geoNode);
        break;
    }
  }
  // Parse single node mesh geometry in FBXTree.Objects.Geometry
  parseMeshGeometry(relationships, geoNode, deformers) {
    const skeletons = deformers.skeletons;
    const morphTargets = [];
    const modelNodes = relationships.parents.map(function(parent) {
      return fbxTree.Objects.Model[parent.ID];
    });
    if (modelNodes.length === 0)
      return;
    const skeleton = relationships.children.reduce(function(skeleton2, child) {
      if (skeletons[child.ID] !== void 0)
        skeleton2 = skeletons[child.ID];
      return skeleton2;
    }, null);
    relationships.children.forEach(function(child) {
      if (deformers.morphTargets[child.ID] !== void 0) {
        morphTargets.push(deformers.morphTargets[child.ID]);
      }
    });
    const modelNode = modelNodes[0];
    const transformData = {};
    if ("RotationOrder" in modelNode)
      transformData.eulerOrder = getEulerOrder(modelNode.RotationOrder.value);
    if ("InheritType" in modelNode)
      transformData.inheritType = parseInt(modelNode.InheritType.value);
    if ("GeometricTranslation" in modelNode)
      transformData.translation = modelNode.GeometricTranslation.value;
    if ("GeometricRotation" in modelNode)
      transformData.rotation = modelNode.GeometricRotation.value;
    if ("GeometricScaling" in modelNode)
      transformData.scale = modelNode.GeometricScaling.value;
    const transform = generateTransform(transformData);
    return this.genGeometry(geoNode, skeleton, morphTargets, transform);
  }
  // Generate a BufferGeometry from a node in FBXTree.Objects.Geometry
  genGeometry(geoNode, skeleton, morphTargets, preTransform) {
    const geo = new BufferGeometry();
    if (geoNode.attrName)
      geo.name = geoNode.attrName;
    const geoInfo = this.parseGeoNode(geoNode, skeleton);
    const buffers = this.genBuffers(geoInfo);
    const positionAttribute = new Float32BufferAttribute(buffers.vertex, 3);
    positionAttribute.applyMatrix4(preTransform);
    geo.setAttribute("position", positionAttribute);
    if (buffers.colors.length > 0) {
      geo.setAttribute("color", new Float32BufferAttribute(buffers.colors, 3));
    }
    if (skeleton) {
      geo.setAttribute("skinIndex", new Uint16BufferAttribute(buffers.weightsIndices, 4));
      geo.setAttribute("skinWeight", new Float32BufferAttribute(buffers.vertexWeights, 4));
      geo.FBX_Deformer = skeleton;
    }
    if (buffers.normal.length > 0) {
      const normalMatrix = new Matrix3().getNormalMatrix(preTransform);
      const normalAttribute = new Float32BufferAttribute(buffers.normal, 3);
      normalAttribute.applyNormalMatrix(normalMatrix);
      geo.setAttribute("normal", normalAttribute);
    }
    buffers.uvs.forEach(function(uvBuffer, i3) {
      let name = "uv" + (i3 + 1).toString();
      if (i3 === 0) {
        name = "uv";
      }
      geo.setAttribute(name, new Float32BufferAttribute(buffers.uvs[i3], 2));
    });
    if (geoInfo.material && geoInfo.material.mappingType !== "AllSame") {
      let prevMaterialIndex = buffers.materialIndex[0];
      let startIndex = 0;
      buffers.materialIndex.forEach(function(currentIndex, i3) {
        if (currentIndex !== prevMaterialIndex) {
          geo.addGroup(startIndex, i3 - startIndex, prevMaterialIndex);
          prevMaterialIndex = currentIndex;
          startIndex = i3;
        }
      });
      if (geo.groups.length > 0) {
        const lastGroup = geo.groups[geo.groups.length - 1];
        const lastIndex = lastGroup.start + lastGroup.count;
        if (lastIndex !== buffers.materialIndex.length) {
          geo.addGroup(lastIndex, buffers.materialIndex.length - lastIndex, prevMaterialIndex);
        }
      }
      if (geo.groups.length === 0) {
        geo.addGroup(0, buffers.materialIndex.length, buffers.materialIndex[0]);
      }
    }
    this.addMorphTargets(geo, geoNode, morphTargets, preTransform);
    return geo;
  }
  parseGeoNode(geoNode, skeleton) {
    const geoInfo = {};
    geoInfo.vertexPositions = geoNode.Vertices !== void 0 ? geoNode.Vertices.a : [];
    geoInfo.vertexIndices = geoNode.PolygonVertexIndex !== void 0 ? geoNode.PolygonVertexIndex.a : [];
    if (geoNode.LayerElementColor) {
      geoInfo.color = this.parseVertexColors(geoNode.LayerElementColor[0]);
    }
    if (geoNode.LayerElementMaterial) {
      geoInfo.material = this.parseMaterialIndices(geoNode.LayerElementMaterial[0]);
    }
    if (geoNode.LayerElementNormal) {
      geoInfo.normal = this.parseNormals(geoNode.LayerElementNormal[0]);
    }
    if (geoNode.LayerElementUV) {
      geoInfo.uv = [];
      let i3 = 0;
      while (geoNode.LayerElementUV[i3]) {
        if (geoNode.LayerElementUV[i3].UV) {
          geoInfo.uv.push(this.parseUVs(geoNode.LayerElementUV[i3]));
        }
        i3++;
      }
    }
    geoInfo.weightTable = {};
    if (skeleton !== null) {
      geoInfo.skeleton = skeleton;
      skeleton.rawBones.forEach(function(rawBone, i3) {
        rawBone.indices.forEach(function(index, j) {
          if (geoInfo.weightTable[index] === void 0)
            geoInfo.weightTable[index] = [];
          geoInfo.weightTable[index].push({
            id: i3,
            weight: rawBone.weights[j]
          });
        });
      });
    }
    return geoInfo;
  }
  genBuffers(geoInfo) {
    const buffers = {
      vertex: [],
      normal: [],
      colors: [],
      uvs: [],
      materialIndex: [],
      vertexWeights: [],
      weightsIndices: []
    };
    let polygonIndex = 0;
    let faceLength = 0;
    let displayedWeightsWarning = false;
    let facePositionIndexes = [];
    let faceNormals = [];
    let faceColors = [];
    let faceUVs = [];
    let faceWeights = [];
    let faceWeightIndices = [];
    const scope = this;
    geoInfo.vertexIndices.forEach(function(vertexIndex, polygonVertexIndex) {
      let materialIndex;
      let endOfFace = false;
      if (vertexIndex < 0) {
        vertexIndex = vertexIndex ^ -1;
        endOfFace = true;
      }
      let weightIndices = [];
      let weights = [];
      facePositionIndexes.push(vertexIndex * 3, vertexIndex * 3 + 1, vertexIndex * 3 + 2);
      if (geoInfo.color) {
        const data = getData(polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.color);
        faceColors.push(data[0], data[1], data[2]);
      }
      if (geoInfo.skeleton) {
        if (geoInfo.weightTable[vertexIndex] !== void 0) {
          geoInfo.weightTable[vertexIndex].forEach(function(wt) {
            weights.push(wt.weight);
            weightIndices.push(wt.id);
          });
        }
        if (weights.length > 4) {
          if (!displayedWeightsWarning) {
            console.warn(
              "THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights."
            );
            displayedWeightsWarning = true;
          }
          const wIndex = [0, 0, 0, 0];
          const Weight = [0, 0, 0, 0];
          weights.forEach(function(weight, weightIndex) {
            let currentWeight = weight;
            let currentIndex = weightIndices[weightIndex];
            Weight.forEach(function(comparedWeight, comparedWeightIndex, comparedWeightArray) {
              if (currentWeight > comparedWeight) {
                comparedWeightArray[comparedWeightIndex] = currentWeight;
                currentWeight = comparedWeight;
                const tmp2 = wIndex[comparedWeightIndex];
                wIndex[comparedWeightIndex] = currentIndex;
                currentIndex = tmp2;
              }
            });
          });
          weightIndices = wIndex;
          weights = Weight;
        }
        while (weights.length < 4) {
          weights.push(0);
          weightIndices.push(0);
        }
        for (let i3 = 0; i3 < 4; ++i3) {
          faceWeights.push(weights[i3]);
          faceWeightIndices.push(weightIndices[i3]);
        }
      }
      if (geoInfo.normal) {
        const data = getData(polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.normal);
        faceNormals.push(data[0], data[1], data[2]);
      }
      if (geoInfo.material && geoInfo.material.mappingType !== "AllSame") {
        materialIndex = getData(polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.material)[0];
      }
      if (geoInfo.uv) {
        geoInfo.uv.forEach(function(uv, i3) {
          const data = getData(polygonVertexIndex, polygonIndex, vertexIndex, uv);
          if (faceUVs[i3] === void 0) {
            faceUVs[i3] = [];
          }
          faceUVs[i3].push(data[0]);
          faceUVs[i3].push(data[1]);
        });
      }
      faceLength++;
      if (endOfFace) {
        scope.genFace(
          buffers,
          geoInfo,
          facePositionIndexes,
          materialIndex,
          faceNormals,
          faceColors,
          faceUVs,
          faceWeights,
          faceWeightIndices,
          faceLength
        );
        polygonIndex++;
        faceLength = 0;
        facePositionIndexes = [];
        faceNormals = [];
        faceColors = [];
        faceUVs = [];
        faceWeights = [];
        faceWeightIndices = [];
      }
    });
    return buffers;
  }
  // Generate data for a single face in a geometry. If the face is a quad then split it into 2 tris
  genFace(buffers, geoInfo, facePositionIndexes, materialIndex, faceNormals, faceColors, faceUVs, faceWeights, faceWeightIndices, faceLength) {
    for (let i3 = 2; i3 < faceLength; i3++) {
      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[0]]);
      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[1]]);
      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[2]]);
      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[(i3 - 1) * 3]]);
      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[(i3 - 1) * 3 + 1]]);
      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[(i3 - 1) * 3 + 2]]);
      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i3 * 3]]);
      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i3 * 3 + 1]]);
      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i3 * 3 + 2]]);
      if (geoInfo.skeleton) {
        buffers.vertexWeights.push(faceWeights[0]);
        buffers.vertexWeights.push(faceWeights[1]);
        buffers.vertexWeights.push(faceWeights[2]);
        buffers.vertexWeights.push(faceWeights[3]);
        buffers.vertexWeights.push(faceWeights[(i3 - 1) * 4]);
        buffers.vertexWeights.push(faceWeights[(i3 - 1) * 4 + 1]);
        buffers.vertexWeights.push(faceWeights[(i3 - 1) * 4 + 2]);
        buffers.vertexWeights.push(faceWeights[(i3 - 1) * 4 + 3]);
        buffers.vertexWeights.push(faceWeights[i3 * 4]);
        buffers.vertexWeights.push(faceWeights[i3 * 4 + 1]);
        buffers.vertexWeights.push(faceWeights[i3 * 4 + 2]);
        buffers.vertexWeights.push(faceWeights[i3 * 4 + 3]);
        buffers.weightsIndices.push(faceWeightIndices[0]);
        buffers.weightsIndices.push(faceWeightIndices[1]);
        buffers.weightsIndices.push(faceWeightIndices[2]);
        buffers.weightsIndices.push(faceWeightIndices[3]);
        buffers.weightsIndices.push(faceWeightIndices[(i3 - 1) * 4]);
        buffers.weightsIndices.push(faceWeightIndices[(i3 - 1) * 4 + 1]);
        buffers.weightsIndices.push(faceWeightIndices[(i3 - 1) * 4 + 2]);
        buffers.weightsIndices.push(faceWeightIndices[(i3 - 1) * 4 + 3]);
        buffers.weightsIndices.push(faceWeightIndices[i3 * 4]);
        buffers.weightsIndices.push(faceWeightIndices[i3 * 4 + 1]);
        buffers.weightsIndices.push(faceWeightIndices[i3 * 4 + 2]);
        buffers.weightsIndices.push(faceWeightIndices[i3 * 4 + 3]);
      }
      if (geoInfo.color) {
        buffers.colors.push(faceColors[0]);
        buffers.colors.push(faceColors[1]);
        buffers.colors.push(faceColors[2]);
        buffers.colors.push(faceColors[(i3 - 1) * 3]);
        buffers.colors.push(faceColors[(i3 - 1) * 3 + 1]);
        buffers.colors.push(faceColors[(i3 - 1) * 3 + 2]);
        buffers.colors.push(faceColors[i3 * 3]);
        buffers.colors.push(faceColors[i3 * 3 + 1]);
        buffers.colors.push(faceColors[i3 * 3 + 2]);
      }
      if (geoInfo.material && geoInfo.material.mappingType !== "AllSame") {
        buffers.materialIndex.push(materialIndex);
        buffers.materialIndex.push(materialIndex);
        buffers.materialIndex.push(materialIndex);
      }
      if (geoInfo.normal) {
        buffers.normal.push(faceNormals[0]);
        buffers.normal.push(faceNormals[1]);
        buffers.normal.push(faceNormals[2]);
        buffers.normal.push(faceNormals[(i3 - 1) * 3]);
        buffers.normal.push(faceNormals[(i3 - 1) * 3 + 1]);
        buffers.normal.push(faceNormals[(i3 - 1) * 3 + 2]);
        buffers.normal.push(faceNormals[i3 * 3]);
        buffers.normal.push(faceNormals[i3 * 3 + 1]);
        buffers.normal.push(faceNormals[i3 * 3 + 2]);
      }
      if (geoInfo.uv) {
        geoInfo.uv.forEach(function(uv, j) {
          if (buffers.uvs[j] === void 0)
            buffers.uvs[j] = [];
          buffers.uvs[j].push(faceUVs[j][0]);
          buffers.uvs[j].push(faceUVs[j][1]);
          buffers.uvs[j].push(faceUVs[j][(i3 - 1) * 2]);
          buffers.uvs[j].push(faceUVs[j][(i3 - 1) * 2 + 1]);
          buffers.uvs[j].push(faceUVs[j][i3 * 2]);
          buffers.uvs[j].push(faceUVs[j][i3 * 2 + 1]);
        });
      }
    }
  }
  addMorphTargets(parentGeo, parentGeoNode, morphTargets, preTransform) {
    if (morphTargets.length === 0)
      return;
    parentGeo.morphTargetsRelative = true;
    parentGeo.morphAttributes.position = [];
    const scope = this;
    morphTargets.forEach(function(morphTarget) {
      morphTarget.rawTargets.forEach(function(rawTarget) {
        const morphGeoNode = fbxTree.Objects.Geometry[rawTarget.geoID];
        if (morphGeoNode !== void 0) {
          scope.genMorphGeometry(parentGeo, parentGeoNode, morphGeoNode, preTransform, rawTarget.name);
        }
      });
    });
  }
  // a morph geometry node is similar to a standard  node, and the node is also contained
  // in FBXTree.Objects.Geometry, however it can only have attributes for position, normal
  // and a special attribute Index defining which vertices of the original geometry are affected
  // Normal and position attributes only have data for the vertices that are affected by the morph
  genMorphGeometry(parentGeo, parentGeoNode, morphGeoNode, preTransform, name) {
    const vertexIndices = parentGeoNode.PolygonVertexIndex !== void 0 ? parentGeoNode.PolygonVertexIndex.a : [];
    const morphPositionsSparse = morphGeoNode.Vertices !== void 0 ? morphGeoNode.Vertices.a : [];
    const indices = morphGeoNode.Indexes !== void 0 ? morphGeoNode.Indexes.a : [];
    const length = parentGeo.attributes.position.count * 3;
    const morphPositions = new Float32Array(length);
    for (let i3 = 0; i3 < indices.length; i3++) {
      const morphIndex = indices[i3] * 3;
      morphPositions[morphIndex] = morphPositionsSparse[i3 * 3];
      morphPositions[morphIndex + 1] = morphPositionsSparse[i3 * 3 + 1];
      morphPositions[morphIndex + 2] = morphPositionsSparse[i3 * 3 + 2];
    }
    const morphGeoInfo = {
      vertexIndices,
      vertexPositions: morphPositions
    };
    const morphBuffers = this.genBuffers(morphGeoInfo);
    const positionAttribute = new Float32BufferAttribute(morphBuffers.vertex, 3);
    positionAttribute.name = name || morphGeoNode.attrName;
    positionAttribute.applyMatrix4(preTransform);
    parentGeo.morphAttributes.position.push(positionAttribute);
  }
  // Parse normal from FBXTree.Objects.Geometry.LayerElementNormal if it exists
  parseNormals(NormalNode) {
    const mappingType = NormalNode.MappingInformationType;
    const referenceType = NormalNode.ReferenceInformationType;
    const buffer = NormalNode.Normals.a;
    let indexBuffer = [];
    if (referenceType === "IndexToDirect") {
      if ("NormalIndex" in NormalNode) {
        indexBuffer = NormalNode.NormalIndex.a;
      } else if ("NormalsIndex" in NormalNode) {
        indexBuffer = NormalNode.NormalsIndex.a;
      }
    }
    return {
      dataSize: 3,
      buffer,
      indices: indexBuffer,
      mappingType,
      referenceType
    };
  }
  // Parse UVs from FBXTree.Objects.Geometry.LayerElementUV if it exists
  parseUVs(UVNode) {
    const mappingType = UVNode.MappingInformationType;
    const referenceType = UVNode.ReferenceInformationType;
    const buffer = UVNode.UV.a;
    let indexBuffer = [];
    if (referenceType === "IndexToDirect") {
      indexBuffer = UVNode.UVIndex.a;
    }
    return {
      dataSize: 2,
      buffer,
      indices: indexBuffer,
      mappingType,
      referenceType
    };
  }
  // Parse Vertex Colors from FBXTree.Objects.Geometry.LayerElementColor if it exists
  parseVertexColors(ColorNode) {
    const mappingType = ColorNode.MappingInformationType;
    const referenceType = ColorNode.ReferenceInformationType;
    const buffer = ColorNode.Colors.a;
    let indexBuffer = [];
    if (referenceType === "IndexToDirect") {
      indexBuffer = ColorNode.ColorIndex.a;
    }
    return {
      dataSize: 4,
      buffer,
      indices: indexBuffer,
      mappingType,
      referenceType
    };
  }
  // Parse mapping and material data in FBXTree.Objects.Geometry.LayerElementMaterial if it exists
  parseMaterialIndices(MaterialNode) {
    const mappingType = MaterialNode.MappingInformationType;
    const referenceType = MaterialNode.ReferenceInformationType;
    if (mappingType === "NoMappingInformation") {
      return {
        dataSize: 1,
        buffer: [0],
        indices: [0],
        mappingType: "AllSame",
        referenceType
      };
    }
    const materialIndexBuffer = MaterialNode.Materials.a;
    const materialIndices = [];
    for (let i3 = 0; i3 < materialIndexBuffer.length; ++i3) {
      materialIndices.push(i3);
    }
    return {
      dataSize: 1,
      buffer: materialIndexBuffer,
      indices: materialIndices,
      mappingType,
      referenceType
    };
  }
  // Generate a NurbGeometry from a node in FBXTree.Objects.Geometry
  parseNurbsGeometry(geoNode) {
    if (NURBSCurve === void 0) {
      console.error(
        "THREE.FBXLoader: The loader relies on NURBSCurve for any nurbs present in the model. Nurbs will show up as empty geometry."
      );
      return new BufferGeometry();
    }
    const order = parseInt(geoNode.Order);
    if (isNaN(order)) {
      console.error("THREE.FBXLoader: Invalid Order %s given for geometry ID: %s", geoNode.Order, geoNode.id);
      return new BufferGeometry();
    }
    const degree = order - 1;
    const knots = geoNode.KnotVector.a;
    const controlPoints = [];
    const pointsValues = geoNode.Points.a;
    for (let i3 = 0, l = pointsValues.length; i3 < l; i3 += 4) {
      controlPoints.push(new Vector4().fromArray(pointsValues, i3));
    }
    let startKnot, endKnot;
    if (geoNode.Form === "Closed") {
      controlPoints.push(controlPoints[0]);
    } else if (geoNode.Form === "Periodic") {
      startKnot = degree;
      endKnot = knots.length - 1 - startKnot;
      for (let i3 = 0; i3 < degree; ++i3) {
        controlPoints.push(controlPoints[i3]);
      }
    }
    const curve = new NURBSCurve(degree, knots, controlPoints, startKnot, endKnot);
    const points = curve.getPoints(controlPoints.length * 12);
    return new BufferGeometry().setFromPoints(points);
  }
};
var AnimationParser = class {
  // take raw animation clips and turn them into three.js animation clips
  parse() {
    const animationClips = [];
    const rawClips = this.parseClips();
    if (rawClips !== void 0) {
      for (const key in rawClips) {
        const rawClip = rawClips[key];
        const clip = this.addClip(rawClip);
        animationClips.push(clip);
      }
    }
    return animationClips;
  }
  parseClips() {
    if (fbxTree.Objects.AnimationCurve === void 0)
      return void 0;
    const curveNodesMap = this.parseAnimationCurveNodes();
    this.parseAnimationCurves(curveNodesMap);
    const layersMap = this.parseAnimationLayers(curveNodesMap);
    const rawClips = this.parseAnimStacks(layersMap);
    return rawClips;
  }
  // parse nodes in FBXTree.Objects.AnimationCurveNode
  // each AnimationCurveNode holds data for an animation transform for a model (e.g. left arm rotation )
  // and is referenced by an AnimationLayer
  parseAnimationCurveNodes() {
    const rawCurveNodes = fbxTree.Objects.AnimationCurveNode;
    const curveNodesMap = /* @__PURE__ */ new Map();
    for (const nodeID in rawCurveNodes) {
      const rawCurveNode = rawCurveNodes[nodeID];
      if (rawCurveNode.attrName.match(/S|R|T|DeformPercent/) !== null) {
        const curveNode = {
          id: rawCurveNode.id,
          attr: rawCurveNode.attrName,
          curves: {}
        };
        curveNodesMap.set(curveNode.id, curveNode);
      }
    }
    return curveNodesMap;
  }
  // parse nodes in FBXTree.Objects.AnimationCurve and connect them up to
  // previously parsed AnimationCurveNodes. Each AnimationCurve holds data for a single animated
  // axis ( e.g. times and values of x rotation)
  parseAnimationCurves(curveNodesMap) {
    const rawCurves = fbxTree.Objects.AnimationCurve;
    for (const nodeID in rawCurves) {
      const animationCurve = {
        id: rawCurves[nodeID].id,
        times: rawCurves[nodeID].KeyTime.a.map(convertFBXTimeToSeconds),
        values: rawCurves[nodeID].KeyValueFloat.a
      };
      const relationships = connections.get(animationCurve.id);
      if (relationships !== void 0) {
        const animationCurveID = relationships.parents[0].ID;
        const animationCurveRelationship = relationships.parents[0].relationship;
        if (animationCurveRelationship.match(/X/)) {
          curveNodesMap.get(animationCurveID).curves["x"] = animationCurve;
        } else if (animationCurveRelationship.match(/Y/)) {
          curveNodesMap.get(animationCurveID).curves["y"] = animationCurve;
        } else if (animationCurveRelationship.match(/Z/)) {
          curveNodesMap.get(animationCurveID).curves["z"] = animationCurve;
        } else if (animationCurveRelationship.match(/d|DeformPercent/) && curveNodesMap.has(animationCurveID)) {
          curveNodesMap.get(animationCurveID).curves["morph"] = animationCurve;
        }
      }
    }
  }
  // parse nodes in FBXTree.Objects.AnimationLayer. Each layers holds references
  // to various AnimationCurveNodes and is referenced by an AnimationStack node
  // note: theoretically a stack can have multiple layers, however in practice there always seems to be one per stack
  parseAnimationLayers(curveNodesMap) {
    const rawLayers = fbxTree.Objects.AnimationLayer;
    const layersMap = /* @__PURE__ */ new Map();
    for (const nodeID in rawLayers) {
      const layerCurveNodes = [];
      const connection = connections.get(parseInt(nodeID));
      if (connection !== void 0) {
        const children = connection.children;
        children.forEach(function(child, i3) {
          if (curveNodesMap.has(child.ID)) {
            const curveNode = curveNodesMap.get(child.ID);
            if (curveNode.curves.x !== void 0 || curveNode.curves.y !== void 0 || curveNode.curves.z !== void 0) {
              if (layerCurveNodes[i3] === void 0) {
                const modelID = connections.get(child.ID).parents.filter(function(parent) {
                  return parent.relationship !== void 0;
                })[0].ID;
                if (modelID !== void 0) {
                  const rawModel = fbxTree.Objects.Model[modelID.toString()];
                  if (rawModel === void 0) {
                    console.warn("THREE.FBXLoader: Encountered a unused curve.", child);
                    return;
                  }
                  const node = {
                    modelName: rawModel.attrName ? PropertyBinding.sanitizeNodeName(rawModel.attrName) : "",
                    ID: rawModel.id,
                    initialPosition: [0, 0, 0],
                    initialRotation: [0, 0, 0],
                    initialScale: [1, 1, 1]
                  };
                  sceneGraph.traverse(function(child2) {
                    if (child2.ID === rawModel.id) {
                      node.transform = child2.matrix;
                      if (child2.userData.transformData)
                        node.eulerOrder = child2.userData.transformData.eulerOrder;
                    }
                  });
                  if (!node.transform)
                    node.transform = new Matrix4();
                  if ("PreRotation" in rawModel)
                    node.preRotation = rawModel.PreRotation.value;
                  if ("PostRotation" in rawModel)
                    node.postRotation = rawModel.PostRotation.value;
                  layerCurveNodes[i3] = node;
                }
              }
              if (layerCurveNodes[i3])
                layerCurveNodes[i3][curveNode.attr] = curveNode;
            } else if (curveNode.curves.morph !== void 0) {
              if (layerCurveNodes[i3] === void 0) {
                const deformerID = connections.get(child.ID).parents.filter(function(parent) {
                  return parent.relationship !== void 0;
                })[0].ID;
                const morpherID = connections.get(deformerID).parents[0].ID;
                const geoID = connections.get(morpherID).parents[0].ID;
                const modelID = connections.get(geoID).parents[0].ID;
                const rawModel = fbxTree.Objects.Model[modelID];
                const node = {
                  modelName: rawModel.attrName ? PropertyBinding.sanitizeNodeName(rawModel.attrName) : "",
                  morphName: fbxTree.Objects.Deformer[deformerID].attrName
                };
                layerCurveNodes[i3] = node;
              }
              layerCurveNodes[i3][curveNode.attr] = curveNode;
            }
          }
        });
        layersMap.set(parseInt(nodeID), layerCurveNodes);
      }
    }
    return layersMap;
  }
  // parse nodes in FBXTree.Objects.AnimationStack. These are the top level node in the animation
  // hierarchy. Each Stack node will be used to create a AnimationClip
  parseAnimStacks(layersMap) {
    const rawStacks = fbxTree.Objects.AnimationStack;
    const rawClips = {};
    for (const nodeID in rawStacks) {
      const children = connections.get(parseInt(nodeID)).children;
      if (children.length > 1) {
        console.warn(
          "THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers."
        );
      }
      const layer = layersMap.get(children[0].ID);
      rawClips[nodeID] = {
        name: rawStacks[nodeID].attrName,
        layer
      };
    }
    return rawClips;
  }
  addClip(rawClip) {
    let tracks = [];
    const scope = this;
    rawClip.layer.forEach(function(rawTracks) {
      tracks = tracks.concat(scope.generateTracks(rawTracks));
    });
    return new AnimationClip(rawClip.name, -1, tracks);
  }
  generateTracks(rawTracks) {
    const tracks = [];
    let initialPosition = new Vector3();
    let initialRotation = new Quaternion();
    let initialScale = new Vector3();
    if (rawTracks.transform)
      rawTracks.transform.decompose(initialPosition, initialRotation, initialScale);
    initialPosition = initialPosition.toArray();
    initialRotation = new Euler().setFromQuaternion(initialRotation, rawTracks.eulerOrder).toArray();
    initialScale = initialScale.toArray();
    if (rawTracks.T !== void 0 && Object.keys(rawTracks.T.curves).length > 0) {
      const positionTrack = this.generateVectorTrack(
        rawTracks.modelName,
        rawTracks.T.curves,
        initialPosition,
        "position"
      );
      if (positionTrack !== void 0)
        tracks.push(positionTrack);
    }
    if (rawTracks.R !== void 0 && Object.keys(rawTracks.R.curves).length > 0) {
      const rotationTrack = this.generateRotationTrack(
        rawTracks.modelName,
        rawTracks.R.curves,
        initialRotation,
        rawTracks.preRotation,
        rawTracks.postRotation,
        rawTracks.eulerOrder
      );
      if (rotationTrack !== void 0)
        tracks.push(rotationTrack);
    }
    if (rawTracks.S !== void 0 && Object.keys(rawTracks.S.curves).length > 0) {
      const scaleTrack = this.generateVectorTrack(rawTracks.modelName, rawTracks.S.curves, initialScale, "scale");
      if (scaleTrack !== void 0)
        tracks.push(scaleTrack);
    }
    if (rawTracks.DeformPercent !== void 0) {
      const morphTrack = this.generateMorphTrack(rawTracks);
      if (morphTrack !== void 0)
        tracks.push(morphTrack);
    }
    return tracks;
  }
  generateVectorTrack(modelName, curves, initialValue, type) {
    const times = this.getTimesForAllAxes(curves);
    const values = this.getKeyframeTrackValues(times, curves, initialValue);
    return new VectorKeyframeTrack(modelName + "." + type, times, values);
  }
  generateRotationTrack(modelName, curves, initialValue, preRotation, postRotation, eulerOrder) {
    if (curves.x !== void 0) {
      this.interpolateRotations(curves.x);
      curves.x.values = curves.x.values.map(MathUtils.degToRad);
    }
    if (curves.y !== void 0) {
      this.interpolateRotations(curves.y);
      curves.y.values = curves.y.values.map(MathUtils.degToRad);
    }
    if (curves.z !== void 0) {
      this.interpolateRotations(curves.z);
      curves.z.values = curves.z.values.map(MathUtils.degToRad);
    }
    const times = this.getTimesForAllAxes(curves);
    const values = this.getKeyframeTrackValues(times, curves, initialValue);
    if (preRotation !== void 0) {
      preRotation = preRotation.map(MathUtils.degToRad);
      preRotation.push(eulerOrder);
      preRotation = new Euler().fromArray(preRotation);
      preRotation = new Quaternion().setFromEuler(preRotation);
    }
    if (postRotation !== void 0) {
      postRotation = postRotation.map(MathUtils.degToRad);
      postRotation.push(eulerOrder);
      postRotation = new Euler().fromArray(postRotation);
      postRotation = new Quaternion().setFromEuler(postRotation).invert();
    }
    const quaternion = new Quaternion();
    const euler = new Euler();
    const quaternionValues = [];
    for (let i3 = 0; i3 < values.length; i3 += 3) {
      euler.set(values[i3], values[i3 + 1], values[i3 + 2], eulerOrder);
      quaternion.setFromEuler(euler);
      if (preRotation !== void 0)
        quaternion.premultiply(preRotation);
      if (postRotation !== void 0)
        quaternion.multiply(postRotation);
      quaternion.toArray(quaternionValues, i3 / 3 * 4);
    }
    return new QuaternionKeyframeTrack(modelName + ".quaternion", times, quaternionValues);
  }
  generateMorphTrack(rawTracks) {
    const curves = rawTracks.DeformPercent.curves.morph;
    const values = curves.values.map(function(val) {
      return val / 100;
    });
    const morphNum = sceneGraph.getObjectByName(rawTracks.modelName).morphTargetDictionary[rawTracks.morphName];
    return new NumberKeyframeTrack(
      rawTracks.modelName + ".morphTargetInfluences[" + morphNum + "]",
      curves.times,
      values
    );
  }
  // For all animated objects, times are defined separately for each axis
  // Here we'll combine the times into one sorted array without duplicates
  getTimesForAllAxes(curves) {
    let times = [];
    if (curves.x !== void 0)
      times = times.concat(curves.x.times);
    if (curves.y !== void 0)
      times = times.concat(curves.y.times);
    if (curves.z !== void 0)
      times = times.concat(curves.z.times);
    times = times.sort(function(a4, b5) {
      return a4 - b5;
    });
    if (times.length > 1) {
      let targetIndex = 1;
      let lastValue = times[0];
      for (let i3 = 1; i3 < times.length; i3++) {
        const currentValue = times[i3];
        if (currentValue !== lastValue) {
          times[targetIndex] = currentValue;
          lastValue = currentValue;
          targetIndex++;
        }
      }
      times = times.slice(0, targetIndex);
    }
    return times;
  }
  getKeyframeTrackValues(times, curves, initialValue) {
    const prevValue = initialValue;
    const values = [];
    let xIndex = -1;
    let yIndex = -1;
    let zIndex = -1;
    times.forEach(function(time) {
      if (curves.x)
        xIndex = curves.x.times.indexOf(time);
      if (curves.y)
        yIndex = curves.y.times.indexOf(time);
      if (curves.z)
        zIndex = curves.z.times.indexOf(time);
      if (xIndex !== -1) {
        const xValue = curves.x.values[xIndex];
        values.push(xValue);
        prevValue[0] = xValue;
      } else {
        values.push(prevValue[0]);
      }
      if (yIndex !== -1) {
        const yValue = curves.y.values[yIndex];
        values.push(yValue);
        prevValue[1] = yValue;
      } else {
        values.push(prevValue[1]);
      }
      if (zIndex !== -1) {
        const zValue = curves.z.values[zIndex];
        values.push(zValue);
        prevValue[2] = zValue;
      } else {
        values.push(prevValue[2]);
      }
    });
    return values;
  }
  // Rotations are defined as Euler angles which can have values  of any size
  // These will be converted to quaternions which don't support values greater than
  // PI, so we'll interpolate large rotations
  interpolateRotations(curve) {
    for (let i3 = 1; i3 < curve.values.length; i3++) {
      const initialValue = curve.values[i3 - 1];
      const valuesSpan = curve.values[i3] - initialValue;
      const absoluteSpan = Math.abs(valuesSpan);
      if (absoluteSpan >= 180) {
        const numSubIntervals = absoluteSpan / 180;
        const step = valuesSpan / numSubIntervals;
        let nextValue = initialValue + step;
        const initialTime = curve.times[i3 - 1];
        const timeSpan = curve.times[i3] - initialTime;
        const interval = timeSpan / numSubIntervals;
        let nextTime = initialTime + interval;
        const interpolatedTimes = [];
        const interpolatedValues = [];
        while (nextTime < curve.times[i3]) {
          interpolatedTimes.push(nextTime);
          nextTime += interval;
          interpolatedValues.push(nextValue);
          nextValue += step;
        }
        curve.times = inject(curve.times, i3, interpolatedTimes);
        curve.values = inject(curve.values, i3, interpolatedValues);
      }
    }
  }
};
var TextParser = class {
  getPrevNode() {
    return this.nodeStack[this.currentIndent - 2];
  }
  getCurrentNode() {
    return this.nodeStack[this.currentIndent - 1];
  }
  getCurrentProp() {
    return this.currentProp;
  }
  pushStack(node) {
    this.nodeStack.push(node);
    this.currentIndent += 1;
  }
  popStack() {
    this.nodeStack.pop();
    this.currentIndent -= 1;
  }
  setCurrentProp(val, name) {
    this.currentProp = val;
    this.currentPropName = name;
  }
  parse(text) {
    this.currentIndent = 0;
    this.allNodes = new FBXTree();
    this.nodeStack = [];
    this.currentProp = [];
    this.currentPropName = "";
    const scope = this;
    const split = text.split(/[\r\n]+/);
    split.forEach(function(line2, i3) {
      const matchComment = line2.match(/^[\s\t]*;/);
      const matchEmpty = line2.match(/^[\s\t]*$/);
      if (matchComment || matchEmpty)
        return;
      const matchBeginning = line2.match("^\\t{" + scope.currentIndent + "}(\\w+):(.*){", "");
      const matchProperty = line2.match("^\\t{" + scope.currentIndent + "}(\\w+):[\\s\\t\\r\\n](.*)");
      const matchEnd = line2.match("^\\t{" + (scope.currentIndent - 1) + "}}");
      if (matchBeginning) {
        scope.parseNodeBegin(line2, matchBeginning);
      } else if (matchProperty) {
        scope.parseNodeProperty(line2, matchProperty, split[++i3]);
      } else if (matchEnd) {
        scope.popStack();
      } else if (line2.match(/^[^\s\t}]/)) {
        scope.parseNodePropertyContinued(line2);
      }
    });
    return this.allNodes;
  }
  parseNodeBegin(line2, property) {
    const nodeName = property[1].trim().replace(/^"/, "").replace(/"$/, "");
    const nodeAttrs = property[2].split(",").map(function(attr) {
      return attr.trim().replace(/^"/, "").replace(/"$/, "");
    });
    const node = { name: nodeName };
    const attrs = this.parseNodeAttr(nodeAttrs);
    const currentNode = this.getCurrentNode();
    if (this.currentIndent === 0) {
      this.allNodes.add(nodeName, node);
    } else {
      if (nodeName in currentNode) {
        if (nodeName === "PoseNode") {
          currentNode.PoseNode.push(node);
        } else if (currentNode[nodeName].id !== void 0) {
          currentNode[nodeName] = {};
          currentNode[nodeName][currentNode[nodeName].id] = currentNode[nodeName];
        }
        if (attrs.id !== "")
          currentNode[nodeName][attrs.id] = node;
      } else if (typeof attrs.id === "number") {
        currentNode[nodeName] = {};
        currentNode[nodeName][attrs.id] = node;
      } else if (nodeName !== "Properties70") {
        if (nodeName === "PoseNode")
          currentNode[nodeName] = [node];
        else
          currentNode[nodeName] = node;
      }
    }
    if (typeof attrs.id === "number")
      node.id = attrs.id;
    if (attrs.name !== "")
      node.attrName = attrs.name;
    if (attrs.type !== "")
      node.attrType = attrs.type;
    this.pushStack(node);
  }
  parseNodeAttr(attrs) {
    let id = attrs[0];
    if (attrs[0] !== "") {
      id = parseInt(attrs[0]);
      if (isNaN(id)) {
        id = attrs[0];
      }
    }
    let name = "", type = "";
    if (attrs.length > 1) {
      name = attrs[1].replace(/^(\w+)::/, "");
      type = attrs[2];
    }
    return { id, name, type };
  }
  parseNodeProperty(line2, property, contentLine) {
    let propName = property[1].replace(/^"/, "").replace(/"$/, "").trim();
    let propValue = property[2].replace(/^"/, "").replace(/"$/, "").trim();
    if (propName === "Content" && propValue === ",") {
      propValue = contentLine.replace(/"/g, "").replace(/,$/, "").trim();
    }
    const currentNode = this.getCurrentNode();
    const parentName = currentNode.name;
    if (parentName === "Properties70") {
      this.parseNodeSpecialProperty(line2, propName, propValue);
      return;
    }
    if (propName === "C") {
      const connProps = propValue.split(",").slice(1);
      const from = parseInt(connProps[0]);
      const to = parseInt(connProps[1]);
      let rest = propValue.split(",").slice(3);
      rest = rest.map(function(elem) {
        return elem.trim().replace(/^"/, "");
      });
      propName = "connections";
      propValue = [from, to];
      append(propValue, rest);
      if (currentNode[propName] === void 0) {
        currentNode[propName] = [];
      }
    }
    if (propName === "Node")
      currentNode.id = propValue;
    if (propName in currentNode && Array.isArray(currentNode[propName])) {
      currentNode[propName].push(propValue);
    } else {
      if (propName !== "a")
        currentNode[propName] = propValue;
      else
        currentNode.a = propValue;
    }
    this.setCurrentProp(currentNode, propName);
    if (propName === "a" && propValue.slice(-1) !== ",") {
      currentNode.a = parseNumberArray(propValue);
    }
  }
  parseNodePropertyContinued(line2) {
    const currentNode = this.getCurrentNode();
    currentNode.a += line2;
    if (line2.slice(-1) !== ",") {
      currentNode.a = parseNumberArray(currentNode.a);
    }
  }
  // parse "Property70"
  parseNodeSpecialProperty(line2, propName, propValue) {
    const props = propValue.split('",').map(function(prop) {
      return prop.trim().replace(/^\"/, "").replace(/\s/, "_");
    });
    const innerPropName = props[0];
    const innerPropType1 = props[1];
    const innerPropType2 = props[2];
    const innerPropFlag = props[3];
    let innerPropValue = props[4];
    switch (innerPropType1) {
      case "int":
      case "enum":
      case "bool":
      case "ULongLong":
      case "double":
      case "Number":
      case "FieldOfView":
        innerPropValue = parseFloat(innerPropValue);
        break;
      case "Color":
      case "ColorRGB":
      case "Vector3D":
      case "Lcl_Translation":
      case "Lcl_Rotation":
      case "Lcl_Scaling":
        innerPropValue = parseNumberArray(innerPropValue);
        break;
    }
    this.getPrevNode()[innerPropName] = {
      type: innerPropType1,
      type2: innerPropType2,
      flag: innerPropFlag,
      value: innerPropValue
    };
    this.setCurrentProp(this.getPrevNode(), innerPropName);
  }
};
var BinaryParser = class {
  parse(buffer) {
    const reader = new BinaryReader(buffer);
    reader.skip(23);
    const version = reader.getUint32();
    if (version < 6400) {
      throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: " + version);
    }
    const allNodes = new FBXTree();
    while (!this.endOfContent(reader)) {
      const node = this.parseNode(reader, version);
      if (node !== null)
        allNodes.add(node.name, node);
    }
    return allNodes;
  }
  // Check if reader has reached the end of content.
  endOfContent(reader) {
    if (reader.size() % 16 === 0) {
      return (reader.getOffset() + 160 + 16 & ~15) >= reader.size();
    } else {
      return reader.getOffset() + 160 + 16 >= reader.size();
    }
  }
  // recursively parse nodes until the end of the file is reached
  parseNode(reader, version) {
    const node = {};
    const endOffset = version >= 7500 ? reader.getUint64() : reader.getUint32();
    const numProperties = version >= 7500 ? reader.getUint64() : reader.getUint32();
    version >= 7500 ? reader.getUint64() : reader.getUint32();
    const nameLen = reader.getUint8();
    const name = reader.getString(nameLen);
    if (endOffset === 0)
      return null;
    const propertyList = [];
    for (let i3 = 0; i3 < numProperties; i3++) {
      propertyList.push(this.parseProperty(reader));
    }
    const id = propertyList.length > 0 ? propertyList[0] : "";
    const attrName = propertyList.length > 1 ? propertyList[1] : "";
    const attrType = propertyList.length > 2 ? propertyList[2] : "";
    node.singleProperty = numProperties === 1 && reader.getOffset() === endOffset ? true : false;
    while (endOffset > reader.getOffset()) {
      const subNode = this.parseNode(reader, version);
      if (subNode !== null)
        this.parseSubNode(name, node, subNode);
    }
    node.propertyList = propertyList;
    if (typeof id === "number")
      node.id = id;
    if (attrName !== "")
      node.attrName = attrName;
    if (attrType !== "")
      node.attrType = attrType;
    if (name !== "")
      node.name = name;
    return node;
  }
  parseSubNode(name, node, subNode) {
    if (subNode.singleProperty === true) {
      const value = subNode.propertyList[0];
      if (Array.isArray(value)) {
        node[subNode.name] = subNode;
        subNode.a = value;
      } else {
        node[subNode.name] = value;
      }
    } else if (name === "Connections" && subNode.name === "C") {
      const array = [];
      subNode.propertyList.forEach(function(property, i3) {
        if (i3 !== 0)
          array.push(property);
      });
      if (node.connections === void 0) {
        node.connections = [];
      }
      node.connections.push(array);
    } else if (subNode.name === "Properties70") {
      const keys = Object.keys(subNode);
      keys.forEach(function(key) {
        node[key] = subNode[key];
      });
    } else if (name === "Properties70" && subNode.name === "P") {
      let innerPropName = subNode.propertyList[0];
      let innerPropType1 = subNode.propertyList[1];
      const innerPropType2 = subNode.propertyList[2];
      const innerPropFlag = subNode.propertyList[3];
      let innerPropValue;
      if (innerPropName.indexOf("Lcl ") === 0)
        innerPropName = innerPropName.replace("Lcl ", "Lcl_");
      if (innerPropType1.indexOf("Lcl ") === 0)
        innerPropType1 = innerPropType1.replace("Lcl ", "Lcl_");
      if (innerPropType1 === "Color" || innerPropType1 === "ColorRGB" || innerPropType1 === "Vector" || innerPropType1 === "Vector3D" || innerPropType1.indexOf("Lcl_") === 0) {
        innerPropValue = [subNode.propertyList[4], subNode.propertyList[5], subNode.propertyList[6]];
      } else {
        innerPropValue = subNode.propertyList[4];
      }
      node[innerPropName] = {
        type: innerPropType1,
        type2: innerPropType2,
        flag: innerPropFlag,
        value: innerPropValue
      };
    } else if (node[subNode.name] === void 0) {
      if (typeof subNode.id === "number") {
        node[subNode.name] = {};
        node[subNode.name][subNode.id] = subNode;
      } else {
        node[subNode.name] = subNode;
      }
    } else {
      if (subNode.name === "PoseNode") {
        if (!Array.isArray(node[subNode.name])) {
          node[subNode.name] = [node[subNode.name]];
        }
        node[subNode.name].push(subNode);
      } else if (node[subNode.name][subNode.id] === void 0) {
        node[subNode.name][subNode.id] = subNode;
      }
    }
  }
  parseProperty(reader) {
    const type = reader.getString(1);
    let length;
    switch (type) {
      case "C":
        return reader.getBoolean();
      case "D":
        return reader.getFloat64();
      case "F":
        return reader.getFloat32();
      case "I":
        return reader.getInt32();
      case "L":
        return reader.getInt64();
      case "R":
        length = reader.getUint32();
        return reader.getArrayBuffer(length);
      case "S":
        length = reader.getUint32();
        return reader.getString(length);
      case "Y":
        return reader.getInt16();
      case "b":
      case "c":
      case "d":
      case "f":
      case "i":
      case "l":
        const arrayLength = reader.getUint32();
        const encoding = reader.getUint32();
        const compressedLength = reader.getUint32();
        if (encoding === 0) {
          switch (type) {
            case "b":
            case "c":
              return reader.getBooleanArray(arrayLength);
            case "d":
              return reader.getFloat64Array(arrayLength);
            case "f":
              return reader.getFloat32Array(arrayLength);
            case "i":
              return reader.getInt32Array(arrayLength);
            case "l":
              return reader.getInt64Array(arrayLength);
          }
        }
        const data = unzlibSync(new Uint8Array(reader.getArrayBuffer(compressedLength)));
        const reader2 = new BinaryReader(data.buffer);
        switch (type) {
          case "b":
          case "c":
            return reader2.getBooleanArray(arrayLength);
          case "d":
            return reader2.getFloat64Array(arrayLength);
          case "f":
            return reader2.getFloat32Array(arrayLength);
          case "i":
            return reader2.getInt32Array(arrayLength);
          case "l":
            return reader2.getInt64Array(arrayLength);
        }
      default:
        throw new Error("THREE.FBXLoader: Unknown property type " + type);
    }
  }
};
var BinaryReader = class {
  constructor(buffer, littleEndian) {
    this.dv = new DataView(buffer);
    this.offset = 0;
    this.littleEndian = littleEndian !== void 0 ? littleEndian : true;
  }
  getOffset() {
    return this.offset;
  }
  size() {
    return this.dv.buffer.byteLength;
  }
  skip(length) {
    this.offset += length;
  }
  // seems like true/false representation depends on exporter.
  // true: 1 or 'Y'(=0x59), false: 0 or 'T'(=0x54)
  // then sees LSB.
  getBoolean() {
    return (this.getUint8() & 1) === 1;
  }
  getBooleanArray(size2) {
    const a4 = [];
    for (let i3 = 0; i3 < size2; i3++) {
      a4.push(this.getBoolean());
    }
    return a4;
  }
  getUint8() {
    const value = this.dv.getUint8(this.offset);
    this.offset += 1;
    return value;
  }
  getInt16() {
    const value = this.dv.getInt16(this.offset, this.littleEndian);
    this.offset += 2;
    return value;
  }
  getInt32() {
    const value = this.dv.getInt32(this.offset, this.littleEndian);
    this.offset += 4;
    return value;
  }
  getInt32Array(size2) {
    const a4 = [];
    for (let i3 = 0; i3 < size2; i3++) {
      a4.push(this.getInt32());
    }
    return a4;
  }
  getUint32() {
    const value = this.dv.getUint32(this.offset, this.littleEndian);
    this.offset += 4;
    return value;
  }
  // JavaScript doesn't support 64-bit integer so calculate this here
  // 1 << 32 will return 1 so using multiply operation instead here.
  // There's a possibility that this method returns wrong value if the value
  // is out of the range between Number.MAX_SAFE_INTEGER and Number.MIN_SAFE_INTEGER.
  // TODO: safely handle 64-bit integer
  getInt64() {
    let low, high;
    if (this.littleEndian) {
      low = this.getUint32();
      high = this.getUint32();
    } else {
      high = this.getUint32();
      low = this.getUint32();
    }
    if (high & 2147483648) {
      high = ~high & 4294967295;
      low = ~low & 4294967295;
      if (low === 4294967295)
        high = high + 1 & 4294967295;
      low = low + 1 & 4294967295;
      return -(high * 4294967296 + low);
    }
    return high * 4294967296 + low;
  }
  getInt64Array(size2) {
    const a4 = [];
    for (let i3 = 0; i3 < size2; i3++) {
      a4.push(this.getInt64());
    }
    return a4;
  }
  // Note: see getInt64() comment
  getUint64() {
    let low, high;
    if (this.littleEndian) {
      low = this.getUint32();
      high = this.getUint32();
    } else {
      high = this.getUint32();
      low = this.getUint32();
    }
    return high * 4294967296 + low;
  }
  getFloat32() {
    const value = this.dv.getFloat32(this.offset, this.littleEndian);
    this.offset += 4;
    return value;
  }
  getFloat32Array(size2) {
    const a4 = [];
    for (let i3 = 0; i3 < size2; i3++) {
      a4.push(this.getFloat32());
    }
    return a4;
  }
  getFloat64() {
    const value = this.dv.getFloat64(this.offset, this.littleEndian);
    this.offset += 8;
    return value;
  }
  getFloat64Array(size2) {
    const a4 = [];
    for (let i3 = 0; i3 < size2; i3++) {
      a4.push(this.getFloat64());
    }
    return a4;
  }
  getArrayBuffer(size2) {
    const value = this.dv.buffer.slice(this.offset, this.offset + size2);
    this.offset += size2;
    return value;
  }
  getString(size2) {
    let a4 = [];
    for (let i3 = 0; i3 < size2; i3++) {
      a4[i3] = this.getUint8();
    }
    const nullByte = a4.indexOf(0);
    if (nullByte >= 0)
      a4 = a4.slice(0, nullByte);
    return LoaderUtils.decodeText(new Uint8Array(a4));
  }
};
var FBXTree = class {
  add(key, val) {
    this[key] = val;
  }
};
function isFbxFormatBinary(buffer) {
  const CORRECT = "Kaydara FBX Binary  \0";
  return buffer.byteLength >= CORRECT.length && CORRECT === convertArrayBufferToString(buffer, 0, CORRECT.length);
}
function isFbxFormatASCII(text) {
  const CORRECT = [
    "K",
    "a",
    "y",
    "d",
    "a",
    "r",
    "a",
    "\\",
    "F",
    "B",
    "X",
    "\\",
    "B",
    "i",
    "n",
    "a",
    "r",
    "y",
    "\\",
    "\\"
  ];
  let cursor = 0;
  function read2(offset) {
    const result = text[offset - 1];
    text = text.slice(cursor + offset);
    cursor++;
    return result;
  }
  for (let i3 = 0; i3 < CORRECT.length; ++i3) {
    const num = read2(1);
    if (num === CORRECT[i3]) {
      return false;
    }
  }
  return true;
}
function getFbxVersion(text) {
  const versionRegExp = /FBXVersion: (\d+)/;
  const match = text.match(versionRegExp);
  if (match) {
    const version = parseInt(match[1]);
    return version;
  }
  throw new Error("THREE.FBXLoader: Cannot find the version number for the file given.");
}
function convertFBXTimeToSeconds(time) {
  return time / 46186158e3;
}
var dataArray = [];
function getData(polygonVertexIndex, polygonIndex, vertexIndex, infoObject) {
  let index;
  switch (infoObject.mappingType) {
    case "ByPolygonVertex":
      index = polygonVertexIndex;
      break;
    case "ByPolygon":
      index = polygonIndex;
      break;
    case "ByVertice":
      index = vertexIndex;
      break;
    case "AllSame":
      index = infoObject.indices[0];
      break;
    default:
      console.warn("THREE.FBXLoader: unknown attribute mapping type " + infoObject.mappingType);
  }
  if (infoObject.referenceType === "IndexToDirect")
    index = infoObject.indices[index];
  const from = index * infoObject.dataSize;
  const to = from + infoObject.dataSize;
  return slice(dataArray, infoObject.buffer, from, to);
}
var tempEuler = new Euler();
var tempVec = new Vector3();
function generateTransform(transformData) {
  const lTranslationM = new Matrix4();
  const lPreRotationM = new Matrix4();
  const lRotationM = new Matrix4();
  const lPostRotationM = new Matrix4();
  const lScalingM = new Matrix4();
  const lScalingPivotM = new Matrix4();
  const lScalingOffsetM = new Matrix4();
  const lRotationOffsetM = new Matrix4();
  const lRotationPivotM = new Matrix4();
  const lParentGX = new Matrix4();
  const lParentLX = new Matrix4();
  const lGlobalT = new Matrix4();
  const inheritType = transformData.inheritType ? transformData.inheritType : 0;
  if (transformData.translation)
    lTranslationM.setPosition(tempVec.fromArray(transformData.translation));
  if (transformData.preRotation) {
    const array = transformData.preRotation.map(MathUtils.degToRad);
    array.push(transformData.eulerOrder);
    lPreRotationM.makeRotationFromEuler(tempEuler.fromArray(array));
  }
  if (transformData.rotation) {
    const array = transformData.rotation.map(MathUtils.degToRad);
    array.push(transformData.eulerOrder);
    lRotationM.makeRotationFromEuler(tempEuler.fromArray(array));
  }
  if (transformData.postRotation) {
    const array = transformData.postRotation.map(MathUtils.degToRad);
    array.push(transformData.eulerOrder);
    lPostRotationM.makeRotationFromEuler(tempEuler.fromArray(array));
    lPostRotationM.invert();
  }
  if (transformData.scale)
    lScalingM.scale(tempVec.fromArray(transformData.scale));
  if (transformData.scalingOffset)
    lScalingOffsetM.setPosition(tempVec.fromArray(transformData.scalingOffset));
  if (transformData.scalingPivot)
    lScalingPivotM.setPosition(tempVec.fromArray(transformData.scalingPivot));
  if (transformData.rotationOffset)
    lRotationOffsetM.setPosition(tempVec.fromArray(transformData.rotationOffset));
  if (transformData.rotationPivot)
    lRotationPivotM.setPosition(tempVec.fromArray(transformData.rotationPivot));
  if (transformData.parentMatrixWorld) {
    lParentLX.copy(transformData.parentMatrix);
    lParentGX.copy(transformData.parentMatrixWorld);
  }
  const lLRM = lPreRotationM.clone().multiply(lRotationM).multiply(lPostRotationM);
  const lParentGRM = new Matrix4();
  lParentGRM.extractRotation(lParentGX);
  const lParentTM = new Matrix4();
  lParentTM.copyPosition(lParentGX);
  const lParentGRSM = lParentTM.clone().invert().multiply(lParentGX);
  const lParentGSM = lParentGRM.clone().invert().multiply(lParentGRSM);
  const lLSM = lScalingM;
  const lGlobalRS = new Matrix4();
  if (inheritType === 0) {
    lGlobalRS.copy(lParentGRM).multiply(lLRM).multiply(lParentGSM).multiply(lLSM);
  } else if (inheritType === 1) {
    lGlobalRS.copy(lParentGRM).multiply(lParentGSM).multiply(lLRM).multiply(lLSM);
  } else {
    const lParentLSM = new Matrix4().scale(new Vector3().setFromMatrixScale(lParentLX));
    const lParentLSM_inv = lParentLSM.clone().invert();
    const lParentGSM_noLocal = lParentGSM.clone().multiply(lParentLSM_inv);
    lGlobalRS.copy(lParentGRM).multiply(lLRM).multiply(lParentGSM_noLocal).multiply(lLSM);
  }
  const lRotationPivotM_inv = lRotationPivotM.clone().invert();
  const lScalingPivotM_inv = lScalingPivotM.clone().invert();
  let lTransform = lTranslationM.clone().multiply(lRotationOffsetM).multiply(lRotationPivotM).multiply(lPreRotationM).multiply(lRotationM).multiply(lPostRotationM).multiply(lRotationPivotM_inv).multiply(lScalingOffsetM).multiply(lScalingPivotM).multiply(lScalingM).multiply(lScalingPivotM_inv);
  const lLocalTWithAllPivotAndOffsetInfo = new Matrix4().copyPosition(lTransform);
  const lGlobalTranslation = lParentGX.clone().multiply(lLocalTWithAllPivotAndOffsetInfo);
  lGlobalT.copyPosition(lGlobalTranslation);
  lTransform = lGlobalT.clone().multiply(lGlobalRS);
  lTransform.premultiply(lParentGX.invert());
  return lTransform;
}
function getEulerOrder(order) {
  order = order || 0;
  const enums = [
    "ZYX",
    // -> XYZ extrinsic
    "YZX",
    // -> XZY extrinsic
    "XZY",
    // -> YZX extrinsic
    "ZXY",
    // -> YXZ extrinsic
    "YXZ",
    // -> ZXY extrinsic
    "XYZ"
    // -> ZYX extrinsic
    //'SphericXYZ', // not possible to support
  ];
  if (order === 6) {
    console.warn("THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect.");
    return enums[0];
  }
  return enums[order];
}
function parseNumberArray(value) {
  const array = value.split(",").map(function(val) {
    return parseFloat(val);
  });
  return array;
}
function convertArrayBufferToString(buffer, from, to) {
  if (from === void 0)
    from = 0;
  if (to === void 0)
    to = buffer.byteLength;
  return LoaderUtils.decodeText(new Uint8Array(buffer, from, to));
}
function append(a4, b5) {
  for (let i3 = 0, j = a4.length, l = b5.length; i3 < l; i3++, j++) {
    a4[j] = b5[i3];
  }
}
function slice(a4, b5, from, to) {
  for (let i3 = from, j = 0; i3 < to; i3++, j++) {
    a4[j] = b5[i3];
  }
  return a4;
}
function inject(a1, index, a22) {
  return a1.slice(0, index).concat(a22).concat(a1.slice(index));
}

// node_modules/three-stdlib/loaders/FontLoader.js
var __defProp21 = Object.defineProperty;
var __defNormalProp21 = (obj, key, value) => key in obj ? __defProp21(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField22 = (obj, key, value) => {
  __defNormalProp21(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var FontLoader = class extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(url, onLoad, onProgress, onError) {
    const loader = new FileLoader(this.manager);
    loader.setPath(this.path);
    loader.setRequestHeader(this.requestHeader);
    loader.setWithCredentials(this.withCredentials);
    loader.load(
      url,
      (response) => {
        if (typeof response !== "string")
          throw new Error("unsupported data type");
        const json = JSON.parse(response);
        const font = this.parse(json);
        if (onLoad)
          onLoad(font);
      },
      onProgress,
      onError
    );
  }
  loadAsync(url, onProgress) {
    return super.loadAsync(url, onProgress);
  }
  parse(json) {
    return new Font(json);
  }
};
var Font = class {
  constructor(data) {
    __publicField22(this, "data");
    this.data = data;
  }
  generateShapes(text, size2 = 100, _options) {
    const shapes = [];
    const options = { letterSpacing: 0, lineHeight: 1, ..._options };
    const paths = createPaths(text, size2, this.data, options);
    for (let p = 0, pl = paths.length; p < pl; p++) {
      Array.prototype.push.apply(shapes, paths[p].toShapes(false));
    }
    return shapes;
  }
};
__publicField22(Font, "isFont");
__publicField22(Font, "type");
function createPaths(text, size2, data, options) {
  const chars = Array.from(text);
  const scale = size2 / data.resolution;
  const line_height = (data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness) * scale;
  const paths = [];
  let offsetX = 0, offsetY = 0;
  for (let i3 = 0; i3 < chars.length; i3++) {
    const char = chars[i3];
    if (char === "\n") {
      offsetX = 0;
      offsetY -= line_height * options.lineHeight;
    } else {
      const ret = createPath(char, scale, offsetX, offsetY, data);
      if (ret) {
        offsetX += ret.offsetX + options.letterSpacing;
        paths.push(ret.path);
      }
    }
  }
  return paths;
}
function createPath(char, scale, offsetX, offsetY, data) {
  const glyph = data.glyphs[char] || data.glyphs["?"];
  if (!glyph) {
    console.error('THREE.Font: character "' + char + '" does not exists in font family ' + data.familyName + ".");
    return;
  }
  const path = new ShapePath();
  let x, y, cpx, cpy, cpx1, cpy1, cpx2, cpy2;
  if (glyph.o) {
    const outline = glyph._cachedOutline || (glyph._cachedOutline = glyph.o.split(" "));
    for (let i3 = 0, l = outline.length; i3 < l; ) {
      const action = outline[i3++];
      switch (action) {
        case "m":
          x = parseInt(outline[i3++]) * scale + offsetX;
          y = parseInt(outline[i3++]) * scale + offsetY;
          path.moveTo(x, y);
          break;
        case "l":
          x = parseInt(outline[i3++]) * scale + offsetX;
          y = parseInt(outline[i3++]) * scale + offsetY;
          path.lineTo(x, y);
          break;
        case "q":
          cpx = parseInt(outline[i3++]) * scale + offsetX;
          cpy = parseInt(outline[i3++]) * scale + offsetY;
          cpx1 = parseInt(outline[i3++]) * scale + offsetX;
          cpy1 = parseInt(outline[i3++]) * scale + offsetY;
          path.quadraticCurveTo(cpx1, cpy1, cpx, cpy);
          break;
        case "b":
          cpx = parseInt(outline[i3++]) * scale + offsetX;
          cpy = parseInt(outline[i3++]) * scale + offsetY;
          cpx1 = parseInt(outline[i3++]) * scale + offsetX;
          cpy1 = parseInt(outline[i3++]) * scale + offsetY;
          cpx2 = parseInt(outline[i3++]) * scale + offsetX;
          cpy2 = parseInt(outline[i3++]) * scale + offsetY;
          path.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, cpx, cpy);
          break;
      }
    }
  }
  return { offsetX: glyph.ha * scale, path };
}

// node_modules/three-stdlib/_polyfill/Data3DTexture.js
var Data3DTexture = class extends Texture {
  constructor(data = null, width = 1, height = 1, depth = 1) {
    super(null);
    this.isData3DTexture = true;
    this.image = { data, width, height, depth };
    this.magFilter = NearestFilter;
    this.minFilter = NearestFilter;
    this.wrapR = ClampToEdgeWrapping;
    this.generateMipmaps = false;
    this.flipY = false;
    this.unpackAlignment = 1;
  }
};

// node_modules/three-stdlib/loaders/XLoader.js
var XLoader = function() {
  var classCallCheck = function(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  };
  var createClass = function() {
    function defineProperties(target, props) {
      for (let i22 = 0; i22 < props.length; i22++) {
        var descriptor = props[i22];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    return function(Constructor, protoProps, staticProps) {
      if (protoProps)
        defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();
  var XboneInf = function XboneInf2() {
    classCallCheck(this, XboneInf2);
    this.boneName = "";
    this.BoneIndex = 0;
    this.Indeces = [];
    this.Weights = [];
    this.initMatrix = null;
    this.OffsetMatrix = null;
  };
  var XAnimationInfo = function XAnimationInfo2() {
    classCallCheck(this, XAnimationInfo2);
    this.animeName = "";
    this.boneName = "";
    this.targetBone = null;
    this.keyType = 4;
    this.frameStartLv = 0;
    this.keyFrames = [];
    this.InverseMx = null;
  };
  var XAnimationObj = function() {
    function XAnimationObj2(_flags) {
      classCallCheck(this, XAnimationObj2);
      this.fps = 30;
      this.name = "xanimation";
      this.length = 0;
      this.hierarchy = [];
      this.putFlags = _flags;
      if (this.putFlags.putPos === void 0) {
        this.putFlags.putPos = true;
      }
      if (this.putFlags.putRot === void 0) {
        this.putFlags.putRot = true;
      }
      if (this.putFlags.putScl === void 0) {
        this.putFlags.putScl = true;
      }
    }
    createClass(XAnimationObj2, [
      {
        key: "make",
        value: function make(XAnimationInfoArray) {
          for (let i22 = 0; i22 < XAnimationInfoArray.length; i22++) {
            this.hierarchy.push(this.makeBonekeys(XAnimationInfoArray[i22]));
          }
          this.length = this.hierarchy[0].keys[this.hierarchy[0].keys.length - 1].time;
        }
      },
      {
        key: "clone",
        value: function clone2() {
          return Object.assign({}, this);
        }
      },
      {
        key: "makeBonekeys",
        value: function makeBonekeys(XAnimationInfo2) {
          var refObj = {};
          refObj.name = XAnimationInfo2.boneName;
          refObj.parent = "";
          refObj.keys = this.keyFrameRefactor(XAnimationInfo2);
          refObj.copy = function() {
            return Object.assign({}, this);
          };
          return refObj;
        }
      },
      {
        key: "keyFrameRefactor",
        value: function keyFrameRefactor(XAnimationInfo2) {
          var keys = [];
          for (let i22 = 0; i22 < XAnimationInfo2.keyFrames.length; i22++) {
            var keyframe = {};
            keyframe.time = XAnimationInfo2.keyFrames[i22].time * this.fps;
            if (XAnimationInfo2.keyFrames[i22].pos && this.putFlags.putPos) {
              keyframe.pos = XAnimationInfo2.keyFrames[i22].pos;
            }
            if (XAnimationInfo2.keyFrames[i22].rot && this.putFlags.putRot) {
              keyframe.rot = XAnimationInfo2.keyFrames[i22].rot;
            }
            if (XAnimationInfo2.keyFrames[i22].scl && this.putFlags.putScl) {
              keyframe.scl = XAnimationInfo2.keyFrames[i22].scl;
            }
            if (XAnimationInfo2.keyFrames[i22].matrix) {
              keyframe.matrix = XAnimationInfo2.keyFrames[i22].matrix;
              if (this.putFlags.putPos) {
                keyframe.pos = new Vector3().setFromMatrixPosition(keyframe.matrix);
              }
              if (this.putFlags.putRot) {
                keyframe.rot = new Quaternion().setFromRotationMatrix(keyframe.matrix);
              }
              if (this.putFlags.putScl) {
                keyframe.scl = new Vector3().setFromMatrixScale(keyframe.matrix);
              }
            }
            keys.push(keyframe);
          }
          return keys;
        }
      }
    ]);
    return XAnimationObj2;
  }();
  var XKeyFrameInfo = function XKeyFrameInfo2() {
    classCallCheck(this, XKeyFrameInfo2);
    this.index = 0;
    this.Frame = 0;
    this.time = 0;
    this.matrix = null;
  };
  var XLoader2 = function() {
    function XLoader3(manager) {
      Loader.call(this, manager);
      classCallCheck(this, XLoader3);
      this.debug = false;
      this.texloader = new TextureLoader(this.manager);
      this.url = "";
      this._putMatLength = 0;
      this._nowMat = null;
      this._nowFrameName = "";
      this.frameHierarchie = [];
      this.Hierarchies = {};
      this.HieStack = [];
      this._currentObject = {};
      this._currentFrame = {};
      this._data = null;
      this.onLoad = null;
      this.IsUvYReverse = true;
      this.Meshes = [];
      this.animations = [];
      this.animTicksPerSecond = 30;
      this._currentGeo = null;
      this._currentAnime = null;
      this._currentAnimeFrames = null;
    }
    createClass(XLoader3, [
      {
        key: "_setArgOption",
        value: function _setArgOption(_arg) {
          var _start3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
          if (!_arg) {
            return;
          }
          for (let i22 = _start3; i22 < _arg.length; i22++) {
            switch (i22) {
              case 0:
                this.url = _arg[i22];
                break;
              case 1:
                this.options = _arg[i22];
                break;
            }
          }
          if (this.options === void 0) {
            this.options = {};
          }
        }
      },
      {
        key: "load",
        value: function load2(_arg, onLoad, onProgress, onError) {
          var _this = this;
          this._setArgOption(_arg);
          var loader = new FileLoader(this.manager);
          loader.setPath(this.path);
          loader.setResponseType("arraybuffer");
          loader.setRequestHeader(this.requestHeader);
          loader.setWithCredentials(this.withCredentials);
          loader.load(
            this.url,
            function(response) {
              try {
                _this.parse(response, onLoad);
              } catch (e) {
                if (onError) {
                  onError(e);
                } else {
                  console.error(e);
                }
                _this.manager.itemError(_this.url);
              }
            },
            onProgress,
            onError
          );
        }
      },
      {
        key: "_readLine",
        value: function _readLine(line2) {
          var readed = 0;
          while (true) {
            var find = -1;
            find = line2.indexOf("//", readed);
            if (find === -1) {
              find = line2.indexOf("#", readed);
            }
            if (find > -1 && find < 2) {
              var foundNewLine = -1;
              foundNewLine = line2.indexOf("\r\n", readed);
              if (foundNewLine > 0) {
                readed = foundNewLine + 2;
              } else {
                foundNewLine = line2.indexOf("\r", readed);
                if (foundNewLine > 0) {
                  readed = foundNewLine + 1;
                } else {
                  readed = line2.indexOf("\n", readed) + 1;
                }
              }
            } else {
              break;
            }
          }
          return line2.substr(readed);
        }
      },
      {
        key: "_readLine",
        value: function _readLine(line2) {
          var readed = 0;
          while (true) {
            var find = -1;
            find = line2.indexOf("//", readed);
            if (find === -1) {
              find = line2.indexOf("#", readed);
            }
            if (find > -1 && find < 2) {
              var foundNewLine = -1;
              foundNewLine = line2.indexOf("\r\n", readed);
              if (foundNewLine > 0) {
                readed = foundNewLine + 2;
              } else {
                foundNewLine = line2.indexOf("\r", readed);
                if (foundNewLine > 0) {
                  readed = foundNewLine + 1;
                } else {
                  readed = line2.indexOf("\n", readed) + 1;
                }
              }
            } else {
              break;
            }
          }
          return line2.substr(readed);
        }
      },
      {
        key: "_isBinary",
        value: function _isBinary(binData) {
          var reader = new DataView(binData);
          var face_size = 32 / 8 * 3 + 32 / 8 * 3 * 3 + 16 / 8;
          var n_faces = reader.getUint32(80, true);
          var expect = 80 + 32 / 8 + n_faces * face_size;
          if (expect === reader.byteLength) {
            return true;
          }
          var fileLength = reader.byteLength;
          for (let index = 0; index < fileLength; index++) {
            if (reader.getUint8(index, false) > 127) {
              return true;
            }
          }
          return false;
        }
      },
      {
        key: "_ensureBinary",
        value: function _ensureBinary(buf) {
          if (typeof buf === "string") {
            var array_buffer = new Uint8Array(buf.length);
            for (let i22 = 0; i22 < buf.length; i22++) {
              array_buffer[i22] = buf.charCodeAt(i22) & 255;
            }
            return array_buffer.buffer || array_buffer;
          } else {
            return buf;
          }
        }
      },
      {
        key: "_ensureString",
        value: function _ensureString(buf) {
          if (typeof buf !== "string") {
            return LoaderUtils.decodeText(new Uint8Array(buf));
          } else {
            return buf;
          }
        }
      },
      {
        key: "parse",
        value: function _parse(data, onLoad) {
          var binData = this._ensureBinary(data);
          this._data = this._ensureString(data);
          this.onLoad = onLoad;
          return this._isBinary(binData) ? this._parseBinary(binData) : this._parseASCII();
        }
      },
      {
        key: "_parseBinary",
        value: function _parseBinary(data) {
          return this._parseASCII(LoaderUtils.decodeText(new Uint8Array(data)));
        }
      },
      {
        key: "_parseASCII",
        value: function _parseASCII() {
          var path;
          if (this.resourcePath !== "") {
            path = this.resourcePath;
          } else if (this.path !== "") {
            path = this.path;
          } else {
            path = LoaderUtils.extractUrlBase(this.url);
          }
          this.texloader.setPath(path).setCrossOrigin(this.crossOrigin);
          var endRead = 16;
          this.Hierarchies.children = [];
          this._hierarchieParse(this.Hierarchies, endRead);
          this._changeRoot();
          this._currentObject = this.Hierarchies.children.shift();
          this._mainloop();
        }
      },
      {
        key: "_hierarchieParse",
        value: function _hierarchieParse(_parent, _end3) {
          var endRead = _end3;
          while (true) {
            var find1 = this._data.indexOf("{", endRead) + 1;
            var findEnd = this._data.indexOf("}", endRead);
            var findNext = this._data.indexOf("{", find1) + 1;
            if (find1 > 0 && findEnd > find1) {
              var _currentObject = {};
              _currentObject.children = [];
              var nameData = this._readLine(this._data.substr(endRead, find1 - endRead - 1)).trim();
              var word = nameData.split(/ /g);
              if (word.length > 0) {
                _currentObject.type = word[0];
                if (word.length >= 2) {
                  _currentObject.name = word[1];
                } else {
                  _currentObject.name = word[0] + this.Hierarchies.children.length;
                }
              } else {
                _currentObject.name = nameData;
                _currentObject.type = "";
              }
              if (_currentObject.type === "Animation") {
                _currentObject.data = this._data.substr(findNext, findEnd - findNext).trim();
                var refs = this._hierarchieParse(_currentObject, findEnd + 1);
                endRead = refs.end;
                _currentObject.children = refs.parent.children;
              } else {
                var DataEnder = this._data.lastIndexOf(";", findNext > 0 ? Math.min(findNext, findEnd) : findEnd);
                _currentObject.data = this._data.substr(find1, DataEnder - find1).trim();
                if (findNext <= 0 || findEnd < findNext) {
                  endRead = findEnd + 1;
                } else {
                  var nextStart = Math.max(DataEnder + 1, find1);
                  var _refs = this._hierarchieParse(_currentObject, nextStart);
                  endRead = _refs.end;
                  _currentObject.children = _refs.parent.children;
                }
              }
              _currentObject.parent = _parent;
              if (_currentObject.type != "template") {
                _parent.children.push(_currentObject);
              }
            } else {
              endRead = find1 === -1 ? this._data.length : findEnd + 1;
              break;
            }
          }
          return {
            parent: _parent,
            end: endRead
          };
        }
      },
      {
        key: "_mainloop",
        value: function _mainloop() {
          var _this2 = this;
          this._mainProc();
          if (this._currentObject.parent || this._currentObject.children.length > 0 || !this._currentObject.worked) {
            setTimeout(function() {
              _this2._mainloop();
            }, 1);
          } else {
            setTimeout(function() {
              _this2.onLoad({
                models: _this2.Meshes,
                animations: _this2.animations
              });
            }, 1);
          }
        }
      },
      {
        key: "_mainProc",
        value: function _mainProc() {
          var breakFlag = false;
          while (true) {
            if (!this._currentObject.worked) {
              switch (this._currentObject.type) {
                case "template":
                  break;
                case "AnimTicksPerSecond":
                  this.animTicksPerSecond = parseInt(this._currentObject.data);
                  break;
                case "Frame":
                  this._setFrame();
                  break;
                case "FrameTransformMatrix":
                  this._setFrameTransformMatrix();
                  break;
                case "Mesh":
                  this._changeRoot();
                  this._currentGeo = {};
                  this._currentGeo.name = this._currentObject.name.trim();
                  this._currentGeo.parentName = this._getParentName(this._currentObject).trim();
                  this._currentGeo.VertexSetedBoneCount = [];
                  this._currentGeo.GeometryData = {
                    vertices: [],
                    normals: [],
                    uvs: [],
                    skinIndices: [],
                    skinWeights: [],
                    indices: [],
                    materialIndices: []
                  };
                  this._currentGeo.Materials = [];
                  this._currentGeo.normalVectors = [];
                  this._currentGeo.BoneInfs = [];
                  this._currentGeo.baseFrame = this._currentFrame;
                  this._makeBoneFrom_CurrentFrame();
                  this._readVertexDatas();
                  breakFlag = true;
                  break;
                case "MeshNormals":
                  this._readVertexDatas();
                  break;
                case "MeshTextureCoords":
                  this._setMeshTextureCoords();
                  break;
                case "VertexDuplicationIndices":
                  break;
                case "MeshMaterialList":
                  this._setMeshMaterialList();
                  break;
                case "Material":
                  this._setMaterial();
                  break;
                case "SkinWeights":
                  this._setSkinWeights();
                  break;
                case "AnimationSet":
                  this._changeRoot();
                  this._currentAnime = {};
                  this._currentAnime.name = this._currentObject.name.trim();
                  this._currentAnime.AnimeFrames = [];
                  break;
                case "Animation":
                  if (this._currentAnimeFrames) {
                    this._currentAnime.AnimeFrames.push(this._currentAnimeFrames);
                  }
                  this._currentAnimeFrames = new XAnimationInfo();
                  this._currentAnimeFrames.boneName = this._currentObject.data.trim();
                  break;
                case "AnimationKey":
                  this._readAnimationKey();
                  breakFlag = true;
                  break;
              }
              this._currentObject.worked = true;
            }
            if (this._currentObject.children.length > 0) {
              this._currentObject = this._currentObject.children.shift();
              if (this.debug) {
                console.log("processing " + this._currentObject.name);
              }
              if (breakFlag)
                break;
            } else {
              if (this._currentObject.worked) {
                if (this._currentObject.parent && !this._currentObject.parent.parent) {
                  this._changeRoot();
                }
              }
              if (this._currentObject.parent) {
                this._currentObject = this._currentObject.parent;
              } else {
                breakFlag = true;
              }
              if (breakFlag)
                break;
            }
          }
          return;
        }
      },
      {
        key: "_changeRoot",
        value: function _changeRoot() {
          if (this._currentGeo != null && this._currentGeo.name) {
            this._makeOutputGeometry();
          }
          this._currentGeo = {};
          if (this._currentAnime != null && this._currentAnime.name) {
            if (this._currentAnimeFrames) {
              this._currentAnime.AnimeFrames.push(this._currentAnimeFrames);
              this._currentAnimeFrames = null;
            }
            this._makeOutputAnimation();
          }
          this._currentAnime = {};
        }
      },
      {
        key: "_getParentName",
        value: function _getParentName(_obj2) {
          if (_obj2.parent) {
            if (_obj2.parent.name) {
              return _obj2.parent.name;
            } else {
              return this._getParentName(_obj2.parent);
            }
          } else {
            return "";
          }
        }
      },
      {
        key: "_setFrame",
        value: function _setFrame() {
          this._nowFrameName = this._currentObject.name.trim();
          this._currentFrame = {};
          this._currentFrame.name = this._nowFrameName;
          this._currentFrame.children = [];
          if (this._currentObject.parent && this._currentObject.parent.name) {
            this._currentFrame.parentName = this._currentObject.parent.name;
          }
          this.frameHierarchie.push(this._nowFrameName);
          this.HieStack[this._nowFrameName] = this._currentFrame;
        }
      },
      {
        key: "_setFrameTransformMatrix",
        value: function _setFrameTransformMatrix() {
          this._currentFrame.FrameTransformMatrix = new Matrix4();
          var data = this._currentObject.data.split(",");
          this._ParseMatrixData(this._currentFrame.FrameTransformMatrix, data);
          this._makeBoneFrom_CurrentFrame();
        }
      },
      {
        key: "_makeBoneFrom_CurrentFrame",
        value: function _makeBoneFrom_CurrentFrame() {
          if (!this._currentFrame.FrameTransformMatrix) {
            return;
          }
          var b5 = new Bone();
          b5.name = this._currentFrame.name;
          b5.applyMatrix4(this._currentFrame.FrameTransformMatrix);
          b5.matrixWorld = b5.matrix;
          b5.FrameTransformMatrix = this._currentFrame.FrameTransformMatrix;
          this._currentFrame.putBone = b5;
          if (this._currentFrame.parentName) {
            for (let frame in this.HieStack) {
              if (this.HieStack[frame].name === this._currentFrame.parentName) {
                this.HieStack[frame].putBone.add(this._currentFrame.putBone);
              }
            }
          }
        }
      },
      {
        key: "_readVertexDatas",
        value: function _readVertexDatas() {
          var endRead = 0;
          var mode = 0;
          var mode_local = 0;
          var maxLength = 0;
          while (true) {
            var changeMode = false;
            if (mode_local === 0) {
              var refO = this._readInt1(endRead);
              endRead = refO.endRead;
              mode_local = 1;
              maxLength = this._currentObject.data.indexOf(";;", endRead) + 1;
              if (maxLength <= 0) {
                maxLength = this._currentObject.data.length;
              }
            } else {
              var find = 0;
              switch (mode) {
                case 0:
                  find = this._currentObject.data.indexOf(",", endRead) + 1;
                  break;
                case 1:
                  find = this._currentObject.data.indexOf(";,", endRead) + 1;
                  break;
              }
              if (find === 0 || find > maxLength) {
                find = maxLength;
                mode_local = 0;
                changeMode = true;
              }
              switch (this._currentObject.type) {
                case "Mesh":
                  switch (mode) {
                    case 0:
                      this._readVertex1(this._currentObject.data.substr(endRead, find - endRead));
                      break;
                    case 1:
                      this._readFace1(this._currentObject.data.substr(endRead, find - endRead));
                      break;
                  }
                  break;
                case "MeshNormals":
                  switch (mode) {
                    case 0:
                      this._readNormalVector1(this._currentObject.data.substr(endRead, find - endRead));
                      break;
                  }
                  break;
              }
              endRead = find + 1;
              if (changeMode) {
                mode++;
              }
            }
            if (endRead >= this._currentObject.data.length) {
              break;
            }
          }
        }
      },
      {
        key: "_readInt1",
        value: function _readInt1(start) {
          var find = this._currentObject.data.indexOf(";", start);
          return {
            refI: parseInt(this._currentObject.data.substr(start, find - start)),
            endRead: find + 1
          };
        }
      },
      {
        key: "_readVertex1",
        value: function _readVertex1(line2) {
          var data = this._readLine(line2.trim()).substr(0, line2.length - 2).split(";");
          this._currentGeo.GeometryData.vertices.push(parseFloat(data[0]), parseFloat(data[1]), parseFloat(data[2]));
          this._currentGeo.GeometryData.skinIndices.push(0, 0, 0, 0);
          this._currentGeo.GeometryData.skinWeights.push(1, 0, 0, 0);
          this._currentGeo.VertexSetedBoneCount.push(0);
        }
      },
      {
        key: "_readFace1",
        value: function _readFace1(line2) {
          var data = this._readLine(line2.trim()).substr(2, line2.length - 4).split(",");
          this._currentGeo.GeometryData.indices.push(
            parseInt(data[0], 10),
            parseInt(data[1], 10),
            parseInt(data[2], 10)
          );
        }
      },
      {
        key: "_readNormalVector1",
        value: function _readNormalVector1(line2) {
          var data = this._readLine(line2.trim()).substr(0, line2.length - 2).split(";");
          this._currentGeo.GeometryData.normals.push(parseFloat(data[0]), parseFloat(data[1]), parseFloat(data[2]));
        }
      },
      {
        key: "_buildGeometry",
        value: function _buildGeometry() {
          var bufferGeometry = new BufferGeometry();
          var position = [];
          var normals = [];
          var uvs = [];
          var skinIndices = [];
          var skinWeights = [];
          var data = this._currentGeo.GeometryData;
          for (let i22 = 0, l = data.indices.length; i22 < l; i22++) {
            var stride2 = data.indices[i22] * 2;
            var stride3 = data.indices[i22] * 3;
            var stride4 = data.indices[i22] * 4;
            position.push(data.vertices[stride3], data.vertices[stride3 + 1], data.vertices[stride3 + 2]);
            normals.push(data.normals[stride3], data.normals[stride3 + 1], data.normals[stride3 + 2]);
            skinIndices.push(
              data.skinIndices[stride4],
              data.skinIndices[stride4 + 1],
              data.skinIndices[stride4 + 2],
              data.skinIndices[stride4 + 3]
            );
            skinWeights.push(
              data.skinWeights[stride4],
              data.skinWeights[stride4 + 1],
              data.skinWeights[stride4 + 2],
              data.skinWeights[stride4 + 3]
            );
            uvs.push(data.uvs[stride2], data.uvs[stride2 + 1]);
          }
          bufferGeometry.setAttribute("position", new Float32BufferAttribute(position, 3));
          bufferGeometry.setAttribute("normal", new Float32BufferAttribute(normals, 3));
          bufferGeometry.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
          bufferGeometry.setAttribute("skinIndex", new Uint16BufferAttribute(skinIndices, 4));
          bufferGeometry.setAttribute("skinWeight", new Float32BufferAttribute(skinWeights, 4));
          this._computeGroups(bufferGeometry, data.materialIndices);
          return bufferGeometry;
        }
      },
      {
        key: "_computeGroups",
        value: function _computeGroups(bufferGeometry, materialIndices) {
          var group;
          var groups = [];
          var materialIndex = void 0;
          for (let i22 = 0; i22 < materialIndices.length; i22++) {
            var currentMaterialIndex = materialIndices[i22];
            if (currentMaterialIndex !== materialIndex) {
              materialIndex = currentMaterialIndex;
              if (group !== void 0) {
                group.count = i22 * 3 - group.start;
                groups.push(group);
              }
              group = {
                start: i22 * 3,
                materialIndex
              };
            }
          }
          if (group !== void 0) {
            group.count = i * 3 - group.start;
            groups.push(group);
          }
          bufferGeometry.groups = groups;
        }
      },
      {
        key: "_setMeshTextureCoords",
        value: function _setMeshTextureCoords() {
          var endRead = 0;
          var mode = 0;
          var mode_local = 0;
          while (true) {
            switch (mode) {
              case 0:
                if (mode_local === 0) {
                  var refO = this._readInt1(0);
                  endRead = refO.endRead;
                  mode_local = 1;
                } else {
                  var find = this._currentObject.data.indexOf(",", endRead) + 1;
                  if (find === 0) {
                    find = this._currentObject.data.length;
                    mode = 2;
                    mode_local = 0;
                  }
                  var line2 = this._currentObject.data.substr(endRead, find - endRead);
                  var data = this._readLine(line2.trim()).split(";");
                  if (this.IsUvYReverse) {
                    this._currentGeo.GeometryData.uvs.push(parseFloat(data[0]), 1 - parseFloat(data[1]));
                  } else {
                    this._currentGeo.GeometryData.uvs.push(parseFloat(data[0]), parseFloat(data[1]));
                  }
                  endRead = find + 1;
                }
                break;
            }
            if (endRead >= this._currentObject.data.length) {
              break;
            }
          }
        }
      },
      {
        key: "_setMeshMaterialList",
        value: function _setMeshMaterialList() {
          var endRead = 0;
          var mode = 0;
          var mode_local = 0;
          while (true) {
            if (mode_local < 2) {
              var refO = this._readInt1(endRead);
              endRead = refO.endRead;
              mode_local++;
            } else {
              var find = this._currentObject.data.indexOf(";", endRead);
              if (find === -1) {
                find = this._currentObject.data.length;
                mode = 3;
                mode_local = 0;
              }
              var line2 = this._currentObject.data.substr(endRead, find - endRead);
              var data = this._readLine(line2.trim()).split(",");
              for (let i22 = 0; i22 < data.length; i22++) {
                this._currentGeo.GeometryData.materialIndices[i22] = parseInt(data[i22]);
              }
              endRead = this._currentObject.data.length;
            }
            if (endRead >= this._currentObject.data.length || mode >= 3) {
              break;
            }
          }
        }
      },
      {
        key: "_setMaterial",
        value: function _setMaterial() {
          var _nowMat = new MeshPhongMaterial({
            color: Math.random() * 16777215
          });
          _nowMat.side = FrontSide;
          _nowMat.name = this._currentObject.name;
          var endRead = 0;
          var find = this._currentObject.data.indexOf(";;", endRead);
          var line2 = this._currentObject.data.substr(endRead, find - endRead);
          var data = this._readLine(line2.trim()).split(";");
          _nowMat.color.r = parseFloat(data[0]);
          _nowMat.color.g = parseFloat(data[1]);
          _nowMat.color.b = parseFloat(data[2]);
          endRead = find + 2;
          find = this._currentObject.data.indexOf(";", endRead);
          line2 = this._currentObject.data.substr(endRead, find - endRead);
          _nowMat.shininess = parseFloat(this._readLine(line2));
          endRead = find + 1;
          find = this._currentObject.data.indexOf(";;", endRead);
          line2 = this._currentObject.data.substr(endRead, find - endRead);
          var data2 = this._readLine(line2.trim()).split(";");
          _nowMat.specular.r = parseFloat(data2[0]);
          _nowMat.specular.g = parseFloat(data2[1]);
          _nowMat.specular.b = parseFloat(data2[2]);
          endRead = find + 2;
          find = this._currentObject.data.indexOf(";;", endRead);
          if (find === -1) {
            find = this._currentObject.data.length;
          }
          line2 = this._currentObject.data.substr(endRead, find - endRead);
          var data3 = this._readLine(line2.trim()).split(";");
          _nowMat.emissive.r = parseFloat(data3[0]);
          _nowMat.emissive.g = parseFloat(data3[1]);
          _nowMat.emissive.b = parseFloat(data3[2]);
          var localObject = null;
          while (true) {
            if (this._currentObject.children.length > 0) {
              localObject = this._currentObject.children.shift();
              if (this.debug) {
                console.log("processing " + localObject.name);
              }
              var fileName = localObject.data.substr(1, localObject.data.length - 2);
              switch (localObject.type) {
                case "TextureFilename":
                  _nowMat.map = this.texloader.load(fileName);
                  break;
                case "BumpMapFilename":
                  _nowMat.bumpMap = this.texloader.load(fileName);
                  _nowMat.bumpScale = 0.05;
                  break;
                case "NormalMapFilename":
                  _nowMat.normalMap = this.texloader.load(fileName);
                  _nowMat.normalScale = new Vector2(2, 2);
                  break;
                case "EmissiveMapFilename":
                  _nowMat.emissiveMap = this.texloader.load(fileName);
                  break;
                case "LightMapFilename":
                  _nowMat.lightMap = this.texloader.load(fileName);
                  break;
              }
            } else {
              break;
            }
          }
          this._currentGeo.Materials.push(_nowMat);
        }
      },
      {
        key: "_setSkinWeights",
        value: function _setSkinWeights() {
          var boneInf = new XboneInf();
          var endRead = 0;
          var find = this._currentObject.data.indexOf(";", endRead);
          var line2 = this._currentObject.data.substr(endRead, find - endRead);
          endRead = find + 1;
          boneInf.boneName = line2.substr(1, line2.length - 2);
          boneInf.BoneIndex = this._currentGeo.BoneInfs.length;
          find = this._currentObject.data.indexOf(";", endRead);
          endRead = find + 1;
          find = this._currentObject.data.indexOf(";", endRead);
          line2 = this._currentObject.data.substr(endRead, find - endRead);
          var data = this._readLine(line2.trim()).split(",");
          for (let i22 = 0; i22 < data.length; i22++) {
            boneInf.Indeces.push(parseInt(data[i22]));
          }
          endRead = find + 1;
          find = this._currentObject.data.indexOf(";", endRead);
          line2 = this._currentObject.data.substr(endRead, find - endRead);
          var data2 = this._readLine(line2.trim()).split(",");
          for (let _i = 0; _i < data2.length; _i++) {
            boneInf.Weights.push(parseFloat(data2[_i]));
          }
          endRead = find + 1;
          find = this._currentObject.data.indexOf(";", endRead);
          if (find <= 0) {
            find = this._currentObject.data.length;
          }
          line2 = this._currentObject.data.substr(endRead, find - endRead);
          var data3 = this._readLine(line2.trim()).split(",");
          boneInf.OffsetMatrix = new Matrix4();
          this._ParseMatrixData(boneInf.OffsetMatrix, data3);
          this._currentGeo.BoneInfs.push(boneInf);
        }
      },
      {
        key: "_makePutBoneList",
        value: function _makePutBoneList(_RootName, _bones) {
          var putting = false;
          for (let frame in this.HieStack) {
            if (this.HieStack[frame].name === _RootName || putting) {
              putting = true;
              var b5 = new Bone();
              b5.name = this.HieStack[frame].name;
              b5.applyMatrix4(this.HieStack[frame].FrameTransformMatrix);
              b5.matrixWorld = b5.matrix;
              b5.FrameTransformMatrix = this.HieStack[frame].FrameTransformMatrix;
              b5.pos = new Vector3().setFromMatrixPosition(b5.FrameTransformMatrix).toArray();
              b5.rotq = new Quaternion().setFromRotationMatrix(b5.FrameTransformMatrix).toArray();
              b5.scl = new Vector3().setFromMatrixScale(b5.FrameTransformMatrix).toArray();
              if (this.HieStack[frame].parentName && this.HieStack[frame].parentName.length > 0) {
                for (let i22 = 0; i22 < _bones.length; i22++) {
                  if (this.HieStack[frame].parentName === _bones[i22].name) {
                    _bones[i22].add(b5);
                    b5.parent = i22;
                    break;
                  }
                }
              }
              _bones.push(b5);
            }
          }
        }
      },
      {
        key: "_makeOutputGeometry",
        value: function _makeOutputGeometry() {
          var mesh = null;
          if (this._currentGeo.BoneInfs.length > 0) {
            var putBones = [];
            this._makePutBoneList(this._currentGeo.baseFrame.parentName, putBones);
            for (let bi = 0; bi < this._currentGeo.BoneInfs.length; bi++) {
              var boneIndex = 0;
              for (let bb = 0; bb < putBones.length; bb++) {
                if (putBones[bb].name === this._currentGeo.BoneInfs[bi].boneName) {
                  boneIndex = bb;
                  putBones[bb].OffsetMatrix = new Matrix4();
                  putBones[bb].OffsetMatrix.copy(this._currentGeo.BoneInfs[bi].OffsetMatrix);
                  break;
                }
              }
              for (let vi = 0; vi < this._currentGeo.BoneInfs[bi].Indeces.length; vi++) {
                var nowVertexID = this._currentGeo.BoneInfs[bi].Indeces[vi];
                var nowVal = this._currentGeo.BoneInfs[bi].Weights[vi];
                var stride = nowVertexID * 4;
                switch (this._currentGeo.VertexSetedBoneCount[nowVertexID]) {
                  case 0:
                    this._currentGeo.GeometryData.skinIndices[stride] = boneIndex;
                    this._currentGeo.GeometryData.skinWeights[stride] = nowVal;
                    break;
                  case 1:
                    this._currentGeo.GeometryData.skinIndices[stride + 1] = boneIndex;
                    this._currentGeo.GeometryData.skinWeights[stride + 1] = nowVal;
                    break;
                  case 2:
                    this._currentGeo.GeometryData.skinIndices[stride + 2] = boneIndex;
                    this._currentGeo.GeometryData.skinWeights[stride + 2] = nowVal;
                    break;
                  case 3:
                    this._currentGeo.GeometryData.skinIndices[stride + 3] = boneIndex;
                    this._currentGeo.GeometryData.skinWeights[stride + 3] = nowVal;
                    break;
                }
                this._currentGeo.VertexSetedBoneCount[nowVertexID]++;
                if (this._currentGeo.VertexSetedBoneCount[nowVertexID] > 4) {
                  console.log("warn! over 4 bone weight! :" + nowVertexID);
                }
              }
            }
            for (let sk = 0; sk < this._currentGeo.Materials.length; sk++) {
              this._currentGeo.Materials[sk].skinning = true;
            }
            var offsetList = [];
            for (let _bi = 0; _bi < putBones.length; _bi++) {
              if (putBones[_bi].OffsetMatrix) {
                offsetList.push(putBones[_bi].OffsetMatrix);
              } else {
                offsetList.push(new Matrix4());
              }
            }
            var bufferGeometry = this._buildGeometry();
            mesh = new SkinnedMesh(
              bufferGeometry,
              this._currentGeo.Materials.length === 1 ? this._currentGeo.Materials[0] : this._currentGeo.Materials
            );
            this._initSkeleton(mesh, putBones, offsetList);
          } else {
            var _bufferGeometry = this._buildGeometry();
            mesh = new Mesh(
              _bufferGeometry,
              this._currentGeo.Materials.length === 1 ? this._currentGeo.Materials[0] : this._currentGeo.Materials
            );
          }
          mesh.name = this._currentGeo.name;
          var worldBaseMx = new Matrix4();
          var currentMxFrame = this._currentGeo.baseFrame.putBone;
          if (currentMxFrame && currentMxFrame.parent) {
            while (true) {
              currentMxFrame = currentMxFrame.parent;
              if (currentMxFrame) {
                worldBaseMx.multiply(currentMxFrame.FrameTransformMatrix);
              } else {
                break;
              }
            }
            mesh.applyMatrix4(worldBaseMx);
          }
          this.Meshes.push(mesh);
        }
      },
      {
        key: "_initSkeleton",
        value: function _initSkeleton(mesh, boneList, boneInverses) {
          var bones = [], bone, gbone;
          var i22, il;
          for (i22 = 0, il = boneList.length; i22 < il; i22++) {
            gbone = boneList[i22];
            bone = new Bone();
            bones.push(bone);
            bone.name = gbone.name;
            bone.position.fromArray(gbone.pos);
            bone.quaternion.fromArray(gbone.rotq);
            if (gbone.scl !== void 0)
              bone.scale.fromArray(gbone.scl);
          }
          for (i22 = 0, il = boneList.length; i22 < il; i22++) {
            gbone = boneList[i22];
            if (gbone.parent !== -1 && gbone.parent !== null && bones[gbone.parent] !== void 0) {
              bones[gbone.parent].add(bones[i22]);
            } else {
              mesh.add(bones[i22]);
            }
          }
          mesh.updateMatrixWorld(true);
          var skeleton = new Skeleton(bones, boneInverses);
          mesh.bind(skeleton, mesh.matrixWorld);
        }
      },
      {
        key: "_readAnimationKey",
        value: function _readAnimationKey() {
          var endRead = 0;
          var find = this._currentObject.data.indexOf(";", endRead);
          var line2 = this._currentObject.data.substr(endRead, find - endRead);
          endRead = find + 1;
          var nowKeyType = parseInt(this._readLine(line2));
          find = this._currentObject.data.indexOf(";", endRead);
          endRead = find + 1;
          line2 = this._currentObject.data.substr(endRead);
          var data = this._readLine(line2.trim()).split(";;,");
          for (let i22 = 0; i22 < data.length; i22++) {
            var data2 = data[i22].split(";");
            var keyInfo = new XKeyFrameInfo();
            keyInfo.type = nowKeyType;
            keyInfo.Frame = parseInt(data2[0]);
            keyInfo.index = this._currentAnimeFrames.keyFrames.length;
            keyInfo.time = keyInfo.Frame;
            if (nowKeyType != 4) {
              var frameFound = false;
              for (let mm = 0; mm < this._currentAnimeFrames.keyFrames.length; mm++) {
                if (this._currentAnimeFrames.keyFrames[mm].Frame === keyInfo.Frame) {
                  keyInfo = this._currentAnimeFrames.keyFrames[mm];
                  frameFound = true;
                  break;
                }
              }
              var frameValue = data2[2].split(",");
              switch (nowKeyType) {
                case 0:
                  keyInfo.rot = new Quaternion(
                    parseFloat(frameValue[1]),
                    parseFloat(frameValue[2]),
                    parseFloat(frameValue[3]),
                    parseFloat(frameValue[0]) * -1
                  );
                  break;
                case 1:
                  keyInfo.scl = new Vector3(
                    parseFloat(frameValue[0]),
                    parseFloat(frameValue[1]),
                    parseFloat(frameValue[2])
                  );
                  break;
                case 2:
                  keyInfo.pos = new Vector3(
                    parseFloat(frameValue[0]),
                    parseFloat(frameValue[1]),
                    parseFloat(frameValue[2])
                  );
                  break;
              }
              if (!frameFound) {
                this._currentAnimeFrames.keyFrames.push(keyInfo);
              }
            } else {
              keyInfo.matrix = new Matrix4();
              this._ParseMatrixData(keyInfo.matrix, data2[2].split(","));
              this._currentAnimeFrames.keyFrames.push(keyInfo);
            }
          }
        }
      },
      {
        key: "_makeOutputAnimation",
        value: function _makeOutputAnimation() {
          var animationObj = new XAnimationObj(this.options);
          animationObj.fps = this.animTicksPerSecond;
          animationObj.name = this._currentAnime.name;
          animationObj.make(this._currentAnime.AnimeFrames);
          this.animations.push(animationObj);
        }
      },
      {
        key: "assignAnimation",
        value: function assignAnimation(_model, _animation) {
          var model = _model;
          var animation = _animation;
          if (!model) {
            model = this.Meshes[0];
          }
          if (!animation) {
            animation = this.animations[0];
          }
          if (!model || !animation) {
            return null;
          }
          var put = {};
          put.fps = animation.fps;
          put.name = animation.name;
          put.length = animation.length;
          put.hierarchy = [];
          for (let b5 = 0; b5 < model.skeleton.bones.length; b5++) {
            var findAnimation = false;
            for (let i22 = 0; i22 < animation.hierarchy.length; i22++) {
              if (model.skeleton.bones[b5].name === animation.hierarchy[i22].name) {
                findAnimation = true;
                var c_key = animation.hierarchy[i22].copy();
                c_key.parent = -1;
                if (model.skeleton.bones[b5].parent && model.skeleton.bones[b5].parent.type === "Bone") {
                  for (let bb = 0; bb < put.hierarchy.length; bb++) {
                    if (put.hierarchy[bb].name === model.skeleton.bones[b5].parent.name) {
                      c_key.parent = bb;
                      c_key.parentName = model.skeleton.bones[b5].parent.name;
                    }
                  }
                }
                put.hierarchy.push(c_key);
                break;
              }
            }
            if (!findAnimation) {
              var _c_key = animation.hierarchy[0].copy();
              _c_key.name = model.skeleton.bones[b5].name;
              _c_key.parent = -1;
              for (let k = 0; k < _c_key.keys.length; k++) {
                if (_c_key.keys[k].pos) {
                  _c_key.keys[k].pos.set(0, 0, 0);
                }
                if (_c_key.keys[k].scl) {
                  _c_key.keys[k].scl.set(1, 1, 1);
                }
                if (_c_key.keys[k].rot) {
                  _c_key.keys[k].rot.set(0, 0, 0, 1);
                }
              }
              put.hierarchy.push(_c_key);
            }
          }
          if (!model.geometry.animations) {
            model.geometry.animations = [];
          }
          model.geometry.animations.push(AnimationClip.parseAnimation(put, model.skeleton.bones));
          if (!model.animationMixer) {
            model.animationMixer = new AnimationMixer(model);
          }
          return put;
        }
      },
      {
        key: "_ParseMatrixData",
        value: function _ParseMatrixData(targetMatrix, data) {
          targetMatrix.set(
            parseFloat(data[0]),
            parseFloat(data[4]),
            parseFloat(data[8]),
            parseFloat(data[12]),
            parseFloat(data[1]),
            parseFloat(data[5]),
            parseFloat(data[9]),
            parseFloat(data[13]),
            parseFloat(data[2]),
            parseFloat(data[6]),
            parseFloat(data[10]),
            parseFloat(data[14]),
            parseFloat(data[3]),
            parseFloat(data[7]),
            parseFloat(data[11]),
            parseFloat(data[15])
          );
        }
      }
    ]);
    return XLoader3;
  }();
  return XLoader2;
}();

// node_modules/chevrotain/lib_esm/api_esm.mjs
var import_api = __toESM(require_api4(), 1);
var Alternation = import_api.default.Alternation;
var Alternative = import_api.default.Alternative;
var CstParser = import_api.default.CstParser;
var EMPTY_ALT = import_api.default.EMPTY_ALT;
var EOF = import_api.default.EOF;
var EarlyExitException = import_api.default.EarlyExitException;
var EmbeddedActionsParser = import_api.default.EmbeddedActionsParser;
var GAstVisitor = import_api.default.GAstVisitor;
var LLkLookaheadStrategy = import_api.default.LLkLookaheadStrategy;
var Lexer = import_api.default.Lexer;
var LexerDefinitionErrorType = import_api.default.LexerDefinitionErrorType;
var MismatchedTokenException = import_api.default.MismatchedTokenException;
var NoViableAltException = import_api.default.NoViableAltException;
var NonTerminal = import_api.default.NonTerminal;
var NotAllInputParsedException = import_api.default.NotAllInputParsedException;
var Option = import_api.default.Option;
var Parser2 = import_api.default.Parser;
var ParserDefinitionErrorType = import_api.default.ParserDefinitionErrorType;
var Repetition = import_api.default.Repetition;
var RepetitionMandatory = import_api.default.RepetitionMandatory;
var RepetitionMandatoryWithSeparator = import_api.default.RepetitionMandatoryWithSeparator;
var RepetitionWithSeparator = import_api.default.RepetitionWithSeparator;
var Rule = import_api.default.Rule;
var Terminal = import_api.default.Terminal;
var VERSION = import_api.default.VERSION;
var clearCache = import_api.default.clearCache;
var createSyntaxDiagramsCode = import_api.default.createSyntaxDiagramsCode;
var createToken = import_api.default.createToken;
var createTokenInstance = import_api.default.createTokenInstance;
var defaultLexerErrorProvider = import_api.default.defaultLexerErrorProvider;
var defaultParserErrorProvider = import_api.default.defaultParserErrorProvider;
var generateCstDts = import_api.default.generateCstDts;
var getLookaheadPaths = import_api.default.getLookaheadPaths;
var isRecognitionException = import_api.default.isRecognitionException;
var serializeGrammar = import_api.default.serializeGrammar;
var serializeProduction = import_api.default.serializeProduction;
var tokenLabel = import_api.default.tokenLabel;
var tokenMatcher = import_api.default.tokenMatcher;
var tokenName = import_api.default.tokenName;

// node_modules/three-stdlib/utils/WorkerPool.js
var WorkerPool = class {
  constructor(pool = 4) {
    this.pool = pool;
    this.queue = [];
    this.workers = [];
    this.workersResolve = [];
    this.workerStatus = 0;
  }
  _initWorker(workerId) {
    if (!this.workers[workerId]) {
      const worker = this.workerCreator();
      worker.addEventListener("message", this._onMessage.bind(this, workerId));
      this.workers[workerId] = worker;
    }
  }
  _getIdleWorker() {
    for (let i3 = 0; i3 < this.pool; i3++)
      if (!(this.workerStatus & 1 << i3))
        return i3;
    return -1;
  }
  _onMessage(workerId, msg) {
    const resolve = this.workersResolve[workerId];
    resolve && resolve(msg);
    if (this.queue.length) {
      const { resolve: resolve2, msg: msg2, transfer } = this.queue.shift();
      this.workersResolve[workerId] = resolve2;
      this.workers[workerId].postMessage(msg2, transfer);
    } else {
      this.workerStatus ^= 1 << workerId;
    }
  }
  setWorkerCreator(workerCreator) {
    this.workerCreator = workerCreator;
  }
  setWorkerLimit(pool) {
    this.pool = pool;
  }
  postMessage(msg, transfer) {
    return new Promise((resolve) => {
      const workerId = this._getIdleWorker();
      if (workerId !== -1) {
        this._initWorker(workerId);
        this.workerStatus |= 1 << workerId;
        this.workersResolve[workerId] = resolve;
        this.workers[workerId].postMessage(msg, transfer);
      } else {
        this.queue.push({ resolve, msg, transfer });
      }
    });
  }
  dispose() {
    this.workers.forEach((worker) => worker.terminate());
    this.workersResolve.length = 0;
    this.workers.length = 0;
    this.queue.length = 0;
    this.workerStatus = 0;
  }
};

// node_modules/ktx-parse/dist/ktx-parse.modern.js
var KHR_SUPERCOMPRESSION_NONE = 0;
var KHR_SUPERCOMPRESSION_ZSTD = 2;
var KHR_DF_KHR_DESCRIPTORTYPE_BASICFORMAT = 0;
var KHR_DF_VENDORID_KHRONOS = 0;
var KHR_DF_VERSION = 2;
var KHR_DF_MODEL_UNSPECIFIED = 0;
var KHR_DF_FLAG_ALPHA_STRAIGHT = 0;
var KHR_DF_FLAG_ALPHA_PREMULTIPLIED = 1;
var KHR_DF_TRANSFER_SRGB = 2;
var KHR_DF_PRIMARIES_BT709 = 1;
var KHR_DF_SAMPLE_DATATYPE_SIGNED = 64;
var VK_FORMAT_UNDEFINED = 0;
var VK_FORMAT_R8_UNORM = 9;
var VK_FORMAT_R8_SRGB = 15;
var VK_FORMAT_R8G8_UNORM = 16;
var VK_FORMAT_R8G8_SRGB = 22;
var VK_FORMAT_R8G8B8A8_UNORM = 37;
var VK_FORMAT_R8G8B8A8_SRGB = 43;
var VK_FORMAT_R16_SFLOAT = 76;
var VK_FORMAT_R16G16_SFLOAT = 83;
var VK_FORMAT_R16G16B16A16_SFLOAT = 97;
var VK_FORMAT_R32_SFLOAT = 100;
var VK_FORMAT_R32G32_SFLOAT = 103;
var VK_FORMAT_R32G32B32A32_SFLOAT = 109;
var KTX2Container = class {
  constructor() {
    this.vkFormat = VK_FORMAT_UNDEFINED;
    this.typeSize = 1;
    this.pixelWidth = 0;
    this.pixelHeight = 0;
    this.pixelDepth = 0;
    this.layerCount = 0;
    this.faceCount = 1;
    this.supercompressionScheme = KHR_SUPERCOMPRESSION_NONE;
    this.levels = [];
    this.dataFormatDescriptor = [{
      vendorId: KHR_DF_VENDORID_KHRONOS,
      descriptorType: KHR_DF_KHR_DESCRIPTORTYPE_BASICFORMAT,
      descriptorBlockSize: 0,
      versionNumber: KHR_DF_VERSION,
      colorModel: KHR_DF_MODEL_UNSPECIFIED,
      colorPrimaries: KHR_DF_PRIMARIES_BT709,
      transferFunction: KHR_DF_TRANSFER_SRGB,
      flags: KHR_DF_FLAG_ALPHA_STRAIGHT,
      texelBlockDimension: [0, 0, 0, 0],
      bytesPlane: [0, 0, 0, 0, 0, 0, 0, 0],
      samples: []
    }];
    this.keyValue = {};
    this.globalData = null;
  }
};
var BufferReader = class {
  constructor(data, byteOffset, byteLength, littleEndian) {
    this._dataView = void 0;
    this._littleEndian = void 0;
    this._offset = void 0;
    this._dataView = new DataView(data.buffer, data.byteOffset + byteOffset, byteLength);
    this._littleEndian = littleEndian;
    this._offset = 0;
  }
  _nextUint8() {
    const value = this._dataView.getUint8(this._offset);
    this._offset += 1;
    return value;
  }
  _nextUint16() {
    const value = this._dataView.getUint16(this._offset, this._littleEndian);
    this._offset += 2;
    return value;
  }
  _nextUint32() {
    const value = this._dataView.getUint32(this._offset, this._littleEndian);
    this._offset += 4;
    return value;
  }
  _nextUint64() {
    const left = this._dataView.getUint32(this._offset, this._littleEndian);
    const right = this._dataView.getUint32(this._offset + 4, this._littleEndian);
    const value = left + 2 ** 32 * right;
    this._offset += 8;
    return value;
  }
  _nextInt32() {
    const value = this._dataView.getInt32(this._offset, this._littleEndian);
    this._offset += 4;
    return value;
  }
  _skip(bytes) {
    this._offset += bytes;
    return this;
  }
  _scan(maxByteLength, term = 0) {
    const byteOffset = this._offset;
    let byteLength = 0;
    while (this._dataView.getUint8(this._offset) !== term && byteLength < maxByteLength) {
      byteLength++;
      this._offset++;
    }
    if (byteLength < maxByteLength)
      this._offset++;
    return new Uint8Array(this._dataView.buffer, this._dataView.byteOffset + byteOffset, byteLength);
  }
};
var NUL = new Uint8Array([0]);
var KTX2_ID = [
  // '´', 'K', 'T', 'X', '2', '0', 'ª', '\r', '\n', '\x1A', '\n'
  171,
  75,
  84,
  88,
  32,
  50,
  48,
  187,
  13,
  10,
  26,
  10
];
function decodeText(buffer) {
  if (typeof TextDecoder !== "undefined") {
    return new TextDecoder().decode(buffer);
  }
  return Buffer.from(buffer).toString("utf8");
}
function read(data) {
  const id = new Uint8Array(data.buffer, data.byteOffset, KTX2_ID.length);
  if (id[0] !== KTX2_ID[0] || // '´'
  id[1] !== KTX2_ID[1] || // 'K'
  id[2] !== KTX2_ID[2] || // 'T'
  id[3] !== KTX2_ID[3] || // 'X'
  id[4] !== KTX2_ID[4] || // ' '
  id[5] !== KTX2_ID[5] || // '2'
  id[6] !== KTX2_ID[6] || // '0'
  id[7] !== KTX2_ID[7] || // 'ª'
  id[8] !== KTX2_ID[8] || // '\r'
  id[9] !== KTX2_ID[9] || // '\n'
  id[10] !== KTX2_ID[10] || // '\x1A'
  id[11] !== KTX2_ID[11]) {
    throw new Error("Missing KTX 2.0 identifier.");
  }
  const container = new KTX2Container();
  const headerByteLength = 17 * Uint32Array.BYTES_PER_ELEMENT;
  const headerReader = new BufferReader(data, KTX2_ID.length, headerByteLength, true);
  container.vkFormat = headerReader._nextUint32();
  container.typeSize = headerReader._nextUint32();
  container.pixelWidth = headerReader._nextUint32();
  container.pixelHeight = headerReader._nextUint32();
  container.pixelDepth = headerReader._nextUint32();
  container.layerCount = headerReader._nextUint32();
  container.faceCount = headerReader._nextUint32();
  const levelCount = headerReader._nextUint32();
  container.supercompressionScheme = headerReader._nextUint32();
  const dfdByteOffset = headerReader._nextUint32();
  const dfdByteLength = headerReader._nextUint32();
  const kvdByteOffset = headerReader._nextUint32();
  const kvdByteLength = headerReader._nextUint32();
  const sgdByteOffset = headerReader._nextUint64();
  const sgdByteLength = headerReader._nextUint64();
  const levelByteLength = levelCount * 3 * 8;
  const levelReader = new BufferReader(data, KTX2_ID.length + headerByteLength, levelByteLength, true);
  for (let i3 = 0; i3 < levelCount; i3++) {
    container.levels.push({
      levelData: new Uint8Array(data.buffer, data.byteOffset + levelReader._nextUint64(), levelReader._nextUint64()),
      uncompressedByteLength: levelReader._nextUint64()
    });
  }
  const dfdReader = new BufferReader(data, dfdByteOffset, dfdByteLength, true);
  const dfd = {
    vendorId: dfdReader._skip(
      4
      /* totalSize */
    )._nextUint16(),
    descriptorType: dfdReader._nextUint16(),
    versionNumber: dfdReader._nextUint16(),
    descriptorBlockSize: dfdReader._nextUint16(),
    colorModel: dfdReader._nextUint8(),
    colorPrimaries: dfdReader._nextUint8(),
    transferFunction: dfdReader._nextUint8(),
    flags: dfdReader._nextUint8(),
    texelBlockDimension: [dfdReader._nextUint8(), dfdReader._nextUint8(), dfdReader._nextUint8(), dfdReader._nextUint8()],
    bytesPlane: [dfdReader._nextUint8(), dfdReader._nextUint8(), dfdReader._nextUint8(), dfdReader._nextUint8(), dfdReader._nextUint8(), dfdReader._nextUint8(), dfdReader._nextUint8(), dfdReader._nextUint8()],
    samples: []
  };
  const sampleStart = 6;
  const sampleWords = 4;
  const numSamples = (dfd.descriptorBlockSize / 4 - sampleStart) / sampleWords;
  for (let i3 = 0; i3 < numSamples; i3++) {
    const sample2 = {
      bitOffset: dfdReader._nextUint16(),
      bitLength: dfdReader._nextUint8(),
      channelType: dfdReader._nextUint8(),
      samplePosition: [dfdReader._nextUint8(), dfdReader._nextUint8(), dfdReader._nextUint8(), dfdReader._nextUint8()],
      sampleLower: -Infinity,
      sampleUpper: Infinity
    };
    if (sample2.channelType & KHR_DF_SAMPLE_DATATYPE_SIGNED) {
      sample2.sampleLower = dfdReader._nextInt32();
      sample2.sampleUpper = dfdReader._nextInt32();
    } else {
      sample2.sampleLower = dfdReader._nextUint32();
      sample2.sampleUpper = dfdReader._nextUint32();
    }
    dfd.samples[i3] = sample2;
  }
  container.dataFormatDescriptor.length = 0;
  container.dataFormatDescriptor.push(dfd);
  const kvdReader = new BufferReader(data, kvdByteOffset, kvdByteLength, true);
  while (kvdReader._offset < kvdByteLength) {
    const keyValueByteLength = kvdReader._nextUint32();
    const keyData = kvdReader._scan(keyValueByteLength);
    const key = decodeText(keyData);
    const valueData = kvdReader._scan(keyValueByteLength - keyData.byteLength);
    container.keyValue[key] = key.match(/^ktx/i) ? decodeText(valueData) : valueData;
    if (kvdReader._offset % 4)
      kvdReader._skip(4 - kvdReader._offset % 4);
  }
  if (sgdByteLength <= 0)
    return container;
  const sgdReader = new BufferReader(data, sgdByteOffset, sgdByteLength, true);
  const endpointCount = sgdReader._nextUint16();
  const selectorCount = sgdReader._nextUint16();
  const endpointsByteLength = sgdReader._nextUint32();
  const selectorsByteLength = sgdReader._nextUint32();
  const tablesByteLength = sgdReader._nextUint32();
  const extendedByteLength = sgdReader._nextUint32();
  const imageDescs = [];
  for (let i3 = 0; i3 < levelCount; i3++) {
    imageDescs.push({
      imageFlags: sgdReader._nextUint32(),
      rgbSliceByteOffset: sgdReader._nextUint32(),
      rgbSliceByteLength: sgdReader._nextUint32(),
      alphaSliceByteOffset: sgdReader._nextUint32(),
      alphaSliceByteLength: sgdReader._nextUint32()
    });
  }
  const endpointsByteOffset = sgdByteOffset + sgdReader._offset;
  const selectorsByteOffset = endpointsByteOffset + endpointsByteLength;
  const tablesByteOffset = selectorsByteOffset + selectorsByteLength;
  const extendedByteOffset = tablesByteOffset + tablesByteLength;
  const endpointsData = new Uint8Array(data.buffer, data.byteOffset + endpointsByteOffset, endpointsByteLength);
  const selectorsData = new Uint8Array(data.buffer, data.byteOffset + selectorsByteOffset, selectorsByteLength);
  const tablesData = new Uint8Array(data.buffer, data.byteOffset + tablesByteOffset, tablesByteLength);
  const extendedData = new Uint8Array(data.buffer, data.byteOffset + extendedByteOffset, extendedByteLength);
  container.globalData = {
    endpointCount,
    selectorCount,
    imageDescs,
    endpointsData,
    selectorsData,
    tablesData,
    extendedData
  };
  return container;
}

// node_modules/zstddec/dist/zstddec.modern.js
var A;
var I;
var B;
var g = { env: { emscripten_notify_memory_growth: function(A2) {
  B = new Uint8Array(I.exports.memory.buffer);
} } };
var Q = class {
  init() {
    return A || (A = "undefined" != typeof fetch ? fetch("data:application/wasm;base64," + C).then((A2) => A2.arrayBuffer()).then((A2) => WebAssembly.instantiate(A2, g)).then(this._init) : WebAssembly.instantiate(Buffer.from(C, "base64"), g).then(this._init), A);
  }
  _init(A2) {
    I = A2.instance, g.env.emscripten_notify_memory_growth(0);
  }
  decode(A2, g2 = 0) {
    if (!I)
      throw new Error("ZSTDDecoder: Await .init() before decoding.");
    const Q2 = A2.byteLength, C2 = I.exports.malloc(Q2);
    B.set(A2, C2), g2 = g2 || Number(I.exports.ZSTD_findDecompressedSize(C2, Q2));
    const E = I.exports.malloc(g2), i3 = I.exports.ZSTD_decompress(E, g2, C2, Q2), D = B.slice(E, E + i3);
    return I.exports.free(C2), I.exports.free(E), D;
  }
};
var C = "AGFzbQEAAAABpQEVYAF/AX9gAn9/AGADf39/AX9gBX9/f39/AX9gAX8AYAJ/fwF/YAR/f39/AX9gA39/fwBgBn9/f39/fwF/YAd/f39/f39/AX9gAn9/AX5gAn5+AX5gAABgBX9/f39/AGAGf39/f39/AGAIf39/f39/f38AYAl/f39/f39/f38AYAABf2AIf39/f39/f38Bf2ANf39/f39/f39/f39/fwF/YAF/AX4CJwEDZW52H2Vtc2NyaXB0ZW5fbm90aWZ5X21lbW9yeV9ncm93dGgABANpaAEFAAAFAgEFCwACAQABAgIFBQcAAwABDgsBAQcAEhMHAAUBDAQEAAANBwQCAgYCBAgDAwMDBgEACQkHBgICAAYGAgQUBwYGAwIGAAMCAQgBBwUGCgoEEQAEBAEIAwgDBQgDEA8IAAcABAUBcAECAgUEAQCAAgYJAX8BQaCgwAILB2AHBm1lbW9yeQIABm1hbGxvYwAoBGZyZWUAJgxaU1REX2lzRXJyb3IAaBlaU1REX2ZpbmREZWNvbXByZXNzZWRTaXplAFQPWlNURF9kZWNvbXByZXNzAEoGX3N0YXJ0ACQJBwEAQQELASQKussBaA8AIAAgACgCBCABajYCBAsZACAAKAIAIAAoAgRBH3F0QQAgAWtBH3F2CwgAIABBiH9LC34BBH9BAyEBIAAoAgQiA0EgTQRAIAAoAggiASAAKAIQTwRAIAAQDQ8LIAAoAgwiAiABRgRAQQFBAiADQSBJGw8LIAAgASABIAJrIANBA3YiBCABIARrIAJJIgEbIgJrIgQ2AgggACADIAJBA3RrNgIEIAAgBCgAADYCAAsgAQsUAQF/IAAgARACIQIgACABEAEgAgv3AQECfyACRQRAIABCADcCACAAQQA2AhAgAEIANwIIQbh/DwsgACABNgIMIAAgAUEEajYCECACQQRPBEAgACABIAJqIgFBfGoiAzYCCCAAIAMoAAA2AgAgAUF/ai0AACIBBEAgAEEIIAEQFGs2AgQgAg8LIABBADYCBEF/DwsgACABNgIIIAAgAS0AACIDNgIAIAJBfmoiBEEBTQRAIARBAWtFBEAgACABLQACQRB0IANyIgM2AgALIAAgAS0AAUEIdCADajYCAAsgASACakF/ai0AACIBRQRAIABBADYCBEFsDwsgAEEoIAEQFCACQQN0ams2AgQgAgsWACAAIAEpAAA3AAAgACABKQAINwAICy8BAX8gAUECdEGgHWooAgAgACgCAEEgIAEgACgCBGprQR9xdnEhAiAAIAEQASACCyEAIAFCz9bTvtLHq9lCfiAAfEIfiUKHla+vmLbem55/fgsdAQF/IAAoAgggACgCDEYEfyAAKAIEQSBGBUEACwuCBAEDfyACQYDAAE8EQCAAIAEgAhBnIAAPCyAAIAJqIQMCQCAAIAFzQQNxRQRAAkAgAkEBSARAIAAhAgwBCyAAQQNxRQRAIAAhAgwBCyAAIQIDQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADTw0BIAJBA3ENAAsLAkAgA0F8cSIEQcAASQ0AIAIgBEFAaiIFSw0AA0AgAiABKAIANgIAIAIgASgCBDYCBCACIAEoAgg2AgggAiABKAIMNgIMIAIgASgCEDYCECACIAEoAhQ2AhQgAiABKAIYNgIYIAIgASgCHDYCHCACIAEoAiA2AiAgAiABKAIkNgIkIAIgASgCKDYCKCACIAEoAiw2AiwgAiABKAIwNgIwIAIgASgCNDYCNCACIAEoAjg2AjggAiABKAI8NgI8IAFBQGshASACQUBrIgIgBU0NAAsLIAIgBE8NAQNAIAIgASgCADYCACABQQRqIQEgAkEEaiICIARJDQALDAELIANBBEkEQCAAIQIMAQsgA0F8aiIEIABJBEAgACECDAELIAAhAgNAIAIgAS0AADoAACACIAEtAAE6AAEgAiABLQACOgACIAIgAS0AAzoAAyABQQRqIQEgAkEEaiICIARNDQALCyACIANJBEADQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADRw0ACwsgAAsMACAAIAEpAAA3AAALQQECfyAAKAIIIgEgACgCEEkEQEEDDwsgACAAKAIEIgJBB3E2AgQgACABIAJBA3ZrIgE2AgggACABKAAANgIAQQALDAAgACABKAIANgAAC/cCAQJ/AkAgACABRg0AAkAgASACaiAASwRAIAAgAmoiBCABSw0BCyAAIAEgAhALDwsgACABc0EDcSEDAkACQCAAIAFJBEAgAwRAIAAhAwwDCyAAQQNxRQRAIAAhAwwCCyAAIQMDQCACRQ0EIAMgAS0AADoAACABQQFqIQEgAkF/aiECIANBAWoiA0EDcQ0ACwwBCwJAIAMNACAEQQNxBEADQCACRQ0FIAAgAkF/aiICaiIDIAEgAmotAAA6AAAgA0EDcQ0ACwsgAkEDTQ0AA0AgACACQXxqIgJqIAEgAmooAgA2AgAgAkEDSw0ACwsgAkUNAgNAIAAgAkF/aiICaiABIAJqLQAAOgAAIAINAAsMAgsgAkEDTQ0AIAIhBANAIAMgASgCADYCACABQQRqIQEgA0EEaiEDIARBfGoiBEEDSw0ACyACQQNxIQILIAJFDQADQCADIAEtAAA6AAAgA0EBaiEDIAFBAWohASACQX9qIgINAAsLIAAL8wICAn8BfgJAIAJFDQAgACACaiIDQX9qIAE6AAAgACABOgAAIAJBA0kNACADQX5qIAE6AAAgACABOgABIANBfWogAToAACAAIAE6AAIgAkEHSQ0AIANBfGogAToAACAAIAE6AAMgAkEJSQ0AIABBACAAa0EDcSIEaiIDIAFB/wFxQYGChAhsIgE2AgAgAyACIARrQXxxIgRqIgJBfGogATYCACAEQQlJDQAgAyABNgIIIAMgATYCBCACQXhqIAE2AgAgAkF0aiABNgIAIARBGUkNACADIAE2AhggAyABNgIUIAMgATYCECADIAE2AgwgAkFwaiABNgIAIAJBbGogATYCACACQWhqIAE2AgAgAkFkaiABNgIAIAQgA0EEcUEYciIEayICQSBJDQAgAa0iBUIghiAFhCEFIAMgBGohAQNAIAEgBTcDGCABIAU3AxAgASAFNwMIIAEgBTcDACABQSBqIQEgAkFgaiICQR9LDQALCyAACy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAIajYCACADCy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAFajYCACADCx8AIAAgASACKAIEEAg2AgAgARAEGiAAIAJBCGo2AgQLCAAgAGdBH3MLugUBDX8jAEEQayIKJAACfyAEQQNNBEAgCkEANgIMIApBDGogAyAEEAsaIAAgASACIApBDGpBBBAVIgBBbCAAEAMbIAAgACAESxsMAQsgAEEAIAEoAgBBAXRBAmoQECENQVQgAygAACIGQQ9xIgBBCksNABogAiAAQQVqNgIAIAMgBGoiAkF8aiEMIAJBeWohDiACQXtqIRAgAEEGaiELQQQhBSAGQQR2IQRBICAAdCIAQQFyIQkgASgCACEPQQAhAiADIQYCQANAIAlBAkggAiAPS3JFBEAgAiEHAkAgCARAA0AgBEH//wNxQf//A0YEQCAHQRhqIQcgBiAQSQR/IAZBAmoiBigAACAFdgUgBUEQaiEFIARBEHYLIQQMAQsLA0AgBEEDcSIIQQNGBEAgBUECaiEFIARBAnYhBCAHQQNqIQcMAQsLIAcgCGoiByAPSw0EIAVBAmohBQNAIAIgB0kEQCANIAJBAXRqQQA7AQAgAkEBaiECDAELCyAGIA5LQQAgBiAFQQN1aiIHIAxLG0UEQCAHKAAAIAVBB3EiBXYhBAwCCyAEQQJ2IQQLIAYhBwsCfyALQX9qIAQgAEF/anEiBiAAQQF0QX9qIgggCWsiEUkNABogBCAIcSIEQQAgESAEIABIG2shBiALCyEIIA0gAkEBdGogBkF/aiIEOwEAIAlBASAGayAEIAZBAUgbayEJA0AgCSAASARAIABBAXUhACALQX9qIQsMAQsLAn8gByAOS0EAIAcgBSAIaiIFQQN1aiIGIAxLG0UEQCAFQQdxDAELIAUgDCIGIAdrQQN0awshBSACQQFqIQIgBEUhCCAGKAAAIAVBH3F2IQQMAQsLQWwgCUEBRyAFQSBKcg0BGiABIAJBf2o2AgAgBiAFQQdqQQN1aiADawwBC0FQCyEAIApBEGokACAACwkAQQFBBSAAGwsMACAAIAEoAAA2AAALqgMBCn8jAEHwAGsiCiQAIAJBAWohDiAAQQhqIQtBgIAEIAVBf2p0QRB1IQxBACECQQEhBkEBIAV0IglBf2oiDyEIA0AgAiAORkUEQAJAIAEgAkEBdCINai8BACIHQf//A0YEQCALIAhBA3RqIAI2AgQgCEF/aiEIQQEhBwwBCyAGQQAgDCAHQRB0QRB1ShshBgsgCiANaiAHOwEAIAJBAWohAgwBCwsgACAFNgIEIAAgBjYCACAJQQN2IAlBAXZqQQNqIQxBACEAQQAhBkEAIQIDQCAGIA5GBEADQAJAIAAgCUYNACAKIAsgAEEDdGoiASgCBCIGQQF0aiICIAIvAQAiAkEBajsBACABIAUgAhAUayIIOgADIAEgAiAIQf8BcXQgCWs7AQAgASAEIAZBAnQiAmooAgA6AAIgASACIANqKAIANgIEIABBAWohAAwBCwsFIAEgBkEBdGouAQAhDUEAIQcDQCAHIA1ORQRAIAsgAkEDdGogBjYCBANAIAIgDGogD3EiAiAISw0ACyAHQQFqIQcMAQsLIAZBAWohBgwBCwsgCkHwAGokAAsjAEIAIAEQCSAAhUKHla+vmLbem55/fkLj3MqV/M7y9YV/fAsQACAAQn43AwggACABNgIACyQBAX8gAARAIAEoAgQiAgRAIAEoAgggACACEQEADwsgABAmCwsfACAAIAEgAi8BABAINgIAIAEQBBogACACQQRqNgIEC0oBAX9BoCAoAgAiASAAaiIAQX9MBEBBiCBBMDYCAEF/DwsCQCAAPwBBEHRNDQAgABBmDQBBiCBBMDYCAEF/DwtBoCAgADYCACABC9cBAQh/Qbp/IQoCQCACKAIEIgggAigCACIJaiIOIAEgAGtLDQBBbCEKIAkgBCADKAIAIgtrSw0AIAAgCWoiBCACKAIIIgxrIQ0gACABQWBqIg8gCyAJQQAQKSADIAkgC2o2AgACQAJAIAwgBCAFa00EQCANIQUMAQsgDCAEIAZrSw0CIAcgDSAFayIAaiIBIAhqIAdNBEAgBCABIAgQDxoMAgsgBCABQQAgAGsQDyEBIAIgACAIaiIINgIEIAEgAGshBAsgBCAPIAUgCEEBECkLIA4hCgsgCgubAgEBfyMAQYABayINJAAgDSADNgJ8AkAgAkEDSwRAQX8hCQwBCwJAAkACQAJAIAJBAWsOAwADAgELIAZFBEBBuH8hCQwEC0FsIQkgBS0AACICIANLDQMgACAHIAJBAnQiAmooAgAgAiAIaigCABA7IAEgADYCAEEBIQkMAwsgASAJNgIAQQAhCQwCCyAKRQRAQWwhCQwCC0EAIQkgC0UgDEEZSHINAUEIIAR0QQhqIQBBACECA0AgAiAATw0CIAJBQGshAgwAAAsAC0FsIQkgDSANQfwAaiANQfgAaiAFIAYQFSICEAMNACANKAJ4IgMgBEsNACAAIA0gDSgCfCAHIAggAxAYIAEgADYCACACIQkLIA1BgAFqJAAgCQsLACAAIAEgAhALGgsQACAALwAAIAAtAAJBEHRyCy8AAn9BuH8gAUEISQ0AGkFyIAAoAAQiAEF3Sw0AGkG4fyAAQQhqIgAgACABSxsLCwkAIAAgATsAAAsDAAELigYBBX8gACAAKAIAIgVBfnE2AgBBACAAIAVBAXZqQYQgKAIAIgQgAEYbIQECQAJAIAAoAgQiAkUNACACKAIAIgNBAXENACACQQhqIgUgA0EBdkF4aiIDQQggA0EISxtnQR9zQQJ0QYAfaiIDKAIARgRAIAMgAigCDDYCAAsgAigCCCIDBEAgAyACKAIMNgIECyACKAIMIgMEQCADIAIoAgg2AgALIAIgAigCACAAKAIAQX5xajYCAEGEICEAAkACQCABRQ0AIAEgAjYCBCABKAIAIgNBAXENASADQQF2QXhqIgNBCCADQQhLG2dBH3NBAnRBgB9qIgMoAgAgAUEIakYEQCADIAEoAgw2AgALIAEoAggiAwRAIAMgASgCDDYCBAsgASgCDCIDBEAgAyABKAIINgIAQYQgKAIAIQQLIAIgAigCACABKAIAQX5xajYCACABIARGDQAgASABKAIAQQF2akEEaiEACyAAIAI2AgALIAIoAgBBAXZBeGoiAEEIIABBCEsbZ0Efc0ECdEGAH2oiASgCACEAIAEgBTYCACACIAA2AgwgAkEANgIIIABFDQEgACAFNgIADwsCQCABRQ0AIAEoAgAiAkEBcQ0AIAJBAXZBeGoiAkEIIAJBCEsbZ0Efc0ECdEGAH2oiAigCACABQQhqRgRAIAIgASgCDDYCAAsgASgCCCICBEAgAiABKAIMNgIECyABKAIMIgIEQCACIAEoAgg2AgBBhCAoAgAhBAsgACAAKAIAIAEoAgBBfnFqIgI2AgACQCABIARHBEAgASABKAIAQQF2aiAANgIEIAAoAgAhAgwBC0GEICAANgIACyACQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgIoAgAhASACIABBCGoiAjYCACAAIAE2AgwgAEEANgIIIAFFDQEgASACNgIADwsgBUEBdkF4aiIBQQggAUEISxtnQR9zQQJ0QYAfaiICKAIAIQEgAiAAQQhqIgI2AgAgACABNgIMIABBADYCCCABRQ0AIAEgAjYCAAsLDgAgAARAIABBeGoQJQsLgAIBA38CQCAAQQ9qQXhxQYQgKAIAKAIAQQF2ayICEB1Bf0YNAAJAQYQgKAIAIgAoAgAiAUEBcQ0AIAFBAXZBeGoiAUEIIAFBCEsbZ0Efc0ECdEGAH2oiASgCACAAQQhqRgRAIAEgACgCDDYCAAsgACgCCCIBBEAgASAAKAIMNgIECyAAKAIMIgFFDQAgASAAKAIINgIAC0EBIQEgACAAKAIAIAJBAXRqIgI2AgAgAkEBcQ0AIAJBAXZBeGoiAkEIIAJBCEsbZ0Efc0ECdEGAH2oiAygCACECIAMgAEEIaiIDNgIAIAAgAjYCDCAAQQA2AgggAkUNACACIAM2AgALIAELtwIBA38CQAJAIABBASAAGyICEDgiAA0AAkACQEGEICgCACIARQ0AIAAoAgAiA0EBcQ0AIAAgA0EBcjYCACADQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgEoAgAgAEEIakYEQCABIAAoAgw2AgALIAAoAggiAQRAIAEgACgCDDYCBAsgACgCDCIBBEAgASAAKAIINgIACyACECchAkEAIQFBhCAoAgAhACACDQEgACAAKAIAQX5xNgIAQQAPCyACQQ9qQXhxIgMQHSICQX9GDQIgAkEHakF4cSIAIAJHBEAgACACaxAdQX9GDQMLAkBBhCAoAgAiAUUEQEGAICAANgIADAELIAAgATYCBAtBhCAgADYCACAAIANBAXRBAXI2AgAMAQsgAEUNAQsgAEEIaiEBCyABC7kDAQJ/IAAgA2ohBQJAIANBB0wEQANAIAAgBU8NAiAAIAItAAA6AAAgAEEBaiEAIAJBAWohAgwAAAsACyAEQQFGBEACQCAAIAJrIgZBB00EQCAAIAItAAA6AAAgACACLQABOgABIAAgAi0AAjoAAiAAIAItAAM6AAMgAEEEaiACIAZBAnQiBkHAHmooAgBqIgIQFyACIAZB4B5qKAIAayECDAELIAAgAhAMCyACQQhqIQIgAEEIaiEACwJAAkACQAJAIAUgAU0EQCAAIANqIQEgBEEBRyAAIAJrQQ9Kcg0BA0AgACACEAwgAkEIaiECIABBCGoiACABSQ0ACwwFCyAAIAFLBEAgACEBDAQLIARBAUcgACACa0EPSnINASAAIQMgAiEEA0AgAyAEEAwgBEEIaiEEIANBCGoiAyABSQ0ACwwCCwNAIAAgAhAHIAJBEGohAiAAQRBqIgAgAUkNAAsMAwsgACEDIAIhBANAIAMgBBAHIARBEGohBCADQRBqIgMgAUkNAAsLIAIgASAAa2ohAgsDQCABIAVPDQEgASACLQAAOgAAIAFBAWohASACQQFqIQIMAAALAAsLQQECfyAAIAAoArjgASIDNgLE4AEgACgCvOABIQQgACABNgK84AEgACABIAJqNgK44AEgACABIAQgA2tqNgLA4AELpgEBAX8gACAAKALs4QEQFjYCyOABIABCADcD+OABIABCADcDuOABIABBwOABakIANwMAIABBqNAAaiIBQYyAgOAANgIAIABBADYCmOIBIABCADcDiOEBIABCAzcDgOEBIABBrNABakHgEikCADcCACAAQbTQAWpB6BIoAgA2AgAgACABNgIMIAAgAEGYIGo2AgggACAAQaAwajYCBCAAIABBEGo2AgALYQEBf0G4fyEDAkAgAUEDSQ0AIAIgABAhIgFBA3YiADYCCCACIAFBAXE2AgQgAiABQQF2QQNxIgM2AgACQCADQX9qIgFBAksNAAJAIAFBAWsOAgEAAgtBbA8LIAAhAwsgAwsMACAAIAEgAkEAEC4LiAQCA38CfiADEBYhBCAAQQBBKBAQIQAgBCACSwRAIAQPCyABRQRAQX8PCwJAAkAgA0EBRg0AIAEoAAAiBkGo6r5pRg0AQXYhAyAGQXBxQdDUtMIBRw0BQQghAyACQQhJDQEgAEEAQSgQECEAIAEoAAQhASAAQQE2AhQgACABrTcDAEEADwsgASACIAMQLyIDIAJLDQAgACADNgIYQXIhAyABIARqIgVBf2otAAAiAkEIcQ0AIAJBIHEiBkUEQEFwIQMgBS0AACIFQacBSw0BIAVBB3GtQgEgBUEDdkEKaq2GIgdCA4h+IAd8IQggBEEBaiEECyACQQZ2IQMgAkECdiEFAkAgAkEDcUF/aiICQQJLBEBBACECDAELAkACQAJAIAJBAWsOAgECAAsgASAEai0AACECIARBAWohBAwCCyABIARqLwAAIQIgBEECaiEEDAELIAEgBGooAAAhAiAEQQRqIQQLIAVBAXEhBQJ+AkACQAJAIANBf2oiA0ECTQRAIANBAWsOAgIDAQtCfyAGRQ0DGiABIARqMQAADAMLIAEgBGovAACtQoACfAwCCyABIARqKAAArQwBCyABIARqKQAACyEHIAAgBTYCICAAIAI2AhwgACAHNwMAQQAhAyAAQQA2AhQgACAHIAggBhsiBzcDCCAAIAdCgIAIIAdCgIAIVBs+AhALIAMLWwEBf0G4fyEDIAIQFiICIAFNBH8gACACakF/ai0AACIAQQNxQQJ0QaAeaigCACACaiAAQQZ2IgFBAnRBsB5qKAIAaiAAQSBxIgBFaiABRSAAQQV2cWoFQbh/CwsdACAAKAKQ4gEQWiAAQQA2AqDiASAAQgA3A5DiAQu1AwEFfyMAQZACayIKJABBuH8hBgJAIAVFDQAgBCwAACIIQf8BcSEHAkAgCEF/TARAIAdBgn9qQQF2IgggBU8NAkFsIQYgB0GBf2oiBUGAAk8NAiAEQQFqIQdBACEGA0AgBiAFTwRAIAUhBiAIIQcMAwUgACAGaiAHIAZBAXZqIgQtAABBBHY6AAAgACAGQQFyaiAELQAAQQ9xOgAAIAZBAmohBgwBCwAACwALIAcgBU8NASAAIARBAWogByAKEFMiBhADDQELIAYhBEEAIQYgAUEAQTQQECEJQQAhBQNAIAQgBkcEQCAAIAZqIggtAAAiAUELSwRAQWwhBgwDBSAJIAFBAnRqIgEgASgCAEEBajYCACAGQQFqIQZBASAILQAAdEEBdSAFaiEFDAILAAsLQWwhBiAFRQ0AIAUQFEEBaiIBQQxLDQAgAyABNgIAQQFBASABdCAFayIDEBQiAXQgA0cNACAAIARqIAFBAWoiADoAACAJIABBAnRqIgAgACgCAEEBajYCACAJKAIEIgBBAkkgAEEBcXINACACIARBAWo2AgAgB0EBaiEGCyAKQZACaiQAIAYLxhEBDH8jAEHwAGsiBSQAQWwhCwJAIANBCkkNACACLwAAIQogAi8AAiEJIAIvAAQhByAFQQhqIAQQDgJAIAMgByAJIApqakEGaiIMSQ0AIAUtAAohCCAFQdgAaiACQQZqIgIgChAGIgsQAw0BIAVBQGsgAiAKaiICIAkQBiILEAMNASAFQShqIAIgCWoiAiAHEAYiCxADDQEgBUEQaiACIAdqIAMgDGsQBiILEAMNASAAIAFqIg9BfWohECAEQQRqIQZBASELIAAgAUEDakECdiIDaiIMIANqIgIgA2oiDiEDIAIhBCAMIQcDQCALIAMgEElxBEAgACAGIAVB2ABqIAgQAkECdGoiCS8BADsAACAFQdgAaiAJLQACEAEgCS0AAyELIAcgBiAFQUBrIAgQAkECdGoiCS8BADsAACAFQUBrIAktAAIQASAJLQADIQogBCAGIAVBKGogCBACQQJ0aiIJLwEAOwAAIAVBKGogCS0AAhABIAktAAMhCSADIAYgBUEQaiAIEAJBAnRqIg0vAQA7AAAgBUEQaiANLQACEAEgDS0AAyENIAAgC2oiCyAGIAVB2ABqIAgQAkECdGoiAC8BADsAACAFQdgAaiAALQACEAEgAC0AAyEAIAcgCmoiCiAGIAVBQGsgCBACQQJ0aiIHLwEAOwAAIAVBQGsgBy0AAhABIActAAMhByAEIAlqIgkgBiAFQShqIAgQAkECdGoiBC8BADsAACAFQShqIAQtAAIQASAELQADIQQgAyANaiIDIAYgBUEQaiAIEAJBAnRqIg0vAQA7AAAgBUEQaiANLQACEAEgACALaiEAIAcgCmohByAEIAlqIQQgAyANLQADaiEDIAVB2ABqEA0gBUFAaxANciAFQShqEA1yIAVBEGoQDXJFIQsMAQsLIAQgDksgByACS3INAEFsIQsgACAMSw0BIAxBfWohCQNAQQAgACAJSSAFQdgAahAEGwRAIAAgBiAFQdgAaiAIEAJBAnRqIgovAQA7AAAgBUHYAGogCi0AAhABIAAgCi0AA2oiACAGIAVB2ABqIAgQAkECdGoiCi8BADsAACAFQdgAaiAKLQACEAEgACAKLQADaiEADAEFIAxBfmohCgNAIAVB2ABqEAQgACAKS3JFBEAgACAGIAVB2ABqIAgQAkECdGoiCS8BADsAACAFQdgAaiAJLQACEAEgACAJLQADaiEADAELCwNAIAAgCk0EQCAAIAYgBUHYAGogCBACQQJ0aiIJLwEAOwAAIAVB2ABqIAktAAIQASAAIAktAANqIQAMAQsLAkAgACAMTw0AIAAgBiAFQdgAaiAIEAIiAEECdGoiDC0AADoAACAMLQADQQFGBEAgBUHYAGogDC0AAhABDAELIAUoAlxBH0sNACAFQdgAaiAGIABBAnRqLQACEAEgBSgCXEEhSQ0AIAVBIDYCXAsgAkF9aiEMA0BBACAHIAxJIAVBQGsQBBsEQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiIAIAYgBUFAayAIEAJBAnRqIgcvAQA7AAAgBUFAayAHLQACEAEgACAHLQADaiEHDAEFIAJBfmohDANAIAVBQGsQBCAHIAxLckUEQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiEHDAELCwNAIAcgDE0EQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiEHDAELCwJAIAcgAk8NACAHIAYgBUFAayAIEAIiAEECdGoiAi0AADoAACACLQADQQFGBEAgBUFAayACLQACEAEMAQsgBSgCREEfSw0AIAVBQGsgBiAAQQJ0ai0AAhABIAUoAkRBIUkNACAFQSA2AkQLIA5BfWohAgNAQQAgBCACSSAFQShqEAQbBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2oiACAGIAVBKGogCBACQQJ0aiIELwEAOwAAIAVBKGogBC0AAhABIAAgBC0AA2ohBAwBBSAOQX5qIQIDQCAFQShqEAQgBCACS3JFBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2ohBAwBCwsDQCAEIAJNBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2ohBAwBCwsCQCAEIA5PDQAgBCAGIAVBKGogCBACIgBBAnRqIgItAAA6AAAgAi0AA0EBRgRAIAVBKGogAi0AAhABDAELIAUoAixBH0sNACAFQShqIAYgAEECdGotAAIQASAFKAIsQSFJDQAgBUEgNgIsCwNAQQAgAyAQSSAFQRBqEAQbBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2oiACAGIAVBEGogCBACQQJ0aiICLwEAOwAAIAVBEGogAi0AAhABIAAgAi0AA2ohAwwBBSAPQX5qIQIDQCAFQRBqEAQgAyACS3JFBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2ohAwwBCwsDQCADIAJNBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2ohAwwBCwsCQCADIA9PDQAgAyAGIAVBEGogCBACIgBBAnRqIgItAAA6AAAgAi0AA0EBRgRAIAVBEGogAi0AAhABDAELIAUoAhRBH0sNACAFQRBqIAYgAEECdGotAAIQASAFKAIUQSFJDQAgBUEgNgIUCyABQWwgBUHYAGoQCiAFQUBrEApxIAVBKGoQCnEgBUEQahAKcRshCwwJCwAACwALAAALAAsAAAsACwAACwALQWwhCwsgBUHwAGokACALC7UEAQ5/IwBBEGsiBiQAIAZBBGogABAOQVQhBQJAIARB3AtJDQAgBi0ABCEHIANB8ARqQQBB7AAQECEIIAdBDEsNACADQdwJaiIJIAggBkEIaiAGQQxqIAEgAhAxIhAQA0UEQCAGKAIMIgQgB0sNASADQdwFaiEPIANBpAVqIREgAEEEaiESIANBqAVqIQEgBCEFA0AgBSICQX9qIQUgCCACQQJ0aigCAEUNAAsgAkEBaiEOQQEhBQNAIAUgDk9FBEAgCCAFQQJ0IgtqKAIAIQwgASALaiAKNgIAIAVBAWohBSAKIAxqIQoMAQsLIAEgCjYCAEEAIQUgBigCCCELA0AgBSALRkUEQCABIAUgCWotAAAiDEECdGoiDSANKAIAIg1BAWo2AgAgDyANQQF0aiINIAw6AAEgDSAFOgAAIAVBAWohBQwBCwtBACEBIANBADYCqAUgBEF/cyAHaiEJQQEhBQNAIAUgDk9FBEAgCCAFQQJ0IgtqKAIAIQwgAyALaiABNgIAIAwgBSAJanQgAWohASAFQQFqIQUMAQsLIAcgBEEBaiIBIAJrIgRrQQFqIQgDQEEBIQUgBCAIT0UEQANAIAUgDk9FBEAgBUECdCIJIAMgBEE0bGpqIAMgCWooAgAgBHY2AgAgBUEBaiEFDAELCyAEQQFqIQQMAQsLIBIgByAPIAogESADIAIgARBkIAZBAToABSAGIAc6AAYgACAGKAIENgIACyAQIQULIAZBEGokACAFC8ENAQt/IwBB8ABrIgUkAEFsIQkCQCADQQpJDQAgAi8AACEKIAIvAAIhDCACLwAEIQYgBUEIaiAEEA4CQCADIAYgCiAMampBBmoiDUkNACAFLQAKIQcgBUHYAGogAkEGaiICIAoQBiIJEAMNASAFQUBrIAIgCmoiAiAMEAYiCRADDQEgBUEoaiACIAxqIgIgBhAGIgkQAw0BIAVBEGogAiAGaiADIA1rEAYiCRADDQEgACABaiIOQX1qIQ8gBEEEaiEGQQEhCSAAIAFBA2pBAnYiAmoiCiACaiIMIAJqIg0hAyAMIQQgCiECA0AgCSADIA9JcQRAIAYgBUHYAGogBxACQQF0aiIILQAAIQsgBUHYAGogCC0AARABIAAgCzoAACAGIAVBQGsgBxACQQF0aiIILQAAIQsgBUFAayAILQABEAEgAiALOgAAIAYgBUEoaiAHEAJBAXRqIggtAAAhCyAFQShqIAgtAAEQASAEIAs6AAAgBiAFQRBqIAcQAkEBdGoiCC0AACELIAVBEGogCC0AARABIAMgCzoAACAGIAVB2ABqIAcQAkEBdGoiCC0AACELIAVB2ABqIAgtAAEQASAAIAs6AAEgBiAFQUBrIAcQAkEBdGoiCC0AACELIAVBQGsgCC0AARABIAIgCzoAASAGIAVBKGogBxACQQF0aiIILQAAIQsgBUEoaiAILQABEAEgBCALOgABIAYgBUEQaiAHEAJBAXRqIggtAAAhCyAFQRBqIAgtAAEQASADIAs6AAEgA0ECaiEDIARBAmohBCACQQJqIQIgAEECaiEAIAkgBUHYAGoQDUVxIAVBQGsQDUVxIAVBKGoQDUVxIAVBEGoQDUVxIQkMAQsLIAQgDUsgAiAMS3INAEFsIQkgACAKSw0BIApBfWohCQNAIAVB2ABqEAQgACAJT3JFBEAgBiAFQdgAaiAHEAJBAXRqIggtAAAhCyAFQdgAaiAILQABEAEgACALOgAAIAYgBUHYAGogBxACQQF0aiIILQAAIQsgBUHYAGogCC0AARABIAAgCzoAASAAQQJqIQAMAQsLA0AgBUHYAGoQBCAAIApPckUEQCAGIAVB2ABqIAcQAkEBdGoiCS0AACEIIAVB2ABqIAktAAEQASAAIAg6AAAgAEEBaiEADAELCwNAIAAgCkkEQCAGIAVB2ABqIAcQAkEBdGoiCS0AACEIIAVB2ABqIAktAAEQASAAIAg6AAAgAEEBaiEADAELCyAMQX1qIQADQCAFQUBrEAQgAiAAT3JFBEAgBiAFQUBrIAcQAkEBdGoiCi0AACEJIAVBQGsgCi0AARABIAIgCToAACAGIAVBQGsgBxACQQF0aiIKLQAAIQkgBUFAayAKLQABEAEgAiAJOgABIAJBAmohAgwBCwsDQCAFQUBrEAQgAiAMT3JFBEAgBiAFQUBrIAcQAkEBdGoiAC0AACEKIAVBQGsgAC0AARABIAIgCjoAACACQQFqIQIMAQsLA0AgAiAMSQRAIAYgBUFAayAHEAJBAXRqIgAtAAAhCiAFQUBrIAAtAAEQASACIAo6AAAgAkEBaiECDAELCyANQX1qIQADQCAFQShqEAQgBCAAT3JFBEAgBiAFQShqIAcQAkEBdGoiAi0AACEKIAVBKGogAi0AARABIAQgCjoAACAGIAVBKGogBxACQQF0aiICLQAAIQogBUEoaiACLQABEAEgBCAKOgABIARBAmohBAwBCwsDQCAFQShqEAQgBCANT3JFBEAgBiAFQShqIAcQAkEBdGoiAC0AACECIAVBKGogAC0AARABIAQgAjoAACAEQQFqIQQMAQsLA0AgBCANSQRAIAYgBUEoaiAHEAJBAXRqIgAtAAAhAiAFQShqIAAtAAEQASAEIAI6AAAgBEEBaiEEDAELCwNAIAVBEGoQBCADIA9PckUEQCAGIAVBEGogBxACQQF0aiIALQAAIQIgBUEQaiAALQABEAEgAyACOgAAIAYgBUEQaiAHEAJBAXRqIgAtAAAhAiAFQRBqIAAtAAEQASADIAI6AAEgA0ECaiEDDAELCwNAIAVBEGoQBCADIA5PckUEQCAGIAVBEGogBxACQQF0aiIALQAAIQIgBUEQaiAALQABEAEgAyACOgAAIANBAWohAwwBCwsDQCADIA5JBEAgBiAFQRBqIAcQAkEBdGoiAC0AACECIAVBEGogAC0AARABIAMgAjoAACADQQFqIQMMAQsLIAFBbCAFQdgAahAKIAVBQGsQCnEgBUEoahAKcSAFQRBqEApxGyEJDAELQWwhCQsgBUHwAGokACAJC8oCAQR/IwBBIGsiBSQAIAUgBBAOIAUtAAIhByAFQQhqIAIgAxAGIgIQA0UEQCAEQQRqIQIgACABaiIDQX1qIQQDQCAFQQhqEAQgACAET3JFBEAgAiAFQQhqIAcQAkEBdGoiBi0AACEIIAVBCGogBi0AARABIAAgCDoAACACIAVBCGogBxACQQF0aiIGLQAAIQggBUEIaiAGLQABEAEgACAIOgABIABBAmohAAwBCwsDQCAFQQhqEAQgACADT3JFBEAgAiAFQQhqIAcQAkEBdGoiBC0AACEGIAVBCGogBC0AARABIAAgBjoAACAAQQFqIQAMAQsLA0AgACADT0UEQCACIAVBCGogBxACQQF0aiIELQAAIQYgBUEIaiAELQABEAEgACAGOgAAIABBAWohAAwBCwsgAUFsIAVBCGoQChshAgsgBUEgaiQAIAILtgMBCX8jAEEQayIGJAAgBkEANgIMIAZBADYCCEFUIQQCQAJAIANBQGsiDCADIAZBCGogBkEMaiABIAIQMSICEAMNACAGQQRqIAAQDiAGKAIMIgcgBi0ABEEBaksNASAAQQRqIQogBkEAOgAFIAYgBzoABiAAIAYoAgQ2AgAgB0EBaiEJQQEhBANAIAQgCUkEQCADIARBAnRqIgEoAgAhACABIAU2AgAgACAEQX9qdCAFaiEFIARBAWohBAwBCwsgB0EBaiEHQQAhBSAGKAIIIQkDQCAFIAlGDQEgAyAFIAxqLQAAIgRBAnRqIgBBASAEdEEBdSILIAAoAgAiAWoiADYCACAHIARrIQhBACEEAkAgC0EDTQRAA0AgBCALRg0CIAogASAEakEBdGoiACAIOgABIAAgBToAACAEQQFqIQQMAAALAAsDQCABIABPDQEgCiABQQF0aiIEIAg6AAEgBCAFOgAAIAQgCDoAAyAEIAU6AAIgBCAIOgAFIAQgBToABCAEIAg6AAcgBCAFOgAGIAFBBGohAQwAAAsACyAFQQFqIQUMAAALAAsgAiEECyAGQRBqJAAgBAutAQECfwJAQYQgKAIAIABHIAAoAgBBAXYiAyABa0F4aiICQXhxQQhHcgR/IAIFIAMQJ0UNASACQQhqC0EQSQ0AIAAgACgCACICQQFxIAAgAWpBD2pBeHEiASAAa0EBdHI2AgAgASAANgIEIAEgASgCAEEBcSAAIAJBAXZqIAFrIgJBAXRyNgIAQYQgIAEgAkH/////B3FqQQRqQYQgKAIAIABGGyABNgIAIAEQJQsLygIBBX8CQAJAAkAgAEEIIABBCEsbZ0EfcyAAaUEBR2oiAUEESSAAIAF2cg0AIAFBAnRB/B5qKAIAIgJFDQADQCACQXhqIgMoAgBBAXZBeGoiBSAATwRAIAIgBUEIIAVBCEsbZ0Efc0ECdEGAH2oiASgCAEYEQCABIAIoAgQ2AgALDAMLIARBHksNASAEQQFqIQQgAigCBCICDQALC0EAIQMgAUEgTw0BA0AgAUECdEGAH2ooAgAiAkUEQCABQR5LIQIgAUEBaiEBIAJFDQEMAwsLIAIgAkF4aiIDKAIAQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgEoAgBGBEAgASACKAIENgIACwsgAigCACIBBEAgASACKAIENgIECyACKAIEIgEEQCABIAIoAgA2AgALIAMgAygCAEEBcjYCACADIAAQNwsgAwvhCwINfwV+IwBB8ABrIgckACAHIAAoAvDhASIINgJcIAEgAmohDSAIIAAoAoDiAWohDwJAAkAgBUUEQCABIQQMAQsgACgCxOABIRAgACgCwOABIREgACgCvOABIQ4gAEEBNgKM4QFBACEIA0AgCEEDRwRAIAcgCEECdCICaiAAIAJqQazQAWooAgA2AkQgCEEBaiEIDAELC0FsIQwgB0EYaiADIAQQBhADDQEgB0EsaiAHQRhqIAAoAgAQEyAHQTRqIAdBGGogACgCCBATIAdBPGogB0EYaiAAKAIEEBMgDUFgaiESIAEhBEEAIQwDQCAHKAIwIAcoAixBA3RqKQIAIhRCEIinQf8BcSEIIAcoAkAgBygCPEEDdGopAgAiFUIQiKdB/wFxIQsgBygCOCAHKAI0QQN0aikCACIWQiCIpyEJIBVCIIghFyAUQiCIpyECAkAgFkIQiKdB/wFxIgNBAk8EQAJAIAZFIANBGUlyRQRAIAkgB0EYaiADQSAgBygCHGsiCiAKIANLGyIKEAUgAyAKayIDdGohCSAHQRhqEAQaIANFDQEgB0EYaiADEAUgCWohCQwBCyAHQRhqIAMQBSAJaiEJIAdBGGoQBBoLIAcpAkQhGCAHIAk2AkQgByAYNwNIDAELAkAgA0UEQCACBEAgBygCRCEJDAMLIAcoAkghCQwBCwJAAkAgB0EYakEBEAUgCSACRWpqIgNBA0YEQCAHKAJEQX9qIgMgA0VqIQkMAQsgA0ECdCAHaigCRCIJIAlFaiEJIANBAUYNAQsgByAHKAJINgJMCwsgByAHKAJENgJIIAcgCTYCRAsgF6chAyALBEAgB0EYaiALEAUgA2ohAwsgCCALakEUTwRAIAdBGGoQBBoLIAgEQCAHQRhqIAgQBSACaiECCyAHQRhqEAQaIAcgB0EYaiAUQhiIp0H/AXEQCCAUp0H//wNxajYCLCAHIAdBGGogFUIYiKdB/wFxEAggFadB//8DcWo2AjwgB0EYahAEGiAHIAdBGGogFkIYiKdB/wFxEAggFqdB//8DcWo2AjQgByACNgJgIAcoAlwhCiAHIAk2AmggByADNgJkAkACQAJAIAQgAiADaiILaiASSw0AIAIgCmoiEyAPSw0AIA0gBGsgC0Egak8NAQsgByAHKQNoNwMQIAcgBykDYDcDCCAEIA0gB0EIaiAHQdwAaiAPIA4gESAQEB4hCwwBCyACIARqIQggBCAKEAcgAkERTwRAIARBEGohAgNAIAIgCkEQaiIKEAcgAkEQaiICIAhJDQALCyAIIAlrIQIgByATNgJcIAkgCCAOa0sEQCAJIAggEWtLBEBBbCELDAILIBAgAiAOayICaiIKIANqIBBNBEAgCCAKIAMQDxoMAgsgCCAKQQAgAmsQDyEIIAcgAiADaiIDNgJkIAggAmshCCAOIQILIAlBEE8EQCADIAhqIQMDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALDAELAkAgCUEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgCUECdCIDQcAeaigCAGoiAhAXIAIgA0HgHmooAgBrIQIgBygCZCEDDAELIAggAhAMCyADQQlJDQAgAyAIaiEDIAhBCGoiCCACQQhqIgJrQQ9MBEADQCAIIAIQDCACQQhqIQIgCEEIaiIIIANJDQAMAgALAAsDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALCyAHQRhqEAQaIAsgDCALEAMiAhshDCAEIAQgC2ogAhshBCAFQX9qIgUNAAsgDBADDQFBbCEMIAdBGGoQBEECSQ0BQQAhCANAIAhBA0cEQCAAIAhBAnQiAmpBrNABaiACIAdqKAJENgIAIAhBAWohCAwBCwsgBygCXCEIC0G6fyEMIA8gCGsiACANIARrSw0AIAQEfyAEIAggABALIABqBUEACyABayEMCyAHQfAAaiQAIAwLkRcCFn8FfiMAQdABayIHJAAgByAAKALw4QEiCDYCvAEgASACaiESIAggACgCgOIBaiETAkACQCAFRQRAIAEhAwwBCyAAKALE4AEhESAAKALA4AEhFSAAKAK84AEhDyAAQQE2AozhAUEAIQgDQCAIQQNHBEAgByAIQQJ0IgJqIAAgAmpBrNABaigCADYCVCAIQQFqIQgMAQsLIAcgETYCZCAHIA82AmAgByABIA9rNgJoQWwhECAHQShqIAMgBBAGEAMNASAFQQQgBUEESBshFyAHQTxqIAdBKGogACgCABATIAdBxABqIAdBKGogACgCCBATIAdBzABqIAdBKGogACgCBBATQQAhBCAHQeAAaiEMIAdB5ABqIQoDQCAHQShqEARBAksgBCAXTnJFBEAgBygCQCAHKAI8QQN0aikCACIdQhCIp0H/AXEhCyAHKAJQIAcoAkxBA3RqKQIAIh5CEIinQf8BcSEJIAcoAkggBygCREEDdGopAgAiH0IgiKchCCAeQiCIISAgHUIgiKchAgJAIB9CEIinQf8BcSIDQQJPBEACQCAGRSADQRlJckUEQCAIIAdBKGogA0EgIAcoAixrIg0gDSADSxsiDRAFIAMgDWsiA3RqIQggB0EoahAEGiADRQ0BIAdBKGogAxAFIAhqIQgMAQsgB0EoaiADEAUgCGohCCAHQShqEAQaCyAHKQJUISEgByAINgJUIAcgITcDWAwBCwJAIANFBEAgAgRAIAcoAlQhCAwDCyAHKAJYIQgMAQsCQAJAIAdBKGpBARAFIAggAkVqaiIDQQNGBEAgBygCVEF/aiIDIANFaiEIDAELIANBAnQgB2ooAlQiCCAIRWohCCADQQFGDQELIAcgBygCWDYCXAsLIAcgBygCVDYCWCAHIAg2AlQLICCnIQMgCQRAIAdBKGogCRAFIANqIQMLIAkgC2pBFE8EQCAHQShqEAQaCyALBEAgB0EoaiALEAUgAmohAgsgB0EoahAEGiAHIAcoAmggAmoiCSADajYCaCAKIAwgCCAJSxsoAgAhDSAHIAdBKGogHUIYiKdB/wFxEAggHadB//8DcWo2AjwgByAHQShqIB5CGIinQf8BcRAIIB6nQf//A3FqNgJMIAdBKGoQBBogB0EoaiAfQhiIp0H/AXEQCCEOIAdB8ABqIARBBHRqIgsgCSANaiAIazYCDCALIAg2AgggCyADNgIEIAsgAjYCACAHIA4gH6dB//8DcWo2AkQgBEEBaiEEDAELCyAEIBdIDQEgEkFgaiEYIAdB4ABqIRogB0HkAGohGyABIQMDQCAHQShqEARBAksgBCAFTnJFBEAgBygCQCAHKAI8QQN0aikCACIdQhCIp0H/AXEhCyAHKAJQIAcoAkxBA3RqKQIAIh5CEIinQf8BcSEIIAcoAkggBygCREEDdGopAgAiH0IgiKchCSAeQiCIISAgHUIgiKchDAJAIB9CEIinQf8BcSICQQJPBEACQCAGRSACQRlJckUEQCAJIAdBKGogAkEgIAcoAixrIgogCiACSxsiChAFIAIgCmsiAnRqIQkgB0EoahAEGiACRQ0BIAdBKGogAhAFIAlqIQkMAQsgB0EoaiACEAUgCWohCSAHQShqEAQaCyAHKQJUISEgByAJNgJUIAcgITcDWAwBCwJAIAJFBEAgDARAIAcoAlQhCQwDCyAHKAJYIQkMAQsCQAJAIAdBKGpBARAFIAkgDEVqaiICQQNGBEAgBygCVEF/aiICIAJFaiEJDAELIAJBAnQgB2ooAlQiCSAJRWohCSACQQFGDQELIAcgBygCWDYCXAsLIAcgBygCVDYCWCAHIAk2AlQLICCnIRQgCARAIAdBKGogCBAFIBRqIRQLIAggC2pBFE8EQCAHQShqEAQaCyALBEAgB0EoaiALEAUgDGohDAsgB0EoahAEGiAHIAcoAmggDGoiGSAUajYCaCAbIBogCSAZSxsoAgAhHCAHIAdBKGogHUIYiKdB/wFxEAggHadB//8DcWo2AjwgByAHQShqIB5CGIinQf8BcRAIIB6nQf//A3FqNgJMIAdBKGoQBBogByAHQShqIB9CGIinQf8BcRAIIB+nQf//A3FqNgJEIAcgB0HwAGogBEEDcUEEdGoiDSkDCCIdNwPIASAHIA0pAwAiHjcDwAECQAJAAkAgBygCvAEiDiAepyICaiIWIBNLDQAgAyAHKALEASIKIAJqIgtqIBhLDQAgEiADayALQSBqTw0BCyAHIAcpA8gBNwMQIAcgBykDwAE3AwggAyASIAdBCGogB0G8AWogEyAPIBUgERAeIQsMAQsgAiADaiEIIAMgDhAHIAJBEU8EQCADQRBqIQIDQCACIA5BEGoiDhAHIAJBEGoiAiAISQ0ACwsgCCAdpyIOayECIAcgFjYCvAEgDiAIIA9rSwRAIA4gCCAVa0sEQEFsIQsMAgsgESACIA9rIgJqIhYgCmogEU0EQCAIIBYgChAPGgwCCyAIIBZBACACaxAPIQggByACIApqIgo2AsQBIAggAmshCCAPIQILIA5BEE8EQCAIIApqIQoDQCAIIAIQByACQRBqIQIgCEEQaiIIIApJDQALDAELAkAgDkEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgDkECdCIKQcAeaigCAGoiAhAXIAIgCkHgHmooAgBrIQIgBygCxAEhCgwBCyAIIAIQDAsgCkEJSQ0AIAggCmohCiAIQQhqIgggAkEIaiICa0EPTARAA0AgCCACEAwgAkEIaiECIAhBCGoiCCAKSQ0ADAIACwALA0AgCCACEAcgAkEQaiECIAhBEGoiCCAKSQ0ACwsgCxADBEAgCyEQDAQFIA0gDDYCACANIBkgHGogCWs2AgwgDSAJNgIIIA0gFDYCBCAEQQFqIQQgAyALaiEDDAILAAsLIAQgBUgNASAEIBdrIQtBACEEA0AgCyAFSARAIAcgB0HwAGogC0EDcUEEdGoiAikDCCIdNwPIASAHIAIpAwAiHjcDwAECQAJAAkAgBygCvAEiDCAepyICaiIKIBNLDQAgAyAHKALEASIJIAJqIhBqIBhLDQAgEiADayAQQSBqTw0BCyAHIAcpA8gBNwMgIAcgBykDwAE3AxggAyASIAdBGGogB0G8AWogEyAPIBUgERAeIRAMAQsgAiADaiEIIAMgDBAHIAJBEU8EQCADQRBqIQIDQCACIAxBEGoiDBAHIAJBEGoiAiAISQ0ACwsgCCAdpyIGayECIAcgCjYCvAEgBiAIIA9rSwRAIAYgCCAVa0sEQEFsIRAMAgsgESACIA9rIgJqIgwgCWogEU0EQCAIIAwgCRAPGgwCCyAIIAxBACACaxAPIQggByACIAlqIgk2AsQBIAggAmshCCAPIQILIAZBEE8EQCAIIAlqIQYDQCAIIAIQByACQRBqIQIgCEEQaiIIIAZJDQALDAELAkAgBkEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgBkECdCIGQcAeaigCAGoiAhAXIAIgBkHgHmooAgBrIQIgBygCxAEhCQwBCyAIIAIQDAsgCUEJSQ0AIAggCWohBiAIQQhqIgggAkEIaiICa0EPTARAA0AgCCACEAwgAkEIaiECIAhBCGoiCCAGSQ0ADAIACwALA0AgCCACEAcgAkEQaiECIAhBEGoiCCAGSQ0ACwsgEBADDQMgC0EBaiELIAMgEGohAwwBCwsDQCAEQQNHBEAgACAEQQJ0IgJqQazQAWogAiAHaigCVDYCACAEQQFqIQQMAQsLIAcoArwBIQgLQbp/IRAgEyAIayIAIBIgA2tLDQAgAwR/IAMgCCAAEAsgAGoFQQALIAFrIRALIAdB0AFqJAAgEAslACAAQgA3AgAgAEEAOwEIIABBADoACyAAIAE2AgwgACACOgAKC7QFAQN/IwBBMGsiBCQAIABB/wFqIgVBfWohBgJAIAMvAQIEQCAEQRhqIAEgAhAGIgIQAw0BIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahASOgAAIAMgBEEIaiAEQRhqEBI6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0FIAEgBEEQaiAEQRhqEBI6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBSABIARBCGogBEEYahASOgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEjoAACABIAJqIABrIQIMAwsgAyAEQRBqIARBGGoQEjoAAiADIARBCGogBEEYahASOgADIANBBGohAwwAAAsACyAEQRhqIAEgAhAGIgIQAw0AIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahAROgAAIAMgBEEIaiAEQRhqEBE6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0EIAEgBEEQaiAEQRhqEBE6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBCABIARBCGogBEEYahAROgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEToAACABIAJqIABrIQIMAgsgAyAEQRBqIARBGGoQEToAAiADIARBCGogBEEYahAROgADIANBBGohAwwAAAsACyAEQTBqJAAgAgtpAQF/An8CQAJAIAJBB00NACABKAAAQbfIwuF+Rw0AIAAgASgABDYCmOIBQWIgAEEQaiABIAIQPiIDEAMNAhogAEKBgICAEDcDiOEBIAAgASADaiACIANrECoMAQsgACABIAIQKgtBAAsLrQMBBn8jAEGAAWsiAyQAQWIhCAJAIAJBCUkNACAAQZjQAGogAUEIaiIEIAJBeGogAEGY0AAQMyIFEAMiBg0AIANBHzYCfCADIANB/ABqIANB+ABqIAQgBCAFaiAGGyIEIAEgAmoiAiAEaxAVIgUQAw0AIAMoAnwiBkEfSw0AIAMoAngiB0EJTw0AIABBiCBqIAMgBkGAC0GADCAHEBggA0E0NgJ8IAMgA0H8AGogA0H4AGogBCAFaiIEIAIgBGsQFSIFEAMNACADKAJ8IgZBNEsNACADKAJ4IgdBCk8NACAAQZAwaiADIAZBgA1B4A4gBxAYIANBIzYCfCADIANB/ABqIANB+ABqIAQgBWoiBCACIARrEBUiBRADDQAgAygCfCIGQSNLDQAgAygCeCIHQQpPDQAgACADIAZBwBBB0BEgBxAYIAQgBWoiBEEMaiIFIAJLDQAgAiAFayEFQQAhAgNAIAJBA0cEQCAEKAAAIgZBf2ogBU8NAiAAIAJBAnRqQZzQAWogBjYCACACQQFqIQIgBEEEaiEEDAELCyAEIAFrIQgLIANBgAFqJAAgCAtGAQN/IABBCGohAyAAKAIEIQJBACEAA0AgACACdkUEQCABIAMgAEEDdGotAAJBFktqIQEgAEEBaiEADAELCyABQQggAmt0C4YDAQV/Qbh/IQcCQCADRQ0AIAItAAAiBEUEQCABQQA2AgBBAUG4fyADQQFGGw8LAn8gAkEBaiIFIARBGHRBGHUiBkF/Sg0AGiAGQX9GBEAgA0EDSA0CIAUvAABBgP4BaiEEIAJBA2oMAQsgA0ECSA0BIAItAAEgBEEIdHJBgIB+aiEEIAJBAmoLIQUgASAENgIAIAVBAWoiASACIANqIgNLDQBBbCEHIABBEGogACAFLQAAIgVBBnZBI0EJIAEgAyABa0HAEEHQEUHwEiAAKAKM4QEgACgCnOIBIAQQHyIGEAMiCA0AIABBmCBqIABBCGogBUEEdkEDcUEfQQggASABIAZqIAgbIgEgAyABa0GAC0GADEGAFyAAKAKM4QEgACgCnOIBIAQQHyIGEAMiCA0AIABBoDBqIABBBGogBUECdkEDcUE0QQkgASABIAZqIAgbIgEgAyABa0GADUHgDkGQGSAAKAKM4QEgACgCnOIBIAQQHyIAEAMNACAAIAFqIAJrIQcLIAcLrQMBCn8jAEGABGsiCCQAAn9BUiACQf8BSw0AGkFUIANBDEsNABogAkEBaiELIABBBGohCUGAgAQgA0F/anRBEHUhCkEAIQJBASEEQQEgA3QiB0F/aiIMIQUDQCACIAtGRQRAAkAgASACQQF0Ig1qLwEAIgZB//8DRgRAIAkgBUECdGogAjoAAiAFQX9qIQVBASEGDAELIARBACAKIAZBEHRBEHVKGyEECyAIIA1qIAY7AQAgAkEBaiECDAELCyAAIAQ7AQIgACADOwEAIAdBA3YgB0EBdmpBA2ohBkEAIQRBACECA0AgBCALRkUEQCABIARBAXRqLgEAIQpBACEAA0AgACAKTkUEQCAJIAJBAnRqIAQ6AAIDQCACIAZqIAxxIgIgBUsNAAsgAEEBaiEADAELCyAEQQFqIQQMAQsLQX8gAg0AGkEAIQIDfyACIAdGBH9BAAUgCCAJIAJBAnRqIgAtAAJBAXRqIgEgAS8BACIBQQFqOwEAIAAgAyABEBRrIgU6AAMgACABIAVB/wFxdCAHazsBACACQQFqIQIMAQsLCyEFIAhBgARqJAAgBQvjBgEIf0FsIQcCQCACQQNJDQACQAJAAkACQCABLQAAIgNBA3EiCUEBaw4DAwEAAgsgACgCiOEBDQBBYg8LIAJBBUkNAkEDIQYgASgAACEFAn8CQAJAIANBAnZBA3EiCEF+aiIEQQFNBEAgBEEBaw0BDAILIAVBDnZB/wdxIQQgBUEEdkH/B3EhAyAIRQwCCyAFQRJ2IQRBBCEGIAVBBHZB//8AcSEDQQAMAQsgBUEEdkH//w9xIgNBgIAISw0DIAEtAARBCnQgBUEWdnIhBEEFIQZBAAshBSAEIAZqIgogAksNAgJAIANBgQZJDQAgACgCnOIBRQ0AQQAhAgNAIAJBg4ABSw0BIAJBQGshAgwAAAsACwJ/IAlBA0YEQCABIAZqIQEgAEHw4gFqIQIgACgCDCEGIAUEQCACIAMgASAEIAYQXwwCCyACIAMgASAEIAYQXQwBCyAAQbjQAWohAiABIAZqIQEgAEHw4gFqIQYgAEGo0ABqIQggBQRAIAggBiADIAEgBCACEF4MAQsgCCAGIAMgASAEIAIQXAsQAw0CIAAgAzYCgOIBIABBATYCiOEBIAAgAEHw4gFqNgLw4QEgCUECRgRAIAAgAEGo0ABqNgIMCyAAIANqIgBBiOMBakIANwAAIABBgOMBakIANwAAIABB+OIBakIANwAAIABB8OIBakIANwAAIAoPCwJ/AkACQAJAIANBAnZBA3FBf2oiBEECSw0AIARBAWsOAgACAQtBASEEIANBA3YMAgtBAiEEIAEvAABBBHYMAQtBAyEEIAEQIUEEdgsiAyAEaiIFQSBqIAJLBEAgBSACSw0CIABB8OIBaiABIARqIAMQCyEBIAAgAzYCgOIBIAAgATYC8OEBIAEgA2oiAEIANwAYIABCADcAECAAQgA3AAggAEIANwAAIAUPCyAAIAM2AoDiASAAIAEgBGo2AvDhASAFDwsCfwJAAkACQCADQQJ2QQNxQX9qIgRBAksNACAEQQFrDgIAAgELQQEhByADQQN2DAILQQIhByABLwAAQQR2DAELIAJBBEkgARAhIgJBj4CAAUtyDQFBAyEHIAJBBHYLIQIgAEHw4gFqIAEgB2otAAAgAkEgahAQIQEgACACNgKA4gEgACABNgLw4QEgB0EBaiEHCyAHC0sAIABC+erQ0OfJoeThADcDICAAQgA3AxggAELP1tO+0ser2UI3AxAgAELW64Lu6v2J9eAANwMIIABCADcDACAAQShqQQBBKBAQGgviAgICfwV+IABBKGoiASAAKAJIaiECAn4gACkDACIDQiBaBEAgACkDECIEQgeJIAApAwgiBUIBiXwgACkDGCIGQgyJfCAAKQMgIgdCEol8IAUQGSAEEBkgBhAZIAcQGQwBCyAAKQMYQsXP2bLx5brqJ3wLIAN8IQMDQCABQQhqIgAgAk0EQEIAIAEpAAAQCSADhUIbiUKHla+vmLbem55/fkLj3MqV/M7y9YV/fCEDIAAhAQwBCwsCQCABQQRqIgAgAksEQCABIQAMAQsgASgAAK1Ch5Wvr5i23puef34gA4VCF4lCz9bTvtLHq9lCfkL5893xmfaZqxZ8IQMLA0AgACACSQRAIAAxAABCxc/ZsvHluuonfiADhUILiUKHla+vmLbem55/fiEDIABBAWohAAwBCwsgA0IhiCADhULP1tO+0ser2UJ+IgNCHYggA4VC+fPd8Zn2masWfiIDQiCIIAOFC+8CAgJ/BH4gACAAKQMAIAKtfDcDAAJAAkAgACgCSCIDIAJqIgRBH00EQCABRQ0BIAAgA2pBKGogASACECAgACgCSCACaiEEDAELIAEgAmohAgJ/IAMEQCAAQShqIgQgA2ogAUEgIANrECAgACAAKQMIIAQpAAAQCTcDCCAAIAApAxAgACkAMBAJNwMQIAAgACkDGCAAKQA4EAk3AxggACAAKQMgIABBQGspAAAQCTcDICAAKAJIIQMgAEEANgJIIAEgA2tBIGohAQsgAUEgaiACTQsEQCACQWBqIQMgACkDICEFIAApAxghBiAAKQMQIQcgACkDCCEIA0AgCCABKQAAEAkhCCAHIAEpAAgQCSEHIAYgASkAEBAJIQYgBSABKQAYEAkhBSABQSBqIgEgA00NAAsgACAFNwMgIAAgBjcDGCAAIAc3AxAgACAINwMICyABIAJPDQEgAEEoaiABIAIgAWsiBBAgCyAAIAQ2AkgLCy8BAX8gAEUEQEG2f0EAIAMbDwtBun8hBCADIAFNBH8gACACIAMQEBogAwVBun8LCy8BAX8gAEUEQEG2f0EAIAMbDwtBun8hBCADIAFNBH8gACACIAMQCxogAwVBun8LC6gCAQZ/IwBBEGsiByQAIABB2OABaikDAEKAgIAQViEIQbh/IQUCQCAEQf//B0sNACAAIAMgBBBCIgUQAyIGDQAgACgCnOIBIQkgACAHQQxqIAMgAyAFaiAGGyIKIARBACAFIAYbayIGEEAiAxADBEAgAyEFDAELIAcoAgwhBCABRQRAQbp/IQUgBEEASg0BCyAGIANrIQUgAyAKaiEDAkAgCQRAIABBADYCnOIBDAELAkACQAJAIARBBUgNACAAQdjgAWopAwBCgICACFgNAAwBCyAAQQA2ApziAQwBCyAAKAIIED8hBiAAQQA2ApziASAGQRRPDQELIAAgASACIAMgBSAEIAgQOSEFDAELIAAgASACIAMgBSAEIAgQOiEFCyAHQRBqJAAgBQtnACAAQdDgAWogASACIAAoAuzhARAuIgEQAwRAIAEPC0G4fyECAkAgAQ0AIABB7OABaigCACIBBEBBYCECIAAoApjiASABRw0BC0EAIQIgAEHw4AFqKAIARQ0AIABBkOEBahBDCyACCycBAX8QVyIERQRAQUAPCyAEIAAgASACIAMgBBBLEE8hACAEEFYgAAs/AQF/AkACQAJAIAAoAqDiAUEBaiIBQQJLDQAgAUEBaw4CAAECCyAAEDBBAA8LIABBADYCoOIBCyAAKAKU4gELvAMCB38BfiMAQRBrIgkkAEG4fyEGAkAgBCgCACIIQQVBCSAAKALs4QEiBRtJDQAgAygCACIHQQFBBSAFGyAFEC8iBRADBEAgBSEGDAELIAggBUEDakkNACAAIAcgBRBJIgYQAw0AIAEgAmohCiAAQZDhAWohCyAIIAVrIQIgBSAHaiEHIAEhBQNAIAcgAiAJECwiBhADDQEgAkF9aiICIAZJBEBBuH8hBgwCCyAJKAIAIghBAksEQEFsIQYMAgsgB0EDaiEHAn8CQAJAAkAgCEEBaw4CAgABCyAAIAUgCiAFayAHIAYQSAwCCyAFIAogBWsgByAGEEcMAQsgBSAKIAVrIActAAAgCSgCCBBGCyIIEAMEQCAIIQYMAgsgACgC8OABBEAgCyAFIAgQRQsgAiAGayECIAYgB2ohByAFIAhqIQUgCSgCBEUNAAsgACkD0OABIgxCf1IEQEFsIQYgDCAFIAFrrFINAQsgACgC8OABBEBBaiEGIAJBBEkNASALEEQhDCAHKAAAIAynRw0BIAdBBGohByACQXxqIQILIAMgBzYCACAEIAI2AgAgBSABayEGCyAJQRBqJAAgBgsuACAAECsCf0EAQQAQAw0AGiABRSACRXJFBEBBYiAAIAEgAhA9EAMNARoLQQALCzcAIAEEQCAAIAAoAsTgASABKAIEIAEoAghqRzYCnOIBCyAAECtBABADIAFFckUEQCAAIAEQWwsL0QIBB38jAEEQayIGJAAgBiAENgIIIAYgAzYCDCAFBEAgBSgCBCEKIAUoAgghCQsgASEIAkACQANAIAAoAuzhARAWIQsCQANAIAQgC0kNASADKAAAQXBxQdDUtMIBRgRAIAMgBBAiIgcQAw0EIAQgB2shBCADIAdqIQMMAQsLIAYgAzYCDCAGIAQ2AggCQCAFBEAgACAFEE5BACEHQQAQA0UNAQwFCyAAIAogCRBNIgcQAw0ECyAAIAgQUCAMQQFHQQAgACAIIAIgBkEMaiAGQQhqEEwiByIDa0EAIAMQAxtBCkdyRQRAQbh/IQcMBAsgBxADDQMgAiAHayECIAcgCGohCEEBIQwgBigCDCEDIAYoAgghBAwBCwsgBiADNgIMIAYgBDYCCEG4fyEHIAQNASAIIAFrIQcMAQsgBiADNgIMIAYgBDYCCAsgBkEQaiQAIAcLRgECfyABIAAoArjgASICRwRAIAAgAjYCxOABIAAgATYCuOABIAAoArzgASEDIAAgATYCvOABIAAgASADIAJrajYCwOABCwutAgIEfwF+IwBBQGoiBCQAAkACQCACQQhJDQAgASgAAEFwcUHQ1LTCAUcNACABIAIQIiEBIABCADcDCCAAQQA2AgQgACABNgIADAELIARBGGogASACEC0iAxADBEAgACADEBoMAQsgAwRAIABBuH8QGgwBCyACIAQoAjAiA2shAiABIANqIQMDQAJAIAAgAyACIARBCGoQLCIFEAMEfyAFBSACIAVBA2oiBU8NAUG4fwsQGgwCCyAGQQFqIQYgAiAFayECIAMgBWohAyAEKAIMRQ0ACyAEKAI4BEAgAkEDTQRAIABBuH8QGgwCCyADQQRqIQMLIAQoAighAiAEKQMYIQcgAEEANgIEIAAgAyABazYCACAAIAIgBmytIAcgB0J/URs3AwgLIARBQGskAAslAQF/IwBBEGsiAiQAIAIgACABEFEgAigCACEAIAJBEGokACAAC30BBH8jAEGQBGsiBCQAIARB/wE2AggCQCAEQRBqIARBCGogBEEMaiABIAIQFSIGEAMEQCAGIQUMAQtBVCEFIAQoAgwiB0EGSw0AIAMgBEEQaiAEKAIIIAcQQSIFEAMNACAAIAEgBmogAiAGayADEDwhBQsgBEGQBGokACAFC4cBAgJ/An5BABAWIQMCQANAIAEgA08EQAJAIAAoAABBcHFB0NS0wgFGBEAgACABECIiAhADRQ0BQn4PCyAAIAEQVSIEQn1WDQMgBCAFfCIFIARUIQJCfiEEIAINAyAAIAEQUiICEAMNAwsgASACayEBIAAgAmohAAwBCwtCfiAFIAEbIQQLIAQLPwIBfwF+IwBBMGsiAiQAAn5CfiACQQhqIAAgARAtDQAaQgAgAigCHEEBRg0AGiACKQMICyEDIAJBMGokACADC40BAQJ/IwBBMGsiASQAAkAgAEUNACAAKAKI4gENACABIABB/OEBaigCADYCKCABIAApAvThATcDICAAEDAgACgCqOIBIQIgASABKAIoNgIYIAEgASkDIDcDECACIAFBEGoQGyAAQQA2AqjiASABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALKgECfyMAQRBrIgAkACAAQQA2AgggAEIANwMAIAAQWCEBIABBEGokACABC4cBAQN/IwBBEGsiAiQAAkAgACgCAEUgACgCBEVzDQAgAiAAKAIINgIIIAIgACkCADcDAAJ/IAIoAgAiAQRAIAIoAghBqOMJIAERBQAMAQtBqOMJECgLIgFFDQAgASAAKQIANwL04QEgAUH84QFqIAAoAgg2AgAgARBZIAEhAwsgAkEQaiQAIAMLywEBAn8jAEEgayIBJAAgAEGBgIDAADYCtOIBIABBADYCiOIBIABBADYC7OEBIABCADcDkOIBIABBADYCpOMJIABBADYC3OIBIABCADcCzOIBIABBADYCvOIBIABBADYCxOABIABCADcCnOIBIABBpOIBakIANwIAIABBrOIBakEANgIAIAFCADcCECABQgA3AhggASABKQMYNwMIIAEgASkDEDcDACABKAIIQQh2QQFxIQIgAEEANgLg4gEgACACNgKM4gEgAUEgaiQAC3YBA38jAEEwayIBJAAgAARAIAEgAEHE0AFqIgIoAgA2AiggASAAKQK80AE3AyAgACgCACEDIAEgAigCADYCGCABIAApArzQATcDECADIAFBEGoQGyABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALzAEBAX8gACABKAK00AE2ApjiASAAIAEoAgQiAjYCwOABIAAgAjYCvOABIAAgAiABKAIIaiICNgK44AEgACACNgLE4AEgASgCuNABBEAgAEKBgICAEDcDiOEBIAAgAUGk0ABqNgIMIAAgAUGUIGo2AgggACABQZwwajYCBCAAIAFBDGo2AgAgAEGs0AFqIAFBqNABaigCADYCACAAQbDQAWogAUGs0AFqKAIANgIAIABBtNABaiABQbDQAWooAgA2AgAPCyAAQgA3A4jhAQs7ACACRQRAQbp/DwsgBEUEQEFsDwsgAiAEEGAEQCAAIAEgAiADIAQgBRBhDwsgACABIAIgAyAEIAUQZQtGAQF/IwBBEGsiBSQAIAVBCGogBBAOAn8gBS0ACQRAIAAgASACIAMgBBAyDAELIAAgASACIAMgBBA0CyEAIAVBEGokACAACzQAIAAgAyAEIAUQNiIFEAMEQCAFDwsgBSAESQR/IAEgAiADIAVqIAQgBWsgABA1BUG4fwsLRgEBfyMAQRBrIgUkACAFQQhqIAQQDgJ/IAUtAAkEQCAAIAEgAiADIAQQYgwBCyAAIAEgAiADIAQQNQshACAFQRBqJAAgAAtZAQF/QQ8hAiABIABJBEAgAUEEdCAAbiECCyAAQQh2IgEgAkEYbCIAQYwIaigCAGwgAEGICGooAgBqIgJBA3YgAmogAEGACGooAgAgAEGECGooAgAgAWxqSQs3ACAAIAMgBCAFQYAQEDMiBRADBEAgBQ8LIAUgBEkEfyABIAIgAyAFaiAEIAVrIAAQMgVBuH8LC78DAQN/IwBBIGsiBSQAIAVBCGogAiADEAYiAhADRQRAIAAgAWoiB0F9aiEGIAUgBBAOIARBBGohAiAFLQACIQMDQEEAIAAgBkkgBUEIahAEGwRAIAAgAiAFQQhqIAMQAkECdGoiBC8BADsAACAFQQhqIAQtAAIQASAAIAQtAANqIgQgAiAFQQhqIAMQAkECdGoiAC8BADsAACAFQQhqIAAtAAIQASAEIAAtAANqIQAMAQUgB0F+aiEEA0AgBUEIahAEIAAgBEtyRQRAIAAgAiAFQQhqIAMQAkECdGoiBi8BADsAACAFQQhqIAYtAAIQASAAIAYtAANqIQAMAQsLA0AgACAES0UEQCAAIAIgBUEIaiADEAJBAnRqIgYvAQA7AAAgBUEIaiAGLQACEAEgACAGLQADaiEADAELCwJAIAAgB08NACAAIAIgBUEIaiADEAIiA0ECdGoiAC0AADoAACAALQADQQFGBEAgBUEIaiAALQACEAEMAQsgBSgCDEEfSw0AIAVBCGogAiADQQJ0ai0AAhABIAUoAgxBIUkNACAFQSA2AgwLIAFBbCAFQQhqEAobIQILCwsgBUEgaiQAIAILkgIBBH8jAEFAaiIJJAAgCSADQTQQCyEDAkAgBEECSA0AIAMgBEECdGooAgAhCSADQTxqIAgQIyADQQE6AD8gAyACOgA+QQAhBCADKAI8IQoDQCAEIAlGDQEgACAEQQJ0aiAKNgEAIARBAWohBAwAAAsAC0EAIQkDQCAGIAlGRQRAIAMgBSAJQQF0aiIKLQABIgtBAnRqIgwoAgAhBCADQTxqIAotAABBCHQgCGpB//8DcRAjIANBAjoAPyADIAcgC2siCiACajoAPiAEQQEgASAKa3RqIQogAygCPCELA0AgACAEQQJ0aiALNgEAIARBAWoiBCAKSQ0ACyAMIAo2AgAgCUEBaiEJDAELCyADQUBrJAALowIBCX8jAEHQAGsiCSQAIAlBEGogBUE0EAsaIAcgBmshDyAHIAFrIRADQAJAIAMgCkcEQEEBIAEgByACIApBAXRqIgYtAAEiDGsiCGsiC3QhDSAGLQAAIQ4gCUEQaiAMQQJ0aiIMKAIAIQYgCyAPTwRAIAAgBkECdGogCyAIIAUgCEE0bGogCCAQaiIIQQEgCEEBShsiCCACIAQgCEECdGooAgAiCEEBdGogAyAIayAHIA4QYyAGIA1qIQgMAgsgCUEMaiAOECMgCUEBOgAPIAkgCDoADiAGIA1qIQggCSgCDCELA0AgBiAITw0CIAAgBkECdGogCzYBACAGQQFqIQYMAAALAAsgCUHQAGokAA8LIAwgCDYCACAKQQFqIQoMAAALAAs0ACAAIAMgBCAFEDYiBRADBEAgBQ8LIAUgBEkEfyABIAIgAyAFaiAEIAVrIAAQNAVBuH8LCyMAIAA/AEEQdGtB//8DakEQdkAAQX9GBEBBAA8LQQAQAEEBCzsBAX8gAgRAA0AgACABIAJBgCAgAkGAIEkbIgMQCyEAIAFBgCBqIQEgAEGAIGohACACIANrIgINAAsLCwYAIAAQAwsLqBUJAEGICAsNAQAAAAEAAAACAAAAAgBBoAgLswYBAAAAAQAAAAIAAAACAAAAJgAAAIIAAAAhBQAASgAAAGcIAAAmAAAAwAEAAIAAAABJBQAASgAAAL4IAAApAAAALAIAAIAAAABJBQAASgAAAL4IAAAvAAAAygIAAIAAAACKBQAASgAAAIQJAAA1AAAAcwMAAIAAAACdBQAASgAAAKAJAAA9AAAAgQMAAIAAAADrBQAASwAAAD4KAABEAAAAngMAAIAAAABNBgAASwAAAKoKAABLAAAAswMAAIAAAADBBgAATQAAAB8NAABNAAAAUwQAAIAAAAAjCAAAUQAAAKYPAABUAAAAmQQAAIAAAABLCQAAVwAAALESAABYAAAA2gQAAIAAAABvCQAAXQAAACMUAABUAAAARQUAAIAAAABUCgAAagAAAIwUAABqAAAArwUAAIAAAAB2CQAAfAAAAE4QAAB8AAAA0gIAAIAAAABjBwAAkQAAAJAHAACSAAAAAAAAAAEAAAABAAAABQAAAA0AAAAdAAAAPQAAAH0AAAD9AAAA/QEAAP0DAAD9BwAA/Q8AAP0fAAD9PwAA/X8AAP3/AAD9/wEA/f8DAP3/BwD9/w8A/f8fAP3/PwD9/38A/f//AP3//wH9//8D/f//B/3//w/9//8f/f//P/3//38AAAAAAQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABEAAAASAAAAEwAAABQAAAAVAAAAFgAAABcAAAAYAAAAGQAAABoAAAAbAAAAHAAAAB0AAAAeAAAAHwAAAAMAAAAEAAAABQAAAAYAAAAHAAAACAAAAAkAAAAKAAAACwAAAAwAAAANAAAADgAAAA8AAAAQAAAAEQAAABIAAAATAAAAFAAAABUAAAAWAAAAFwAAABgAAAAZAAAAGgAAABsAAAAcAAAAHQAAAB4AAAAfAAAAIAAAACEAAAAiAAAAIwAAACUAAAAnAAAAKQAAACsAAAAvAAAAMwAAADsAAABDAAAAUwAAAGMAAACDAAAAAwEAAAMCAAADBAAAAwgAAAMQAAADIAAAA0AAAAOAAAADAAEAQeAPC1EBAAAAAQAAAAEAAAABAAAAAgAAAAIAAAADAAAAAwAAAAQAAAAEAAAABQAAAAcAAAAIAAAACQAAAAoAAAALAAAADAAAAA0AAAAOAAAADwAAABAAQcQQC4sBAQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABIAAAAUAAAAFgAAABgAAAAcAAAAIAAAACgAAAAwAAAAQAAAAIAAAAAAAQAAAAIAAAAEAAAACAAAABAAAAAgAAAAQAAAAIAAAAAAAQBBkBIL5gQBAAAAAQAAAAEAAAABAAAAAgAAAAIAAAADAAAAAwAAAAQAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAAAEAAAAEAAAACAAAAAAAAAABAAEBBgAAAAAAAAQAAAAAEAAABAAAAAAgAAAFAQAAAAAAAAUDAAAAAAAABQQAAAAAAAAFBgAAAAAAAAUHAAAAAAAABQkAAAAAAAAFCgAAAAAAAAUMAAAAAAAABg4AAAAAAAEFEAAAAAAAAQUUAAAAAAABBRYAAAAAAAIFHAAAAAAAAwUgAAAAAAAEBTAAAAAgAAYFQAAAAAAABwWAAAAAAAAIBgABAAAAAAoGAAQAAAAADAYAEAAAIAAABAAAAAAAAAAEAQAAAAAAAAUCAAAAIAAABQQAAAAAAAAFBQAAACAAAAUHAAAAAAAABQgAAAAgAAAFCgAAAAAAAAULAAAAAAAABg0AAAAgAAEFEAAAAAAAAQUSAAAAIAABBRYAAAAAAAIFGAAAACAAAwUgAAAAAAADBSgAAAAAAAYEQAAAABAABgRAAAAAIAAHBYAAAAAAAAkGAAIAAAAACwYACAAAMAAABAAAAAAQAAAEAQAAACAAAAUCAAAAIAAABQMAAAAgAAAFBQAAACAAAAUGAAAAIAAABQgAAAAgAAAFCQAAACAAAAULAAAAIAAABQwAAAAAAAAGDwAAACAAAQUSAAAAIAABBRQAAAAgAAIFGAAAACAAAgUcAAAAIAADBSgAAAAgAAQFMAAAAAAAEAYAAAEAAAAPBgCAAAAAAA4GAEAAAAAADQYAIABBgBcLhwIBAAEBBQAAAAAAAAUAAAAAAAAGBD0AAAAAAAkF/QEAAAAADwX9fwAAAAAVBf3/HwAAAAMFBQAAAAAABwR9AAAAAAAMBf0PAAAAABIF/f8DAAAAFwX9/38AAAAFBR0AAAAAAAgE/QAAAAAADgX9PwAAAAAUBf3/DwAAAAIFAQAAABAABwR9AAAAAAALBf0HAAAAABEF/f8BAAAAFgX9/z8AAAAEBQ0AAAAQAAgE/QAAAAAADQX9HwAAAAATBf3/BwAAAAEFAQAAABAABgQ9AAAAAAAKBf0DAAAAABAF/f8AAAAAHAX9//8PAAAbBf3//wcAABoF/f//AwAAGQX9//8BAAAYBf3//wBBkBkLhgQBAAEBBgAAAAAAAAYDAAAAAAAABAQAAAAgAAAFBQAAAAAAAAUGAAAAAAAABQgAAAAAAAAFCQAAAAAAAAULAAAAAAAABg0AAAAAAAAGEAAAAAAAAAYTAAAAAAAABhYAAAAAAAAGGQAAAAAAAAYcAAAAAAAABh8AAAAAAAAGIgAAAAAAAQYlAAAAAAABBikAAAAAAAIGLwAAAAAAAwY7AAAAAAAEBlMAAAAAAAcGgwAAAAAACQYDAgAAEAAABAQAAAAAAAAEBQAAACAAAAUGAAAAAAAABQcAAAAgAAAFCQAAAAAAAAUKAAAAAAAABgwAAAAAAAAGDwAAAAAAAAYSAAAAAAAABhUAAAAAAAAGGAAAAAAAAAYbAAAAAAAABh4AAAAAAAAGIQAAAAAAAQYjAAAAAAABBicAAAAAAAIGKwAAAAAAAwYzAAAAAAAEBkMAAAAAAAUGYwAAAAAACAYDAQAAIAAABAQAAAAwAAAEBAAAABAAAAQFAAAAIAAABQcAAAAgAAAFCAAAACAAAAUKAAAAIAAABQsAAAAAAAAGDgAAAAAAAAYRAAAAAAAABhQAAAAAAAAGFwAAAAAAAAYaAAAAAAAABh0AAAAAAAAGIAAAAAAAEAYDAAEAAAAPBgOAAAAAAA4GA0AAAAAADQYDIAAAAAAMBgMQAAAAAAsGAwgAAAAACgYDBABBpB0L2QEBAAAAAwAAAAcAAAAPAAAAHwAAAD8AAAB/AAAA/wAAAP8BAAD/AwAA/wcAAP8PAAD/HwAA/z8AAP9/AAD//wAA//8BAP//AwD//wcA//8PAP//HwD//z8A//9/AP///wD///8B////A////wf///8P////H////z////9/AAAAAAEAAAACAAAABAAAAAAAAAACAAAABAAAAAgAAAAAAAAAAQAAAAIAAAABAAAABAAAAAQAAAAEAAAABAAAAAgAAAAIAAAACAAAAAcAAAAIAAAACQAAAAoAAAALAEGgIAsDwBBQ";

// node_modules/three-stdlib/_polyfill/CompressedArrayTexture.js
var CompressedArrayTexture = class extends CompressedTexture {
  constructor(mipmaps, width, height, depth, format, type) {
    super(mipmaps, width, height, format, type);
    this.isCompressedArrayTexture = true;
    this.image.depth = depth;
    this.wrapR = ClampToEdgeWrapping;
  }
};

// node_modules/three-stdlib/loaders/KTX2Loader.js
var __defProp22 = Object.defineProperty;
var __defNormalProp22 = (obj, key, value) => key in obj ? __defProp22(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField23 = (obj, key, value) => {
  __defNormalProp22(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var _taskCache = /* @__PURE__ */ new WeakMap();
var _activeLoaders = 0;
var _zstd;
var _KTX2Loader = class extends Loader {
  constructor(manager) {
    super(manager);
    this.transcoderPath = "";
    this.transcoderBinary = null;
    this.transcoderPending = null;
    this.workerPool = new WorkerPool();
    this.workerSourceURL = "";
    this.workerConfig = null;
    if (typeof MSC_TRANSCODER !== "undefined") {
      console.warn(
        'THREE.KTX2Loader: Please update to latest "basis_transcoder". "msc_basis_transcoder" is no longer supported in three.js r125+.'
      );
    }
  }
  setTranscoderPath(path) {
    this.transcoderPath = path;
    return this;
  }
  setWorkerLimit(num) {
    this.workerPool.setWorkerLimit(num);
    return this;
  }
  detectSupport(renderer) {
    this.workerConfig = {
      astcSupported: renderer.extensions.has("WEBGL_compressed_texture_astc"),
      etc1Supported: renderer.extensions.has("WEBGL_compressed_texture_etc1"),
      etc2Supported: renderer.extensions.has("WEBGL_compressed_texture_etc"),
      dxtSupported: renderer.extensions.has("WEBGL_compressed_texture_s3tc"),
      bptcSupported: renderer.extensions.has("EXT_texture_compression_bptc"),
      pvrtcSupported: renderer.extensions.has("WEBGL_compressed_texture_pvrtc") || renderer.extensions.has("WEBKIT_WEBGL_compressed_texture_pvrtc")
    };
    if (renderer.capabilities.isWebGL2) {
      this.workerConfig.etc1Supported = false;
    }
    return this;
  }
  init() {
    if (!this.transcoderPending) {
      const jsLoader = new FileLoader(this.manager);
      jsLoader.setPath(this.transcoderPath);
      jsLoader.setWithCredentials(this.withCredentials);
      const jsContent = jsLoader.loadAsync("basis_transcoder.js");
      const binaryLoader = new FileLoader(this.manager);
      binaryLoader.setPath(this.transcoderPath);
      binaryLoader.setResponseType("arraybuffer");
      binaryLoader.setWithCredentials(this.withCredentials);
      const binaryContent = binaryLoader.loadAsync("basis_transcoder.wasm");
      this.transcoderPending = Promise.all([jsContent, binaryContent]).then(([jsContent2, binaryContent2]) => {
        const fn = _KTX2Loader.BasisWorker.toString();
        const body = [
          "/* constants */",
          "let _EngineFormat = " + JSON.stringify(_KTX2Loader.EngineFormat),
          "let _TranscoderFormat = " + JSON.stringify(_KTX2Loader.TranscoderFormat),
          "let _BasisFormat = " + JSON.stringify(_KTX2Loader.BasisFormat),
          "/* basis_transcoder.js */",
          jsContent2,
          "/* worker */",
          fn.substring(fn.indexOf("{") + 1, fn.lastIndexOf("}"))
        ].join("\n");
        this.workerSourceURL = URL.createObjectURL(new Blob([body]));
        this.transcoderBinary = binaryContent2;
        this.workerPool.setWorkerCreator(() => {
          const worker = new Worker(this.workerSourceURL);
          const transcoderBinary = this.transcoderBinary.slice(0);
          worker.postMessage({ type: "init", config: this.workerConfig, transcoderBinary }, [transcoderBinary]);
          return worker;
        });
      });
      if (_activeLoaders > 0) {
        console.warn(
          "THREE.KTX2Loader: Multiple active KTX2 loaders may cause performance issues. Use a single KTX2Loader instance, or call .dispose() on old instances."
        );
      }
      _activeLoaders++;
    }
    return this.transcoderPending;
  }
  load(url, onLoad, onProgress, onError) {
    if (this.workerConfig === null) {
      throw new Error("THREE.KTX2Loader: Missing initialization with `.detectSupport( renderer )`.");
    }
    const loader = new FileLoader(this.manager);
    loader.setResponseType("arraybuffer");
    loader.setWithCredentials(this.withCredentials);
    loader.load(
      url,
      (buffer) => {
        if (_taskCache.has(buffer)) {
          const cachedTask = _taskCache.get(buffer);
          return cachedTask.promise.then(onLoad).catch(onError);
        }
        this._createTexture(buffer).then((texture) => onLoad ? onLoad(texture) : null).catch(onError);
      },
      onProgress,
      onError
    );
  }
  _createTextureFrom(transcodeResult, container) {
    const { mipmaps, width, height, format, type, error, dfdTransferFn, dfdFlags } = transcodeResult;
    if (type === "error")
      return Promise.reject(error);
    const texture = container.layerCount > 1 ? new CompressedArrayTexture(mipmaps, width, height, container.layerCount, format, UnsignedByteType) : new CompressedTexture(mipmaps, width, height, format, UnsignedByteType);
    texture.minFilter = mipmaps.length === 1 ? LinearFilter : LinearMipmapLinearFilter;
    texture.magFilter = LinearFilter;
    texture.generateMipmaps = false;
    texture.needsUpdate = true;
    if ("colorSpace" in texture)
      texture.colorSpace = dfdTransferFn === KHR_DF_TRANSFER_SRGB ? "srgb" : "srgb-linear";
    else
      texture.encoding = dfdTransferFn === KHR_DF_TRANSFER_SRGB ? 3001 : 3e3;
    texture.premultiplyAlpha = !!(dfdFlags & KHR_DF_FLAG_ALPHA_PREMULTIPLIED);
    return texture;
  }
  /**
   * @param {ArrayBuffer} buffer
   * @param {object?} config
   * @return {Promise<CompressedTexture|CompressedArrayTexture|DataTexture|Data3DTexture>}
   */
  async _createTexture(buffer, config3 = {}) {
    const container = read(new Uint8Array(buffer));
    if (container.vkFormat !== VK_FORMAT_UNDEFINED) {
      return createDataTexture(container);
    }
    const taskConfig = config3;
    const texturePending = this.init().then(() => {
      return this.workerPool.postMessage({ type: "transcode", buffer, taskConfig }, [buffer]);
    }).then((e) => this._createTextureFrom(e.data, container));
    _taskCache.set(buffer, { promise: texturePending });
    return texturePending;
  }
  dispose() {
    this.workerPool.dispose();
    if (this.workerSourceURL)
      URL.revokeObjectURL(this.workerSourceURL);
    _activeLoaders--;
    return this;
  }
};
var KTX2Loader = _KTX2Loader;
__publicField23(KTX2Loader, "BasisFormat", {
  ETC1S: 0,
  UASTC_4x4: 1
});
__publicField23(KTX2Loader, "TranscoderFormat", {
  ETC1: 0,
  ETC2: 1,
  BC1: 2,
  BC3: 3,
  BC4: 4,
  BC5: 5,
  BC7_M6_OPAQUE_ONLY: 6,
  BC7_M5: 7,
  PVRTC1_4_RGB: 8,
  PVRTC1_4_RGBA: 9,
  ASTC_4x4: 10,
  ATC_RGB: 11,
  ATC_RGBA_INTERPOLATED_ALPHA: 12,
  RGBA32: 13,
  RGB565: 14,
  BGR565: 15,
  RGBA4444: 16
});
__publicField23(KTX2Loader, "EngineFormat", {
  RGBAFormat,
  RGBA_ASTC_4x4_Format,
  RGBA_BPTC_Format,
  RGBA_ETC2_EAC_Format,
  RGBA_PVRTC_4BPPV1_Format,
  RGBA_S3TC_DXT5_Format,
  RGB_ETC1_Format,
  RGB_ETC2_Format,
  RGB_PVRTC_4BPPV1_Format,
  RGB_S3TC_DXT1_Format
});
__publicField23(KTX2Loader, "BasisWorker", function() {
  let config3;
  let transcoderPending;
  let BasisModule;
  const EngineFormat = _EngineFormat;
  const TranscoderFormat = _TranscoderFormat;
  const BasisFormat = _BasisFormat;
  self.addEventListener("message", function(e) {
    const message = e.data;
    switch (message.type) {
      case "init":
        config3 = message.config;
        init5(message.transcoderBinary);
        break;
      case "transcode":
        transcoderPending.then(() => {
          try {
            const { width, height, hasAlpha, mipmaps, format, dfdTransferFn, dfdFlags } = transcode(message.buffer);
            const buffers = [];
            for (let i3 = 0; i3 < mipmaps.length; ++i3) {
              buffers.push(mipmaps[i3].data.buffer);
            }
            self.postMessage(
              {
                type: "transcode",
                id: message.id,
                width,
                height,
                hasAlpha,
                mipmaps,
                format,
                dfdTransferFn,
                dfdFlags
              },
              buffers
            );
          } catch (error) {
            console.error(error);
            self.postMessage({ type: "error", id: message.id, error: error.message });
          }
        });
        break;
    }
  });
  function init5(wasmBinary) {
    transcoderPending = new Promise((resolve) => {
      BasisModule = { wasmBinary, onRuntimeInitialized: resolve };
      BASIS(BasisModule);
    }).then(() => {
      BasisModule.initializeBasis();
      if (BasisModule.KTX2File === void 0) {
        console.warn("THREE.KTX2Loader: Please update Basis Universal transcoder.");
      }
    });
  }
  function transcode(buffer) {
    const ktx2File = new BasisModule.KTX2File(new Uint8Array(buffer));
    function cleanup() {
      ktx2File.close();
      ktx2File.delete();
    }
    if (!ktx2File.isValid()) {
      cleanup();
      throw new Error("THREE.KTX2Loader:	Invalid or unsupported .ktx2 file");
    }
    const basisFormat = ktx2File.isUASTC() ? BasisFormat.UASTC_4x4 : BasisFormat.ETC1S;
    const width = ktx2File.getWidth();
    const height = ktx2File.getHeight();
    const layers = ktx2File.getLayers() || 1;
    const levels = ktx2File.getLevels();
    const hasAlpha = ktx2File.getHasAlpha();
    const dfdTransferFn = ktx2File.getDFDTransferFunc();
    const dfdFlags = ktx2File.getDFDFlags();
    const { transcoderFormat, engineFormat } = getTranscoderFormat(basisFormat, width, height, hasAlpha);
    if (!width || !height || !levels) {
      cleanup();
      throw new Error("THREE.KTX2Loader:	Invalid texture");
    }
    if (!ktx2File.startTranscoding()) {
      cleanup();
      throw new Error("THREE.KTX2Loader: .startTranscoding failed");
    }
    const mipmaps = [];
    for (let mip = 0; mip < levels; mip++) {
      const layerMips = [];
      let mipWidth, mipHeight;
      for (let layer = 0; layer < layers; layer++) {
        const levelInfo = ktx2File.getImageLevelInfo(mip, layer, 0);
        mipWidth = levelInfo.origWidth < 4 ? levelInfo.origWidth : levelInfo.width;
        mipHeight = levelInfo.origHeight < 4 ? levelInfo.origHeight : levelInfo.height;
        const dst = new Uint8Array(ktx2File.getImageTranscodedSizeInBytes(mip, layer, 0, transcoderFormat));
        const status = ktx2File.transcodeImage(dst, mip, layer, 0, transcoderFormat, 0, -1, -1);
        if (!status) {
          cleanup();
          throw new Error("THREE.KTX2Loader: .transcodeImage failed.");
        }
        layerMips.push(dst);
      }
      mipmaps.push({ data: concat(layerMips), width: mipWidth, height: mipHeight });
    }
    cleanup();
    return { width, height, hasAlpha, mipmaps, format: engineFormat, dfdTransferFn, dfdFlags };
  }
  const FORMAT_OPTIONS = [
    {
      if: "astcSupported",
      basisFormat: [BasisFormat.UASTC_4x4],
      transcoderFormat: [TranscoderFormat.ASTC_4x4, TranscoderFormat.ASTC_4x4],
      engineFormat: [EngineFormat.RGBA_ASTC_4x4_Format, EngineFormat.RGBA_ASTC_4x4_Format],
      priorityETC1S: Infinity,
      priorityUASTC: 1,
      needsPowerOfTwo: false
    },
    {
      if: "bptcSupported",
      basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],
      transcoderFormat: [TranscoderFormat.BC7_M5, TranscoderFormat.BC7_M5],
      engineFormat: [EngineFormat.RGBA_BPTC_Format, EngineFormat.RGBA_BPTC_Format],
      priorityETC1S: 3,
      priorityUASTC: 2,
      needsPowerOfTwo: false
    },
    {
      if: "dxtSupported",
      basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],
      transcoderFormat: [TranscoderFormat.BC1, TranscoderFormat.BC3],
      engineFormat: [EngineFormat.RGB_S3TC_DXT1_Format, EngineFormat.RGBA_S3TC_DXT5_Format],
      priorityETC1S: 4,
      priorityUASTC: 5,
      needsPowerOfTwo: false
    },
    {
      if: "etc2Supported",
      basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],
      transcoderFormat: [TranscoderFormat.ETC1, TranscoderFormat.ETC2],
      engineFormat: [EngineFormat.RGB_ETC2_Format, EngineFormat.RGBA_ETC2_EAC_Format],
      priorityETC1S: 1,
      priorityUASTC: 3,
      needsPowerOfTwo: false
    },
    {
      if: "etc1Supported",
      basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],
      transcoderFormat: [TranscoderFormat.ETC1],
      engineFormat: [EngineFormat.RGB_ETC1_Format],
      priorityETC1S: 2,
      priorityUASTC: 4,
      needsPowerOfTwo: false
    },
    {
      if: "pvrtcSupported",
      basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],
      transcoderFormat: [TranscoderFormat.PVRTC1_4_RGB, TranscoderFormat.PVRTC1_4_RGBA],
      engineFormat: [EngineFormat.RGB_PVRTC_4BPPV1_Format, EngineFormat.RGBA_PVRTC_4BPPV1_Format],
      priorityETC1S: 5,
      priorityUASTC: 6,
      needsPowerOfTwo: true
    }
  ];
  const ETC1S_OPTIONS = FORMAT_OPTIONS.sort(function(a4, b5) {
    return a4.priorityETC1S - b5.priorityETC1S;
  });
  const UASTC_OPTIONS = FORMAT_OPTIONS.sort(function(a4, b5) {
    return a4.priorityUASTC - b5.priorityUASTC;
  });
  function getTranscoderFormat(basisFormat, width, height, hasAlpha) {
    let transcoderFormat;
    let engineFormat;
    const options = basisFormat === BasisFormat.ETC1S ? ETC1S_OPTIONS : UASTC_OPTIONS;
    for (let i3 = 0; i3 < options.length; i3++) {
      const opt = options[i3];
      if (!config3[opt.if])
        continue;
      if (!opt.basisFormat.includes(basisFormat))
        continue;
      if (hasAlpha && opt.transcoderFormat.length < 2)
        continue;
      if (opt.needsPowerOfTwo && !(isPowerOfTwo(width) && isPowerOfTwo(height)))
        continue;
      transcoderFormat = opt.transcoderFormat[hasAlpha ? 1 : 0];
      engineFormat = opt.engineFormat[hasAlpha ? 1 : 0];
      return { transcoderFormat, engineFormat };
    }
    console.warn("THREE.KTX2Loader: No suitable compressed texture format found. Decoding to RGBA32.");
    transcoderFormat = TranscoderFormat.RGBA32;
    engineFormat = EngineFormat.RGBAFormat;
    return { transcoderFormat, engineFormat };
  }
  function isPowerOfTwo(value) {
    if (value <= 2)
      return true;
    return (value & value - 1) === 0 && value !== 0;
  }
  function concat(arrays) {
    let totalByteLength = 0;
    for (let i3 = 0; i3 < arrays.length; i3++) {
      const array = arrays[i3];
      totalByteLength += array.byteLength;
    }
    const result = new Uint8Array(totalByteLength);
    let byteOffset = 0;
    for (let i3 = 0; i3 < arrays.length; i3++) {
      const array = arrays[i3];
      result.set(array, byteOffset);
      byteOffset += array.byteLength;
    }
    return result;
  }
});
var FORMAT_MAP = {
  [VK_FORMAT_R32G32B32A32_SFLOAT]: RGBAFormat,
  [VK_FORMAT_R16G16B16A16_SFLOAT]: RGBAFormat,
  [VK_FORMAT_R8G8B8A8_UNORM]: RGBAFormat,
  [VK_FORMAT_R8G8B8A8_SRGB]: RGBAFormat,
  [VK_FORMAT_R32G32_SFLOAT]: RGFormat,
  [VK_FORMAT_R16G16_SFLOAT]: RGFormat,
  [VK_FORMAT_R8G8_UNORM]: RGFormat,
  [VK_FORMAT_R8G8_SRGB]: RGFormat,
  [VK_FORMAT_R32_SFLOAT]: RedFormat,
  [VK_FORMAT_R16_SFLOAT]: RedFormat,
  [VK_FORMAT_R8_SRGB]: RedFormat,
  [VK_FORMAT_R8_UNORM]: RedFormat
};
var TYPE_MAP = {
  [VK_FORMAT_R32G32B32A32_SFLOAT]: FloatType,
  [VK_FORMAT_R16G16B16A16_SFLOAT]: HalfFloatType,
  [VK_FORMAT_R8G8B8A8_UNORM]: UnsignedByteType,
  [VK_FORMAT_R8G8B8A8_SRGB]: UnsignedByteType,
  [VK_FORMAT_R32G32_SFLOAT]: FloatType,
  [VK_FORMAT_R16G16_SFLOAT]: HalfFloatType,
  [VK_FORMAT_R8G8_UNORM]: UnsignedByteType,
  [VK_FORMAT_R8G8_SRGB]: UnsignedByteType,
  [VK_FORMAT_R32_SFLOAT]: FloatType,
  [VK_FORMAT_R16_SFLOAT]: HalfFloatType,
  [VK_FORMAT_R8_SRGB]: UnsignedByteType,
  [VK_FORMAT_R8_UNORM]: UnsignedByteType
};
var ENCODING_MAP = {
  [VK_FORMAT_R8G8B8A8_SRGB]: 3001,
  // sRGBEncoding
  [VK_FORMAT_R8G8_SRGB]: 3001,
  // sRGBEncoding
  [VK_FORMAT_R8_SRGB]: 3001
  // sRGBEncoding
};
async function createDataTexture(container) {
  const { vkFormat, pixelWidth, pixelHeight, pixelDepth } = container;
  if (FORMAT_MAP[vkFormat] === void 0) {
    throw new Error("THREE.KTX2Loader: Unsupported vkFormat.");
  }
  const level = container.levels[0];
  let levelData;
  let view;
  if (container.supercompressionScheme === KHR_SUPERCOMPRESSION_NONE) {
    levelData = level.levelData;
  } else if (container.supercompressionScheme === KHR_SUPERCOMPRESSION_ZSTD) {
    if (!_zstd) {
      _zstd = new Promise(async (resolve) => {
        const zstd = new Q();
        await zstd.init();
        resolve(zstd);
      });
    }
    levelData = (await _zstd).decode(level.levelData, level.uncompressedByteLength);
  } else {
    throw new Error("THREE.KTX2Loader: Unsupported supercompressionScheme.");
  }
  if (TYPE_MAP[vkFormat] === FloatType) {
    view = new Float32Array(
      levelData.buffer,
      levelData.byteOffset,
      levelData.byteLength / Float32Array.BYTES_PER_ELEMENT
    );
  } else if (TYPE_MAP[vkFormat] === HalfFloatType) {
    view = new Uint16Array(levelData.buffer, levelData.byteOffset, levelData.byteLength / Uint16Array.BYTES_PER_ELEMENT);
  } else {
    view = levelData;
  }
  const texture = pixelDepth === 0 ? new DataTexture(view, pixelWidth, pixelHeight) : new Data3DTexture(view, pixelWidth, pixelHeight, pixelDepth);
  texture.type = TYPE_MAP[vkFormat];
  texture.format = FORMAT_MAP[vkFormat];
  texture.encoding = ENCODING_MAP[vkFormat] || 3e3;
  texture.needsUpdate = true;
  return Promise.resolve(texture);
}

// node_modules/opentype.js/dist/opentype.module.js
if (!String.prototype.codePointAt) {
  (function() {
    var defineProperty = function() {
      try {
        var object = {};
        var $defineProperty = Object.defineProperty;
        var result = $defineProperty(object, object, object) && $defineProperty;
      } catch (error) {
      }
      return result;
    }();
    var codePointAt = function(position) {
      if (this == null) {
        throw TypeError();
      }
      var string = String(this);
      var size2 = string.length;
      var index = position ? Number(position) : 0;
      if (index != index) {
        index = 0;
      }
      if (index < 0 || index >= size2) {
        return void 0;
      }
      var first2 = string.charCodeAt(index);
      var second;
      if (
        // check if it’s the start of a surrogate pair
        first2 >= 55296 && first2 <= 56319 && // high surrogate
        size2 > index + 1
      ) {
        second = string.charCodeAt(index + 1);
        if (second >= 56320 && second <= 57343) {
          return (first2 - 55296) * 1024 + second - 56320 + 65536;
        }
      }
      return first2;
    };
    if (defineProperty) {
      defineProperty(String.prototype, "codePointAt", {
        "value": codePointAt,
        "configurable": true,
        "writable": true
      });
    } else {
      String.prototype.codePointAt = codePointAt;
    }
  })();
}
var TINF_OK = 0;
var TINF_DATA_ERROR = -3;
function Tree() {
  this.table = new Uint16Array(16);
  this.trans = new Uint16Array(288);
}
function Data(source, dest) {
  this.source = source;
  this.sourceIndex = 0;
  this.tag = 0;
  this.bitcount = 0;
  this.dest = dest;
  this.destLen = 0;
  this.ltree = new Tree();
  this.dtree = new Tree();
}
var sltree = new Tree();
var sdtree = new Tree();
var length_bits = new Uint8Array(30);
var length_base = new Uint16Array(30);
var dist_bits = new Uint8Array(30);
var dist_base = new Uint16Array(30);
var clcidx = new Uint8Array([
  16,
  17,
  18,
  0,
  8,
  7,
  9,
  6,
  10,
  5,
  11,
  4,
  12,
  3,
  13,
  2,
  14,
  1,
  15
]);
var code_tree = new Tree();
var lengths = new Uint8Array(288 + 32);
function tinf_build_bits_base(bits3, base, delta, first2) {
  var i3, sum;
  for (i3 = 0; i3 < delta; ++i3) {
    bits3[i3] = 0;
  }
  for (i3 = 0; i3 < 30 - delta; ++i3) {
    bits3[i3 + delta] = i3 / delta | 0;
  }
  for (sum = first2, i3 = 0; i3 < 30; ++i3) {
    base[i3] = sum;
    sum += 1 << bits3[i3];
  }
}
function tinf_build_fixed_trees(lt, dt) {
  var i3;
  for (i3 = 0; i3 < 7; ++i3) {
    lt.table[i3] = 0;
  }
  lt.table[7] = 24;
  lt.table[8] = 152;
  lt.table[9] = 112;
  for (i3 = 0; i3 < 24; ++i3) {
    lt.trans[i3] = 256 + i3;
  }
  for (i3 = 0; i3 < 144; ++i3) {
    lt.trans[24 + i3] = i3;
  }
  for (i3 = 0; i3 < 8; ++i3) {
    lt.trans[24 + 144 + i3] = 280 + i3;
  }
  for (i3 = 0; i3 < 112; ++i3) {
    lt.trans[24 + 144 + 8 + i3] = 144 + i3;
  }
  for (i3 = 0; i3 < 5; ++i3) {
    dt.table[i3] = 0;
  }
  dt.table[5] = 32;
  for (i3 = 0; i3 < 32; ++i3) {
    dt.trans[i3] = i3;
  }
}
var offs = new Uint16Array(16);
function tinf_build_tree(t2, lengths2, off, num) {
  var i3, sum;
  for (i3 = 0; i3 < 16; ++i3) {
    t2.table[i3] = 0;
  }
  for (i3 = 0; i3 < num; ++i3) {
    t2.table[lengths2[off + i3]]++;
  }
  t2.table[0] = 0;
  for (sum = 0, i3 = 0; i3 < 16; ++i3) {
    offs[i3] = sum;
    sum += t2.table[i3];
  }
  for (i3 = 0; i3 < num; ++i3) {
    if (lengths2[off + i3]) {
      t2.trans[offs[lengths2[off + i3]]++] = i3;
    }
  }
}
function tinf_getbit(d) {
  if (!d.bitcount--) {
    d.tag = d.source[d.sourceIndex++];
    d.bitcount = 7;
  }
  var bit = d.tag & 1;
  d.tag >>>= 1;
  return bit;
}
function tinf_read_bits(d, num, base) {
  if (!num) {
    return base;
  }
  while (d.bitcount < 24) {
    d.tag |= d.source[d.sourceIndex++] << d.bitcount;
    d.bitcount += 8;
  }
  var val = d.tag & 65535 >>> 16 - num;
  d.tag >>>= num;
  d.bitcount -= num;
  return val + base;
}
function tinf_decode_symbol(d, t2) {
  while (d.bitcount < 24) {
    d.tag |= d.source[d.sourceIndex++] << d.bitcount;
    d.bitcount += 8;
  }
  var sum = 0, cur = 0, len = 0;
  var tag = d.tag;
  do {
    cur = 2 * cur + (tag & 1);
    tag >>>= 1;
    ++len;
    sum += t2.table[len];
    cur -= t2.table[len];
  } while (cur >= 0);
  d.tag = tag;
  d.bitcount -= len;
  return t2.trans[sum + cur];
}
function tinf_decode_trees(d, lt, dt) {
  var hlit, hdist, hclen;
  var i3, num, length;
  hlit = tinf_read_bits(d, 5, 257);
  hdist = tinf_read_bits(d, 5, 1);
  hclen = tinf_read_bits(d, 4, 4);
  for (i3 = 0; i3 < 19; ++i3) {
    lengths[i3] = 0;
  }
  for (i3 = 0; i3 < hclen; ++i3) {
    var clen3 = tinf_read_bits(d, 3, 0);
    lengths[clcidx[i3]] = clen3;
  }
  tinf_build_tree(code_tree, lengths, 0, 19);
  for (num = 0; num < hlit + hdist; ) {
    var sym = tinf_decode_symbol(d, code_tree);
    switch (sym) {
      case 16:
        var prev = lengths[num - 1];
        for (length = tinf_read_bits(d, 2, 3); length; --length) {
          lengths[num++] = prev;
        }
        break;
      case 17:
        for (length = tinf_read_bits(d, 3, 3); length; --length) {
          lengths[num++] = 0;
        }
        break;
      case 18:
        for (length = tinf_read_bits(d, 7, 11); length; --length) {
          lengths[num++] = 0;
        }
        break;
      default:
        lengths[num++] = sym;
        break;
    }
  }
  tinf_build_tree(lt, lengths, 0, hlit);
  tinf_build_tree(dt, lengths, hlit, hdist);
}
function tinf_inflate_block_data(d, lt, dt) {
  while (1) {
    var sym = tinf_decode_symbol(d, lt);
    if (sym === 256) {
      return TINF_OK;
    }
    if (sym < 256) {
      d.dest[d.destLen++] = sym;
    } else {
      var length, dist, offs2;
      var i3;
      sym -= 257;
      length = tinf_read_bits(d, length_bits[sym], length_base[sym]);
      dist = tinf_decode_symbol(d, dt);
      offs2 = d.destLen - tinf_read_bits(d, dist_bits[dist], dist_base[dist]);
      for (i3 = offs2; i3 < offs2 + length; ++i3) {
        d.dest[d.destLen++] = d.dest[i3];
      }
    }
  }
}
function tinf_inflate_uncompressed_block(d) {
  var length, invlength;
  var i3;
  while (d.bitcount > 8) {
    d.sourceIndex--;
    d.bitcount -= 8;
  }
  length = d.source[d.sourceIndex + 1];
  length = 256 * length + d.source[d.sourceIndex];
  invlength = d.source[d.sourceIndex + 3];
  invlength = 256 * invlength + d.source[d.sourceIndex + 2];
  if (length !== (~invlength & 65535)) {
    return TINF_DATA_ERROR;
  }
  d.sourceIndex += 4;
  for (i3 = length; i3; --i3) {
    d.dest[d.destLen++] = d.source[d.sourceIndex++];
  }
  d.bitcount = 0;
  return TINF_OK;
}
function tinf_uncompress(source, dest) {
  var d = new Data(source, dest);
  var bfinal, btype, res;
  do {
    bfinal = tinf_getbit(d);
    btype = tinf_read_bits(d, 2, 0);
    switch (btype) {
      case 0:
        res = tinf_inflate_uncompressed_block(d);
        break;
      case 1:
        res = tinf_inflate_block_data(d, sltree, sdtree);
        break;
      case 2:
        tinf_decode_trees(d, d.ltree, d.dtree);
        res = tinf_inflate_block_data(d, d.ltree, d.dtree);
        break;
      default:
        res = TINF_DATA_ERROR;
    }
    if (res !== TINF_OK) {
      throw new Error("Data error");
    }
  } while (!bfinal);
  if (d.destLen < d.dest.length) {
    if (typeof d.dest.slice === "function") {
      return d.dest.slice(0, d.destLen);
    } else {
      return d.dest.subarray(0, d.destLen);
    }
  }
  return d.dest;
}
tinf_build_fixed_trees(sltree, sdtree);
tinf_build_bits_base(length_bits, length_base, 4, 3);
tinf_build_bits_base(dist_bits, dist_base, 2, 1);
length_bits[28] = 0;
length_base[28] = 258;
var tinyInflate = tinf_uncompress;
function derive(v02, v14, v23, v32, t2) {
  return Math.pow(1 - t2, 3) * v02 + 3 * Math.pow(1 - t2, 2) * t2 * v14 + 3 * (1 - t2) * Math.pow(t2, 2) * v23 + Math.pow(t2, 3) * v32;
}
function BoundingBox() {
  this.x1 = Number.NaN;
  this.y1 = Number.NaN;
  this.x2 = Number.NaN;
  this.y2 = Number.NaN;
}
BoundingBox.prototype.isEmpty = function() {
  return isNaN(this.x1) || isNaN(this.y1) || isNaN(this.x2) || isNaN(this.y2);
};
BoundingBox.prototype.addPoint = function(x, y) {
  if (typeof x === "number") {
    if (isNaN(this.x1) || isNaN(this.x2)) {
      this.x1 = x;
      this.x2 = x;
    }
    if (x < this.x1) {
      this.x1 = x;
    }
    if (x > this.x2) {
      this.x2 = x;
    }
  }
  if (typeof y === "number") {
    if (isNaN(this.y1) || isNaN(this.y2)) {
      this.y1 = y;
      this.y2 = y;
    }
    if (y < this.y1) {
      this.y1 = y;
    }
    if (y > this.y2) {
      this.y2 = y;
    }
  }
};
BoundingBox.prototype.addX = function(x) {
  this.addPoint(x, null);
};
BoundingBox.prototype.addY = function(y) {
  this.addPoint(null, y);
};
BoundingBox.prototype.addBezier = function(x0, y0, x1, y1, x2, y2, x, y) {
  var p0 = [x0, y0];
  var p1 = [x1, y1];
  var p2 = [x2, y2];
  var p3 = [x, y];
  this.addPoint(x0, y0);
  this.addPoint(x, y);
  for (var i3 = 0; i3 <= 1; i3++) {
    var b5 = 6 * p0[i3] - 12 * p1[i3] + 6 * p2[i3];
    var a4 = -3 * p0[i3] + 9 * p1[i3] - 9 * p2[i3] + 3 * p3[i3];
    var c3 = 3 * p1[i3] - 3 * p0[i3];
    if (a4 === 0) {
      if (b5 === 0) {
        continue;
      }
      var t2 = -c3 / b5;
      if (0 < t2 && t2 < 1) {
        if (i3 === 0) {
          this.addX(derive(p0[i3], p1[i3], p2[i3], p3[i3], t2));
        }
        if (i3 === 1) {
          this.addY(derive(p0[i3], p1[i3], p2[i3], p3[i3], t2));
        }
      }
      continue;
    }
    var b2ac = Math.pow(b5, 2) - 4 * c3 * a4;
    if (b2ac < 0) {
      continue;
    }
    var t1 = (-b5 + Math.sqrt(b2ac)) / (2 * a4);
    if (0 < t1 && t1 < 1) {
      if (i3 === 0) {
        this.addX(derive(p0[i3], p1[i3], p2[i3], p3[i3], t1));
      }
      if (i3 === 1) {
        this.addY(derive(p0[i3], p1[i3], p2[i3], p3[i3], t1));
      }
    }
    var t22 = (-b5 - Math.sqrt(b2ac)) / (2 * a4);
    if (0 < t22 && t22 < 1) {
      if (i3 === 0) {
        this.addX(derive(p0[i3], p1[i3], p2[i3], p3[i3], t22));
      }
      if (i3 === 1) {
        this.addY(derive(p0[i3], p1[i3], p2[i3], p3[i3], t22));
      }
    }
  }
};
BoundingBox.prototype.addQuad = function(x0, y0, x1, y1, x, y) {
  var cp1x = x0 + 2 / 3 * (x1 - x0);
  var cp1y = y0 + 2 / 3 * (y1 - y0);
  var cp2x = cp1x + 1 / 3 * (x - x0);
  var cp2y = cp1y + 1 / 3 * (y - y0);
  this.addBezier(x0, y0, cp1x, cp1y, cp2x, cp2y, x, y);
};
function Path2() {
  this.commands = [];
  this.fill = "black";
  this.stroke = null;
  this.strokeWidth = 1;
}
Path2.prototype.moveTo = function(x, y) {
  this.commands.push({
    type: "M",
    x,
    y
  });
};
Path2.prototype.lineTo = function(x, y) {
  this.commands.push({
    type: "L",
    x,
    y
  });
};
Path2.prototype.curveTo = Path2.prototype.bezierCurveTo = function(x1, y1, x2, y2, x, y) {
  this.commands.push({
    type: "C",
    x1,
    y1,
    x2,
    y2,
    x,
    y
  });
};
Path2.prototype.quadTo = Path2.prototype.quadraticCurveTo = function(x1, y1, x, y) {
  this.commands.push({
    type: "Q",
    x1,
    y1,
    x,
    y
  });
};
Path2.prototype.close = Path2.prototype.closePath = function() {
  this.commands.push({
    type: "Z"
  });
};
Path2.prototype.extend = function(pathOrCommands) {
  if (pathOrCommands.commands) {
    pathOrCommands = pathOrCommands.commands;
  } else if (pathOrCommands instanceof BoundingBox) {
    var box = pathOrCommands;
    this.moveTo(box.x1, box.y1);
    this.lineTo(box.x2, box.y1);
    this.lineTo(box.x2, box.y2);
    this.lineTo(box.x1, box.y2);
    this.close();
    return;
  }
  Array.prototype.push.apply(this.commands, pathOrCommands);
};
Path2.prototype.getBoundingBox = function() {
  var box = new BoundingBox();
  var startX = 0;
  var startY = 0;
  var prevX = 0;
  var prevY = 0;
  for (var i3 = 0; i3 < this.commands.length; i3++) {
    var cmd = this.commands[i3];
    switch (cmd.type) {
      case "M":
        box.addPoint(cmd.x, cmd.y);
        startX = prevX = cmd.x;
        startY = prevY = cmd.y;
        break;
      case "L":
        box.addPoint(cmd.x, cmd.y);
        prevX = cmd.x;
        prevY = cmd.y;
        break;
      case "Q":
        box.addQuad(prevX, prevY, cmd.x1, cmd.y1, cmd.x, cmd.y);
        prevX = cmd.x;
        prevY = cmd.y;
        break;
      case "C":
        box.addBezier(prevX, prevY, cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.x, cmd.y);
        prevX = cmd.x;
        prevY = cmd.y;
        break;
      case "Z":
        prevX = startX;
        prevY = startY;
        break;
      default:
        throw new Error("Unexpected path command " + cmd.type);
    }
  }
  if (box.isEmpty()) {
    box.addPoint(0, 0);
  }
  return box;
};
Path2.prototype.draw = function(ctx) {
  ctx.beginPath();
  for (var i3 = 0; i3 < this.commands.length; i3 += 1) {
    var cmd = this.commands[i3];
    if (cmd.type === "M") {
      ctx.moveTo(cmd.x, cmd.y);
    } else if (cmd.type === "L") {
      ctx.lineTo(cmd.x, cmd.y);
    } else if (cmd.type === "C") {
      ctx.bezierCurveTo(cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.x, cmd.y);
    } else if (cmd.type === "Q") {
      ctx.quadraticCurveTo(cmd.x1, cmd.y1, cmd.x, cmd.y);
    } else if (cmd.type === "Z") {
      ctx.closePath();
    }
  }
  if (this.fill) {
    ctx.fillStyle = this.fill;
    ctx.fill();
  }
  if (this.stroke) {
    ctx.strokeStyle = this.stroke;
    ctx.lineWidth = this.strokeWidth;
    ctx.stroke();
  }
};
Path2.prototype.toPathData = function(decimalPlaces) {
  decimalPlaces = decimalPlaces !== void 0 ? decimalPlaces : 2;
  function floatToString(v) {
    if (Math.round(v) === v) {
      return "" + Math.round(v);
    } else {
      return v.toFixed(decimalPlaces);
    }
  }
  function packValues() {
    var arguments$1 = arguments;
    var s = "";
    for (var i4 = 0; i4 < arguments.length; i4 += 1) {
      var v = arguments$1[i4];
      if (v >= 0 && i4 > 0) {
        s += " ";
      }
      s += floatToString(v);
    }
    return s;
  }
  var d = "";
  for (var i3 = 0; i3 < this.commands.length; i3 += 1) {
    var cmd = this.commands[i3];
    if (cmd.type === "M") {
      d += "M" + packValues(cmd.x, cmd.y);
    } else if (cmd.type === "L") {
      d += "L" + packValues(cmd.x, cmd.y);
    } else if (cmd.type === "C") {
      d += "C" + packValues(cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.x, cmd.y);
    } else if (cmd.type === "Q") {
      d += "Q" + packValues(cmd.x1, cmd.y1, cmd.x, cmd.y);
    } else if (cmd.type === "Z") {
      d += "Z";
    }
  }
  return d;
};
Path2.prototype.toSVG = function(decimalPlaces) {
  var svg = '<path d="';
  svg += this.toPathData(decimalPlaces);
  svg += '"';
  if (this.fill && this.fill !== "black") {
    if (this.fill === null) {
      svg += ' fill="none"';
    } else {
      svg += ' fill="' + this.fill + '"';
    }
  }
  if (this.stroke) {
    svg += ' stroke="' + this.stroke + '" stroke-width="' + this.strokeWidth + '"';
  }
  svg += "/>";
  return svg;
};
Path2.prototype.toDOMElement = function(decimalPlaces) {
  var temporaryPath = this.toPathData(decimalPlaces);
  var newPath = document.createElementNS("http://www.w3.org/2000/svg", "path");
  newPath.setAttribute("d", temporaryPath);
  return newPath;
};
function fail(message) {
  throw new Error(message);
}
function argument(predicate, message) {
  if (!predicate) {
    fail(message);
  }
}
var check = { fail, argument, assert: argument };
var LIMIT16 = 32768;
var LIMIT32 = 2147483648;
var decode = {};
var encode = {};
var sizeOf = {};
function constant(v) {
  return function() {
    return v;
  };
}
encode.BYTE = function(v) {
  check.argument(v >= 0 && v <= 255, "Byte value should be between 0 and 255.");
  return [v];
};
sizeOf.BYTE = constant(1);
encode.CHAR = function(v) {
  return [v.charCodeAt(0)];
};
sizeOf.CHAR = constant(1);
encode.CHARARRAY = function(v) {
  if (typeof v === "undefined") {
    v = "";
    console.warn("Undefined CHARARRAY encountered and treated as an empty string. This is probably caused by a missing glyph name.");
  }
  var b5 = [];
  for (var i3 = 0; i3 < v.length; i3 += 1) {
    b5[i3] = v.charCodeAt(i3);
  }
  return b5;
};
sizeOf.CHARARRAY = function(v) {
  if (typeof v === "undefined") {
    return 0;
  }
  return v.length;
};
encode.USHORT = function(v) {
  return [v >> 8 & 255, v & 255];
};
sizeOf.USHORT = constant(2);
encode.SHORT = function(v) {
  if (v >= LIMIT16) {
    v = -(2 * LIMIT16 - v);
  }
  return [v >> 8 & 255, v & 255];
};
sizeOf.SHORT = constant(2);
encode.UINT24 = function(v) {
  return [v >> 16 & 255, v >> 8 & 255, v & 255];
};
sizeOf.UINT24 = constant(3);
encode.ULONG = function(v) {
  return [v >> 24 & 255, v >> 16 & 255, v >> 8 & 255, v & 255];
};
sizeOf.ULONG = constant(4);
encode.LONG = function(v) {
  if (v >= LIMIT32) {
    v = -(2 * LIMIT32 - v);
  }
  return [v >> 24 & 255, v >> 16 & 255, v >> 8 & 255, v & 255];
};
sizeOf.LONG = constant(4);
encode.FIXED = encode.ULONG;
sizeOf.FIXED = sizeOf.ULONG;
encode.FWORD = encode.SHORT;
sizeOf.FWORD = sizeOf.SHORT;
encode.UFWORD = encode.USHORT;
sizeOf.UFWORD = sizeOf.USHORT;
encode.LONGDATETIME = function(v) {
  return [0, 0, 0, 0, v >> 24 & 255, v >> 16 & 255, v >> 8 & 255, v & 255];
};
sizeOf.LONGDATETIME = constant(8);
encode.TAG = function(v) {
  check.argument(v.length === 4, "Tag should be exactly 4 ASCII characters.");
  return [
    v.charCodeAt(0),
    v.charCodeAt(1),
    v.charCodeAt(2),
    v.charCodeAt(3)
  ];
};
sizeOf.TAG = constant(4);
encode.Card8 = encode.BYTE;
sizeOf.Card8 = sizeOf.BYTE;
encode.Card16 = encode.USHORT;
sizeOf.Card16 = sizeOf.USHORT;
encode.OffSize = encode.BYTE;
sizeOf.OffSize = sizeOf.BYTE;
encode.SID = encode.USHORT;
sizeOf.SID = sizeOf.USHORT;
encode.NUMBER = function(v) {
  if (v >= -107 && v <= 107) {
    return [v + 139];
  } else if (v >= 108 && v <= 1131) {
    v = v - 108;
    return [(v >> 8) + 247, v & 255];
  } else if (v >= -1131 && v <= -108) {
    v = -v - 108;
    return [(v >> 8) + 251, v & 255];
  } else if (v >= -32768 && v <= 32767) {
    return encode.NUMBER16(v);
  } else {
    return encode.NUMBER32(v);
  }
};
sizeOf.NUMBER = function(v) {
  return encode.NUMBER(v).length;
};
encode.NUMBER16 = function(v) {
  return [28, v >> 8 & 255, v & 255];
};
sizeOf.NUMBER16 = constant(3);
encode.NUMBER32 = function(v) {
  return [29, v >> 24 & 255, v >> 16 & 255, v >> 8 & 255, v & 255];
};
sizeOf.NUMBER32 = constant(5);
encode.REAL = function(v) {
  var value = v.toString();
  var m = /\.(\d*?)(?:9{5,20}|0{5,20})\d{0,2}(?:e(.+)|$)/.exec(value);
  if (m) {
    var epsilon2 = parseFloat("1e" + ((m[2] ? +m[2] : 0) + m[1].length));
    value = (Math.round(v * epsilon2) / epsilon2).toString();
  }
  var nibbles = "";
  for (var i3 = 0, ii = value.length; i3 < ii; i3 += 1) {
    var c3 = value[i3];
    if (c3 === "e") {
      nibbles += value[++i3] === "-" ? "c" : "b";
    } else if (c3 === ".") {
      nibbles += "a";
    } else if (c3 === "-") {
      nibbles += "e";
    } else {
      nibbles += c3;
    }
  }
  nibbles += nibbles.length & 1 ? "f" : "ff";
  var out = [30];
  for (var i$1 = 0, ii$1 = nibbles.length; i$1 < ii$1; i$1 += 2) {
    out.push(parseInt(nibbles.substr(i$1, 2), 16));
  }
  return out;
};
sizeOf.REAL = function(v) {
  return encode.REAL(v).length;
};
encode.NAME = encode.CHARARRAY;
sizeOf.NAME = sizeOf.CHARARRAY;
encode.STRING = encode.CHARARRAY;
sizeOf.STRING = sizeOf.CHARARRAY;
decode.UTF8 = function(data, offset, numBytes) {
  var codePoints = [];
  var numChars = numBytes;
  for (var j = 0; j < numChars; j++, offset += 1) {
    codePoints[j] = data.getUint8(offset);
  }
  return String.fromCharCode.apply(null, codePoints);
};
decode.UTF16 = function(data, offset, numBytes) {
  var codePoints = [];
  var numChars = numBytes / 2;
  for (var j = 0; j < numChars; j++, offset += 2) {
    codePoints[j] = data.getUint16(offset);
  }
  return String.fromCharCode.apply(null, codePoints);
};
encode.UTF16 = function(v) {
  var b5 = [];
  for (var i3 = 0; i3 < v.length; i3 += 1) {
    var codepoint = v.charCodeAt(i3);
    b5[b5.length] = codepoint >> 8 & 255;
    b5[b5.length] = codepoint & 255;
  }
  return b5;
};
sizeOf.UTF16 = function(v) {
  return v.length * 2;
};
var eightBitMacEncodings = {
  "x-mac-croatian": (
    // Python: 'mac_croatian'
    "ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®Š™´¨≠ŽØ∞±≤≥∆µ∂∑∏š∫ªºΩžø¿¡¬√ƒ≈Ć«Č… ÀÃÕŒœĐ—“”‘’÷◊©⁄€‹›Æ»–·‚„‰ÂćÁčÈÍÎÏÌÓÔđÒÚÛÙıˆ˜¯πË˚¸Êæˇ"
  ),
  "x-mac-cyrillic": (
    // Python: 'mac_cyrillic'
    "АБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ†°Ґ£§•¶І®©™Ђђ≠Ѓѓ∞±≤≥іµґЈЄєЇїЉљЊњјЅ¬√ƒ≈∆«»… ЋћЌќѕ–—“”‘’÷„ЎўЏџ№Ёёяабвгдежзийклмнопрстуфхцчшщъыьэю"
  ),
  "x-mac-gaelic": (
    // http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/GAELIC.TXT
    "ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ÆØḂ±≤≥ḃĊċḊḋḞḟĠġṀæøṁṖṗɼƒſṠ«»… ÀÃÕŒœ–—“”‘’ṡẛÿŸṪ€‹›Ŷŷṫ·Ỳỳ⁊ÂÊÁËÈÍÎÏÌÓÔ♣ÒÚÛÙıÝýŴŵẄẅẀẁẂẃ"
  ),
  "x-mac-greek": (
    // Python: 'mac_greek'
    "Ä¹²É³ÖÜ΅àâä΄¨çéèêë£™îï•½‰ôö¦€ùûü†ΓΔΘΛΞΠß®©ΣΪ§≠°·Α±≤≥¥ΒΕΖΗΙΚΜΦΫΨΩάΝ¬ΟΡ≈Τ«»… ΥΧΆΈœ–―“”‘’÷ΉΊΌΎέήίόΏύαβψδεφγηιξκλμνοπώρστθωςχυζϊϋΐΰ­"
  ),
  "x-mac-icelandic": (
    // Python: 'mac_iceland'
    "ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûüÝ°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄€ÐðÞþý·‚„‰ÂÊÁËÈÍÎÏÌÓÔÒÚÛÙıˆ˜¯˘˙˚¸˝˛ˇ"
  ),
  "x-mac-inuit": (
    // http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/INUIT.TXT
    "ᐃᐄᐅᐆᐊᐋᐱᐲᐳᐴᐸᐹᑉᑎᑏᑐᑑᑕᑖᑦᑭᑮᑯᑰᑲᑳᒃᒋᒌᒍᒎᒐᒑ°ᒡᒥᒦ•¶ᒧ®©™ᒨᒪᒫᒻᓂᓃᓄᓅᓇᓈᓐᓯᓰᓱᓲᓴᓵᔅᓕᓖᓗᓘᓚᓛᓪᔨᔩᔪᔫᔭ… ᔮᔾᕕᕖᕗ–—“”‘’ᕘᕙᕚᕝᕆᕇᕈᕉᕋᕌᕐᕿᖀᖁᖂᖃᖄᖅᖏᖐᖑᖒᖓᖔᖕᙱᙲᙳᙴᙵᙶᖖᖠᖡᖢᖣᖤᖥᖦᕼŁł"
  ),
  "x-mac-ce": (
    // Python: 'mac_latin2'
    "ÄĀāÉĄÖÜáąČäčĆćéŹźĎíďĒēĖóėôöõúĚěü†°Ę£§•¶ß®©™ę¨≠ģĮįĪ≤≥īĶ∂∑łĻļĽľĹĺŅņŃ¬√ńŇ∆«»… ňŐÕőŌ–—“”‘’÷◊ōŔŕŘ‹›řŖŗŠ‚„šŚśÁŤťÍŽžŪÓÔūŮÚůŰűŲųÝýķŻŁżĢˇ"
  ),
  macintosh: (
    // Python: 'mac_roman'
    "ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄€‹›ﬁﬂ‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔÒÚÛÙıˆ˜¯˘˙˚¸˝˛ˇ"
  ),
  "x-mac-romanian": (
    // Python: 'mac_romanian'
    "ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ĂȘ∞±≤≥¥µ∂∑∏π∫ªºΩăș¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄€‹›Țț‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔÒÚÛÙıˆ˜¯˘˙˚¸˝˛ˇ"
  ),
  "x-mac-turkish": (
    // Python: 'mac_turkish'
    "ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸĞğİıŞş‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔÒÚÛÙˆ˜¯˘˙˚¸˝˛ˇ"
  )
};
decode.MACSTRING = function(dataView, offset, dataLength, encoding) {
  var table2 = eightBitMacEncodings[encoding];
  if (table2 === void 0) {
    return void 0;
  }
  var result = "";
  for (var i3 = 0; i3 < dataLength; i3++) {
    var c3 = dataView.getUint8(offset + i3);
    if (c3 <= 127) {
      result += String.fromCharCode(c3);
    } else {
      result += table2[c3 & 127];
    }
  }
  return result;
};
var macEncodingTableCache = typeof WeakMap === "function" && /* @__PURE__ */ new WeakMap();
var macEncodingCacheKeys;
var getMacEncodingTable = function(encoding) {
  if (!macEncodingCacheKeys) {
    macEncodingCacheKeys = {};
    for (var e in eightBitMacEncodings) {
      macEncodingCacheKeys[e] = new String(e);
    }
  }
  var cacheKey = macEncodingCacheKeys[encoding];
  if (cacheKey === void 0) {
    return void 0;
  }
  if (macEncodingTableCache) {
    var cachedTable = macEncodingTableCache.get(cacheKey);
    if (cachedTable !== void 0) {
      return cachedTable;
    }
  }
  var decodingTable = eightBitMacEncodings[encoding];
  if (decodingTable === void 0) {
    return void 0;
  }
  var encodingTable = {};
  for (var i3 = 0; i3 < decodingTable.length; i3++) {
    encodingTable[decodingTable.charCodeAt(i3)] = i3 + 128;
  }
  if (macEncodingTableCache) {
    macEncodingTableCache.set(cacheKey, encodingTable);
  }
  return encodingTable;
};
encode.MACSTRING = function(str, encoding) {
  var table2 = getMacEncodingTable(encoding);
  if (table2 === void 0) {
    return void 0;
  }
  var result = [];
  for (var i3 = 0; i3 < str.length; i3++) {
    var c3 = str.charCodeAt(i3);
    if (c3 >= 128) {
      c3 = table2[c3];
      if (c3 === void 0) {
        return void 0;
      }
    }
    result[i3] = c3;
  }
  return result;
};
sizeOf.MACSTRING = function(str, encoding) {
  var b5 = encode.MACSTRING(str, encoding);
  if (b5 !== void 0) {
    return b5.length;
  } else {
    return 0;
  }
};
function isByteEncodable(value) {
  return value >= -128 && value <= 127;
}
function encodeVarDeltaRunAsZeroes(deltas, pos, result) {
  var runLength = 0;
  var numDeltas = deltas.length;
  while (pos < numDeltas && runLength < 64 && deltas[pos] === 0) {
    ++pos;
    ++runLength;
  }
  result.push(128 | runLength - 1);
  return pos;
}
function encodeVarDeltaRunAsBytes(deltas, offset, result) {
  var runLength = 0;
  var numDeltas = deltas.length;
  var pos = offset;
  while (pos < numDeltas && runLength < 64) {
    var value = deltas[pos];
    if (!isByteEncodable(value)) {
      break;
    }
    if (value === 0 && pos + 1 < numDeltas && deltas[pos + 1] === 0) {
      break;
    }
    ++pos;
    ++runLength;
  }
  result.push(runLength - 1);
  for (var i3 = offset; i3 < pos; ++i3) {
    result.push(deltas[i3] + 256 & 255);
  }
  return pos;
}
function encodeVarDeltaRunAsWords(deltas, offset, result) {
  var runLength = 0;
  var numDeltas = deltas.length;
  var pos = offset;
  while (pos < numDeltas && runLength < 64) {
    var value = deltas[pos];
    if (value === 0) {
      break;
    }
    if (isByteEncodable(value) && pos + 1 < numDeltas && isByteEncodable(deltas[pos + 1])) {
      break;
    }
    ++pos;
    ++runLength;
  }
  result.push(64 | runLength - 1);
  for (var i3 = offset; i3 < pos; ++i3) {
    var val = deltas[i3];
    result.push(val + 65536 >> 8 & 255, val + 256 & 255);
  }
  return pos;
}
encode.VARDELTAS = function(deltas) {
  var pos = 0;
  var result = [];
  while (pos < deltas.length) {
    var value = deltas[pos];
    if (value === 0) {
      pos = encodeVarDeltaRunAsZeroes(deltas, pos, result);
    } else if (value >= -128 && value <= 127) {
      pos = encodeVarDeltaRunAsBytes(deltas, pos, result);
    } else {
      pos = encodeVarDeltaRunAsWords(deltas, pos, result);
    }
  }
  return result;
};
encode.INDEX = function(l) {
  var offset = 1;
  var offsets = [offset];
  var data = [];
  for (var i3 = 0; i3 < l.length; i3 += 1) {
    var v = encode.OBJECT(l[i3]);
    Array.prototype.push.apply(data, v);
    offset += v.length;
    offsets.push(offset);
  }
  if (data.length === 0) {
    return [0, 0];
  }
  var encodedOffsets = [];
  var offSize = 1 + Math.floor(Math.log(offset) / Math.log(2)) / 8 | 0;
  var offsetEncoder = [void 0, encode.BYTE, encode.USHORT, encode.UINT24, encode.ULONG][offSize];
  for (var i$1 = 0; i$1 < offsets.length; i$1 += 1) {
    var encodedOffset = offsetEncoder(offsets[i$1]);
    Array.prototype.push.apply(encodedOffsets, encodedOffset);
  }
  return Array.prototype.concat(
    encode.Card16(l.length),
    encode.OffSize(offSize),
    encodedOffsets,
    data
  );
};
sizeOf.INDEX = function(v) {
  return encode.INDEX(v).length;
};
encode.DICT = function(m) {
  var d = [];
  var keys = Object.keys(m);
  var length = keys.length;
  for (var i3 = 0; i3 < length; i3 += 1) {
    var k = parseInt(keys[i3], 0);
    var v = m[k];
    d = d.concat(encode.OPERAND(v.value, v.type));
    d = d.concat(encode.OPERATOR(k));
  }
  return d;
};
sizeOf.DICT = function(m) {
  return encode.DICT(m).length;
};
encode.OPERATOR = function(v) {
  if (v < 1200) {
    return [v];
  } else {
    return [12, v - 1200];
  }
};
encode.OPERAND = function(v, type) {
  var d = [];
  if (Array.isArray(type)) {
    for (var i3 = 0; i3 < type.length; i3 += 1) {
      check.argument(v.length === type.length, "Not enough arguments given for type" + type);
      d = d.concat(encode.OPERAND(v[i3], type[i3]));
    }
  } else {
    if (type === "SID") {
      d = d.concat(encode.NUMBER(v));
    } else if (type === "offset") {
      d = d.concat(encode.NUMBER32(v));
    } else if (type === "number") {
      d = d.concat(encode.NUMBER(v));
    } else if (type === "real") {
      d = d.concat(encode.REAL(v));
    } else {
      throw new Error("Unknown operand type " + type);
    }
  }
  return d;
};
encode.OP = encode.BYTE;
sizeOf.OP = sizeOf.BYTE;
var wmm = typeof WeakMap === "function" && /* @__PURE__ */ new WeakMap();
encode.CHARSTRING = function(ops) {
  if (wmm) {
    var cachedValue = wmm.get(ops);
    if (cachedValue !== void 0) {
      return cachedValue;
    }
  }
  var d = [];
  var length = ops.length;
  for (var i3 = 0; i3 < length; i3 += 1) {
    var op = ops[i3];
    d = d.concat(encode[op.type](op.value));
  }
  if (wmm) {
    wmm.set(ops, d);
  }
  return d;
};
sizeOf.CHARSTRING = function(ops) {
  return encode.CHARSTRING(ops).length;
};
encode.OBJECT = function(v) {
  var encodingFunction = encode[v.type];
  check.argument(encodingFunction !== void 0, "No encoding function for type " + v.type);
  return encodingFunction(v.value);
};
sizeOf.OBJECT = function(v) {
  var sizeOfFunction = sizeOf[v.type];
  check.argument(sizeOfFunction !== void 0, "No sizeOf function for type " + v.type);
  return sizeOfFunction(v.value);
};
encode.TABLE = function(table2) {
  var d = [];
  var length = table2.fields.length;
  var subtables = [];
  var subtableOffsets = [];
  for (var i3 = 0; i3 < length; i3 += 1) {
    var field = table2.fields[i3];
    var encodingFunction = encode[field.type];
    check.argument(encodingFunction !== void 0, "No encoding function for field type " + field.type + " (" + field.name + ")");
    var value = table2[field.name];
    if (value === void 0) {
      value = field.value;
    }
    var bytes = encodingFunction(value);
    if (field.type === "TABLE") {
      subtableOffsets.push(d.length);
      d = d.concat([0, 0]);
      subtables.push(bytes);
    } else {
      d = d.concat(bytes);
    }
  }
  for (var i$1 = 0; i$1 < subtables.length; i$1 += 1) {
    var o = subtableOffsets[i$1];
    var offset = d.length;
    check.argument(offset < 65536, "Table " + table2.tableName + " too big.");
    d[o] = offset >> 8;
    d[o + 1] = offset & 255;
    d = d.concat(subtables[i$1]);
  }
  return d;
};
sizeOf.TABLE = function(table2) {
  var numBytes = 0;
  var length = table2.fields.length;
  for (var i3 = 0; i3 < length; i3 += 1) {
    var field = table2.fields[i3];
    var sizeOfFunction = sizeOf[field.type];
    check.argument(sizeOfFunction !== void 0, "No sizeOf function for field type " + field.type + " (" + field.name + ")");
    var value = table2[field.name];
    if (value === void 0) {
      value = field.value;
    }
    numBytes += sizeOfFunction(value);
    if (field.type === "TABLE") {
      numBytes += 2;
    }
  }
  return numBytes;
};
encode.RECORD = encode.TABLE;
sizeOf.RECORD = sizeOf.TABLE;
encode.LITERAL = function(v) {
  return v;
};
sizeOf.LITERAL = function(v) {
  return v.length;
};
function Table(tableName, fields, options) {
  if (fields.length && (fields[0].name !== "coverageFormat" || fields[0].value === 1)) {
    for (var i3 = 0; i3 < fields.length; i3 += 1) {
      var field = fields[i3];
      this[field.name] = field.value;
    }
  }
  this.tableName = tableName;
  this.fields = fields;
  if (options) {
    var optionKeys = Object.keys(options);
    for (var i$1 = 0; i$1 < optionKeys.length; i$1 += 1) {
      var k = optionKeys[i$1];
      var v = options[k];
      if (this[k] !== void 0) {
        this[k] = v;
      }
    }
  }
}
Table.prototype.encode = function() {
  return encode.TABLE(this);
};
Table.prototype.sizeOf = function() {
  return sizeOf.TABLE(this);
};
function ushortList(itemName, list, count) {
  if (count === void 0) {
    count = list.length;
  }
  var fields = new Array(list.length + 1);
  fields[0] = { name: itemName + "Count", type: "USHORT", value: count };
  for (var i3 = 0; i3 < list.length; i3++) {
    fields[i3 + 1] = { name: itemName + i3, type: "USHORT", value: list[i3] };
  }
  return fields;
}
function tableList(itemName, records, itemCallback) {
  var count = records.length;
  var fields = new Array(count + 1);
  fields[0] = { name: itemName + "Count", type: "USHORT", value: count };
  for (var i3 = 0; i3 < count; i3++) {
    fields[i3 + 1] = { name: itemName + i3, type: "TABLE", value: itemCallback(records[i3], i3) };
  }
  return fields;
}
function recordList(itemName, records, itemCallback) {
  var count = records.length;
  var fields = [];
  fields[0] = { name: itemName + "Count", type: "USHORT", value: count };
  for (var i3 = 0; i3 < count; i3++) {
    fields = fields.concat(itemCallback(records[i3], i3));
  }
  return fields;
}
function Coverage(coverageTable) {
  if (coverageTable.format === 1) {
    Table.call(
      this,
      "coverageTable",
      [{ name: "coverageFormat", type: "USHORT", value: 1 }].concat(ushortList("glyph", coverageTable.glyphs))
    );
  } else if (coverageTable.format === 2) {
    Table.call(
      this,
      "coverageTable",
      [{ name: "coverageFormat", type: "USHORT", value: 2 }].concat(recordList("rangeRecord", coverageTable.ranges, function(RangeRecord) {
        return [
          { name: "startGlyphID", type: "USHORT", value: RangeRecord.start },
          { name: "endGlyphID", type: "USHORT", value: RangeRecord.end },
          { name: "startCoverageIndex", type: "USHORT", value: RangeRecord.index }
        ];
      }))
    );
  } else {
    check.assert(false, "Coverage format must be 1 or 2.");
  }
}
Coverage.prototype = Object.create(Table.prototype);
Coverage.prototype.constructor = Coverage;
function ScriptList(scriptListTable) {
  Table.call(
    this,
    "scriptListTable",
    recordList("scriptRecord", scriptListTable, function(scriptRecord, i3) {
      var script = scriptRecord.script;
      var defaultLangSys = script.defaultLangSys;
      check.assert(!!defaultLangSys, "Unable to write GSUB: script " + scriptRecord.tag + " has no default language system.");
      return [
        { name: "scriptTag" + i3, type: "TAG", value: scriptRecord.tag },
        { name: "script" + i3, type: "TABLE", value: new Table("scriptTable", [
          { name: "defaultLangSys", type: "TABLE", value: new Table("defaultLangSys", [
            { name: "lookupOrder", type: "USHORT", value: 0 },
            { name: "reqFeatureIndex", type: "USHORT", value: defaultLangSys.reqFeatureIndex }
          ].concat(ushortList("featureIndex", defaultLangSys.featureIndexes))) }
        ].concat(recordList("langSys", script.langSysRecords, function(langSysRecord, i4) {
          var langSys = langSysRecord.langSys;
          return [
            { name: "langSysTag" + i4, type: "TAG", value: langSysRecord.tag },
            { name: "langSys" + i4, type: "TABLE", value: new Table("langSys", [
              { name: "lookupOrder", type: "USHORT", value: 0 },
              { name: "reqFeatureIndex", type: "USHORT", value: langSys.reqFeatureIndex }
            ].concat(ushortList("featureIndex", langSys.featureIndexes))) }
          ];
        }))) }
      ];
    })
  );
}
ScriptList.prototype = Object.create(Table.prototype);
ScriptList.prototype.constructor = ScriptList;
function FeatureList(featureListTable) {
  Table.call(
    this,
    "featureListTable",
    recordList("featureRecord", featureListTable, function(featureRecord, i3) {
      var feature = featureRecord.feature;
      return [
        { name: "featureTag" + i3, type: "TAG", value: featureRecord.tag },
        { name: "feature" + i3, type: "TABLE", value: new Table("featureTable", [
          { name: "featureParams", type: "USHORT", value: feature.featureParams }
        ].concat(ushortList("lookupListIndex", feature.lookupListIndexes))) }
      ];
    })
  );
}
FeatureList.prototype = Object.create(Table.prototype);
FeatureList.prototype.constructor = FeatureList;
function LookupList(lookupListTable, subtableMakers2) {
  Table.call(this, "lookupListTable", tableList("lookup", lookupListTable, function(lookupTable) {
    var subtableCallback = subtableMakers2[lookupTable.lookupType];
    check.assert(!!subtableCallback, "Unable to write GSUB lookup type " + lookupTable.lookupType + " tables.");
    return new Table("lookupTable", [
      { name: "lookupType", type: "USHORT", value: lookupTable.lookupType },
      { name: "lookupFlag", type: "USHORT", value: lookupTable.lookupFlag }
    ].concat(tableList("subtable", lookupTable.subtables, subtableCallback)));
  }));
}
LookupList.prototype = Object.create(Table.prototype);
LookupList.prototype.constructor = LookupList;
var table = {
  Table,
  Record: Table,
  Coverage,
  ScriptList,
  FeatureList,
  LookupList,
  ushortList,
  tableList,
  recordList
};
function getByte(dataView, offset) {
  return dataView.getUint8(offset);
}
function getUShort(dataView, offset) {
  return dataView.getUint16(offset, false);
}
function getShort(dataView, offset) {
  return dataView.getInt16(offset, false);
}
function getULong(dataView, offset) {
  return dataView.getUint32(offset, false);
}
function getFixed(dataView, offset) {
  var decimal = dataView.getInt16(offset, false);
  var fraction = dataView.getUint16(offset + 2, false);
  return decimal + fraction / 65535;
}
function getTag(dataView, offset) {
  var tag = "";
  for (var i3 = offset; i3 < offset + 4; i3 += 1) {
    tag += String.fromCharCode(dataView.getInt8(i3));
  }
  return tag;
}
function getOffset(dataView, offset, offSize) {
  var v = 0;
  for (var i3 = 0; i3 < offSize; i3 += 1) {
    v <<= 8;
    v += dataView.getUint8(offset + i3);
  }
  return v;
}
function getBytes(dataView, startOffset, endOffset) {
  var bytes = [];
  for (var i3 = startOffset; i3 < endOffset; i3 += 1) {
    bytes.push(dataView.getUint8(i3));
  }
  return bytes;
}
function bytesToString(bytes) {
  var s = "";
  for (var i3 = 0; i3 < bytes.length; i3 += 1) {
    s += String.fromCharCode(bytes[i3]);
  }
  return s;
}
var typeOffsets = {
  byte: 1,
  uShort: 2,
  short: 2,
  uLong: 4,
  fixed: 4,
  longDateTime: 8,
  tag: 4
};
function Parser3(data, offset) {
  this.data = data;
  this.offset = offset;
  this.relativeOffset = 0;
}
Parser3.prototype.parseByte = function() {
  var v = this.data.getUint8(this.offset + this.relativeOffset);
  this.relativeOffset += 1;
  return v;
};
Parser3.prototype.parseChar = function() {
  var v = this.data.getInt8(this.offset + this.relativeOffset);
  this.relativeOffset += 1;
  return v;
};
Parser3.prototype.parseCard8 = Parser3.prototype.parseByte;
Parser3.prototype.parseUShort = function() {
  var v = this.data.getUint16(this.offset + this.relativeOffset);
  this.relativeOffset += 2;
  return v;
};
Parser3.prototype.parseCard16 = Parser3.prototype.parseUShort;
Parser3.prototype.parseSID = Parser3.prototype.parseUShort;
Parser3.prototype.parseOffset16 = Parser3.prototype.parseUShort;
Parser3.prototype.parseShort = function() {
  var v = this.data.getInt16(this.offset + this.relativeOffset);
  this.relativeOffset += 2;
  return v;
};
Parser3.prototype.parseF2Dot14 = function() {
  var v = this.data.getInt16(this.offset + this.relativeOffset) / 16384;
  this.relativeOffset += 2;
  return v;
};
Parser3.prototype.parseULong = function() {
  var v = getULong(this.data, this.offset + this.relativeOffset);
  this.relativeOffset += 4;
  return v;
};
Parser3.prototype.parseOffset32 = Parser3.prototype.parseULong;
Parser3.prototype.parseFixed = function() {
  var v = getFixed(this.data, this.offset + this.relativeOffset);
  this.relativeOffset += 4;
  return v;
};
Parser3.prototype.parseString = function(length) {
  var dataView = this.data;
  var offset = this.offset + this.relativeOffset;
  var string = "";
  this.relativeOffset += length;
  for (var i3 = 0; i3 < length; i3++) {
    string += String.fromCharCode(dataView.getUint8(offset + i3));
  }
  return string;
};
Parser3.prototype.parseTag = function() {
  return this.parseString(4);
};
Parser3.prototype.parseLongDateTime = function() {
  var v = getULong(this.data, this.offset + this.relativeOffset + 4);
  v -= 2082844800;
  this.relativeOffset += 8;
  return v;
};
Parser3.prototype.parseVersion = function(minorBase) {
  var major = getUShort(this.data, this.offset + this.relativeOffset);
  var minor = getUShort(this.data, this.offset + this.relativeOffset + 2);
  this.relativeOffset += 4;
  if (minorBase === void 0) {
    minorBase = 4096;
  }
  return major + minor / minorBase / 10;
};
Parser3.prototype.skip = function(type, amount) {
  if (amount === void 0) {
    amount = 1;
  }
  this.relativeOffset += typeOffsets[type] * amount;
};
Parser3.prototype.parseULongList = function(count) {
  if (count === void 0) {
    count = this.parseULong();
  }
  var offsets = new Array(count);
  var dataView = this.data;
  var offset = this.offset + this.relativeOffset;
  for (var i3 = 0; i3 < count; i3++) {
    offsets[i3] = dataView.getUint32(offset);
    offset += 4;
  }
  this.relativeOffset += count * 4;
  return offsets;
};
Parser3.prototype.parseOffset16List = Parser3.prototype.parseUShortList = function(count) {
  if (count === void 0) {
    count = this.parseUShort();
  }
  var offsets = new Array(count);
  var dataView = this.data;
  var offset = this.offset + this.relativeOffset;
  for (var i3 = 0; i3 < count; i3++) {
    offsets[i3] = dataView.getUint16(offset);
    offset += 2;
  }
  this.relativeOffset += count * 2;
  return offsets;
};
Parser3.prototype.parseShortList = function(count) {
  var list = new Array(count);
  var dataView = this.data;
  var offset = this.offset + this.relativeOffset;
  for (var i3 = 0; i3 < count; i3++) {
    list[i3] = dataView.getInt16(offset);
    offset += 2;
  }
  this.relativeOffset += count * 2;
  return list;
};
Parser3.prototype.parseByteList = function(count) {
  var list = new Array(count);
  var dataView = this.data;
  var offset = this.offset + this.relativeOffset;
  for (var i3 = 0; i3 < count; i3++) {
    list[i3] = dataView.getUint8(offset++);
  }
  this.relativeOffset += count;
  return list;
};
Parser3.prototype.parseList = function(count, itemCallback) {
  if (!itemCallback) {
    itemCallback = count;
    count = this.parseUShort();
  }
  var list = new Array(count);
  for (var i3 = 0; i3 < count; i3++) {
    list[i3] = itemCallback.call(this);
  }
  return list;
};
Parser3.prototype.parseList32 = function(count, itemCallback) {
  if (!itemCallback) {
    itemCallback = count;
    count = this.parseULong();
  }
  var list = new Array(count);
  for (var i3 = 0; i3 < count; i3++) {
    list[i3] = itemCallback.call(this);
  }
  return list;
};
Parser3.prototype.parseRecordList = function(count, recordDescription) {
  if (!recordDescription) {
    recordDescription = count;
    count = this.parseUShort();
  }
  var records = new Array(count);
  var fields = Object.keys(recordDescription);
  for (var i3 = 0; i3 < count; i3++) {
    var rec = {};
    for (var j = 0; j < fields.length; j++) {
      var fieldName = fields[j];
      var fieldType = recordDescription[fieldName];
      rec[fieldName] = fieldType.call(this);
    }
    records[i3] = rec;
  }
  return records;
};
Parser3.prototype.parseRecordList32 = function(count, recordDescription) {
  if (!recordDescription) {
    recordDescription = count;
    count = this.parseULong();
  }
  var records = new Array(count);
  var fields = Object.keys(recordDescription);
  for (var i3 = 0; i3 < count; i3++) {
    var rec = {};
    for (var j = 0; j < fields.length; j++) {
      var fieldName = fields[j];
      var fieldType = recordDescription[fieldName];
      rec[fieldName] = fieldType.call(this);
    }
    records[i3] = rec;
  }
  return records;
};
Parser3.prototype.parseStruct = function(description) {
  if (typeof description === "function") {
    return description.call(this);
  } else {
    var fields = Object.keys(description);
    var struct = {};
    for (var j = 0; j < fields.length; j++) {
      var fieldName = fields[j];
      var fieldType = description[fieldName];
      struct[fieldName] = fieldType.call(this);
    }
    return struct;
  }
};
Parser3.prototype.parseValueRecord = function(valueFormat) {
  if (valueFormat === void 0) {
    valueFormat = this.parseUShort();
  }
  if (valueFormat === 0) {
    return;
  }
  var valueRecord = {};
  if (valueFormat & 1) {
    valueRecord.xPlacement = this.parseShort();
  }
  if (valueFormat & 2) {
    valueRecord.yPlacement = this.parseShort();
  }
  if (valueFormat & 4) {
    valueRecord.xAdvance = this.parseShort();
  }
  if (valueFormat & 8) {
    valueRecord.yAdvance = this.parseShort();
  }
  if (valueFormat & 16) {
    valueRecord.xPlaDevice = void 0;
    this.parseShort();
  }
  if (valueFormat & 32) {
    valueRecord.yPlaDevice = void 0;
    this.parseShort();
  }
  if (valueFormat & 64) {
    valueRecord.xAdvDevice = void 0;
    this.parseShort();
  }
  if (valueFormat & 128) {
    valueRecord.yAdvDevice = void 0;
    this.parseShort();
  }
  return valueRecord;
};
Parser3.prototype.parseValueRecordList = function() {
  var valueFormat = this.parseUShort();
  var valueCount = this.parseUShort();
  var values = new Array(valueCount);
  for (var i3 = 0; i3 < valueCount; i3++) {
    values[i3] = this.parseValueRecord(valueFormat);
  }
  return values;
};
Parser3.prototype.parsePointer = function(description) {
  var structOffset = this.parseOffset16();
  if (structOffset > 0) {
    return new Parser3(this.data, this.offset + structOffset).parseStruct(description);
  }
  return void 0;
};
Parser3.prototype.parsePointer32 = function(description) {
  var structOffset = this.parseOffset32();
  if (structOffset > 0) {
    return new Parser3(this.data, this.offset + structOffset).parseStruct(description);
  }
  return void 0;
};
Parser3.prototype.parseListOfLists = function(itemCallback) {
  var offsets = this.parseOffset16List();
  var count = offsets.length;
  var relativeOffset = this.relativeOffset;
  var list = new Array(count);
  for (var i3 = 0; i3 < count; i3++) {
    var start = offsets[i3];
    if (start === 0) {
      list[i3] = void 0;
      continue;
    }
    this.relativeOffset = start;
    if (itemCallback) {
      var subOffsets = this.parseOffset16List();
      var subList = new Array(subOffsets.length);
      for (var j = 0; j < subOffsets.length; j++) {
        this.relativeOffset = start + subOffsets[j];
        subList[j] = itemCallback.call(this);
      }
      list[i3] = subList;
    } else {
      list[i3] = this.parseUShortList();
    }
  }
  this.relativeOffset = relativeOffset;
  return list;
};
Parser3.prototype.parseCoverage = function() {
  var startOffset = this.offset + this.relativeOffset;
  var format = this.parseUShort();
  var count = this.parseUShort();
  if (format === 1) {
    return {
      format: 1,
      glyphs: this.parseUShortList(count)
    };
  } else if (format === 2) {
    var ranges = new Array(count);
    for (var i3 = 0; i3 < count; i3++) {
      ranges[i3] = {
        start: this.parseUShort(),
        end: this.parseUShort(),
        index: this.parseUShort()
      };
    }
    return {
      format: 2,
      ranges
    };
  }
  throw new Error("0x" + startOffset.toString(16) + ": Coverage format must be 1 or 2.");
};
Parser3.prototype.parseClassDef = function() {
  var startOffset = this.offset + this.relativeOffset;
  var format = this.parseUShort();
  if (format === 1) {
    return {
      format: 1,
      startGlyph: this.parseUShort(),
      classes: this.parseUShortList()
    };
  } else if (format === 2) {
    return {
      format: 2,
      ranges: this.parseRecordList({
        start: Parser3.uShort,
        end: Parser3.uShort,
        classId: Parser3.uShort
      })
    };
  }
  throw new Error("0x" + startOffset.toString(16) + ": ClassDef format must be 1 or 2.");
};
Parser3.list = function(count, itemCallback) {
  return function() {
    return this.parseList(count, itemCallback);
  };
};
Parser3.list32 = function(count, itemCallback) {
  return function() {
    return this.parseList32(count, itemCallback);
  };
};
Parser3.recordList = function(count, recordDescription) {
  return function() {
    return this.parseRecordList(count, recordDescription);
  };
};
Parser3.recordList32 = function(count, recordDescription) {
  return function() {
    return this.parseRecordList32(count, recordDescription);
  };
};
Parser3.pointer = function(description) {
  return function() {
    return this.parsePointer(description);
  };
};
Parser3.pointer32 = function(description) {
  return function() {
    return this.parsePointer32(description);
  };
};
Parser3.tag = Parser3.prototype.parseTag;
Parser3.byte = Parser3.prototype.parseByte;
Parser3.uShort = Parser3.offset16 = Parser3.prototype.parseUShort;
Parser3.uShortList = Parser3.prototype.parseUShortList;
Parser3.uLong = Parser3.offset32 = Parser3.prototype.parseULong;
Parser3.uLongList = Parser3.prototype.parseULongList;
Parser3.struct = Parser3.prototype.parseStruct;
Parser3.coverage = Parser3.prototype.parseCoverage;
Parser3.classDef = Parser3.prototype.parseClassDef;
var langSysTable = {
  reserved: Parser3.uShort,
  reqFeatureIndex: Parser3.uShort,
  featureIndexes: Parser3.uShortList
};
Parser3.prototype.parseScriptList = function() {
  return this.parsePointer(Parser3.recordList({
    tag: Parser3.tag,
    script: Parser3.pointer({
      defaultLangSys: Parser3.pointer(langSysTable),
      langSysRecords: Parser3.recordList({
        tag: Parser3.tag,
        langSys: Parser3.pointer(langSysTable)
      })
    })
  })) || [];
};
Parser3.prototype.parseFeatureList = function() {
  return this.parsePointer(Parser3.recordList({
    tag: Parser3.tag,
    feature: Parser3.pointer({
      featureParams: Parser3.offset16,
      lookupListIndexes: Parser3.uShortList
    })
  })) || [];
};
Parser3.prototype.parseLookupList = function(lookupTableParsers) {
  return this.parsePointer(Parser3.list(Parser3.pointer(function() {
    var lookupType = this.parseUShort();
    check.argument(1 <= lookupType && lookupType <= 9, "GPOS/GSUB lookup type " + lookupType + " unknown.");
    var lookupFlag = this.parseUShort();
    var useMarkFilteringSet = lookupFlag & 16;
    return {
      lookupType,
      lookupFlag,
      subtables: this.parseList(Parser3.pointer(lookupTableParsers[lookupType])),
      markFilteringSet: useMarkFilteringSet ? this.parseUShort() : void 0
    };
  }))) || [];
};
Parser3.prototype.parseFeatureVariationsList = function() {
  return this.parsePointer32(function() {
    var majorVersion = this.parseUShort();
    var minorVersion = this.parseUShort();
    check.argument(majorVersion === 1 && minorVersion < 1, "GPOS/GSUB feature variations table unknown.");
    var featureVariations = this.parseRecordList32({
      conditionSetOffset: Parser3.offset32,
      featureTableSubstitutionOffset: Parser3.offset32
    });
    return featureVariations;
  }) || [];
};
var parse = {
  getByte,
  getCard8: getByte,
  getUShort,
  getCard16: getUShort,
  getShort,
  getULong,
  getFixed,
  getTag,
  getOffset,
  getBytes,
  bytesToString,
  Parser: Parser3
};
function parseCmapTableFormat12(cmap2, p) {
  p.parseUShort();
  cmap2.length = p.parseULong();
  cmap2.language = p.parseULong();
  var groupCount;
  cmap2.groupCount = groupCount = p.parseULong();
  cmap2.glyphIndexMap = {};
  for (var i3 = 0; i3 < groupCount; i3 += 1) {
    var startCharCode = p.parseULong();
    var endCharCode = p.parseULong();
    var startGlyphId = p.parseULong();
    for (var c3 = startCharCode; c3 <= endCharCode; c3 += 1) {
      cmap2.glyphIndexMap[c3] = startGlyphId;
      startGlyphId++;
    }
  }
}
function parseCmapTableFormat4(cmap2, p, data, start, offset) {
  cmap2.length = p.parseUShort();
  cmap2.language = p.parseUShort();
  var segCount;
  cmap2.segCount = segCount = p.parseUShort() >> 1;
  p.skip("uShort", 3);
  cmap2.glyphIndexMap = {};
  var endCountParser = new parse.Parser(data, start + offset + 14);
  var startCountParser = new parse.Parser(data, start + offset + 16 + segCount * 2);
  var idDeltaParser = new parse.Parser(data, start + offset + 16 + segCount * 4);
  var idRangeOffsetParser = new parse.Parser(data, start + offset + 16 + segCount * 6);
  var glyphIndexOffset = start + offset + 16 + segCount * 8;
  for (var i3 = 0; i3 < segCount - 1; i3 += 1) {
    var glyphIndex = void 0;
    var endCount = endCountParser.parseUShort();
    var startCount = startCountParser.parseUShort();
    var idDelta = idDeltaParser.parseShort();
    var idRangeOffset = idRangeOffsetParser.parseUShort();
    for (var c3 = startCount; c3 <= endCount; c3 += 1) {
      if (idRangeOffset !== 0) {
        glyphIndexOffset = idRangeOffsetParser.offset + idRangeOffsetParser.relativeOffset - 2;
        glyphIndexOffset += idRangeOffset;
        glyphIndexOffset += (c3 - startCount) * 2;
        glyphIndex = parse.getUShort(data, glyphIndexOffset);
        if (glyphIndex !== 0) {
          glyphIndex = glyphIndex + idDelta & 65535;
        }
      } else {
        glyphIndex = c3 + idDelta & 65535;
      }
      cmap2.glyphIndexMap[c3] = glyphIndex;
    }
  }
}
function parseCmapTable(data, start) {
  var cmap2 = {};
  cmap2.version = parse.getUShort(data, start);
  check.argument(cmap2.version === 0, "cmap table version should be 0.");
  cmap2.numTables = parse.getUShort(data, start + 2);
  var offset = -1;
  for (var i3 = cmap2.numTables - 1; i3 >= 0; i3 -= 1) {
    var platformId = parse.getUShort(data, start + 4 + i3 * 8);
    var encodingId = parse.getUShort(data, start + 4 + i3 * 8 + 2);
    if (platformId === 3 && (encodingId === 0 || encodingId === 1 || encodingId === 10) || platformId === 0 && (encodingId === 0 || encodingId === 1 || encodingId === 2 || encodingId === 3 || encodingId === 4)) {
      offset = parse.getULong(data, start + 4 + i3 * 8 + 4);
      break;
    }
  }
  if (offset === -1) {
    throw new Error("No valid cmap sub-tables found.");
  }
  var p = new parse.Parser(data, start + offset);
  cmap2.format = p.parseUShort();
  if (cmap2.format === 12) {
    parseCmapTableFormat12(cmap2, p);
  } else if (cmap2.format === 4) {
    parseCmapTableFormat4(cmap2, p, data, start, offset);
  } else {
    throw new Error("Only format 4 and 12 cmap tables are supported (found format " + cmap2.format + ").");
  }
  return cmap2;
}
function addSegment(t2, code, glyphIndex) {
  t2.segments.push({
    end: code,
    start: code,
    delta: -(code - glyphIndex),
    offset: 0,
    glyphIndex
  });
}
function addTerminatorSegment(t2) {
  t2.segments.push({
    end: 65535,
    start: 65535,
    delta: 1,
    offset: 0
  });
}
function makeCmapTable(glyphs) {
  var isPlan0Only = true;
  var i3;
  for (i3 = glyphs.length - 1; i3 > 0; i3 -= 1) {
    var g2 = glyphs.get(i3);
    if (g2.unicode > 65535) {
      console.log("Adding CMAP format 12 (needed!)");
      isPlan0Only = false;
      break;
    }
  }
  var cmapTable = [
    { name: "version", type: "USHORT", value: 0 },
    { name: "numTables", type: "USHORT", value: isPlan0Only ? 1 : 2 },
    // CMAP 4 header
    { name: "platformID", type: "USHORT", value: 3 },
    { name: "encodingID", type: "USHORT", value: 1 },
    { name: "offset", type: "ULONG", value: isPlan0Only ? 12 : 12 + 8 }
  ];
  if (!isPlan0Only) {
    cmapTable = cmapTable.concat([
      // CMAP 12 header
      { name: "cmap12PlatformID", type: "USHORT", value: 3 },
      // We encode only for PlatformID = 3 (Windows) because it is supported everywhere
      { name: "cmap12EncodingID", type: "USHORT", value: 10 },
      { name: "cmap12Offset", type: "ULONG", value: 0 }
    ]);
  }
  cmapTable = cmapTable.concat([
    // CMAP 4 Subtable
    { name: "format", type: "USHORT", value: 4 },
    { name: "cmap4Length", type: "USHORT", value: 0 },
    { name: "language", type: "USHORT", value: 0 },
    { name: "segCountX2", type: "USHORT", value: 0 },
    { name: "searchRange", type: "USHORT", value: 0 },
    { name: "entrySelector", type: "USHORT", value: 0 },
    { name: "rangeShift", type: "USHORT", value: 0 }
  ]);
  var t2 = new table.Table("cmap", cmapTable);
  t2.segments = [];
  for (i3 = 0; i3 < glyphs.length; i3 += 1) {
    var glyph = glyphs.get(i3);
    for (var j = 0; j < glyph.unicodes.length; j += 1) {
      addSegment(t2, glyph.unicodes[j], i3);
    }
    t2.segments = t2.segments.sort(function(a4, b5) {
      return a4.start - b5.start;
    });
  }
  addTerminatorSegment(t2);
  var segCount = t2.segments.length;
  var segCountToRemove = 0;
  var endCounts = [];
  var startCounts = [];
  var idDeltas = [];
  var idRangeOffsets = [];
  var glyphIds = [];
  var cmap12Groups = [];
  for (i3 = 0; i3 < segCount; i3 += 1) {
    var segment = t2.segments[i3];
    if (segment.end <= 65535 && segment.start <= 65535) {
      endCounts = endCounts.concat({ name: "end_" + i3, type: "USHORT", value: segment.end });
      startCounts = startCounts.concat({ name: "start_" + i3, type: "USHORT", value: segment.start });
      idDeltas = idDeltas.concat({ name: "idDelta_" + i3, type: "SHORT", value: segment.delta });
      idRangeOffsets = idRangeOffsets.concat({ name: "idRangeOffset_" + i3, type: "USHORT", value: segment.offset });
      if (segment.glyphId !== void 0) {
        glyphIds = glyphIds.concat({ name: "glyph_" + i3, type: "USHORT", value: segment.glyphId });
      }
    } else {
      segCountToRemove += 1;
    }
    if (!isPlan0Only && segment.glyphIndex !== void 0) {
      cmap12Groups = cmap12Groups.concat({ name: "cmap12Start_" + i3, type: "ULONG", value: segment.start });
      cmap12Groups = cmap12Groups.concat({ name: "cmap12End_" + i3, type: "ULONG", value: segment.end });
      cmap12Groups = cmap12Groups.concat({ name: "cmap12Glyph_" + i3, type: "ULONG", value: segment.glyphIndex });
    }
  }
  t2.segCountX2 = (segCount - segCountToRemove) * 2;
  t2.searchRange = Math.pow(2, Math.floor(Math.log(segCount - segCountToRemove) / Math.log(2))) * 2;
  t2.entrySelector = Math.log(t2.searchRange / 2) / Math.log(2);
  t2.rangeShift = t2.segCountX2 - t2.searchRange;
  t2.fields = t2.fields.concat(endCounts);
  t2.fields.push({ name: "reservedPad", type: "USHORT", value: 0 });
  t2.fields = t2.fields.concat(startCounts);
  t2.fields = t2.fields.concat(idDeltas);
  t2.fields = t2.fields.concat(idRangeOffsets);
  t2.fields = t2.fields.concat(glyphIds);
  t2.cmap4Length = 14 + // Subtable header
  endCounts.length * 2 + 2 + // reservedPad
  startCounts.length * 2 + idDeltas.length * 2 + idRangeOffsets.length * 2 + glyphIds.length * 2;
  if (!isPlan0Only) {
    var cmap12Length = 16 + // Subtable header
    cmap12Groups.length * 4;
    t2.cmap12Offset = 12 + 2 * 2 + 4 + t2.cmap4Length;
    t2.fields = t2.fields.concat([
      { name: "cmap12Format", type: "USHORT", value: 12 },
      { name: "cmap12Reserved", type: "USHORT", value: 0 },
      { name: "cmap12Length", type: "ULONG", value: cmap12Length },
      { name: "cmap12Language", type: "ULONG", value: 0 },
      { name: "cmap12nGroups", type: "ULONG", value: cmap12Groups.length / 3 }
    ]);
    t2.fields = t2.fields.concat(cmap12Groups);
  }
  return t2;
}
var cmap = { parse: parseCmapTable, make: makeCmapTable };
var cffStandardStrings = [
  ".notdef",
  "space",
  "exclam",
  "quotedbl",
  "numbersign",
  "dollar",
  "percent",
  "ampersand",
  "quoteright",
  "parenleft",
  "parenright",
  "asterisk",
  "plus",
  "comma",
  "hyphen",
  "period",
  "slash",
  "zero",
  "one",
  "two",
  "three",
  "four",
  "five",
  "six",
  "seven",
  "eight",
  "nine",
  "colon",
  "semicolon",
  "less",
  "equal",
  "greater",
  "question",
  "at",
  "A",
  "B",
  "C",
  "D",
  "E",
  "F",
  "G",
  "H",
  "I",
  "J",
  "K",
  "L",
  "M",
  "N",
  "O",
  "P",
  "Q",
  "R",
  "S",
  "T",
  "U",
  "V",
  "W",
  "X",
  "Y",
  "Z",
  "bracketleft",
  "backslash",
  "bracketright",
  "asciicircum",
  "underscore",
  "quoteleft",
  "a",
  "b",
  "c",
  "d",
  "e",
  "f",
  "g",
  "h",
  "i",
  "j",
  "k",
  "l",
  "m",
  "n",
  "o",
  "p",
  "q",
  "r",
  "s",
  "t",
  "u",
  "v",
  "w",
  "x",
  "y",
  "z",
  "braceleft",
  "bar",
  "braceright",
  "asciitilde",
  "exclamdown",
  "cent",
  "sterling",
  "fraction",
  "yen",
  "florin",
  "section",
  "currency",
  "quotesingle",
  "quotedblleft",
  "guillemotleft",
  "guilsinglleft",
  "guilsinglright",
  "fi",
  "fl",
  "endash",
  "dagger",
  "daggerdbl",
  "periodcentered",
  "paragraph",
  "bullet",
  "quotesinglbase",
  "quotedblbase",
  "quotedblright",
  "guillemotright",
  "ellipsis",
  "perthousand",
  "questiondown",
  "grave",
  "acute",
  "circumflex",
  "tilde",
  "macron",
  "breve",
  "dotaccent",
  "dieresis",
  "ring",
  "cedilla",
  "hungarumlaut",
  "ogonek",
  "caron",
  "emdash",
  "AE",
  "ordfeminine",
  "Lslash",
  "Oslash",
  "OE",
  "ordmasculine",
  "ae",
  "dotlessi",
  "lslash",
  "oslash",
  "oe",
  "germandbls",
  "onesuperior",
  "logicalnot",
  "mu",
  "trademark",
  "Eth",
  "onehalf",
  "plusminus",
  "Thorn",
  "onequarter",
  "divide",
  "brokenbar",
  "degree",
  "thorn",
  "threequarters",
  "twosuperior",
  "registered",
  "minus",
  "eth",
  "multiply",
  "threesuperior",
  "copyright",
  "Aacute",
  "Acircumflex",
  "Adieresis",
  "Agrave",
  "Aring",
  "Atilde",
  "Ccedilla",
  "Eacute",
  "Ecircumflex",
  "Edieresis",
  "Egrave",
  "Iacute",
  "Icircumflex",
  "Idieresis",
  "Igrave",
  "Ntilde",
  "Oacute",
  "Ocircumflex",
  "Odieresis",
  "Ograve",
  "Otilde",
  "Scaron",
  "Uacute",
  "Ucircumflex",
  "Udieresis",
  "Ugrave",
  "Yacute",
  "Ydieresis",
  "Zcaron",
  "aacute",
  "acircumflex",
  "adieresis",
  "agrave",
  "aring",
  "atilde",
  "ccedilla",
  "eacute",
  "ecircumflex",
  "edieresis",
  "egrave",
  "iacute",
  "icircumflex",
  "idieresis",
  "igrave",
  "ntilde",
  "oacute",
  "ocircumflex",
  "odieresis",
  "ograve",
  "otilde",
  "scaron",
  "uacute",
  "ucircumflex",
  "udieresis",
  "ugrave",
  "yacute",
  "ydieresis",
  "zcaron",
  "exclamsmall",
  "Hungarumlautsmall",
  "dollaroldstyle",
  "dollarsuperior",
  "ampersandsmall",
  "Acutesmall",
  "parenleftsuperior",
  "parenrightsuperior",
  "266 ff",
  "onedotenleader",
  "zerooldstyle",
  "oneoldstyle",
  "twooldstyle",
  "threeoldstyle",
  "fouroldstyle",
  "fiveoldstyle",
  "sixoldstyle",
  "sevenoldstyle",
  "eightoldstyle",
  "nineoldstyle",
  "commasuperior",
  "threequartersemdash",
  "periodsuperior",
  "questionsmall",
  "asuperior",
  "bsuperior",
  "centsuperior",
  "dsuperior",
  "esuperior",
  "isuperior",
  "lsuperior",
  "msuperior",
  "nsuperior",
  "osuperior",
  "rsuperior",
  "ssuperior",
  "tsuperior",
  "ff",
  "ffi",
  "ffl",
  "parenleftinferior",
  "parenrightinferior",
  "Circumflexsmall",
  "hyphensuperior",
  "Gravesmall",
  "Asmall",
  "Bsmall",
  "Csmall",
  "Dsmall",
  "Esmall",
  "Fsmall",
  "Gsmall",
  "Hsmall",
  "Ismall",
  "Jsmall",
  "Ksmall",
  "Lsmall",
  "Msmall",
  "Nsmall",
  "Osmall",
  "Psmall",
  "Qsmall",
  "Rsmall",
  "Ssmall",
  "Tsmall",
  "Usmall",
  "Vsmall",
  "Wsmall",
  "Xsmall",
  "Ysmall",
  "Zsmall",
  "colonmonetary",
  "onefitted",
  "rupiah",
  "Tildesmall",
  "exclamdownsmall",
  "centoldstyle",
  "Lslashsmall",
  "Scaronsmall",
  "Zcaronsmall",
  "Dieresissmall",
  "Brevesmall",
  "Caronsmall",
  "Dotaccentsmall",
  "Macronsmall",
  "figuredash",
  "hypheninferior",
  "Ogoneksmall",
  "Ringsmall",
  "Cedillasmall",
  "questiondownsmall",
  "oneeighth",
  "threeeighths",
  "fiveeighths",
  "seveneighths",
  "onethird",
  "twothirds",
  "zerosuperior",
  "foursuperior",
  "fivesuperior",
  "sixsuperior",
  "sevensuperior",
  "eightsuperior",
  "ninesuperior",
  "zeroinferior",
  "oneinferior",
  "twoinferior",
  "threeinferior",
  "fourinferior",
  "fiveinferior",
  "sixinferior",
  "seveninferior",
  "eightinferior",
  "nineinferior",
  "centinferior",
  "dollarinferior",
  "periodinferior",
  "commainferior",
  "Agravesmall",
  "Aacutesmall",
  "Acircumflexsmall",
  "Atildesmall",
  "Adieresissmall",
  "Aringsmall",
  "AEsmall",
  "Ccedillasmall",
  "Egravesmall",
  "Eacutesmall",
  "Ecircumflexsmall",
  "Edieresissmall",
  "Igravesmall",
  "Iacutesmall",
  "Icircumflexsmall",
  "Idieresissmall",
  "Ethsmall",
  "Ntildesmall",
  "Ogravesmall",
  "Oacutesmall",
  "Ocircumflexsmall",
  "Otildesmall",
  "Odieresissmall",
  "OEsmall",
  "Oslashsmall",
  "Ugravesmall",
  "Uacutesmall",
  "Ucircumflexsmall",
  "Udieresissmall",
  "Yacutesmall",
  "Thornsmall",
  "Ydieresissmall",
  "001.000",
  "001.001",
  "001.002",
  "001.003",
  "Black",
  "Bold",
  "Book",
  "Light",
  "Medium",
  "Regular",
  "Roman",
  "Semibold"
];
var cffStandardEncoding = [
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "space",
  "exclam",
  "quotedbl",
  "numbersign",
  "dollar",
  "percent",
  "ampersand",
  "quoteright",
  "parenleft",
  "parenright",
  "asterisk",
  "plus",
  "comma",
  "hyphen",
  "period",
  "slash",
  "zero",
  "one",
  "two",
  "three",
  "four",
  "five",
  "six",
  "seven",
  "eight",
  "nine",
  "colon",
  "semicolon",
  "less",
  "equal",
  "greater",
  "question",
  "at",
  "A",
  "B",
  "C",
  "D",
  "E",
  "F",
  "G",
  "H",
  "I",
  "J",
  "K",
  "L",
  "M",
  "N",
  "O",
  "P",
  "Q",
  "R",
  "S",
  "T",
  "U",
  "V",
  "W",
  "X",
  "Y",
  "Z",
  "bracketleft",
  "backslash",
  "bracketright",
  "asciicircum",
  "underscore",
  "quoteleft",
  "a",
  "b",
  "c",
  "d",
  "e",
  "f",
  "g",
  "h",
  "i",
  "j",
  "k",
  "l",
  "m",
  "n",
  "o",
  "p",
  "q",
  "r",
  "s",
  "t",
  "u",
  "v",
  "w",
  "x",
  "y",
  "z",
  "braceleft",
  "bar",
  "braceright",
  "asciitilde",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "exclamdown",
  "cent",
  "sterling",
  "fraction",
  "yen",
  "florin",
  "section",
  "currency",
  "quotesingle",
  "quotedblleft",
  "guillemotleft",
  "guilsinglleft",
  "guilsinglright",
  "fi",
  "fl",
  "",
  "endash",
  "dagger",
  "daggerdbl",
  "periodcentered",
  "",
  "paragraph",
  "bullet",
  "quotesinglbase",
  "quotedblbase",
  "quotedblright",
  "guillemotright",
  "ellipsis",
  "perthousand",
  "",
  "questiondown",
  "",
  "grave",
  "acute",
  "circumflex",
  "tilde",
  "macron",
  "breve",
  "dotaccent",
  "dieresis",
  "",
  "ring",
  "cedilla",
  "",
  "hungarumlaut",
  "ogonek",
  "caron",
  "emdash",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "AE",
  "",
  "ordfeminine",
  "",
  "",
  "",
  "",
  "Lslash",
  "Oslash",
  "OE",
  "ordmasculine",
  "",
  "",
  "",
  "",
  "",
  "ae",
  "",
  "",
  "",
  "dotlessi",
  "",
  "",
  "lslash",
  "oslash",
  "oe",
  "germandbls"
];
var cffExpertEncoding = [
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "space",
  "exclamsmall",
  "Hungarumlautsmall",
  "",
  "dollaroldstyle",
  "dollarsuperior",
  "ampersandsmall",
  "Acutesmall",
  "parenleftsuperior",
  "parenrightsuperior",
  "twodotenleader",
  "onedotenleader",
  "comma",
  "hyphen",
  "period",
  "fraction",
  "zerooldstyle",
  "oneoldstyle",
  "twooldstyle",
  "threeoldstyle",
  "fouroldstyle",
  "fiveoldstyle",
  "sixoldstyle",
  "sevenoldstyle",
  "eightoldstyle",
  "nineoldstyle",
  "colon",
  "semicolon",
  "commasuperior",
  "threequartersemdash",
  "periodsuperior",
  "questionsmall",
  "",
  "asuperior",
  "bsuperior",
  "centsuperior",
  "dsuperior",
  "esuperior",
  "",
  "",
  "isuperior",
  "",
  "",
  "lsuperior",
  "msuperior",
  "nsuperior",
  "osuperior",
  "",
  "",
  "rsuperior",
  "ssuperior",
  "tsuperior",
  "",
  "ff",
  "fi",
  "fl",
  "ffi",
  "ffl",
  "parenleftinferior",
  "",
  "parenrightinferior",
  "Circumflexsmall",
  "hyphensuperior",
  "Gravesmall",
  "Asmall",
  "Bsmall",
  "Csmall",
  "Dsmall",
  "Esmall",
  "Fsmall",
  "Gsmall",
  "Hsmall",
  "Ismall",
  "Jsmall",
  "Ksmall",
  "Lsmall",
  "Msmall",
  "Nsmall",
  "Osmall",
  "Psmall",
  "Qsmall",
  "Rsmall",
  "Ssmall",
  "Tsmall",
  "Usmall",
  "Vsmall",
  "Wsmall",
  "Xsmall",
  "Ysmall",
  "Zsmall",
  "colonmonetary",
  "onefitted",
  "rupiah",
  "Tildesmall",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "exclamdownsmall",
  "centoldstyle",
  "Lslashsmall",
  "",
  "",
  "Scaronsmall",
  "Zcaronsmall",
  "Dieresissmall",
  "Brevesmall",
  "Caronsmall",
  "",
  "Dotaccentsmall",
  "",
  "",
  "Macronsmall",
  "",
  "",
  "figuredash",
  "hypheninferior",
  "",
  "",
  "Ogoneksmall",
  "Ringsmall",
  "Cedillasmall",
  "",
  "",
  "",
  "onequarter",
  "onehalf",
  "threequarters",
  "questiondownsmall",
  "oneeighth",
  "threeeighths",
  "fiveeighths",
  "seveneighths",
  "onethird",
  "twothirds",
  "",
  "",
  "zerosuperior",
  "onesuperior",
  "twosuperior",
  "threesuperior",
  "foursuperior",
  "fivesuperior",
  "sixsuperior",
  "sevensuperior",
  "eightsuperior",
  "ninesuperior",
  "zeroinferior",
  "oneinferior",
  "twoinferior",
  "threeinferior",
  "fourinferior",
  "fiveinferior",
  "sixinferior",
  "seveninferior",
  "eightinferior",
  "nineinferior",
  "centinferior",
  "dollarinferior",
  "periodinferior",
  "commainferior",
  "Agravesmall",
  "Aacutesmall",
  "Acircumflexsmall",
  "Atildesmall",
  "Adieresissmall",
  "Aringsmall",
  "AEsmall",
  "Ccedillasmall",
  "Egravesmall",
  "Eacutesmall",
  "Ecircumflexsmall",
  "Edieresissmall",
  "Igravesmall",
  "Iacutesmall",
  "Icircumflexsmall",
  "Idieresissmall",
  "Ethsmall",
  "Ntildesmall",
  "Ogravesmall",
  "Oacutesmall",
  "Ocircumflexsmall",
  "Otildesmall",
  "Odieresissmall",
  "OEsmall",
  "Oslashsmall",
  "Ugravesmall",
  "Uacutesmall",
  "Ucircumflexsmall",
  "Udieresissmall",
  "Yacutesmall",
  "Thornsmall",
  "Ydieresissmall"
];
var standardNames = [
  ".notdef",
  ".null",
  "nonmarkingreturn",
  "space",
  "exclam",
  "quotedbl",
  "numbersign",
  "dollar",
  "percent",
  "ampersand",
  "quotesingle",
  "parenleft",
  "parenright",
  "asterisk",
  "plus",
  "comma",
  "hyphen",
  "period",
  "slash",
  "zero",
  "one",
  "two",
  "three",
  "four",
  "five",
  "six",
  "seven",
  "eight",
  "nine",
  "colon",
  "semicolon",
  "less",
  "equal",
  "greater",
  "question",
  "at",
  "A",
  "B",
  "C",
  "D",
  "E",
  "F",
  "G",
  "H",
  "I",
  "J",
  "K",
  "L",
  "M",
  "N",
  "O",
  "P",
  "Q",
  "R",
  "S",
  "T",
  "U",
  "V",
  "W",
  "X",
  "Y",
  "Z",
  "bracketleft",
  "backslash",
  "bracketright",
  "asciicircum",
  "underscore",
  "grave",
  "a",
  "b",
  "c",
  "d",
  "e",
  "f",
  "g",
  "h",
  "i",
  "j",
  "k",
  "l",
  "m",
  "n",
  "o",
  "p",
  "q",
  "r",
  "s",
  "t",
  "u",
  "v",
  "w",
  "x",
  "y",
  "z",
  "braceleft",
  "bar",
  "braceright",
  "asciitilde",
  "Adieresis",
  "Aring",
  "Ccedilla",
  "Eacute",
  "Ntilde",
  "Odieresis",
  "Udieresis",
  "aacute",
  "agrave",
  "acircumflex",
  "adieresis",
  "atilde",
  "aring",
  "ccedilla",
  "eacute",
  "egrave",
  "ecircumflex",
  "edieresis",
  "iacute",
  "igrave",
  "icircumflex",
  "idieresis",
  "ntilde",
  "oacute",
  "ograve",
  "ocircumflex",
  "odieresis",
  "otilde",
  "uacute",
  "ugrave",
  "ucircumflex",
  "udieresis",
  "dagger",
  "degree",
  "cent",
  "sterling",
  "section",
  "bullet",
  "paragraph",
  "germandbls",
  "registered",
  "copyright",
  "trademark",
  "acute",
  "dieresis",
  "notequal",
  "AE",
  "Oslash",
  "infinity",
  "plusminus",
  "lessequal",
  "greaterequal",
  "yen",
  "mu",
  "partialdiff",
  "summation",
  "product",
  "pi",
  "integral",
  "ordfeminine",
  "ordmasculine",
  "Omega",
  "ae",
  "oslash",
  "questiondown",
  "exclamdown",
  "logicalnot",
  "radical",
  "florin",
  "approxequal",
  "Delta",
  "guillemotleft",
  "guillemotright",
  "ellipsis",
  "nonbreakingspace",
  "Agrave",
  "Atilde",
  "Otilde",
  "OE",
  "oe",
  "endash",
  "emdash",
  "quotedblleft",
  "quotedblright",
  "quoteleft",
  "quoteright",
  "divide",
  "lozenge",
  "ydieresis",
  "Ydieresis",
  "fraction",
  "currency",
  "guilsinglleft",
  "guilsinglright",
  "fi",
  "fl",
  "daggerdbl",
  "periodcentered",
  "quotesinglbase",
  "quotedblbase",
  "perthousand",
  "Acircumflex",
  "Ecircumflex",
  "Aacute",
  "Edieresis",
  "Egrave",
  "Iacute",
  "Icircumflex",
  "Idieresis",
  "Igrave",
  "Oacute",
  "Ocircumflex",
  "apple",
  "Ograve",
  "Uacute",
  "Ucircumflex",
  "Ugrave",
  "dotlessi",
  "circumflex",
  "tilde",
  "macron",
  "breve",
  "dotaccent",
  "ring",
  "cedilla",
  "hungarumlaut",
  "ogonek",
  "caron",
  "Lslash",
  "lslash",
  "Scaron",
  "scaron",
  "Zcaron",
  "zcaron",
  "brokenbar",
  "Eth",
  "eth",
  "Yacute",
  "yacute",
  "Thorn",
  "thorn",
  "minus",
  "multiply",
  "onesuperior",
  "twosuperior",
  "threesuperior",
  "onehalf",
  "onequarter",
  "threequarters",
  "franc",
  "Gbreve",
  "gbreve",
  "Idotaccent",
  "Scedilla",
  "scedilla",
  "Cacute",
  "cacute",
  "Ccaron",
  "ccaron",
  "dcroat"
];
function DefaultEncoding(font) {
  this.font = font;
}
DefaultEncoding.prototype.charToGlyphIndex = function(c3) {
  var code = c3.codePointAt(0);
  var glyphs = this.font.glyphs;
  if (glyphs) {
    for (var i3 = 0; i3 < glyphs.length; i3 += 1) {
      var glyph = glyphs.get(i3);
      for (var j = 0; j < glyph.unicodes.length; j += 1) {
        if (glyph.unicodes[j] === code) {
          return i3;
        }
      }
    }
  }
  return null;
};
function CmapEncoding(cmap2) {
  this.cmap = cmap2;
}
CmapEncoding.prototype.charToGlyphIndex = function(c3) {
  return this.cmap.glyphIndexMap[c3.codePointAt(0)] || 0;
};
function CffEncoding(encoding, charset) {
  this.encoding = encoding;
  this.charset = charset;
}
CffEncoding.prototype.charToGlyphIndex = function(s) {
  var code = s.codePointAt(0);
  var charName = this.encoding[code];
  return this.charset.indexOf(charName);
};
function GlyphNames(post2) {
  switch (post2.version) {
    case 1:
      this.names = standardNames.slice();
      break;
    case 2:
      this.names = new Array(post2.numberOfGlyphs);
      for (var i3 = 0; i3 < post2.numberOfGlyphs; i3++) {
        if (post2.glyphNameIndex[i3] < standardNames.length) {
          this.names[i3] = standardNames[post2.glyphNameIndex[i3]];
        } else {
          this.names[i3] = post2.names[post2.glyphNameIndex[i3] - standardNames.length];
        }
      }
      break;
    case 2.5:
      this.names = new Array(post2.numberOfGlyphs);
      for (var i$1 = 0; i$1 < post2.numberOfGlyphs; i$1++) {
        this.names[i$1] = standardNames[i$1 + post2.glyphNameIndex[i$1]];
      }
      break;
    case 3:
      this.names = [];
      break;
    default:
      this.names = [];
      break;
  }
}
GlyphNames.prototype.nameToGlyphIndex = function(name) {
  return this.names.indexOf(name);
};
GlyphNames.prototype.glyphIndexToName = function(gid) {
  return this.names[gid];
};
function addGlyphNamesAll(font) {
  var glyph;
  var glyphIndexMap = font.tables.cmap.glyphIndexMap;
  var charCodes = Object.keys(glyphIndexMap);
  for (var i3 = 0; i3 < charCodes.length; i3 += 1) {
    var c3 = charCodes[i3];
    var glyphIndex = glyphIndexMap[c3];
    glyph = font.glyphs.get(glyphIndex);
    glyph.addUnicode(parseInt(c3));
  }
  for (var i$1 = 0; i$1 < font.glyphs.length; i$1 += 1) {
    glyph = font.glyphs.get(i$1);
    if (font.cffEncoding) {
      if (font.isCIDFont) {
        glyph.name = "gid" + i$1;
      } else {
        glyph.name = font.cffEncoding.charset[i$1];
      }
    } else if (font.glyphNames.names) {
      glyph.name = font.glyphNames.glyphIndexToName(i$1);
    }
  }
}
function addGlyphNamesToUnicodeMap(font) {
  font._IndexToUnicodeMap = {};
  var glyphIndexMap = font.tables.cmap.glyphIndexMap;
  var charCodes = Object.keys(glyphIndexMap);
  for (var i3 = 0; i3 < charCodes.length; i3 += 1) {
    var c3 = charCodes[i3];
    var glyphIndex = glyphIndexMap[c3];
    if (font._IndexToUnicodeMap[glyphIndex] === void 0) {
      font._IndexToUnicodeMap[glyphIndex] = {
        unicodes: [parseInt(c3)]
      };
    } else {
      font._IndexToUnicodeMap[glyphIndex].unicodes.push(parseInt(c3));
    }
  }
}
function addGlyphNames(font, opt) {
  if (opt.lowMemory) {
    addGlyphNamesToUnicodeMap(font);
  } else {
    addGlyphNamesAll(font);
  }
}
function line(ctx, x1, y1, x2, y2) {
  ctx.beginPath();
  ctx.moveTo(x1, y1);
  ctx.lineTo(x2, y2);
  ctx.stroke();
}
var draw = { line };
function getPathDefinition(glyph, path) {
  var _path = path || new Path2();
  return {
    configurable: true,
    get: function() {
      if (typeof _path === "function") {
        _path = _path();
      }
      return _path;
    },
    set: function(p) {
      _path = p;
    }
  };
}
function Glyph(options) {
  this.bindConstructorValues(options);
}
Glyph.prototype.bindConstructorValues = function(options) {
  this.index = options.index || 0;
  this.name = options.name || null;
  this.unicode = options.unicode || void 0;
  this.unicodes = options.unicodes || options.unicode !== void 0 ? [options.unicode] : [];
  if ("xMin" in options) {
    this.xMin = options.xMin;
  }
  if ("yMin" in options) {
    this.yMin = options.yMin;
  }
  if ("xMax" in options) {
    this.xMax = options.xMax;
  }
  if ("yMax" in options) {
    this.yMax = options.yMax;
  }
  if ("advanceWidth" in options) {
    this.advanceWidth = options.advanceWidth;
  }
  Object.defineProperty(this, "path", getPathDefinition(this, options.path));
};
Glyph.prototype.addUnicode = function(unicode) {
  if (this.unicodes.length === 0) {
    this.unicode = unicode;
  }
  this.unicodes.push(unicode);
};
Glyph.prototype.getBoundingBox = function() {
  return this.path.getBoundingBox();
};
Glyph.prototype.getPath = function(x, y, fontSize, options, font) {
  x = x !== void 0 ? x : 0;
  y = y !== void 0 ? y : 0;
  fontSize = fontSize !== void 0 ? fontSize : 72;
  var commands;
  var hPoints;
  if (!options) {
    options = {};
  }
  var xScale = options.xScale;
  var yScale = options.yScale;
  if (options.hinting && font && font.hinting) {
    hPoints = this.path && font.hinting.exec(this, fontSize);
  }
  if (hPoints) {
    commands = font.hinting.getCommands(hPoints);
    x = Math.round(x);
    y = Math.round(y);
    xScale = yScale = 1;
  } else {
    commands = this.path.commands;
    var scale = 1 / (this.path.unitsPerEm || 1e3) * fontSize;
    if (xScale === void 0) {
      xScale = scale;
    }
    if (yScale === void 0) {
      yScale = scale;
    }
  }
  var p = new Path2();
  for (var i3 = 0; i3 < commands.length; i3 += 1) {
    var cmd = commands[i3];
    if (cmd.type === "M") {
      p.moveTo(x + cmd.x * xScale, y + -cmd.y * yScale);
    } else if (cmd.type === "L") {
      p.lineTo(x + cmd.x * xScale, y + -cmd.y * yScale);
    } else if (cmd.type === "Q") {
      p.quadraticCurveTo(
        x + cmd.x1 * xScale,
        y + -cmd.y1 * yScale,
        x + cmd.x * xScale,
        y + -cmd.y * yScale
      );
    } else if (cmd.type === "C") {
      p.curveTo(
        x + cmd.x1 * xScale,
        y + -cmd.y1 * yScale,
        x + cmd.x2 * xScale,
        y + -cmd.y2 * yScale,
        x + cmd.x * xScale,
        y + -cmd.y * yScale
      );
    } else if (cmd.type === "Z") {
      p.closePath();
    }
  }
  return p;
};
Glyph.prototype.getContours = function() {
  if (this.points === void 0) {
    return [];
  }
  var contours = [];
  var currentContour = [];
  for (var i3 = 0; i3 < this.points.length; i3 += 1) {
    var pt = this.points[i3];
    currentContour.push(pt);
    if (pt.lastPointOfContour) {
      contours.push(currentContour);
      currentContour = [];
    }
  }
  check.argument(currentContour.length === 0, "There are still points left in the current contour.");
  return contours;
};
Glyph.prototype.getMetrics = function() {
  var commands = this.path.commands;
  var xCoords = [];
  var yCoords = [];
  for (var i3 = 0; i3 < commands.length; i3 += 1) {
    var cmd = commands[i3];
    if (cmd.type !== "Z") {
      xCoords.push(cmd.x);
      yCoords.push(cmd.y);
    }
    if (cmd.type === "Q" || cmd.type === "C") {
      xCoords.push(cmd.x1);
      yCoords.push(cmd.y1);
    }
    if (cmd.type === "C") {
      xCoords.push(cmd.x2);
      yCoords.push(cmd.y2);
    }
  }
  var metrics = {
    xMin: Math.min.apply(null, xCoords),
    yMin: Math.min.apply(null, yCoords),
    xMax: Math.max.apply(null, xCoords),
    yMax: Math.max.apply(null, yCoords),
    leftSideBearing: this.leftSideBearing
  };
  if (!isFinite(metrics.xMin)) {
    metrics.xMin = 0;
  }
  if (!isFinite(metrics.xMax)) {
    metrics.xMax = this.advanceWidth;
  }
  if (!isFinite(metrics.yMin)) {
    metrics.yMin = 0;
  }
  if (!isFinite(metrics.yMax)) {
    metrics.yMax = 0;
  }
  metrics.rightSideBearing = this.advanceWidth - metrics.leftSideBearing - (metrics.xMax - metrics.xMin);
  return metrics;
};
Glyph.prototype.draw = function(ctx, x, y, fontSize, options) {
  this.getPath(x, y, fontSize, options).draw(ctx);
};
Glyph.prototype.drawPoints = function(ctx, x, y, fontSize) {
  function drawCircles(l, x2, y2, scale2) {
    ctx.beginPath();
    for (var j = 0; j < l.length; j += 1) {
      ctx.moveTo(x2 + l[j].x * scale2, y2 + l[j].y * scale2);
      ctx.arc(x2 + l[j].x * scale2, y2 + l[j].y * scale2, 2, 0, Math.PI * 2, false);
    }
    ctx.closePath();
    ctx.fill();
  }
  x = x !== void 0 ? x : 0;
  y = y !== void 0 ? y : 0;
  fontSize = fontSize !== void 0 ? fontSize : 24;
  var scale = 1 / this.path.unitsPerEm * fontSize;
  var blueCircles = [];
  var redCircles = [];
  var path = this.path;
  for (var i3 = 0; i3 < path.commands.length; i3 += 1) {
    var cmd = path.commands[i3];
    if (cmd.x !== void 0) {
      blueCircles.push({ x: cmd.x, y: -cmd.y });
    }
    if (cmd.x1 !== void 0) {
      redCircles.push({ x: cmd.x1, y: -cmd.y1 });
    }
    if (cmd.x2 !== void 0) {
      redCircles.push({ x: cmd.x2, y: -cmd.y2 });
    }
  }
  ctx.fillStyle = "blue";
  drawCircles(blueCircles, x, y, scale);
  ctx.fillStyle = "red";
  drawCircles(redCircles, x, y, scale);
};
Glyph.prototype.drawMetrics = function(ctx, x, y, fontSize) {
  var scale;
  x = x !== void 0 ? x : 0;
  y = y !== void 0 ? y : 0;
  fontSize = fontSize !== void 0 ? fontSize : 24;
  scale = 1 / this.path.unitsPerEm * fontSize;
  ctx.lineWidth = 1;
  ctx.strokeStyle = "black";
  draw.line(ctx, x, -1e4, x, 1e4);
  draw.line(ctx, -1e4, y, 1e4, y);
  var xMin = this.xMin || 0;
  var yMin = this.yMin || 0;
  var xMax = this.xMax || 0;
  var yMax = this.yMax || 0;
  var advanceWidth = this.advanceWidth || 0;
  ctx.strokeStyle = "blue";
  draw.line(ctx, x + xMin * scale, -1e4, x + xMin * scale, 1e4);
  draw.line(ctx, x + xMax * scale, -1e4, x + xMax * scale, 1e4);
  draw.line(ctx, -1e4, y + -yMin * scale, 1e4, y + -yMin * scale);
  draw.line(ctx, -1e4, y + -yMax * scale, 1e4, y + -yMax * scale);
  ctx.strokeStyle = "green";
  draw.line(ctx, x + advanceWidth * scale, -1e4, x + advanceWidth * scale, 1e4);
};
function defineDependentProperty(glyph, externalName, internalName) {
  Object.defineProperty(glyph, externalName, {
    get: function() {
      glyph.path;
      return glyph[internalName];
    },
    set: function(newValue) {
      glyph[internalName] = newValue;
    },
    enumerable: true,
    configurable: true
  });
}
function GlyphSet(font, glyphs) {
  this.font = font;
  this.glyphs = {};
  if (Array.isArray(glyphs)) {
    for (var i3 = 0; i3 < glyphs.length; i3++) {
      var glyph = glyphs[i3];
      glyph.path.unitsPerEm = font.unitsPerEm;
      this.glyphs[i3] = glyph;
    }
  }
  this.length = glyphs && glyphs.length || 0;
}
GlyphSet.prototype.get = function(index) {
  if (this.glyphs[index] === void 0) {
    this.font._push(index);
    if (typeof this.glyphs[index] === "function") {
      this.glyphs[index] = this.glyphs[index]();
    }
    var glyph = this.glyphs[index];
    var unicodeObj = this.font._IndexToUnicodeMap[index];
    if (unicodeObj) {
      for (var j = 0; j < unicodeObj.unicodes.length; j++) {
        glyph.addUnicode(unicodeObj.unicodes[j]);
      }
    }
    if (this.font.cffEncoding) {
      if (this.font.isCIDFont) {
        glyph.name = "gid" + index;
      } else {
        glyph.name = this.font.cffEncoding.charset[index];
      }
    } else if (this.font.glyphNames.names) {
      glyph.name = this.font.glyphNames.glyphIndexToName(index);
    }
    this.glyphs[index].advanceWidth = this.font._hmtxTableData[index].advanceWidth;
    this.glyphs[index].leftSideBearing = this.font._hmtxTableData[index].leftSideBearing;
  } else {
    if (typeof this.glyphs[index] === "function") {
      this.glyphs[index] = this.glyphs[index]();
    }
  }
  return this.glyphs[index];
};
GlyphSet.prototype.push = function(index, loader) {
  this.glyphs[index] = loader;
  this.length++;
};
function glyphLoader(font, index) {
  return new Glyph({ index, font });
}
function ttfGlyphLoader(font, index, parseGlyph2, data, position, buildPath2) {
  return function() {
    var glyph = new Glyph({ index, font });
    glyph.path = function() {
      parseGlyph2(glyph, data, position);
      var path = buildPath2(font.glyphs, glyph);
      path.unitsPerEm = font.unitsPerEm;
      return path;
    };
    defineDependentProperty(glyph, "xMin", "_xMin");
    defineDependentProperty(glyph, "xMax", "_xMax");
    defineDependentProperty(glyph, "yMin", "_yMin");
    defineDependentProperty(glyph, "yMax", "_yMax");
    return glyph;
  };
}
function cffGlyphLoader(font, index, parseCFFCharstring2, charstring) {
  return function() {
    var glyph = new Glyph({ index, font });
    glyph.path = function() {
      var path = parseCFFCharstring2(font, glyph, charstring);
      path.unitsPerEm = font.unitsPerEm;
      return path;
    };
    return glyph;
  };
}
var glyphset = { GlyphSet, glyphLoader, ttfGlyphLoader, cffGlyphLoader };
function equals(a4, b5) {
  if (a4 === b5) {
    return true;
  } else if (Array.isArray(a4) && Array.isArray(b5)) {
    if (a4.length !== b5.length) {
      return false;
    }
    for (var i3 = 0; i3 < a4.length; i3 += 1) {
      if (!equals(a4[i3], b5[i3])) {
        return false;
      }
    }
    return true;
  } else {
    return false;
  }
}
function calcCFFSubroutineBias(subrs) {
  var bias;
  if (subrs.length < 1240) {
    bias = 107;
  } else if (subrs.length < 33900) {
    bias = 1131;
  } else {
    bias = 32768;
  }
  return bias;
}
function parseCFFIndex(data, start, conversionFn) {
  var offsets = [];
  var objects = [];
  var count = parse.getCard16(data, start);
  var objectOffset;
  var endOffset;
  if (count !== 0) {
    var offsetSize = parse.getByte(data, start + 2);
    objectOffset = start + (count + 1) * offsetSize + 2;
    var pos = start + 3;
    for (var i3 = 0; i3 < count + 1; i3 += 1) {
      offsets.push(parse.getOffset(data, pos, offsetSize));
      pos += offsetSize;
    }
    endOffset = objectOffset + offsets[count];
  } else {
    endOffset = start + 2;
  }
  for (var i$1 = 0; i$1 < offsets.length - 1; i$1 += 1) {
    var value = parse.getBytes(data, objectOffset + offsets[i$1], objectOffset + offsets[i$1 + 1]);
    if (conversionFn) {
      value = conversionFn(value);
    }
    objects.push(value);
  }
  return { objects, startOffset: start, endOffset };
}
function parseCFFIndexLowMemory(data, start) {
  var offsets = [];
  var count = parse.getCard16(data, start);
  var objectOffset;
  var endOffset;
  if (count !== 0) {
    var offsetSize = parse.getByte(data, start + 2);
    objectOffset = start + (count + 1) * offsetSize + 2;
    var pos = start + 3;
    for (var i3 = 0; i3 < count + 1; i3 += 1) {
      offsets.push(parse.getOffset(data, pos, offsetSize));
      pos += offsetSize;
    }
    endOffset = objectOffset + offsets[count];
  } else {
    endOffset = start + 2;
  }
  return { offsets, startOffset: start, endOffset };
}
function getCffIndexObject(i3, offsets, data, start, conversionFn) {
  var count = parse.getCard16(data, start);
  var objectOffset = 0;
  if (count !== 0) {
    var offsetSize = parse.getByte(data, start + 2);
    objectOffset = start + (count + 1) * offsetSize + 2;
  }
  var value = parse.getBytes(data, objectOffset + offsets[i3], objectOffset + offsets[i3 + 1]);
  if (conversionFn) {
    value = conversionFn(value);
  }
  return value;
}
function parseFloatOperand(parser) {
  var s = "";
  var eof = 15;
  var lookup = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", ".", "E", "E-", null, "-"];
  while (true) {
    var b5 = parser.parseByte();
    var n1 = b5 >> 4;
    var n2 = b5 & 15;
    if (n1 === eof) {
      break;
    }
    s += lookup[n1];
    if (n2 === eof) {
      break;
    }
    s += lookup[n2];
  }
  return parseFloat(s);
}
function parseOperand(parser, b0) {
  var b1;
  var b23;
  var b32;
  var b43;
  if (b0 === 28) {
    b1 = parser.parseByte();
    b23 = parser.parseByte();
    return b1 << 8 | b23;
  }
  if (b0 === 29) {
    b1 = parser.parseByte();
    b23 = parser.parseByte();
    b32 = parser.parseByte();
    b43 = parser.parseByte();
    return b1 << 24 | b23 << 16 | b32 << 8 | b43;
  }
  if (b0 === 30) {
    return parseFloatOperand(parser);
  }
  if (b0 >= 32 && b0 <= 246) {
    return b0 - 139;
  }
  if (b0 >= 247 && b0 <= 250) {
    b1 = parser.parseByte();
    return (b0 - 247) * 256 + b1 + 108;
  }
  if (b0 >= 251 && b0 <= 254) {
    b1 = parser.parseByte();
    return -(b0 - 251) * 256 - b1 - 108;
  }
  throw new Error("Invalid b0 " + b0);
}
function entriesToObject(entries) {
  var o = {};
  for (var i3 = 0; i3 < entries.length; i3 += 1) {
    var key = entries[i3][0];
    var values = entries[i3][1];
    var value = void 0;
    if (values.length === 1) {
      value = values[0];
    } else {
      value = values;
    }
    if (o.hasOwnProperty(key) && !isNaN(o[key])) {
      throw new Error("Object " + o + " already has key " + key);
    }
    o[key] = value;
  }
  return o;
}
function parseCFFDict(data, start, size2) {
  start = start !== void 0 ? start : 0;
  var parser = new parse.Parser(data, start);
  var entries = [];
  var operands = [];
  size2 = size2 !== void 0 ? size2 : data.length;
  while (parser.relativeOffset < size2) {
    var op = parser.parseByte();
    if (op <= 21) {
      if (op === 12) {
        op = 1200 + parser.parseByte();
      }
      entries.push([op, operands]);
      operands = [];
    } else {
      operands.push(parseOperand(parser, op));
    }
  }
  return entriesToObject(entries);
}
function getCFFString(strings, index) {
  if (index <= 390) {
    index = cffStandardStrings[index];
  } else {
    index = strings[index - 391];
  }
  return index;
}
function interpretDict(dict, meta2, strings) {
  var newDict = {};
  var value;
  for (var i3 = 0; i3 < meta2.length; i3 += 1) {
    var m = meta2[i3];
    if (Array.isArray(m.type)) {
      var values = [];
      values.length = m.type.length;
      for (var j = 0; j < m.type.length; j++) {
        value = dict[m.op] !== void 0 ? dict[m.op][j] : void 0;
        if (value === void 0) {
          value = m.value !== void 0 && m.value[j] !== void 0 ? m.value[j] : null;
        }
        if (m.type[j] === "SID") {
          value = getCFFString(strings, value);
        }
        values[j] = value;
      }
      newDict[m.name] = values;
    } else {
      value = dict[m.op];
      if (value === void 0) {
        value = m.value !== void 0 ? m.value : null;
      }
      if (m.type === "SID") {
        value = getCFFString(strings, value);
      }
      newDict[m.name] = value;
    }
  }
  return newDict;
}
function parseCFFHeader(data, start) {
  var header = {};
  header.formatMajor = parse.getCard8(data, start);
  header.formatMinor = parse.getCard8(data, start + 1);
  header.size = parse.getCard8(data, start + 2);
  header.offsetSize = parse.getCard8(data, start + 3);
  header.startOffset = start;
  header.endOffset = start + 4;
  return header;
}
var TOP_DICT_META = [
  { name: "version", op: 0, type: "SID" },
  { name: "notice", op: 1, type: "SID" },
  { name: "copyright", op: 1200, type: "SID" },
  { name: "fullName", op: 2, type: "SID" },
  { name: "familyName", op: 3, type: "SID" },
  { name: "weight", op: 4, type: "SID" },
  { name: "isFixedPitch", op: 1201, type: "number", value: 0 },
  { name: "italicAngle", op: 1202, type: "number", value: 0 },
  { name: "underlinePosition", op: 1203, type: "number", value: -100 },
  { name: "underlineThickness", op: 1204, type: "number", value: 50 },
  { name: "paintType", op: 1205, type: "number", value: 0 },
  { name: "charstringType", op: 1206, type: "number", value: 2 },
  {
    name: "fontMatrix",
    op: 1207,
    type: ["real", "real", "real", "real", "real", "real"],
    value: [1e-3, 0, 0, 1e-3, 0, 0]
  },
  { name: "uniqueId", op: 13, type: "number" },
  { name: "fontBBox", op: 5, type: ["number", "number", "number", "number"], value: [0, 0, 0, 0] },
  { name: "strokeWidth", op: 1208, type: "number", value: 0 },
  { name: "xuid", op: 14, type: [], value: null },
  { name: "charset", op: 15, type: "offset", value: 0 },
  { name: "encoding", op: 16, type: "offset", value: 0 },
  { name: "charStrings", op: 17, type: "offset", value: 0 },
  { name: "private", op: 18, type: ["number", "offset"], value: [0, 0] },
  { name: "ros", op: 1230, type: ["SID", "SID", "number"] },
  { name: "cidFontVersion", op: 1231, type: "number", value: 0 },
  { name: "cidFontRevision", op: 1232, type: "number", value: 0 },
  { name: "cidFontType", op: 1233, type: "number", value: 0 },
  { name: "cidCount", op: 1234, type: "number", value: 8720 },
  { name: "uidBase", op: 1235, type: "number" },
  { name: "fdArray", op: 1236, type: "offset" },
  { name: "fdSelect", op: 1237, type: "offset" },
  { name: "fontName", op: 1238, type: "SID" }
];
var PRIVATE_DICT_META = [
  { name: "subrs", op: 19, type: "offset", value: 0 },
  { name: "defaultWidthX", op: 20, type: "number", value: 0 },
  { name: "nominalWidthX", op: 21, type: "number", value: 0 }
];
function parseCFFTopDict(data, strings) {
  var dict = parseCFFDict(data, 0, data.byteLength);
  return interpretDict(dict, TOP_DICT_META, strings);
}
function parseCFFPrivateDict(data, start, size2, strings) {
  var dict = parseCFFDict(data, start, size2);
  return interpretDict(dict, PRIVATE_DICT_META, strings);
}
function gatherCFFTopDicts(data, start, cffIndex, strings) {
  var topDictArray = [];
  for (var iTopDict = 0; iTopDict < cffIndex.length; iTopDict += 1) {
    var topDictData = new DataView(new Uint8Array(cffIndex[iTopDict]).buffer);
    var topDict = parseCFFTopDict(topDictData, strings);
    topDict._subrs = [];
    topDict._subrsBias = 0;
    topDict._defaultWidthX = 0;
    topDict._nominalWidthX = 0;
    var privateSize = topDict.private[0];
    var privateOffset = topDict.private[1];
    if (privateSize !== 0 && privateOffset !== 0) {
      var privateDict = parseCFFPrivateDict(data, privateOffset + start, privateSize, strings);
      topDict._defaultWidthX = privateDict.defaultWidthX;
      topDict._nominalWidthX = privateDict.nominalWidthX;
      if (privateDict.subrs !== 0) {
        var subrOffset = privateOffset + privateDict.subrs;
        var subrIndex = parseCFFIndex(data, subrOffset + start);
        topDict._subrs = subrIndex.objects;
        topDict._subrsBias = calcCFFSubroutineBias(topDict._subrs);
      }
      topDict._privateDict = privateDict;
    }
    topDictArray.push(topDict);
  }
  return topDictArray;
}
function parseCFFCharset(data, start, nGlyphs, strings) {
  var sid;
  var count;
  var parser = new parse.Parser(data, start);
  nGlyphs -= 1;
  var charset = [".notdef"];
  var format = parser.parseCard8();
  if (format === 0) {
    for (var i3 = 0; i3 < nGlyphs; i3 += 1) {
      sid = parser.parseSID();
      charset.push(getCFFString(strings, sid));
    }
  } else if (format === 1) {
    while (charset.length <= nGlyphs) {
      sid = parser.parseSID();
      count = parser.parseCard8();
      for (var i$1 = 0; i$1 <= count; i$1 += 1) {
        charset.push(getCFFString(strings, sid));
        sid += 1;
      }
    }
  } else if (format === 2) {
    while (charset.length <= nGlyphs) {
      sid = parser.parseSID();
      count = parser.parseCard16();
      for (var i$2 = 0; i$2 <= count; i$2 += 1) {
        charset.push(getCFFString(strings, sid));
        sid += 1;
      }
    }
  } else {
    throw new Error("Unknown charset format " + format);
  }
  return charset;
}
function parseCFFEncoding(data, start, charset) {
  var code;
  var enc = {};
  var parser = new parse.Parser(data, start);
  var format = parser.parseCard8();
  if (format === 0) {
    var nCodes = parser.parseCard8();
    for (var i3 = 0; i3 < nCodes; i3 += 1) {
      code = parser.parseCard8();
      enc[code] = i3;
    }
  } else if (format === 1) {
    var nRanges = parser.parseCard8();
    code = 1;
    for (var i$1 = 0; i$1 < nRanges; i$1 += 1) {
      var first2 = parser.parseCard8();
      var nLeft = parser.parseCard8();
      for (var j = first2; j <= first2 + nLeft; j += 1) {
        enc[j] = code;
        code += 1;
      }
    }
  } else {
    throw new Error("Unknown encoding format " + format);
  }
  return new CffEncoding(enc, charset);
}
function parseCFFCharstring(font, glyph, code) {
  var c1x;
  var c1y;
  var c2x;
  var c2y;
  var p = new Path2();
  var stack = [];
  var nStems = 0;
  var haveWidth = false;
  var open = false;
  var x = 0;
  var y = 0;
  var subrs;
  var subrsBias;
  var defaultWidthX;
  var nominalWidthX;
  if (font.isCIDFont) {
    var fdIndex = font.tables.cff.topDict._fdSelect[glyph.index];
    var fdDict = font.tables.cff.topDict._fdArray[fdIndex];
    subrs = fdDict._subrs;
    subrsBias = fdDict._subrsBias;
    defaultWidthX = fdDict._defaultWidthX;
    nominalWidthX = fdDict._nominalWidthX;
  } else {
    subrs = font.tables.cff.topDict._subrs;
    subrsBias = font.tables.cff.topDict._subrsBias;
    defaultWidthX = font.tables.cff.topDict._defaultWidthX;
    nominalWidthX = font.tables.cff.topDict._nominalWidthX;
  }
  var width = defaultWidthX;
  function newContour(x2, y2) {
    if (open) {
      p.closePath();
    }
    p.moveTo(x2, y2);
    open = true;
  }
  function parseStems() {
    var hasWidthArg;
    hasWidthArg = stack.length % 2 !== 0;
    if (hasWidthArg && !haveWidth) {
      width = stack.shift() + nominalWidthX;
    }
    nStems += stack.length >> 1;
    stack.length = 0;
    haveWidth = true;
  }
  function parse2(code2) {
    var b1;
    var b23;
    var b32;
    var b43;
    var codeIndex;
    var subrCode;
    var jpx;
    var jpy;
    var c3x;
    var c3y;
    var c4x;
    var c4y;
    var i3 = 0;
    while (i3 < code2.length) {
      var v = code2[i3];
      i3 += 1;
      switch (v) {
        case 1:
          parseStems();
          break;
        case 3:
          parseStems();
          break;
        case 4:
          if (stack.length > 1 && !haveWidth) {
            width = stack.shift() + nominalWidthX;
            haveWidth = true;
          }
          y += stack.pop();
          newContour(x, y);
          break;
        case 5:
          while (stack.length > 0) {
            x += stack.shift();
            y += stack.shift();
            p.lineTo(x, y);
          }
          break;
        case 6:
          while (stack.length > 0) {
            x += stack.shift();
            p.lineTo(x, y);
            if (stack.length === 0) {
              break;
            }
            y += stack.shift();
            p.lineTo(x, y);
          }
          break;
        case 7:
          while (stack.length > 0) {
            y += stack.shift();
            p.lineTo(x, y);
            if (stack.length === 0) {
              break;
            }
            x += stack.shift();
            p.lineTo(x, y);
          }
          break;
        case 8:
          while (stack.length > 0) {
            c1x = x + stack.shift();
            c1y = y + stack.shift();
            c2x = c1x + stack.shift();
            c2y = c1y + stack.shift();
            x = c2x + stack.shift();
            y = c2y + stack.shift();
            p.curveTo(c1x, c1y, c2x, c2y, x, y);
          }
          break;
        case 10:
          codeIndex = stack.pop() + subrsBias;
          subrCode = subrs[codeIndex];
          if (subrCode) {
            parse2(subrCode);
          }
          break;
        case 11:
          return;
        case 12:
          v = code2[i3];
          i3 += 1;
          switch (v) {
            case 35:
              c1x = x + stack.shift();
              c1y = y + stack.shift();
              c2x = c1x + stack.shift();
              c2y = c1y + stack.shift();
              jpx = c2x + stack.shift();
              jpy = c2y + stack.shift();
              c3x = jpx + stack.shift();
              c3y = jpy + stack.shift();
              c4x = c3x + stack.shift();
              c4y = c3y + stack.shift();
              x = c4x + stack.shift();
              y = c4y + stack.shift();
              stack.shift();
              p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);
              p.curveTo(c3x, c3y, c4x, c4y, x, y);
              break;
            case 34:
              c1x = x + stack.shift();
              c1y = y;
              c2x = c1x + stack.shift();
              c2y = c1y + stack.shift();
              jpx = c2x + stack.shift();
              jpy = c2y;
              c3x = jpx + stack.shift();
              c3y = c2y;
              c4x = c3x + stack.shift();
              c4y = y;
              x = c4x + stack.shift();
              p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);
              p.curveTo(c3x, c3y, c4x, c4y, x, y);
              break;
            case 36:
              c1x = x + stack.shift();
              c1y = y + stack.shift();
              c2x = c1x + stack.shift();
              c2y = c1y + stack.shift();
              jpx = c2x + stack.shift();
              jpy = c2y;
              c3x = jpx + stack.shift();
              c3y = c2y;
              c4x = c3x + stack.shift();
              c4y = c3y + stack.shift();
              x = c4x + stack.shift();
              p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);
              p.curveTo(c3x, c3y, c4x, c4y, x, y);
              break;
            case 37:
              c1x = x + stack.shift();
              c1y = y + stack.shift();
              c2x = c1x + stack.shift();
              c2y = c1y + stack.shift();
              jpx = c2x + stack.shift();
              jpy = c2y + stack.shift();
              c3x = jpx + stack.shift();
              c3y = jpy + stack.shift();
              c4x = c3x + stack.shift();
              c4y = c3y + stack.shift();
              if (Math.abs(c4x - x) > Math.abs(c4y - y)) {
                x = c4x + stack.shift();
              } else {
                y = c4y + stack.shift();
              }
              p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);
              p.curveTo(c3x, c3y, c4x, c4y, x, y);
              break;
            default:
              console.log("Glyph " + glyph.index + ": unknown operator 1200" + v);
              stack.length = 0;
          }
          break;
        case 14:
          if (stack.length > 0 && !haveWidth) {
            width = stack.shift() + nominalWidthX;
            haveWidth = true;
          }
          if (open) {
            p.closePath();
            open = false;
          }
          break;
        case 18:
          parseStems();
          break;
        case 19:
        case 20:
          parseStems();
          i3 += nStems + 7 >> 3;
          break;
        case 21:
          if (stack.length > 2 && !haveWidth) {
            width = stack.shift() + nominalWidthX;
            haveWidth = true;
          }
          y += stack.pop();
          x += stack.pop();
          newContour(x, y);
          break;
        case 22:
          if (stack.length > 1 && !haveWidth) {
            width = stack.shift() + nominalWidthX;
            haveWidth = true;
          }
          x += stack.pop();
          newContour(x, y);
          break;
        case 23:
          parseStems();
          break;
        case 24:
          while (stack.length > 2) {
            c1x = x + stack.shift();
            c1y = y + stack.shift();
            c2x = c1x + stack.shift();
            c2y = c1y + stack.shift();
            x = c2x + stack.shift();
            y = c2y + stack.shift();
            p.curveTo(c1x, c1y, c2x, c2y, x, y);
          }
          x += stack.shift();
          y += stack.shift();
          p.lineTo(x, y);
          break;
        case 25:
          while (stack.length > 6) {
            x += stack.shift();
            y += stack.shift();
            p.lineTo(x, y);
          }
          c1x = x + stack.shift();
          c1y = y + stack.shift();
          c2x = c1x + stack.shift();
          c2y = c1y + stack.shift();
          x = c2x + stack.shift();
          y = c2y + stack.shift();
          p.curveTo(c1x, c1y, c2x, c2y, x, y);
          break;
        case 26:
          if (stack.length % 2) {
            x += stack.shift();
          }
          while (stack.length > 0) {
            c1x = x;
            c1y = y + stack.shift();
            c2x = c1x + stack.shift();
            c2y = c1y + stack.shift();
            x = c2x;
            y = c2y + stack.shift();
            p.curveTo(c1x, c1y, c2x, c2y, x, y);
          }
          break;
        case 27:
          if (stack.length % 2) {
            y += stack.shift();
          }
          while (stack.length > 0) {
            c1x = x + stack.shift();
            c1y = y;
            c2x = c1x + stack.shift();
            c2y = c1y + stack.shift();
            x = c2x + stack.shift();
            y = c2y;
            p.curveTo(c1x, c1y, c2x, c2y, x, y);
          }
          break;
        case 28:
          b1 = code2[i3];
          b23 = code2[i3 + 1];
          stack.push((b1 << 24 | b23 << 16) >> 16);
          i3 += 2;
          break;
        case 29:
          codeIndex = stack.pop() + font.gsubrsBias;
          subrCode = font.gsubrs[codeIndex];
          if (subrCode) {
            parse2(subrCode);
          }
          break;
        case 30:
          while (stack.length > 0) {
            c1x = x;
            c1y = y + stack.shift();
            c2x = c1x + stack.shift();
            c2y = c1y + stack.shift();
            x = c2x + stack.shift();
            y = c2y + (stack.length === 1 ? stack.shift() : 0);
            p.curveTo(c1x, c1y, c2x, c2y, x, y);
            if (stack.length === 0) {
              break;
            }
            c1x = x + stack.shift();
            c1y = y;
            c2x = c1x + stack.shift();
            c2y = c1y + stack.shift();
            y = c2y + stack.shift();
            x = c2x + (stack.length === 1 ? stack.shift() : 0);
            p.curveTo(c1x, c1y, c2x, c2y, x, y);
          }
          break;
        case 31:
          while (stack.length > 0) {
            c1x = x + stack.shift();
            c1y = y;
            c2x = c1x + stack.shift();
            c2y = c1y + stack.shift();
            y = c2y + stack.shift();
            x = c2x + (stack.length === 1 ? stack.shift() : 0);
            p.curveTo(c1x, c1y, c2x, c2y, x, y);
            if (stack.length === 0) {
              break;
            }
            c1x = x;
            c1y = y + stack.shift();
            c2x = c1x + stack.shift();
            c2y = c1y + stack.shift();
            x = c2x + stack.shift();
            y = c2y + (stack.length === 1 ? stack.shift() : 0);
            p.curveTo(c1x, c1y, c2x, c2y, x, y);
          }
          break;
        default:
          if (v < 32) {
            console.log("Glyph " + glyph.index + ": unknown operator " + v);
          } else if (v < 247) {
            stack.push(v - 139);
          } else if (v < 251) {
            b1 = code2[i3];
            i3 += 1;
            stack.push((v - 247) * 256 + b1 + 108);
          } else if (v < 255) {
            b1 = code2[i3];
            i3 += 1;
            stack.push(-(v - 251) * 256 - b1 - 108);
          } else {
            b1 = code2[i3];
            b23 = code2[i3 + 1];
            b32 = code2[i3 + 2];
            b43 = code2[i3 + 3];
            i3 += 4;
            stack.push((b1 << 24 | b23 << 16 | b32 << 8 | b43) / 65536);
          }
      }
    }
  }
  parse2(code);
  glyph.advanceWidth = width;
  return p;
}
function parseCFFFDSelect(data, start, nGlyphs, fdArrayCount) {
  var fdSelect = [];
  var fdIndex;
  var parser = new parse.Parser(data, start);
  var format = parser.parseCard8();
  if (format === 0) {
    for (var iGid = 0; iGid < nGlyphs; iGid++) {
      fdIndex = parser.parseCard8();
      if (fdIndex >= fdArrayCount) {
        throw new Error("CFF table CID Font FDSelect has bad FD index value " + fdIndex + " (FD count " + fdArrayCount + ")");
      }
      fdSelect.push(fdIndex);
    }
  } else if (format === 3) {
    var nRanges = parser.parseCard16();
    var first2 = parser.parseCard16();
    if (first2 !== 0) {
      throw new Error("CFF Table CID Font FDSelect format 3 range has bad initial GID " + first2);
    }
    var next;
    for (var iRange = 0; iRange < nRanges; iRange++) {
      fdIndex = parser.parseCard8();
      next = parser.parseCard16();
      if (fdIndex >= fdArrayCount) {
        throw new Error("CFF table CID Font FDSelect has bad FD index value " + fdIndex + " (FD count " + fdArrayCount + ")");
      }
      if (next > nGlyphs) {
        throw new Error("CFF Table CID Font FDSelect format 3 range has bad GID " + next);
      }
      for (; first2 < next; first2++) {
        fdSelect.push(fdIndex);
      }
      first2 = next;
    }
    if (next !== nGlyphs) {
      throw new Error("CFF Table CID Font FDSelect format 3 range has bad final GID " + next);
    }
  } else {
    throw new Error("CFF Table CID Font FDSelect table has unsupported format " + format);
  }
  return fdSelect;
}
function parseCFFTable(data, start, font, opt) {
  font.tables.cff = {};
  var header = parseCFFHeader(data, start);
  var nameIndex = parseCFFIndex(data, header.endOffset, parse.bytesToString);
  var topDictIndex = parseCFFIndex(data, nameIndex.endOffset);
  var stringIndex = parseCFFIndex(data, topDictIndex.endOffset, parse.bytesToString);
  var globalSubrIndex = parseCFFIndex(data, stringIndex.endOffset);
  font.gsubrs = globalSubrIndex.objects;
  font.gsubrsBias = calcCFFSubroutineBias(font.gsubrs);
  var topDictArray = gatherCFFTopDicts(data, start, topDictIndex.objects, stringIndex.objects);
  if (topDictArray.length !== 1) {
    throw new Error("CFF table has too many fonts in 'FontSet' - count of fonts NameIndex.length = " + topDictArray.length);
  }
  var topDict = topDictArray[0];
  font.tables.cff.topDict = topDict;
  if (topDict._privateDict) {
    font.defaultWidthX = topDict._privateDict.defaultWidthX;
    font.nominalWidthX = topDict._privateDict.nominalWidthX;
  }
  if (topDict.ros[0] !== void 0 && topDict.ros[1] !== void 0) {
    font.isCIDFont = true;
  }
  if (font.isCIDFont) {
    var fdArrayOffset = topDict.fdArray;
    var fdSelectOffset = topDict.fdSelect;
    if (fdArrayOffset === 0 || fdSelectOffset === 0) {
      throw new Error("Font is marked as a CID font, but FDArray and/or FDSelect information is missing");
    }
    fdArrayOffset += start;
    var fdArrayIndex = parseCFFIndex(data, fdArrayOffset);
    var fdArray = gatherCFFTopDicts(data, start, fdArrayIndex.objects, stringIndex.objects);
    topDict._fdArray = fdArray;
    fdSelectOffset += start;
    topDict._fdSelect = parseCFFFDSelect(data, fdSelectOffset, font.numGlyphs, fdArray.length);
  }
  var privateDictOffset = start + topDict.private[1];
  var privateDict = parseCFFPrivateDict(data, privateDictOffset, topDict.private[0], stringIndex.objects);
  font.defaultWidthX = privateDict.defaultWidthX;
  font.nominalWidthX = privateDict.nominalWidthX;
  if (privateDict.subrs !== 0) {
    var subrOffset = privateDictOffset + privateDict.subrs;
    var subrIndex = parseCFFIndex(data, subrOffset);
    font.subrs = subrIndex.objects;
    font.subrsBias = calcCFFSubroutineBias(font.subrs);
  } else {
    font.subrs = [];
    font.subrsBias = 0;
  }
  var charStringsIndex;
  if (opt.lowMemory) {
    charStringsIndex = parseCFFIndexLowMemory(data, start + topDict.charStrings);
    font.nGlyphs = charStringsIndex.offsets.length;
  } else {
    charStringsIndex = parseCFFIndex(data, start + topDict.charStrings);
    font.nGlyphs = charStringsIndex.objects.length;
  }
  var charset = parseCFFCharset(data, start + topDict.charset, font.nGlyphs, stringIndex.objects);
  if (topDict.encoding === 0) {
    font.cffEncoding = new CffEncoding(cffStandardEncoding, charset);
  } else if (topDict.encoding === 1) {
    font.cffEncoding = new CffEncoding(cffExpertEncoding, charset);
  } else {
    font.cffEncoding = parseCFFEncoding(data, start + topDict.encoding, charset);
  }
  font.encoding = font.encoding || font.cffEncoding;
  font.glyphs = new glyphset.GlyphSet(font);
  if (opt.lowMemory) {
    font._push = function(i4) {
      var charString2 = getCffIndexObject(i4, charStringsIndex.offsets, data, start + topDict.charStrings);
      font.glyphs.push(i4, glyphset.cffGlyphLoader(font, i4, parseCFFCharstring, charString2));
    };
  } else {
    for (var i3 = 0; i3 < font.nGlyphs; i3 += 1) {
      var charString = charStringsIndex.objects[i3];
      font.glyphs.push(i3, glyphset.cffGlyphLoader(font, i3, parseCFFCharstring, charString));
    }
  }
}
function encodeString(s, strings) {
  var sid;
  var i3 = cffStandardStrings.indexOf(s);
  if (i3 >= 0) {
    sid = i3;
  }
  i3 = strings.indexOf(s);
  if (i3 >= 0) {
    sid = i3 + cffStandardStrings.length;
  } else {
    sid = cffStandardStrings.length + strings.length;
    strings.push(s);
  }
  return sid;
}
function makeHeader() {
  return new table.Record("Header", [
    { name: "major", type: "Card8", value: 1 },
    { name: "minor", type: "Card8", value: 0 },
    { name: "hdrSize", type: "Card8", value: 4 },
    { name: "major", type: "Card8", value: 1 }
  ]);
}
function makeNameIndex(fontNames) {
  var t2 = new table.Record("Name INDEX", [
    { name: "names", type: "INDEX", value: [] }
  ]);
  t2.names = [];
  for (var i3 = 0; i3 < fontNames.length; i3 += 1) {
    t2.names.push({ name: "name_" + i3, type: "NAME", value: fontNames[i3] });
  }
  return t2;
}
function makeDict(meta2, attrs, strings) {
  var m = {};
  for (var i3 = 0; i3 < meta2.length; i3 += 1) {
    var entry = meta2[i3];
    var value = attrs[entry.name];
    if (value !== void 0 && !equals(value, entry.value)) {
      if (entry.type === "SID") {
        value = encodeString(value, strings);
      }
      m[entry.op] = { name: entry.name, type: entry.type, value };
    }
  }
  return m;
}
function makeTopDict(attrs, strings) {
  var t2 = new table.Record("Top DICT", [
    { name: "dict", type: "DICT", value: {} }
  ]);
  t2.dict = makeDict(TOP_DICT_META, attrs, strings);
  return t2;
}
function makeTopDictIndex(topDict) {
  var t2 = new table.Record("Top DICT INDEX", [
    { name: "topDicts", type: "INDEX", value: [] }
  ]);
  t2.topDicts = [{ name: "topDict_0", type: "TABLE", value: topDict }];
  return t2;
}
function makeStringIndex(strings) {
  var t2 = new table.Record("String INDEX", [
    { name: "strings", type: "INDEX", value: [] }
  ]);
  t2.strings = [];
  for (var i3 = 0; i3 < strings.length; i3 += 1) {
    t2.strings.push({ name: "string_" + i3, type: "STRING", value: strings[i3] });
  }
  return t2;
}
function makeGlobalSubrIndex() {
  return new table.Record("Global Subr INDEX", [
    { name: "subrs", type: "INDEX", value: [] }
  ]);
}
function makeCharsets(glyphNames, strings) {
  var t2 = new table.Record("Charsets", [
    { name: "format", type: "Card8", value: 0 }
  ]);
  for (var i3 = 0; i3 < glyphNames.length; i3 += 1) {
    var glyphName = glyphNames[i3];
    var glyphSID = encodeString(glyphName, strings);
    t2.fields.push({ name: "glyph_" + i3, type: "SID", value: glyphSID });
  }
  return t2;
}
function glyphToOps(glyph) {
  var ops = [];
  var path = glyph.path;
  ops.push({ name: "width", type: "NUMBER", value: glyph.advanceWidth });
  var x = 0;
  var y = 0;
  for (var i3 = 0; i3 < path.commands.length; i3 += 1) {
    var dx = void 0;
    var dy = void 0;
    var cmd = path.commands[i3];
    if (cmd.type === "Q") {
      var _13 = 1 / 3;
      var _23 = 2 / 3;
      cmd = {
        type: "C",
        x: cmd.x,
        y: cmd.y,
        x1: Math.round(_13 * x + _23 * cmd.x1),
        y1: Math.round(_13 * y + _23 * cmd.y1),
        x2: Math.round(_13 * cmd.x + _23 * cmd.x1),
        y2: Math.round(_13 * cmd.y + _23 * cmd.y1)
      };
    }
    if (cmd.type === "M") {
      dx = Math.round(cmd.x - x);
      dy = Math.round(cmd.y - y);
      ops.push({ name: "dx", type: "NUMBER", value: dx });
      ops.push({ name: "dy", type: "NUMBER", value: dy });
      ops.push({ name: "rmoveto", type: "OP", value: 21 });
      x = Math.round(cmd.x);
      y = Math.round(cmd.y);
    } else if (cmd.type === "L") {
      dx = Math.round(cmd.x - x);
      dy = Math.round(cmd.y - y);
      ops.push({ name: "dx", type: "NUMBER", value: dx });
      ops.push({ name: "dy", type: "NUMBER", value: dy });
      ops.push({ name: "rlineto", type: "OP", value: 5 });
      x = Math.round(cmd.x);
      y = Math.round(cmd.y);
    } else if (cmd.type === "C") {
      var dx1 = Math.round(cmd.x1 - x);
      var dy1 = Math.round(cmd.y1 - y);
      var dx2 = Math.round(cmd.x2 - cmd.x1);
      var dy2 = Math.round(cmd.y2 - cmd.y1);
      dx = Math.round(cmd.x - cmd.x2);
      dy = Math.round(cmd.y - cmd.y2);
      ops.push({ name: "dx1", type: "NUMBER", value: dx1 });
      ops.push({ name: "dy1", type: "NUMBER", value: dy1 });
      ops.push({ name: "dx2", type: "NUMBER", value: dx2 });
      ops.push({ name: "dy2", type: "NUMBER", value: dy2 });
      ops.push({ name: "dx", type: "NUMBER", value: dx });
      ops.push({ name: "dy", type: "NUMBER", value: dy });
      ops.push({ name: "rrcurveto", type: "OP", value: 8 });
      x = Math.round(cmd.x);
      y = Math.round(cmd.y);
    }
  }
  ops.push({ name: "endchar", type: "OP", value: 14 });
  return ops;
}
function makeCharStringsIndex(glyphs) {
  var t2 = new table.Record("CharStrings INDEX", [
    { name: "charStrings", type: "INDEX", value: [] }
  ]);
  for (var i3 = 0; i3 < glyphs.length; i3 += 1) {
    var glyph = glyphs.get(i3);
    var ops = glyphToOps(glyph);
    t2.charStrings.push({ name: glyph.name, type: "CHARSTRING", value: ops });
  }
  return t2;
}
function makePrivateDict(attrs, strings) {
  var t2 = new table.Record("Private DICT", [
    { name: "dict", type: "DICT", value: {} }
  ]);
  t2.dict = makeDict(PRIVATE_DICT_META, attrs, strings);
  return t2;
}
function makeCFFTable(glyphs, options) {
  var t2 = new table.Table("CFF ", [
    { name: "header", type: "RECORD" },
    { name: "nameIndex", type: "RECORD" },
    { name: "topDictIndex", type: "RECORD" },
    { name: "stringIndex", type: "RECORD" },
    { name: "globalSubrIndex", type: "RECORD" },
    { name: "charsets", type: "RECORD" },
    { name: "charStringsIndex", type: "RECORD" },
    { name: "privateDict", type: "RECORD" }
  ]);
  var fontScale = 1 / options.unitsPerEm;
  var attrs = {
    version: options.version,
    fullName: options.fullName,
    familyName: options.familyName,
    weight: options.weightName,
    fontBBox: options.fontBBox || [0, 0, 0, 0],
    fontMatrix: [fontScale, 0, 0, fontScale, 0, 0],
    charset: 999,
    encoding: 0,
    charStrings: 999,
    private: [0, 999]
  };
  var privateAttrs = {};
  var glyphNames = [];
  var glyph;
  for (var i3 = 1; i3 < glyphs.length; i3 += 1) {
    glyph = glyphs.get(i3);
    glyphNames.push(glyph.name);
  }
  var strings = [];
  t2.header = makeHeader();
  t2.nameIndex = makeNameIndex([options.postScriptName]);
  var topDict = makeTopDict(attrs, strings);
  t2.topDictIndex = makeTopDictIndex(topDict);
  t2.globalSubrIndex = makeGlobalSubrIndex();
  t2.charsets = makeCharsets(glyphNames, strings);
  t2.charStringsIndex = makeCharStringsIndex(glyphs);
  t2.privateDict = makePrivateDict(privateAttrs, strings);
  t2.stringIndex = makeStringIndex(strings);
  var startOffset = t2.header.sizeOf() + t2.nameIndex.sizeOf() + t2.topDictIndex.sizeOf() + t2.stringIndex.sizeOf() + t2.globalSubrIndex.sizeOf();
  attrs.charset = startOffset;
  attrs.encoding = 0;
  attrs.charStrings = attrs.charset + t2.charsets.sizeOf();
  attrs.private[1] = attrs.charStrings + t2.charStringsIndex.sizeOf();
  topDict = makeTopDict(attrs, strings);
  t2.topDictIndex = makeTopDictIndex(topDict);
  return t2;
}
var cff = { parse: parseCFFTable, make: makeCFFTable };
function parseHeadTable(data, start) {
  var head2 = {};
  var p = new parse.Parser(data, start);
  head2.version = p.parseVersion();
  head2.fontRevision = Math.round(p.parseFixed() * 1e3) / 1e3;
  head2.checkSumAdjustment = p.parseULong();
  head2.magicNumber = p.parseULong();
  check.argument(head2.magicNumber === 1594834165, "Font header has wrong magic number.");
  head2.flags = p.parseUShort();
  head2.unitsPerEm = p.parseUShort();
  head2.created = p.parseLongDateTime();
  head2.modified = p.parseLongDateTime();
  head2.xMin = p.parseShort();
  head2.yMin = p.parseShort();
  head2.xMax = p.parseShort();
  head2.yMax = p.parseShort();
  head2.macStyle = p.parseUShort();
  head2.lowestRecPPEM = p.parseUShort();
  head2.fontDirectionHint = p.parseShort();
  head2.indexToLocFormat = p.parseShort();
  head2.glyphDataFormat = p.parseShort();
  return head2;
}
function makeHeadTable(options) {
  var timestamp = Math.round((/* @__PURE__ */ new Date()).getTime() / 1e3) + 2082844800;
  var createdTimestamp = timestamp;
  if (options.createdTimestamp) {
    createdTimestamp = options.createdTimestamp + 2082844800;
  }
  return new table.Table("head", [
    { name: "version", type: "FIXED", value: 65536 },
    { name: "fontRevision", type: "FIXED", value: 65536 },
    { name: "checkSumAdjustment", type: "ULONG", value: 0 },
    { name: "magicNumber", type: "ULONG", value: 1594834165 },
    { name: "flags", type: "USHORT", value: 0 },
    { name: "unitsPerEm", type: "USHORT", value: 1e3 },
    { name: "created", type: "LONGDATETIME", value: createdTimestamp },
    { name: "modified", type: "LONGDATETIME", value: timestamp },
    { name: "xMin", type: "SHORT", value: 0 },
    { name: "yMin", type: "SHORT", value: 0 },
    { name: "xMax", type: "SHORT", value: 0 },
    { name: "yMax", type: "SHORT", value: 0 },
    { name: "macStyle", type: "USHORT", value: 0 },
    { name: "lowestRecPPEM", type: "USHORT", value: 0 },
    { name: "fontDirectionHint", type: "SHORT", value: 2 },
    { name: "indexToLocFormat", type: "SHORT", value: 0 },
    { name: "glyphDataFormat", type: "SHORT", value: 0 }
  ], options);
}
var head = { parse: parseHeadTable, make: makeHeadTable };
function parseHheaTable(data, start) {
  var hhea2 = {};
  var p = new parse.Parser(data, start);
  hhea2.version = p.parseVersion();
  hhea2.ascender = p.parseShort();
  hhea2.descender = p.parseShort();
  hhea2.lineGap = p.parseShort();
  hhea2.advanceWidthMax = p.parseUShort();
  hhea2.minLeftSideBearing = p.parseShort();
  hhea2.minRightSideBearing = p.parseShort();
  hhea2.xMaxExtent = p.parseShort();
  hhea2.caretSlopeRise = p.parseShort();
  hhea2.caretSlopeRun = p.parseShort();
  hhea2.caretOffset = p.parseShort();
  p.relativeOffset += 8;
  hhea2.metricDataFormat = p.parseShort();
  hhea2.numberOfHMetrics = p.parseUShort();
  return hhea2;
}
function makeHheaTable(options) {
  return new table.Table("hhea", [
    { name: "version", type: "FIXED", value: 65536 },
    { name: "ascender", type: "FWORD", value: 0 },
    { name: "descender", type: "FWORD", value: 0 },
    { name: "lineGap", type: "FWORD", value: 0 },
    { name: "advanceWidthMax", type: "UFWORD", value: 0 },
    { name: "minLeftSideBearing", type: "FWORD", value: 0 },
    { name: "minRightSideBearing", type: "FWORD", value: 0 },
    { name: "xMaxExtent", type: "FWORD", value: 0 },
    { name: "caretSlopeRise", type: "SHORT", value: 1 },
    { name: "caretSlopeRun", type: "SHORT", value: 0 },
    { name: "caretOffset", type: "SHORT", value: 0 },
    { name: "reserved1", type: "SHORT", value: 0 },
    { name: "reserved2", type: "SHORT", value: 0 },
    { name: "reserved3", type: "SHORT", value: 0 },
    { name: "reserved4", type: "SHORT", value: 0 },
    { name: "metricDataFormat", type: "SHORT", value: 0 },
    { name: "numberOfHMetrics", type: "USHORT", value: 0 }
  ], options);
}
var hhea = { parse: parseHheaTable, make: makeHheaTable };
function parseHmtxTableAll(data, start, numMetrics, numGlyphs, glyphs) {
  var advanceWidth;
  var leftSideBearing;
  var p = new parse.Parser(data, start);
  for (var i3 = 0; i3 < numGlyphs; i3 += 1) {
    if (i3 < numMetrics) {
      advanceWidth = p.parseUShort();
      leftSideBearing = p.parseShort();
    }
    var glyph = glyphs.get(i3);
    glyph.advanceWidth = advanceWidth;
    glyph.leftSideBearing = leftSideBearing;
  }
}
function parseHmtxTableOnLowMemory(font, data, start, numMetrics, numGlyphs) {
  font._hmtxTableData = {};
  var advanceWidth;
  var leftSideBearing;
  var p = new parse.Parser(data, start);
  for (var i3 = 0; i3 < numGlyphs; i3 += 1) {
    if (i3 < numMetrics) {
      advanceWidth = p.parseUShort();
      leftSideBearing = p.parseShort();
    }
    font._hmtxTableData[i3] = {
      advanceWidth,
      leftSideBearing
    };
  }
}
function parseHmtxTable(font, data, start, numMetrics, numGlyphs, glyphs, opt) {
  if (opt.lowMemory) {
    parseHmtxTableOnLowMemory(font, data, start, numMetrics, numGlyphs);
  } else {
    parseHmtxTableAll(data, start, numMetrics, numGlyphs, glyphs);
  }
}
function makeHmtxTable(glyphs) {
  var t2 = new table.Table("hmtx", []);
  for (var i3 = 0; i3 < glyphs.length; i3 += 1) {
    var glyph = glyphs.get(i3);
    var advanceWidth = glyph.advanceWidth || 0;
    var leftSideBearing = glyph.leftSideBearing || 0;
    t2.fields.push({ name: "advanceWidth_" + i3, type: "USHORT", value: advanceWidth });
    t2.fields.push({ name: "leftSideBearing_" + i3, type: "SHORT", value: leftSideBearing });
  }
  return t2;
}
var hmtx = { parse: parseHmtxTable, make: makeHmtxTable };
function makeLtagTable(tags) {
  var result = new table.Table("ltag", [
    { name: "version", type: "ULONG", value: 1 },
    { name: "flags", type: "ULONG", value: 0 },
    { name: "numTags", type: "ULONG", value: tags.length }
  ]);
  var stringPool = "";
  var stringPoolOffset = 12 + tags.length * 4;
  for (var i3 = 0; i3 < tags.length; ++i3) {
    var pos = stringPool.indexOf(tags[i3]);
    if (pos < 0) {
      pos = stringPool.length;
      stringPool += tags[i3];
    }
    result.fields.push({ name: "offset " + i3, type: "USHORT", value: stringPoolOffset + pos });
    result.fields.push({ name: "length " + i3, type: "USHORT", value: tags[i3].length });
  }
  result.fields.push({ name: "stringPool", type: "CHARARRAY", value: stringPool });
  return result;
}
function parseLtagTable(data, start) {
  var p = new parse.Parser(data, start);
  var tableVersion = p.parseULong();
  check.argument(tableVersion === 1, "Unsupported ltag table version.");
  p.skip("uLong", 1);
  var numTags = p.parseULong();
  var tags = [];
  for (var i3 = 0; i3 < numTags; i3++) {
    var tag = "";
    var offset = start + p.parseUShort();
    var length = p.parseUShort();
    for (var j = offset; j < offset + length; ++j) {
      tag += String.fromCharCode(data.getInt8(j));
    }
    tags.push(tag);
  }
  return tags;
}
var ltag = { make: makeLtagTable, parse: parseLtagTable };
function parseMaxpTable(data, start) {
  var maxp2 = {};
  var p = new parse.Parser(data, start);
  maxp2.version = p.parseVersion();
  maxp2.numGlyphs = p.parseUShort();
  if (maxp2.version === 1) {
    maxp2.maxPoints = p.parseUShort();
    maxp2.maxContours = p.parseUShort();
    maxp2.maxCompositePoints = p.parseUShort();
    maxp2.maxCompositeContours = p.parseUShort();
    maxp2.maxZones = p.parseUShort();
    maxp2.maxTwilightPoints = p.parseUShort();
    maxp2.maxStorage = p.parseUShort();
    maxp2.maxFunctionDefs = p.parseUShort();
    maxp2.maxInstructionDefs = p.parseUShort();
    maxp2.maxStackElements = p.parseUShort();
    maxp2.maxSizeOfInstructions = p.parseUShort();
    maxp2.maxComponentElements = p.parseUShort();
    maxp2.maxComponentDepth = p.parseUShort();
  }
  return maxp2;
}
function makeMaxpTable(numGlyphs) {
  return new table.Table("maxp", [
    { name: "version", type: "FIXED", value: 20480 },
    { name: "numGlyphs", type: "USHORT", value: numGlyphs }
  ]);
}
var maxp = { parse: parseMaxpTable, make: makeMaxpTable };
var nameTableNames = [
  "copyright",
  // 0
  "fontFamily",
  // 1
  "fontSubfamily",
  // 2
  "uniqueID",
  // 3
  "fullName",
  // 4
  "version",
  // 5
  "postScriptName",
  // 6
  "trademark",
  // 7
  "manufacturer",
  // 8
  "designer",
  // 9
  "description",
  // 10
  "manufacturerURL",
  // 11
  "designerURL",
  // 12
  "license",
  // 13
  "licenseURL",
  // 14
  "reserved",
  // 15
  "preferredFamily",
  // 16
  "preferredSubfamily",
  // 17
  "compatibleFullName",
  // 18
  "sampleText",
  // 19
  "postScriptFindFontName",
  // 20
  "wwsFamily",
  // 21
  "wwsSubfamily"
  // 22
];
var macLanguages = {
  0: "en",
  1: "fr",
  2: "de",
  3: "it",
  4: "nl",
  5: "sv",
  6: "es",
  7: "da",
  8: "pt",
  9: "no",
  10: "he",
  11: "ja",
  12: "ar",
  13: "fi",
  14: "el",
  15: "is",
  16: "mt",
  17: "tr",
  18: "hr",
  19: "zh-Hant",
  20: "ur",
  21: "hi",
  22: "th",
  23: "ko",
  24: "lt",
  25: "pl",
  26: "hu",
  27: "es",
  28: "lv",
  29: "se",
  30: "fo",
  31: "fa",
  32: "ru",
  33: "zh",
  34: "nl-BE",
  35: "ga",
  36: "sq",
  37: "ro",
  38: "cz",
  39: "sk",
  40: "si",
  41: "yi",
  42: "sr",
  43: "mk",
  44: "bg",
  45: "uk",
  46: "be",
  47: "uz",
  48: "kk",
  49: "az-Cyrl",
  50: "az-Arab",
  51: "hy",
  52: "ka",
  53: "mo",
  54: "ky",
  55: "tg",
  56: "tk",
  57: "mn-CN",
  58: "mn",
  59: "ps",
  60: "ks",
  61: "ku",
  62: "sd",
  63: "bo",
  64: "ne",
  65: "sa",
  66: "mr",
  67: "bn",
  68: "as",
  69: "gu",
  70: "pa",
  71: "or",
  72: "ml",
  73: "kn",
  74: "ta",
  75: "te",
  76: "si",
  77: "my",
  78: "km",
  79: "lo",
  80: "vi",
  81: "id",
  82: "tl",
  83: "ms",
  84: "ms-Arab",
  85: "am",
  86: "ti",
  87: "om",
  88: "so",
  89: "sw",
  90: "rw",
  91: "rn",
  92: "ny",
  93: "mg",
  94: "eo",
  128: "cy",
  129: "eu",
  130: "ca",
  131: "la",
  132: "qu",
  133: "gn",
  134: "ay",
  135: "tt",
  136: "ug",
  137: "dz",
  138: "jv",
  139: "su",
  140: "gl",
  141: "af",
  142: "br",
  143: "iu",
  144: "gd",
  145: "gv",
  146: "ga",
  147: "to",
  148: "el-polyton",
  149: "kl",
  150: "az",
  151: "nn"
};
var macLanguageToScript = {
  0: 0,
  // langEnglish → smRoman
  1: 0,
  // langFrench → smRoman
  2: 0,
  // langGerman → smRoman
  3: 0,
  // langItalian → smRoman
  4: 0,
  // langDutch → smRoman
  5: 0,
  // langSwedish → smRoman
  6: 0,
  // langSpanish → smRoman
  7: 0,
  // langDanish → smRoman
  8: 0,
  // langPortuguese → smRoman
  9: 0,
  // langNorwegian → smRoman
  10: 5,
  // langHebrew → smHebrew
  11: 1,
  // langJapanese → smJapanese
  12: 4,
  // langArabic → smArabic
  13: 0,
  // langFinnish → smRoman
  14: 6,
  // langGreek → smGreek
  15: 0,
  // langIcelandic → smRoman (modified)
  16: 0,
  // langMaltese → smRoman
  17: 0,
  // langTurkish → smRoman (modified)
  18: 0,
  // langCroatian → smRoman (modified)
  19: 2,
  // langTradChinese → smTradChinese
  20: 4,
  // langUrdu → smArabic
  21: 9,
  // langHindi → smDevanagari
  22: 21,
  // langThai → smThai
  23: 3,
  // langKorean → smKorean
  24: 29,
  // langLithuanian → smCentralEuroRoman
  25: 29,
  // langPolish → smCentralEuroRoman
  26: 29,
  // langHungarian → smCentralEuroRoman
  27: 29,
  // langEstonian → smCentralEuroRoman
  28: 29,
  // langLatvian → smCentralEuroRoman
  29: 0,
  // langSami → smRoman
  30: 0,
  // langFaroese → smRoman (modified)
  31: 4,
  // langFarsi → smArabic (modified)
  32: 7,
  // langRussian → smCyrillic
  33: 25,
  // langSimpChinese → smSimpChinese
  34: 0,
  // langFlemish → smRoman
  35: 0,
  // langIrishGaelic → smRoman (modified)
  36: 0,
  // langAlbanian → smRoman
  37: 0,
  // langRomanian → smRoman (modified)
  38: 29,
  // langCzech → smCentralEuroRoman
  39: 29,
  // langSlovak → smCentralEuroRoman
  40: 0,
  // langSlovenian → smRoman (modified)
  41: 5,
  // langYiddish → smHebrew
  42: 7,
  // langSerbian → smCyrillic
  43: 7,
  // langMacedonian → smCyrillic
  44: 7,
  // langBulgarian → smCyrillic
  45: 7,
  // langUkrainian → smCyrillic (modified)
  46: 7,
  // langByelorussian → smCyrillic
  47: 7,
  // langUzbek → smCyrillic
  48: 7,
  // langKazakh → smCyrillic
  49: 7,
  // langAzerbaijani → smCyrillic
  50: 4,
  // langAzerbaijanAr → smArabic
  51: 24,
  // langArmenian → smArmenian
  52: 23,
  // langGeorgian → smGeorgian
  53: 7,
  // langMoldavian → smCyrillic
  54: 7,
  // langKirghiz → smCyrillic
  55: 7,
  // langTajiki → smCyrillic
  56: 7,
  // langTurkmen → smCyrillic
  57: 27,
  // langMongolian → smMongolian
  58: 7,
  // langMongolianCyr → smCyrillic
  59: 4,
  // langPashto → smArabic
  60: 4,
  // langKurdish → smArabic
  61: 4,
  // langKashmiri → smArabic
  62: 4,
  // langSindhi → smArabic
  63: 26,
  // langTibetan → smTibetan
  64: 9,
  // langNepali → smDevanagari
  65: 9,
  // langSanskrit → smDevanagari
  66: 9,
  // langMarathi → smDevanagari
  67: 13,
  // langBengali → smBengali
  68: 13,
  // langAssamese → smBengali
  69: 11,
  // langGujarati → smGujarati
  70: 10,
  // langPunjabi → smGurmukhi
  71: 12,
  // langOriya → smOriya
  72: 17,
  // langMalayalam → smMalayalam
  73: 16,
  // langKannada → smKannada
  74: 14,
  // langTamil → smTamil
  75: 15,
  // langTelugu → smTelugu
  76: 18,
  // langSinhalese → smSinhalese
  77: 19,
  // langBurmese → smBurmese
  78: 20,
  // langKhmer → smKhmer
  79: 22,
  // langLao → smLao
  80: 30,
  // langVietnamese → smVietnamese
  81: 0,
  // langIndonesian → smRoman
  82: 0,
  // langTagalog → smRoman
  83: 0,
  // langMalayRoman → smRoman
  84: 4,
  // langMalayArabic → smArabic
  85: 28,
  // langAmharic → smEthiopic
  86: 28,
  // langTigrinya → smEthiopic
  87: 28,
  // langOromo → smEthiopic
  88: 0,
  // langSomali → smRoman
  89: 0,
  // langSwahili → smRoman
  90: 0,
  // langKinyarwanda → smRoman
  91: 0,
  // langRundi → smRoman
  92: 0,
  // langNyanja → smRoman
  93: 0,
  // langMalagasy → smRoman
  94: 0,
  // langEsperanto → smRoman
  128: 0,
  // langWelsh → smRoman (modified)
  129: 0,
  // langBasque → smRoman
  130: 0,
  // langCatalan → smRoman
  131: 0,
  // langLatin → smRoman
  132: 0,
  // langQuechua → smRoman
  133: 0,
  // langGuarani → smRoman
  134: 0,
  // langAymara → smRoman
  135: 7,
  // langTatar → smCyrillic
  136: 4,
  // langUighur → smArabic
  137: 26,
  // langDzongkha → smTibetan
  138: 0,
  // langJavaneseRom → smRoman
  139: 0,
  // langSundaneseRom → smRoman
  140: 0,
  // langGalician → smRoman
  141: 0,
  // langAfrikaans → smRoman
  142: 0,
  // langBreton → smRoman (modified)
  143: 28,
  // langInuktitut → smEthiopic (modified)
  144: 0,
  // langScottishGaelic → smRoman (modified)
  145: 0,
  // langManxGaelic → smRoman (modified)
  146: 0,
  // langIrishGaelicScript → smRoman (modified)
  147: 0,
  // langTongan → smRoman
  148: 6,
  // langGreekAncient → smRoman
  149: 0,
  // langGreenlandic → smRoman
  150: 0,
  // langAzerbaijanRoman → smRoman
  151: 0
  // langNynorsk → smRoman
};
var windowsLanguages = {
  1078: "af",
  1052: "sq",
  1156: "gsw",
  1118: "am",
  5121: "ar-DZ",
  15361: "ar-BH",
  3073: "ar",
  2049: "ar-IQ",
  11265: "ar-JO",
  13313: "ar-KW",
  12289: "ar-LB",
  4097: "ar-LY",
  6145: "ary",
  8193: "ar-OM",
  16385: "ar-QA",
  1025: "ar-SA",
  10241: "ar-SY",
  7169: "aeb",
  14337: "ar-AE",
  9217: "ar-YE",
  1067: "hy",
  1101: "as",
  2092: "az-Cyrl",
  1068: "az",
  1133: "ba",
  1069: "eu",
  1059: "be",
  2117: "bn",
  1093: "bn-IN",
  8218: "bs-Cyrl",
  5146: "bs",
  1150: "br",
  1026: "bg",
  1027: "ca",
  3076: "zh-HK",
  5124: "zh-MO",
  2052: "zh",
  4100: "zh-SG",
  1028: "zh-TW",
  1155: "co",
  1050: "hr",
  4122: "hr-BA",
  1029: "cs",
  1030: "da",
  1164: "prs",
  1125: "dv",
  2067: "nl-BE",
  1043: "nl",
  3081: "en-AU",
  10249: "en-BZ",
  4105: "en-CA",
  9225: "en-029",
  16393: "en-IN",
  6153: "en-IE",
  8201: "en-JM",
  17417: "en-MY",
  5129: "en-NZ",
  13321: "en-PH",
  18441: "en-SG",
  7177: "en-ZA",
  11273: "en-TT",
  2057: "en-GB",
  1033: "en",
  12297: "en-ZW",
  1061: "et",
  1080: "fo",
  1124: "fil",
  1035: "fi",
  2060: "fr-BE",
  3084: "fr-CA",
  1036: "fr",
  5132: "fr-LU",
  6156: "fr-MC",
  4108: "fr-CH",
  1122: "fy",
  1110: "gl",
  1079: "ka",
  3079: "de-AT",
  1031: "de",
  5127: "de-LI",
  4103: "de-LU",
  2055: "de-CH",
  1032: "el",
  1135: "kl",
  1095: "gu",
  1128: "ha",
  1037: "he",
  1081: "hi",
  1038: "hu",
  1039: "is",
  1136: "ig",
  1057: "id",
  1117: "iu",
  2141: "iu-Latn",
  2108: "ga",
  1076: "xh",
  1077: "zu",
  1040: "it",
  2064: "it-CH",
  1041: "ja",
  1099: "kn",
  1087: "kk",
  1107: "km",
  1158: "quc",
  1159: "rw",
  1089: "sw",
  1111: "kok",
  1042: "ko",
  1088: "ky",
  1108: "lo",
  1062: "lv",
  1063: "lt",
  2094: "dsb",
  1134: "lb",
  1071: "mk",
  2110: "ms-BN",
  1086: "ms",
  1100: "ml",
  1082: "mt",
  1153: "mi",
  1146: "arn",
  1102: "mr",
  1148: "moh",
  1104: "mn",
  2128: "mn-CN",
  1121: "ne",
  1044: "nb",
  2068: "nn",
  1154: "oc",
  1096: "or",
  1123: "ps",
  1045: "pl",
  1046: "pt",
  2070: "pt-PT",
  1094: "pa",
  1131: "qu-BO",
  2155: "qu-EC",
  3179: "qu",
  1048: "ro",
  1047: "rm",
  1049: "ru",
  9275: "smn",
  4155: "smj-NO",
  5179: "smj",
  3131: "se-FI",
  1083: "se",
  2107: "se-SE",
  8251: "sms",
  6203: "sma-NO",
  7227: "sms",
  1103: "sa",
  7194: "sr-Cyrl-BA",
  3098: "sr",
  6170: "sr-Latn-BA",
  2074: "sr-Latn",
  1132: "nso",
  1074: "tn",
  1115: "si",
  1051: "sk",
  1060: "sl",
  11274: "es-AR",
  16394: "es-BO",
  13322: "es-CL",
  9226: "es-CO",
  5130: "es-CR",
  7178: "es-DO",
  12298: "es-EC",
  17418: "es-SV",
  4106: "es-GT",
  18442: "es-HN",
  2058: "es-MX",
  19466: "es-NI",
  6154: "es-PA",
  15370: "es-PY",
  10250: "es-PE",
  20490: "es-PR",
  // Microsoft has defined two different language codes for
  // “Spanish with modern sorting” and “Spanish with traditional
  // sorting”. This makes sense for collation APIs, and it would be
  // possible to express this in BCP 47 language tags via Unicode
  // extensions (eg., es-u-co-trad is Spanish with traditional
  // sorting). However, for storing names in fonts, the distinction
  // does not make sense, so we give “es” in both cases.
  3082: "es",
  1034: "es",
  21514: "es-US",
  14346: "es-UY",
  8202: "es-VE",
  2077: "sv-FI",
  1053: "sv",
  1114: "syr",
  1064: "tg",
  2143: "tzm",
  1097: "ta",
  1092: "tt",
  1098: "te",
  1054: "th",
  1105: "bo",
  1055: "tr",
  1090: "tk",
  1152: "ug",
  1058: "uk",
  1070: "hsb",
  1056: "ur",
  2115: "uz-Cyrl",
  1091: "uz",
  1066: "vi",
  1106: "cy",
  1160: "wo",
  1157: "sah",
  1144: "ii",
  1130: "yo"
};
function getLanguageCode(platformID, languageID, ltag2) {
  switch (platformID) {
    case 0:
      if (languageID === 65535) {
        return "und";
      } else if (ltag2) {
        return ltag2[languageID];
      }
      break;
    case 1:
      return macLanguages[languageID];
    case 3:
      return windowsLanguages[languageID];
  }
  return void 0;
}
var utf16 = "utf-16";
var macScriptEncodings = {
  0: "macintosh",
  // smRoman
  1: "x-mac-japanese",
  // smJapanese
  2: "x-mac-chinesetrad",
  // smTradChinese
  3: "x-mac-korean",
  // smKorean
  6: "x-mac-greek",
  // smGreek
  7: "x-mac-cyrillic",
  // smCyrillic
  9: "x-mac-devanagai",
  // smDevanagari
  10: "x-mac-gurmukhi",
  // smGurmukhi
  11: "x-mac-gujarati",
  // smGujarati
  12: "x-mac-oriya",
  // smOriya
  13: "x-mac-bengali",
  // smBengali
  14: "x-mac-tamil",
  // smTamil
  15: "x-mac-telugu",
  // smTelugu
  16: "x-mac-kannada",
  // smKannada
  17: "x-mac-malayalam",
  // smMalayalam
  18: "x-mac-sinhalese",
  // smSinhalese
  19: "x-mac-burmese",
  // smBurmese
  20: "x-mac-khmer",
  // smKhmer
  21: "x-mac-thai",
  // smThai
  22: "x-mac-lao",
  // smLao
  23: "x-mac-georgian",
  // smGeorgian
  24: "x-mac-armenian",
  // smArmenian
  25: "x-mac-chinesesimp",
  // smSimpChinese
  26: "x-mac-tibetan",
  // smTibetan
  27: "x-mac-mongolian",
  // smMongolian
  28: "x-mac-ethiopic",
  // smEthiopic
  29: "x-mac-ce",
  // smCentralEuroRoman
  30: "x-mac-vietnamese",
  // smVietnamese
  31: "x-mac-extarabic"
  // smExtArabic
};
var macLanguageEncodings = {
  15: "x-mac-icelandic",
  // langIcelandic
  17: "x-mac-turkish",
  // langTurkish
  18: "x-mac-croatian",
  // langCroatian
  24: "x-mac-ce",
  // langLithuanian
  25: "x-mac-ce",
  // langPolish
  26: "x-mac-ce",
  // langHungarian
  27: "x-mac-ce",
  // langEstonian
  28: "x-mac-ce",
  // langLatvian
  30: "x-mac-icelandic",
  // langFaroese
  37: "x-mac-romanian",
  // langRomanian
  38: "x-mac-ce",
  // langCzech
  39: "x-mac-ce",
  // langSlovak
  40: "x-mac-ce",
  // langSlovenian
  143: "x-mac-inuit",
  // langInuktitut
  146: "x-mac-gaelic"
  // langIrishGaelicScript
};
function getEncoding(platformID, encodingID, languageID) {
  switch (platformID) {
    case 0:
      return utf16;
    case 1:
      return macLanguageEncodings[languageID] || macScriptEncodings[encodingID];
    case 3:
      if (encodingID === 1 || encodingID === 10) {
        return utf16;
      }
      break;
  }
  return void 0;
}
function parseNameTable(data, start, ltag2) {
  var name = {};
  var p = new parse.Parser(data, start);
  var format = p.parseUShort();
  var count = p.parseUShort();
  var stringOffset = p.offset + p.parseUShort();
  for (var i3 = 0; i3 < count; i3++) {
    var platformID = p.parseUShort();
    var encodingID = p.parseUShort();
    var languageID = p.parseUShort();
    var nameID = p.parseUShort();
    var property = nameTableNames[nameID] || nameID;
    var byteLength = p.parseUShort();
    var offset = p.parseUShort();
    var language = getLanguageCode(platformID, languageID, ltag2);
    var encoding = getEncoding(platformID, encodingID, languageID);
    if (encoding !== void 0 && language !== void 0) {
      var text = void 0;
      if (encoding === utf16) {
        text = decode.UTF16(data, stringOffset + offset, byteLength);
      } else {
        text = decode.MACSTRING(data, stringOffset + offset, byteLength, encoding);
      }
      if (text) {
        var translations = name[property];
        if (translations === void 0) {
          translations = name[property] = {};
        }
        translations[language] = text;
      }
    }
  }
  var langTagCount = 0;
  if (format === 1) {
    langTagCount = p.parseUShort();
  }
  return name;
}
function reverseDict(dict) {
  var result = {};
  for (var key in dict) {
    result[dict[key]] = parseInt(key);
  }
  return result;
}
function makeNameRecord(platformID, encodingID, languageID, nameID, length, offset) {
  return new table.Record("NameRecord", [
    { name: "platformID", type: "USHORT", value: platformID },
    { name: "encodingID", type: "USHORT", value: encodingID },
    { name: "languageID", type: "USHORT", value: languageID },
    { name: "nameID", type: "USHORT", value: nameID },
    { name: "length", type: "USHORT", value: length },
    { name: "offset", type: "USHORT", value: offset }
  ]);
}
function findSubArray(needle, haystack) {
  var needleLength = needle.length;
  var limit = haystack.length - needleLength + 1;
  loop:
    for (var pos = 0; pos < limit; pos++) {
      for (; pos < limit; pos++) {
        for (var k = 0; k < needleLength; k++) {
          if (haystack[pos + k] !== needle[k]) {
            continue loop;
          }
        }
        return pos;
      }
    }
  return -1;
}
function addStringToPool(s, pool) {
  var offset = findSubArray(s, pool);
  if (offset < 0) {
    offset = pool.length;
    var i3 = 0;
    var len = s.length;
    for (; i3 < len; ++i3) {
      pool.push(s[i3]);
    }
  }
  return offset;
}
function makeNameTable(names, ltag2) {
  var nameID;
  var nameIDs = [];
  var namesWithNumericKeys = {};
  var nameTableIds = reverseDict(nameTableNames);
  for (var key in names) {
    var id = nameTableIds[key];
    if (id === void 0) {
      id = key;
    }
    nameID = parseInt(id);
    if (isNaN(nameID)) {
      throw new Error('Name table entry "' + key + '" does not exist, see nameTableNames for complete list.');
    }
    namesWithNumericKeys[nameID] = names[key];
    nameIDs.push(nameID);
  }
  var macLanguageIds = reverseDict(macLanguages);
  var windowsLanguageIds = reverseDict(windowsLanguages);
  var nameRecords = [];
  var stringPool = [];
  for (var i3 = 0; i3 < nameIDs.length; i3++) {
    nameID = nameIDs[i3];
    var translations = namesWithNumericKeys[nameID];
    for (var lang in translations) {
      var text = translations[lang];
      var macPlatform = 1;
      var macLanguage = macLanguageIds[lang];
      var macScript = macLanguageToScript[macLanguage];
      var macEncoding = getEncoding(macPlatform, macScript, macLanguage);
      var macName = encode.MACSTRING(text, macEncoding);
      if (macName === void 0) {
        macPlatform = 0;
        macLanguage = ltag2.indexOf(lang);
        if (macLanguage < 0) {
          macLanguage = ltag2.length;
          ltag2.push(lang);
        }
        macScript = 4;
        macName = encode.UTF16(text);
      }
      var macNameOffset = addStringToPool(macName, stringPool);
      nameRecords.push(makeNameRecord(
        macPlatform,
        macScript,
        macLanguage,
        nameID,
        macName.length,
        macNameOffset
      ));
      var winLanguage = windowsLanguageIds[lang];
      if (winLanguage !== void 0) {
        var winName = encode.UTF16(text);
        var winNameOffset = addStringToPool(winName, stringPool);
        nameRecords.push(makeNameRecord(
          3,
          1,
          winLanguage,
          nameID,
          winName.length,
          winNameOffset
        ));
      }
    }
  }
  nameRecords.sort(function(a4, b5) {
    return a4.platformID - b5.platformID || a4.encodingID - b5.encodingID || a4.languageID - b5.languageID || a4.nameID - b5.nameID;
  });
  var t2 = new table.Table("name", [
    { name: "format", type: "USHORT", value: 0 },
    { name: "count", type: "USHORT", value: nameRecords.length },
    { name: "stringOffset", type: "USHORT", value: 6 + nameRecords.length * 12 }
  ]);
  for (var r = 0; r < nameRecords.length; r++) {
    t2.fields.push({ name: "record_" + r, type: "RECORD", value: nameRecords[r] });
  }
  t2.fields.push({ name: "strings", type: "LITERAL", value: stringPool });
  return t2;
}
var _name = { parse: parseNameTable, make: makeNameTable };
var unicodeRanges = [
  { begin: 0, end: 127 },
  // Basic Latin
  { begin: 128, end: 255 },
  // Latin-1 Supplement
  { begin: 256, end: 383 },
  // Latin Extended-A
  { begin: 384, end: 591 },
  // Latin Extended-B
  { begin: 592, end: 687 },
  // IPA Extensions
  { begin: 688, end: 767 },
  // Spacing Modifier Letters
  { begin: 768, end: 879 },
  // Combining Diacritical Marks
  { begin: 880, end: 1023 },
  // Greek and Coptic
  { begin: 11392, end: 11519 },
  // Coptic
  { begin: 1024, end: 1279 },
  // Cyrillic
  { begin: 1328, end: 1423 },
  // Armenian
  { begin: 1424, end: 1535 },
  // Hebrew
  { begin: 42240, end: 42559 },
  // Vai
  { begin: 1536, end: 1791 },
  // Arabic
  { begin: 1984, end: 2047 },
  // NKo
  { begin: 2304, end: 2431 },
  // Devanagari
  { begin: 2432, end: 2559 },
  // Bengali
  { begin: 2560, end: 2687 },
  // Gurmukhi
  { begin: 2688, end: 2815 },
  // Gujarati
  { begin: 2816, end: 2943 },
  // Oriya
  { begin: 2944, end: 3071 },
  // Tamil
  { begin: 3072, end: 3199 },
  // Telugu
  { begin: 3200, end: 3327 },
  // Kannada
  { begin: 3328, end: 3455 },
  // Malayalam
  { begin: 3584, end: 3711 },
  // Thai
  { begin: 3712, end: 3839 },
  // Lao
  { begin: 4256, end: 4351 },
  // Georgian
  { begin: 6912, end: 7039 },
  // Balinese
  { begin: 4352, end: 4607 },
  // Hangul Jamo
  { begin: 7680, end: 7935 },
  // Latin Extended Additional
  { begin: 7936, end: 8191 },
  // Greek Extended
  { begin: 8192, end: 8303 },
  // General Punctuation
  { begin: 8304, end: 8351 },
  // Superscripts And Subscripts
  { begin: 8352, end: 8399 },
  // Currency Symbol
  { begin: 8400, end: 8447 },
  // Combining Diacritical Marks For Symbols
  { begin: 8448, end: 8527 },
  // Letterlike Symbols
  { begin: 8528, end: 8591 },
  // Number Forms
  { begin: 8592, end: 8703 },
  // Arrows
  { begin: 8704, end: 8959 },
  // Mathematical Operators
  { begin: 8960, end: 9215 },
  // Miscellaneous Technical
  { begin: 9216, end: 9279 },
  // Control Pictures
  { begin: 9280, end: 9311 },
  // Optical Character Recognition
  { begin: 9312, end: 9471 },
  // Enclosed Alphanumerics
  { begin: 9472, end: 9599 },
  // Box Drawing
  { begin: 9600, end: 9631 },
  // Block Elements
  { begin: 9632, end: 9727 },
  // Geometric Shapes
  { begin: 9728, end: 9983 },
  // Miscellaneous Symbols
  { begin: 9984, end: 10175 },
  // Dingbats
  { begin: 12288, end: 12351 },
  // CJK Symbols And Punctuation
  { begin: 12352, end: 12447 },
  // Hiragana
  { begin: 12448, end: 12543 },
  // Katakana
  { begin: 12544, end: 12591 },
  // Bopomofo
  { begin: 12592, end: 12687 },
  // Hangul Compatibility Jamo
  { begin: 43072, end: 43135 },
  // Phags-pa
  { begin: 12800, end: 13055 },
  // Enclosed CJK Letters And Months
  { begin: 13056, end: 13311 },
  // CJK Compatibility
  { begin: 44032, end: 55215 },
  // Hangul Syllables
  { begin: 55296, end: 57343 },
  // Non-Plane 0 *
  { begin: 67840, end: 67871 },
  // Phoenicia
  { begin: 19968, end: 40959 },
  // CJK Unified Ideographs
  { begin: 57344, end: 63743 },
  // Private Use Area (plane 0)
  { begin: 12736, end: 12783 },
  // CJK Strokes
  { begin: 64256, end: 64335 },
  // Alphabetic Presentation Forms
  { begin: 64336, end: 65023 },
  // Arabic Presentation Forms-A
  { begin: 65056, end: 65071 },
  // Combining Half Marks
  { begin: 65040, end: 65055 },
  // Vertical Forms
  { begin: 65104, end: 65135 },
  // Small Form Variants
  { begin: 65136, end: 65279 },
  // Arabic Presentation Forms-B
  { begin: 65280, end: 65519 },
  // Halfwidth And Fullwidth Forms
  { begin: 65520, end: 65535 },
  // Specials
  { begin: 3840, end: 4095 },
  // Tibetan
  { begin: 1792, end: 1871 },
  // Syriac
  { begin: 1920, end: 1983 },
  // Thaana
  { begin: 3456, end: 3583 },
  // Sinhala
  { begin: 4096, end: 4255 },
  // Myanmar
  { begin: 4608, end: 4991 },
  // Ethiopic
  { begin: 5024, end: 5119 },
  // Cherokee
  { begin: 5120, end: 5759 },
  // Unified Canadian Aboriginal Syllabics
  { begin: 5760, end: 5791 },
  // Ogham
  { begin: 5792, end: 5887 },
  // Runic
  { begin: 6016, end: 6143 },
  // Khmer
  { begin: 6144, end: 6319 },
  // Mongolian
  { begin: 10240, end: 10495 },
  // Braille Patterns
  { begin: 40960, end: 42127 },
  // Yi Syllables
  { begin: 5888, end: 5919 },
  // Tagalog
  { begin: 66304, end: 66351 },
  // Old Italic
  { begin: 66352, end: 66383 },
  // Gothic
  { begin: 66560, end: 66639 },
  // Deseret
  { begin: 118784, end: 119039 },
  // Byzantine Musical Symbols
  { begin: 119808, end: 120831 },
  // Mathematical Alphanumeric Symbols
  { begin: 1044480, end: 1048573 },
  // Private Use (plane 15)
  { begin: 65024, end: 65039 },
  // Variation Selectors
  { begin: 917504, end: 917631 },
  // Tags
  { begin: 6400, end: 6479 },
  // Limbu
  { begin: 6480, end: 6527 },
  // Tai Le
  { begin: 6528, end: 6623 },
  // New Tai Lue
  { begin: 6656, end: 6687 },
  // Buginese
  { begin: 11264, end: 11359 },
  // Glagolitic
  { begin: 11568, end: 11647 },
  // Tifinagh
  { begin: 19904, end: 19967 },
  // Yijing Hexagram Symbols
  { begin: 43008, end: 43055 },
  // Syloti Nagri
  { begin: 65536, end: 65663 },
  // Linear B Syllabary
  { begin: 65856, end: 65935 },
  // Ancient Greek Numbers
  { begin: 66432, end: 66463 },
  // Ugaritic
  { begin: 66464, end: 66527 },
  // Old Persian
  { begin: 66640, end: 66687 },
  // Shavian
  { begin: 66688, end: 66735 },
  // Osmanya
  { begin: 67584, end: 67647 },
  // Cypriot Syllabary
  { begin: 68096, end: 68191 },
  // Kharoshthi
  { begin: 119552, end: 119647 },
  // Tai Xuan Jing Symbols
  { begin: 73728, end: 74751 },
  // Cuneiform
  { begin: 119648, end: 119679 },
  // Counting Rod Numerals
  { begin: 7040, end: 7103 },
  // Sundanese
  { begin: 7168, end: 7247 },
  // Lepcha
  { begin: 7248, end: 7295 },
  // Ol Chiki
  { begin: 43136, end: 43231 },
  // Saurashtra
  { begin: 43264, end: 43311 },
  // Kayah Li
  { begin: 43312, end: 43359 },
  // Rejang
  { begin: 43520, end: 43615 },
  // Cham
  { begin: 65936, end: 65999 },
  // Ancient Symbols
  { begin: 66e3, end: 66047 },
  // Phaistos Disc
  { begin: 66208, end: 66271 },
  // Carian
  { begin: 127024, end: 127135 }
  // Domino Tiles
];
function getUnicodeRange(unicode) {
  for (var i3 = 0; i3 < unicodeRanges.length; i3 += 1) {
    var range2 = unicodeRanges[i3];
    if (unicode >= range2.begin && unicode < range2.end) {
      return i3;
    }
  }
  return -1;
}
function parseOS2Table(data, start) {
  var os22 = {};
  var p = new parse.Parser(data, start);
  os22.version = p.parseUShort();
  os22.xAvgCharWidth = p.parseShort();
  os22.usWeightClass = p.parseUShort();
  os22.usWidthClass = p.parseUShort();
  os22.fsType = p.parseUShort();
  os22.ySubscriptXSize = p.parseShort();
  os22.ySubscriptYSize = p.parseShort();
  os22.ySubscriptXOffset = p.parseShort();
  os22.ySubscriptYOffset = p.parseShort();
  os22.ySuperscriptXSize = p.parseShort();
  os22.ySuperscriptYSize = p.parseShort();
  os22.ySuperscriptXOffset = p.parseShort();
  os22.ySuperscriptYOffset = p.parseShort();
  os22.yStrikeoutSize = p.parseShort();
  os22.yStrikeoutPosition = p.parseShort();
  os22.sFamilyClass = p.parseShort();
  os22.panose = [];
  for (var i3 = 0; i3 < 10; i3++) {
    os22.panose[i3] = p.parseByte();
  }
  os22.ulUnicodeRange1 = p.parseULong();
  os22.ulUnicodeRange2 = p.parseULong();
  os22.ulUnicodeRange3 = p.parseULong();
  os22.ulUnicodeRange4 = p.parseULong();
  os22.achVendID = String.fromCharCode(p.parseByte(), p.parseByte(), p.parseByte(), p.parseByte());
  os22.fsSelection = p.parseUShort();
  os22.usFirstCharIndex = p.parseUShort();
  os22.usLastCharIndex = p.parseUShort();
  os22.sTypoAscender = p.parseShort();
  os22.sTypoDescender = p.parseShort();
  os22.sTypoLineGap = p.parseShort();
  os22.usWinAscent = p.parseUShort();
  os22.usWinDescent = p.parseUShort();
  if (os22.version >= 1) {
    os22.ulCodePageRange1 = p.parseULong();
    os22.ulCodePageRange2 = p.parseULong();
  }
  if (os22.version >= 2) {
    os22.sxHeight = p.parseShort();
    os22.sCapHeight = p.parseShort();
    os22.usDefaultChar = p.parseUShort();
    os22.usBreakChar = p.parseUShort();
    os22.usMaxContent = p.parseUShort();
  }
  return os22;
}
function makeOS2Table(options) {
  return new table.Table("OS/2", [
    { name: "version", type: "USHORT", value: 3 },
    { name: "xAvgCharWidth", type: "SHORT", value: 0 },
    { name: "usWeightClass", type: "USHORT", value: 0 },
    { name: "usWidthClass", type: "USHORT", value: 0 },
    { name: "fsType", type: "USHORT", value: 0 },
    { name: "ySubscriptXSize", type: "SHORT", value: 650 },
    { name: "ySubscriptYSize", type: "SHORT", value: 699 },
    { name: "ySubscriptXOffset", type: "SHORT", value: 0 },
    { name: "ySubscriptYOffset", type: "SHORT", value: 140 },
    { name: "ySuperscriptXSize", type: "SHORT", value: 650 },
    { name: "ySuperscriptYSize", type: "SHORT", value: 699 },
    { name: "ySuperscriptXOffset", type: "SHORT", value: 0 },
    { name: "ySuperscriptYOffset", type: "SHORT", value: 479 },
    { name: "yStrikeoutSize", type: "SHORT", value: 49 },
    { name: "yStrikeoutPosition", type: "SHORT", value: 258 },
    { name: "sFamilyClass", type: "SHORT", value: 0 },
    { name: "bFamilyType", type: "BYTE", value: 0 },
    { name: "bSerifStyle", type: "BYTE", value: 0 },
    { name: "bWeight", type: "BYTE", value: 0 },
    { name: "bProportion", type: "BYTE", value: 0 },
    { name: "bContrast", type: "BYTE", value: 0 },
    { name: "bStrokeVariation", type: "BYTE", value: 0 },
    { name: "bArmStyle", type: "BYTE", value: 0 },
    { name: "bLetterform", type: "BYTE", value: 0 },
    { name: "bMidline", type: "BYTE", value: 0 },
    { name: "bXHeight", type: "BYTE", value: 0 },
    { name: "ulUnicodeRange1", type: "ULONG", value: 0 },
    { name: "ulUnicodeRange2", type: "ULONG", value: 0 },
    { name: "ulUnicodeRange3", type: "ULONG", value: 0 },
    { name: "ulUnicodeRange4", type: "ULONG", value: 0 },
    { name: "achVendID", type: "CHARARRAY", value: "XXXX" },
    { name: "fsSelection", type: "USHORT", value: 0 },
    { name: "usFirstCharIndex", type: "USHORT", value: 0 },
    { name: "usLastCharIndex", type: "USHORT", value: 0 },
    { name: "sTypoAscender", type: "SHORT", value: 0 },
    { name: "sTypoDescender", type: "SHORT", value: 0 },
    { name: "sTypoLineGap", type: "SHORT", value: 0 },
    { name: "usWinAscent", type: "USHORT", value: 0 },
    { name: "usWinDescent", type: "USHORT", value: 0 },
    { name: "ulCodePageRange1", type: "ULONG", value: 0 },
    { name: "ulCodePageRange2", type: "ULONG", value: 0 },
    { name: "sxHeight", type: "SHORT", value: 0 },
    { name: "sCapHeight", type: "SHORT", value: 0 },
    { name: "usDefaultChar", type: "USHORT", value: 0 },
    { name: "usBreakChar", type: "USHORT", value: 0 },
    { name: "usMaxContext", type: "USHORT", value: 0 }
  ], options);
}
var os2 = { parse: parseOS2Table, make: makeOS2Table, unicodeRanges, getUnicodeRange };
function parsePostTable(data, start) {
  var post2 = {};
  var p = new parse.Parser(data, start);
  post2.version = p.parseVersion();
  post2.italicAngle = p.parseFixed();
  post2.underlinePosition = p.parseShort();
  post2.underlineThickness = p.parseShort();
  post2.isFixedPitch = p.parseULong();
  post2.minMemType42 = p.parseULong();
  post2.maxMemType42 = p.parseULong();
  post2.minMemType1 = p.parseULong();
  post2.maxMemType1 = p.parseULong();
  switch (post2.version) {
    case 1:
      post2.names = standardNames.slice();
      break;
    case 2:
      post2.numberOfGlyphs = p.parseUShort();
      post2.glyphNameIndex = new Array(post2.numberOfGlyphs);
      for (var i3 = 0; i3 < post2.numberOfGlyphs; i3++) {
        post2.glyphNameIndex[i3] = p.parseUShort();
      }
      post2.names = [];
      for (var i$1 = 0; i$1 < post2.numberOfGlyphs; i$1++) {
        if (post2.glyphNameIndex[i$1] >= standardNames.length) {
          var nameLength = p.parseChar();
          post2.names.push(p.parseString(nameLength));
        }
      }
      break;
    case 2.5:
      post2.numberOfGlyphs = p.parseUShort();
      post2.offset = new Array(post2.numberOfGlyphs);
      for (var i$2 = 0; i$2 < post2.numberOfGlyphs; i$2++) {
        post2.offset[i$2] = p.parseChar();
      }
      break;
  }
  return post2;
}
function makePostTable() {
  return new table.Table("post", [
    { name: "version", type: "FIXED", value: 196608 },
    { name: "italicAngle", type: "FIXED", value: 0 },
    { name: "underlinePosition", type: "FWORD", value: 0 },
    { name: "underlineThickness", type: "FWORD", value: 0 },
    { name: "isFixedPitch", type: "ULONG", value: 0 },
    { name: "minMemType42", type: "ULONG", value: 0 },
    { name: "maxMemType42", type: "ULONG", value: 0 },
    { name: "minMemType1", type: "ULONG", value: 0 },
    { name: "maxMemType1", type: "ULONG", value: 0 }
  ]);
}
var post = { parse: parsePostTable, make: makePostTable };
var subtableParsers = new Array(9);
subtableParsers[1] = function parseLookup1() {
  var start = this.offset + this.relativeOffset;
  var substFormat = this.parseUShort();
  if (substFormat === 1) {
    return {
      substFormat: 1,
      coverage: this.parsePointer(Parser3.coverage),
      deltaGlyphId: this.parseUShort()
    };
  } else if (substFormat === 2) {
    return {
      substFormat: 2,
      coverage: this.parsePointer(Parser3.coverage),
      substitute: this.parseOffset16List()
    };
  }
  check.assert(false, "0x" + start.toString(16) + ": lookup type 1 format must be 1 or 2.");
};
subtableParsers[2] = function parseLookup2() {
  var substFormat = this.parseUShort();
  check.argument(substFormat === 1, "GSUB Multiple Substitution Subtable identifier-format must be 1");
  return {
    substFormat,
    coverage: this.parsePointer(Parser3.coverage),
    sequences: this.parseListOfLists()
  };
};
subtableParsers[3] = function parseLookup3() {
  var substFormat = this.parseUShort();
  check.argument(substFormat === 1, "GSUB Alternate Substitution Subtable identifier-format must be 1");
  return {
    substFormat,
    coverage: this.parsePointer(Parser3.coverage),
    alternateSets: this.parseListOfLists()
  };
};
subtableParsers[4] = function parseLookup4() {
  var substFormat = this.parseUShort();
  check.argument(substFormat === 1, "GSUB ligature table identifier-format must be 1");
  return {
    substFormat,
    coverage: this.parsePointer(Parser3.coverage),
    ligatureSets: this.parseListOfLists(function() {
      return {
        ligGlyph: this.parseUShort(),
        components: this.parseUShortList(this.parseUShort() - 1)
      };
    })
  };
};
var lookupRecordDesc = {
  sequenceIndex: Parser3.uShort,
  lookupListIndex: Parser3.uShort
};
subtableParsers[5] = function parseLookup5() {
  var start = this.offset + this.relativeOffset;
  var substFormat = this.parseUShort();
  if (substFormat === 1) {
    return {
      substFormat,
      coverage: this.parsePointer(Parser3.coverage),
      ruleSets: this.parseListOfLists(function() {
        var glyphCount2 = this.parseUShort();
        var substCount2 = this.parseUShort();
        return {
          input: this.parseUShortList(glyphCount2 - 1),
          lookupRecords: this.parseRecordList(substCount2, lookupRecordDesc)
        };
      })
    };
  } else if (substFormat === 2) {
    return {
      substFormat,
      coverage: this.parsePointer(Parser3.coverage),
      classDef: this.parsePointer(Parser3.classDef),
      classSets: this.parseListOfLists(function() {
        var glyphCount2 = this.parseUShort();
        var substCount2 = this.parseUShort();
        return {
          classes: this.parseUShortList(glyphCount2 - 1),
          lookupRecords: this.parseRecordList(substCount2, lookupRecordDesc)
        };
      })
    };
  } else if (substFormat === 3) {
    var glyphCount = this.parseUShort();
    var substCount = this.parseUShort();
    return {
      substFormat,
      coverages: this.parseList(glyphCount, Parser3.pointer(Parser3.coverage)),
      lookupRecords: this.parseRecordList(substCount, lookupRecordDesc)
    };
  }
  check.assert(false, "0x" + start.toString(16) + ": lookup type 5 format must be 1, 2 or 3.");
};
subtableParsers[6] = function parseLookup6() {
  var start = this.offset + this.relativeOffset;
  var substFormat = this.parseUShort();
  if (substFormat === 1) {
    return {
      substFormat: 1,
      coverage: this.parsePointer(Parser3.coverage),
      chainRuleSets: this.parseListOfLists(function() {
        return {
          backtrack: this.parseUShortList(),
          input: this.parseUShortList(this.parseShort() - 1),
          lookahead: this.parseUShortList(),
          lookupRecords: this.parseRecordList(lookupRecordDesc)
        };
      })
    };
  } else if (substFormat === 2) {
    return {
      substFormat: 2,
      coverage: this.parsePointer(Parser3.coverage),
      backtrackClassDef: this.parsePointer(Parser3.classDef),
      inputClassDef: this.parsePointer(Parser3.classDef),
      lookaheadClassDef: this.parsePointer(Parser3.classDef),
      chainClassSet: this.parseListOfLists(function() {
        return {
          backtrack: this.parseUShortList(),
          input: this.parseUShortList(this.parseShort() - 1),
          lookahead: this.parseUShortList(),
          lookupRecords: this.parseRecordList(lookupRecordDesc)
        };
      })
    };
  } else if (substFormat === 3) {
    return {
      substFormat: 3,
      backtrackCoverage: this.parseList(Parser3.pointer(Parser3.coverage)),
      inputCoverage: this.parseList(Parser3.pointer(Parser3.coverage)),
      lookaheadCoverage: this.parseList(Parser3.pointer(Parser3.coverage)),
      lookupRecords: this.parseRecordList(lookupRecordDesc)
    };
  }
  check.assert(false, "0x" + start.toString(16) + ": lookup type 6 format must be 1, 2 or 3.");
};
subtableParsers[7] = function parseLookup7() {
  var substFormat = this.parseUShort();
  check.argument(substFormat === 1, "GSUB Extension Substitution subtable identifier-format must be 1");
  var extensionLookupType = this.parseUShort();
  var extensionParser = new Parser3(this.data, this.offset + this.parseULong());
  return {
    substFormat: 1,
    lookupType: extensionLookupType,
    extension: subtableParsers[extensionLookupType].call(extensionParser)
  };
};
subtableParsers[8] = function parseLookup8() {
  var substFormat = this.parseUShort();
  check.argument(substFormat === 1, "GSUB Reverse Chaining Contextual Single Substitution Subtable identifier-format must be 1");
  return {
    substFormat,
    coverage: this.parsePointer(Parser3.coverage),
    backtrackCoverage: this.parseList(Parser3.pointer(Parser3.coverage)),
    lookaheadCoverage: this.parseList(Parser3.pointer(Parser3.coverage)),
    substitutes: this.parseUShortList()
  };
};
function parseGsubTable(data, start) {
  start = start || 0;
  var p = new Parser3(data, start);
  var tableVersion = p.parseVersion(1);
  check.argument(tableVersion === 1 || tableVersion === 1.1, "Unsupported GSUB table version.");
  if (tableVersion === 1) {
    return {
      version: tableVersion,
      scripts: p.parseScriptList(),
      features: p.parseFeatureList(),
      lookups: p.parseLookupList(subtableParsers)
    };
  } else {
    return {
      version: tableVersion,
      scripts: p.parseScriptList(),
      features: p.parseFeatureList(),
      lookups: p.parseLookupList(subtableParsers),
      variations: p.parseFeatureVariationsList()
    };
  }
}
var subtableMakers = new Array(9);
subtableMakers[1] = function makeLookup1(subtable) {
  if (subtable.substFormat === 1) {
    return new table.Table("substitutionTable", [
      { name: "substFormat", type: "USHORT", value: 1 },
      { name: "coverage", type: "TABLE", value: new table.Coverage(subtable.coverage) },
      { name: "deltaGlyphID", type: "USHORT", value: subtable.deltaGlyphId }
    ]);
  } else {
    return new table.Table("substitutionTable", [
      { name: "substFormat", type: "USHORT", value: 2 },
      { name: "coverage", type: "TABLE", value: new table.Coverage(subtable.coverage) }
    ].concat(table.ushortList("substitute", subtable.substitute)));
  }
};
subtableMakers[2] = function makeLookup2(subtable) {
  check.assert(subtable.substFormat === 1, "Lookup type 2 substFormat must be 1.");
  return new table.Table("substitutionTable", [
    { name: "substFormat", type: "USHORT", value: 1 },
    { name: "coverage", type: "TABLE", value: new table.Coverage(subtable.coverage) }
  ].concat(table.tableList("seqSet", subtable.sequences, function(sequenceSet) {
    return new table.Table("sequenceSetTable", table.ushortList("sequence", sequenceSet));
  })));
};
subtableMakers[3] = function makeLookup3(subtable) {
  check.assert(subtable.substFormat === 1, "Lookup type 3 substFormat must be 1.");
  return new table.Table("substitutionTable", [
    { name: "substFormat", type: "USHORT", value: 1 },
    { name: "coverage", type: "TABLE", value: new table.Coverage(subtable.coverage) }
  ].concat(table.tableList("altSet", subtable.alternateSets, function(alternateSet) {
    return new table.Table("alternateSetTable", table.ushortList("alternate", alternateSet));
  })));
};
subtableMakers[4] = function makeLookup4(subtable) {
  check.assert(subtable.substFormat === 1, "Lookup type 4 substFormat must be 1.");
  return new table.Table("substitutionTable", [
    { name: "substFormat", type: "USHORT", value: 1 },
    { name: "coverage", type: "TABLE", value: new table.Coverage(subtable.coverage) }
  ].concat(table.tableList("ligSet", subtable.ligatureSets, function(ligatureSet) {
    return new table.Table("ligatureSetTable", table.tableList("ligature", ligatureSet, function(ligature) {
      return new table.Table(
        "ligatureTable",
        [{ name: "ligGlyph", type: "USHORT", value: ligature.ligGlyph }].concat(table.ushortList("component", ligature.components, ligature.components.length + 1))
      );
    }));
  })));
};
subtableMakers[6] = function makeLookup6(subtable) {
  if (subtable.substFormat === 1) {
    var returnTable = new table.Table("chainContextTable", [
      { name: "substFormat", type: "USHORT", value: subtable.substFormat },
      { name: "coverage", type: "TABLE", value: new table.Coverage(subtable.coverage) }
    ].concat(table.tableList("chainRuleSet", subtable.chainRuleSets, function(chainRuleSet) {
      return new table.Table("chainRuleSetTable", table.tableList("chainRule", chainRuleSet, function(chainRule) {
        var tableData2 = table.ushortList("backtrackGlyph", chainRule.backtrack, chainRule.backtrack.length).concat(table.ushortList("inputGlyph", chainRule.input, chainRule.input.length + 1)).concat(table.ushortList("lookaheadGlyph", chainRule.lookahead, chainRule.lookahead.length)).concat(table.ushortList("substitution", [], chainRule.lookupRecords.length));
        chainRule.lookupRecords.forEach(function(record, i3) {
          tableData2 = tableData2.concat({ name: "sequenceIndex" + i3, type: "USHORT", value: record.sequenceIndex }).concat({ name: "lookupListIndex" + i3, type: "USHORT", value: record.lookupListIndex });
        });
        return new table.Table("chainRuleTable", tableData2);
      }));
    })));
    return returnTable;
  } else if (subtable.substFormat === 2) {
    check.assert(false, "lookup type 6 format 2 is not yet supported.");
  } else if (subtable.substFormat === 3) {
    var tableData = [
      { name: "substFormat", type: "USHORT", value: subtable.substFormat }
    ];
    tableData.push({ name: "backtrackGlyphCount", type: "USHORT", value: subtable.backtrackCoverage.length });
    subtable.backtrackCoverage.forEach(function(coverage, i3) {
      tableData.push({ name: "backtrackCoverage" + i3, type: "TABLE", value: new table.Coverage(coverage) });
    });
    tableData.push({ name: "inputGlyphCount", type: "USHORT", value: subtable.inputCoverage.length });
    subtable.inputCoverage.forEach(function(coverage, i3) {
      tableData.push({ name: "inputCoverage" + i3, type: "TABLE", value: new table.Coverage(coverage) });
    });
    tableData.push({ name: "lookaheadGlyphCount", type: "USHORT", value: subtable.lookaheadCoverage.length });
    subtable.lookaheadCoverage.forEach(function(coverage, i3) {
      tableData.push({ name: "lookaheadCoverage" + i3, type: "TABLE", value: new table.Coverage(coverage) });
    });
    tableData.push({ name: "substitutionCount", type: "USHORT", value: subtable.lookupRecords.length });
    subtable.lookupRecords.forEach(function(record, i3) {
      tableData = tableData.concat({ name: "sequenceIndex" + i3, type: "USHORT", value: record.sequenceIndex }).concat({ name: "lookupListIndex" + i3, type: "USHORT", value: record.lookupListIndex });
    });
    var returnTable$1 = new table.Table("chainContextTable", tableData);
    return returnTable$1;
  }
  check.assert(false, "lookup type 6 format must be 1, 2 or 3.");
};
function makeGsubTable(gsub2) {
  return new table.Table("GSUB", [
    { name: "version", type: "ULONG", value: 65536 },
    { name: "scripts", type: "TABLE", value: new table.ScriptList(gsub2.scripts) },
    { name: "features", type: "TABLE", value: new table.FeatureList(gsub2.features) },
    { name: "lookups", type: "TABLE", value: new table.LookupList(gsub2.lookups, subtableMakers) }
  ]);
}
var gsub = { parse: parseGsubTable, make: makeGsubTable };
function parseMetaTable(data, start) {
  var p = new parse.Parser(data, start);
  var tableVersion = p.parseULong();
  check.argument(tableVersion === 1, "Unsupported META table version.");
  p.parseULong();
  p.parseULong();
  var numDataMaps = p.parseULong();
  var tags = {};
  for (var i3 = 0; i3 < numDataMaps; i3++) {
    var tag = p.parseTag();
    var dataOffset = p.parseULong();
    var dataLength = p.parseULong();
    var text = decode.UTF8(data, start + dataOffset, dataLength);
    tags[tag] = text;
  }
  return tags;
}
function makeMetaTable(tags) {
  var numTags = Object.keys(tags).length;
  var stringPool = "";
  var stringPoolOffset = 16 + numTags * 12;
  var result = new table.Table("meta", [
    { name: "version", type: "ULONG", value: 1 },
    { name: "flags", type: "ULONG", value: 0 },
    { name: "offset", type: "ULONG", value: stringPoolOffset },
    { name: "numTags", type: "ULONG", value: numTags }
  ]);
  for (var tag in tags) {
    var pos = stringPool.length;
    stringPool += tags[tag];
    result.fields.push({ name: "tag " + tag, type: "TAG", value: tag });
    result.fields.push({ name: "offset " + tag, type: "ULONG", value: stringPoolOffset + pos });
    result.fields.push({ name: "length " + tag, type: "ULONG", value: tags[tag].length });
  }
  result.fields.push({ name: "stringPool", type: "CHARARRAY", value: stringPool });
  return result;
}
var meta = { parse: parseMetaTable, make: makeMetaTable };
function log2(v) {
  return Math.log(v) / Math.log(2) | 0;
}
function computeCheckSum(bytes) {
  while (bytes.length % 4 !== 0) {
    bytes.push(0);
  }
  var sum = 0;
  for (var i3 = 0; i3 < bytes.length; i3 += 4) {
    sum += (bytes[i3] << 24) + (bytes[i3 + 1] << 16) + (bytes[i3 + 2] << 8) + bytes[i3 + 3];
  }
  sum %= Math.pow(2, 32);
  return sum;
}
function makeTableRecord(tag, checkSum, offset, length) {
  return new table.Record("Table Record", [
    { name: "tag", type: "TAG", value: tag !== void 0 ? tag : "" },
    { name: "checkSum", type: "ULONG", value: checkSum !== void 0 ? checkSum : 0 },
    { name: "offset", type: "ULONG", value: offset !== void 0 ? offset : 0 },
    { name: "length", type: "ULONG", value: length !== void 0 ? length : 0 }
  ]);
}
function makeSfntTable(tables) {
  var sfnt2 = new table.Table("sfnt", [
    { name: "version", type: "TAG", value: "OTTO" },
    { name: "numTables", type: "USHORT", value: 0 },
    { name: "searchRange", type: "USHORT", value: 0 },
    { name: "entrySelector", type: "USHORT", value: 0 },
    { name: "rangeShift", type: "USHORT", value: 0 }
  ]);
  sfnt2.tables = tables;
  sfnt2.numTables = tables.length;
  var highestPowerOf2 = Math.pow(2, log2(sfnt2.numTables));
  sfnt2.searchRange = 16 * highestPowerOf2;
  sfnt2.entrySelector = log2(highestPowerOf2);
  sfnt2.rangeShift = sfnt2.numTables * 16 - sfnt2.searchRange;
  var recordFields = [];
  var tableFields = [];
  var offset = sfnt2.sizeOf() + makeTableRecord().sizeOf() * sfnt2.numTables;
  while (offset % 4 !== 0) {
    offset += 1;
    tableFields.push({ name: "padding", type: "BYTE", value: 0 });
  }
  for (var i3 = 0; i3 < tables.length; i3 += 1) {
    var t2 = tables[i3];
    check.argument(t2.tableName.length === 4, "Table name" + t2.tableName + " is invalid.");
    var tableLength = t2.sizeOf();
    var tableRecord = makeTableRecord(t2.tableName, computeCheckSum(t2.encode()), offset, tableLength);
    recordFields.push({ name: tableRecord.tag + " Table Record", type: "RECORD", value: tableRecord });
    tableFields.push({ name: t2.tableName + " table", type: "RECORD", value: t2 });
    offset += tableLength;
    check.argument(!isNaN(offset), "Something went wrong calculating the offset.");
    while (offset % 4 !== 0) {
      offset += 1;
      tableFields.push({ name: "padding", type: "BYTE", value: 0 });
    }
  }
  recordFields.sort(function(r1, r2) {
    if (r1.value.tag > r2.value.tag) {
      return 1;
    } else {
      return -1;
    }
  });
  sfnt2.fields = sfnt2.fields.concat(recordFields);
  sfnt2.fields = sfnt2.fields.concat(tableFields);
  return sfnt2;
}
function metricsForChar(font, chars, notFoundMetrics) {
  for (var i3 = 0; i3 < chars.length; i3 += 1) {
    var glyphIndex = font.charToGlyphIndex(chars[i3]);
    if (glyphIndex > 0) {
      var glyph = font.glyphs.get(glyphIndex);
      return glyph.getMetrics();
    }
  }
  return notFoundMetrics;
}
function average(vs) {
  var sum = 0;
  for (var i3 = 0; i3 < vs.length; i3 += 1) {
    sum += vs[i3];
  }
  return sum / vs.length;
}
function fontToSfntTable(font) {
  var xMins = [];
  var yMins = [];
  var xMaxs = [];
  var yMaxs = [];
  var advanceWidths = [];
  var leftSideBearings = [];
  var rightSideBearings = [];
  var firstCharIndex;
  var lastCharIndex = 0;
  var ulUnicodeRange1 = 0;
  var ulUnicodeRange2 = 0;
  var ulUnicodeRange3 = 0;
  var ulUnicodeRange4 = 0;
  for (var i3 = 0; i3 < font.glyphs.length; i3 += 1) {
    var glyph = font.glyphs.get(i3);
    var unicode = glyph.unicode | 0;
    if (isNaN(glyph.advanceWidth)) {
      throw new Error("Glyph " + glyph.name + " (" + i3 + "): advanceWidth is not a number.");
    }
    if (firstCharIndex > unicode || firstCharIndex === void 0) {
      if (unicode > 0) {
        firstCharIndex = unicode;
      }
    }
    if (lastCharIndex < unicode) {
      lastCharIndex = unicode;
    }
    var position = os2.getUnicodeRange(unicode);
    if (position < 32) {
      ulUnicodeRange1 |= 1 << position;
    } else if (position < 64) {
      ulUnicodeRange2 |= 1 << position - 32;
    } else if (position < 96) {
      ulUnicodeRange3 |= 1 << position - 64;
    } else if (position < 123) {
      ulUnicodeRange4 |= 1 << position - 96;
    } else {
      throw new Error("Unicode ranges bits > 123 are reserved for internal usage");
    }
    if (glyph.name === ".notdef") {
      continue;
    }
    var metrics = glyph.getMetrics();
    xMins.push(metrics.xMin);
    yMins.push(metrics.yMin);
    xMaxs.push(metrics.xMax);
    yMaxs.push(metrics.yMax);
    leftSideBearings.push(metrics.leftSideBearing);
    rightSideBearings.push(metrics.rightSideBearing);
    advanceWidths.push(glyph.advanceWidth);
  }
  var globals = {
    xMin: Math.min.apply(null, xMins),
    yMin: Math.min.apply(null, yMins),
    xMax: Math.max.apply(null, xMaxs),
    yMax: Math.max.apply(null, yMaxs),
    advanceWidthMax: Math.max.apply(null, advanceWidths),
    advanceWidthAvg: average(advanceWidths),
    minLeftSideBearing: Math.min.apply(null, leftSideBearings),
    maxLeftSideBearing: Math.max.apply(null, leftSideBearings),
    minRightSideBearing: Math.min.apply(null, rightSideBearings)
  };
  globals.ascender = font.ascender;
  globals.descender = font.descender;
  var headTable = head.make({
    flags: 3,
    // 00000011 (baseline for font at y=0; left sidebearing point at x=0)
    unitsPerEm: font.unitsPerEm,
    xMin: globals.xMin,
    yMin: globals.yMin,
    xMax: globals.xMax,
    yMax: globals.yMax,
    lowestRecPPEM: 3,
    createdTimestamp: font.createdTimestamp
  });
  var hheaTable = hhea.make({
    ascender: globals.ascender,
    descender: globals.descender,
    advanceWidthMax: globals.advanceWidthMax,
    minLeftSideBearing: globals.minLeftSideBearing,
    minRightSideBearing: globals.minRightSideBearing,
    xMaxExtent: globals.maxLeftSideBearing + (globals.xMax - globals.xMin),
    numberOfHMetrics: font.glyphs.length
  });
  var maxpTable = maxp.make(font.glyphs.length);
  var os2Table = os2.make(Object.assign({
    xAvgCharWidth: Math.round(globals.advanceWidthAvg),
    usFirstCharIndex: firstCharIndex,
    usLastCharIndex: lastCharIndex,
    ulUnicodeRange1,
    ulUnicodeRange2,
    ulUnicodeRange3,
    ulUnicodeRange4,
    // See http://typophile.com/node/13081 for more info on vertical metrics.
    // We get metrics for typical characters (such as "x" for xHeight).
    // We provide some fallback characters if characters are unavailable: their
    // ordering was chosen experimentally.
    sTypoAscender: globals.ascender,
    sTypoDescender: globals.descender,
    sTypoLineGap: 0,
    usWinAscent: globals.yMax,
    usWinDescent: Math.abs(globals.yMin),
    ulCodePageRange1: 1,
    // FIXME: hard-code Latin 1 support for now
    sxHeight: metricsForChar(font, "xyvw", { yMax: Math.round(globals.ascender / 2) }).yMax,
    sCapHeight: metricsForChar(font, "HIKLEFJMNTZBDPRAGOQSUVWXY", globals).yMax,
    usDefaultChar: font.hasChar(" ") ? 32 : 0,
    // Use space as the default character, if available.
    usBreakChar: font.hasChar(" ") ? 32 : 0
    // Use space as the break character, if available.
  }, font.tables.os2));
  var hmtxTable = hmtx.make(font.glyphs);
  var cmapTable = cmap.make(font.glyphs);
  var englishFamilyName = font.getEnglishName("fontFamily");
  var englishStyleName = font.getEnglishName("fontSubfamily");
  var englishFullName = englishFamilyName + " " + englishStyleName;
  var postScriptName = font.getEnglishName("postScriptName");
  if (!postScriptName) {
    postScriptName = englishFamilyName.replace(/\s/g, "") + "-" + englishStyleName;
  }
  var names = {};
  for (var n in font.names) {
    names[n] = font.names[n];
  }
  if (!names.uniqueID) {
    names.uniqueID = { en: font.getEnglishName("manufacturer") + ":" + englishFullName };
  }
  if (!names.postScriptName) {
    names.postScriptName = { en: postScriptName };
  }
  if (!names.preferredFamily) {
    names.preferredFamily = font.names.fontFamily;
  }
  if (!names.preferredSubfamily) {
    names.preferredSubfamily = font.names.fontSubfamily;
  }
  var languageTags = [];
  var nameTable = _name.make(names, languageTags);
  var ltagTable = languageTags.length > 0 ? ltag.make(languageTags) : void 0;
  var postTable = post.make();
  var cffTable = cff.make(font.glyphs, {
    version: font.getEnglishName("version"),
    fullName: englishFullName,
    familyName: englishFamilyName,
    weightName: englishStyleName,
    postScriptName,
    unitsPerEm: font.unitsPerEm,
    fontBBox: [0, globals.yMin, globals.ascender, globals.advanceWidthMax]
  });
  var metaTable = font.metas && Object.keys(font.metas).length > 0 ? meta.make(font.metas) : void 0;
  var tables = [headTable, hheaTable, maxpTable, os2Table, nameTable, cmapTable, postTable, cffTable, hmtxTable];
  if (ltagTable) {
    tables.push(ltagTable);
  }
  if (font.tables.gsub) {
    tables.push(gsub.make(font.tables.gsub));
  }
  if (metaTable) {
    tables.push(metaTable);
  }
  var sfntTable = makeSfntTable(tables);
  var bytes = sfntTable.encode();
  var checkSum = computeCheckSum(bytes);
  var tableFields = sfntTable.fields;
  var checkSumAdjusted = false;
  for (var i$1 = 0; i$1 < tableFields.length; i$1 += 1) {
    if (tableFields[i$1].name === "head table") {
      tableFields[i$1].value.checkSumAdjustment = 2981146554 - checkSum;
      checkSumAdjusted = true;
      break;
    }
  }
  if (!checkSumAdjusted) {
    throw new Error("Could not find head table with checkSum to adjust.");
  }
  return sfntTable;
}
var sfnt = { make: makeSfntTable, fontToTable: fontToSfntTable, computeCheckSum };
function searchTag(arr, tag) {
  var imin = 0;
  var imax = arr.length - 1;
  while (imin <= imax) {
    var imid = imin + imax >>> 1;
    var val = arr[imid].tag;
    if (val === tag) {
      return imid;
    } else if (val < tag) {
      imin = imid + 1;
    } else {
      imax = imid - 1;
    }
  }
  return -imin - 1;
}
function binSearch(arr, value) {
  var imin = 0;
  var imax = arr.length - 1;
  while (imin <= imax) {
    var imid = imin + imax >>> 1;
    var val = arr[imid];
    if (val === value) {
      return imid;
    } else if (val < value) {
      imin = imid + 1;
    } else {
      imax = imid - 1;
    }
  }
  return -imin - 1;
}
function searchRange(ranges, value) {
  var range2;
  var imin = 0;
  var imax = ranges.length - 1;
  while (imin <= imax) {
    var imid = imin + imax >>> 1;
    range2 = ranges[imid];
    var start = range2.start;
    if (start === value) {
      return range2;
    } else if (start < value) {
      imin = imid + 1;
    } else {
      imax = imid - 1;
    }
  }
  if (imin > 0) {
    range2 = ranges[imin - 1];
    if (value > range2.end) {
      return 0;
    }
    return range2;
  }
}
function Layout(font, tableName) {
  this.font = font;
  this.tableName = tableName;
}
Layout.prototype = {
  /**
   * Binary search an object by "tag" property
   * @instance
   * @function searchTag
   * @memberof opentype.Layout
   * @param  {Array} arr
   * @param  {string} tag
   * @return {number}
   */
  searchTag,
  /**
   * Binary search in a list of numbers
   * @instance
   * @function binSearch
   * @memberof opentype.Layout
   * @param  {Array} arr
   * @param  {number} value
   * @return {number}
   */
  binSearch,
  /**
   * Get or create the Layout table (GSUB, GPOS etc).
   * @param  {boolean} create - Whether to create a new one.
   * @return {Object} The GSUB or GPOS table.
   */
  getTable: function(create) {
    var layout = this.font.tables[this.tableName];
    if (!layout && create) {
      layout = this.font.tables[this.tableName] = this.createDefaultTable();
    }
    return layout;
  },
  /**
   * Returns all scripts in the substitution table.
   * @instance
   * @return {Array}
   */
  getScriptNames: function() {
    var layout = this.getTable();
    if (!layout) {
      return [];
    }
    return layout.scripts.map(function(script) {
      return script.tag;
    });
  },
  /**
   * Returns the best bet for a script name.
   * Returns 'DFLT' if it exists.
   * If not, returns 'latn' if it exists.
   * If neither exist, returns undefined.
   */
  getDefaultScriptName: function() {
    var layout = this.getTable();
    if (!layout) {
      return;
    }
    var hasLatn = false;
    for (var i3 = 0; i3 < layout.scripts.length; i3++) {
      var name = layout.scripts[i3].tag;
      if (name === "DFLT") {
        return name;
      }
      if (name === "latn") {
        hasLatn = true;
      }
    }
    if (hasLatn) {
      return "latn";
    }
  },
  /**
   * Returns all LangSysRecords in the given script.
   * @instance
   * @param {string} [script='DFLT']
   * @param {boolean} create - forces the creation of this script table if it doesn't exist.
   * @return {Object} An object with tag and script properties.
   */
  getScriptTable: function(script, create) {
    var layout = this.getTable(create);
    if (layout) {
      script = script || "DFLT";
      var scripts = layout.scripts;
      var pos = searchTag(layout.scripts, script);
      if (pos >= 0) {
        return scripts[pos].script;
      } else if (create) {
        var scr = {
          tag: script,
          script: {
            defaultLangSys: { reserved: 0, reqFeatureIndex: 65535, featureIndexes: [] },
            langSysRecords: []
          }
        };
        scripts.splice(-1 - pos, 0, scr);
        return scr.script;
      }
    }
  },
  /**
   * Returns a language system table
   * @instance
   * @param {string} [script='DFLT']
   * @param {string} [language='dlft']
   * @param {boolean} create - forces the creation of this langSysTable if it doesn't exist.
   * @return {Object}
   */
  getLangSysTable: function(script, language, create) {
    var scriptTable = this.getScriptTable(script, create);
    if (scriptTable) {
      if (!language || language === "dflt" || language === "DFLT") {
        return scriptTable.defaultLangSys;
      }
      var pos = searchTag(scriptTable.langSysRecords, language);
      if (pos >= 0) {
        return scriptTable.langSysRecords[pos].langSys;
      } else if (create) {
        var langSysRecord = {
          tag: language,
          langSys: { reserved: 0, reqFeatureIndex: 65535, featureIndexes: [] }
        };
        scriptTable.langSysRecords.splice(-1 - pos, 0, langSysRecord);
        return langSysRecord.langSys;
      }
    }
  },
  /**
   * Get a specific feature table.
   * @instance
   * @param {string} [script='DFLT']
   * @param {string} [language='dlft']
   * @param {string} feature - One of the codes listed at https://www.microsoft.com/typography/OTSPEC/featurelist.htm
   * @param {boolean} create - forces the creation of the feature table if it doesn't exist.
   * @return {Object}
   */
  getFeatureTable: function(script, language, feature, create) {
    var langSysTable2 = this.getLangSysTable(script, language, create);
    if (langSysTable2) {
      var featureRecord;
      var featIndexes = langSysTable2.featureIndexes;
      var allFeatures = this.font.tables[this.tableName].features;
      for (var i3 = 0; i3 < featIndexes.length; i3++) {
        featureRecord = allFeatures[featIndexes[i3]];
        if (featureRecord.tag === feature) {
          return featureRecord.feature;
        }
      }
      if (create) {
        var index = allFeatures.length;
        check.assert(index === 0 || feature >= allFeatures[index - 1].tag, "Features must be added in alphabetical order.");
        featureRecord = {
          tag: feature,
          feature: { params: 0, lookupListIndexes: [] }
        };
        allFeatures.push(featureRecord);
        featIndexes.push(index);
        return featureRecord.feature;
      }
    }
  },
  /**
   * Get the lookup tables of a given type for a script/language/feature.
   * @instance
   * @param {string} [script='DFLT']
   * @param {string} [language='dlft']
   * @param {string} feature - 4-letter feature code
   * @param {number} lookupType - 1 to 9
   * @param {boolean} create - forces the creation of the lookup table if it doesn't exist, with no subtables.
   * @return {Object[]}
   */
  getLookupTables: function(script, language, feature, lookupType, create) {
    var featureTable = this.getFeatureTable(script, language, feature, create);
    var tables = [];
    if (featureTable) {
      var lookupTable;
      var lookupListIndexes = featureTable.lookupListIndexes;
      var allLookups = this.font.tables[this.tableName].lookups;
      for (var i3 = 0; i3 < lookupListIndexes.length; i3++) {
        lookupTable = allLookups[lookupListIndexes[i3]];
        if (lookupTable.lookupType === lookupType) {
          tables.push(lookupTable);
        }
      }
      if (tables.length === 0 && create) {
        lookupTable = {
          lookupType,
          lookupFlag: 0,
          subtables: [],
          markFilteringSet: void 0
        };
        var index = allLookups.length;
        allLookups.push(lookupTable);
        lookupListIndexes.push(index);
        return [lookupTable];
      }
    }
    return tables;
  },
  /**
   * Find a glyph in a class definition table
   * https://docs.microsoft.com/en-us/typography/opentype/spec/chapter2#class-definition-table
   * @param {object} classDefTable - an OpenType Layout class definition table
   * @param {number} glyphIndex - the index of the glyph to find
   * @returns {number} -1 if not found
   */
  getGlyphClass: function(classDefTable, glyphIndex) {
    switch (classDefTable.format) {
      case 1:
        if (classDefTable.startGlyph <= glyphIndex && glyphIndex < classDefTable.startGlyph + classDefTable.classes.length) {
          return classDefTable.classes[glyphIndex - classDefTable.startGlyph];
        }
        return 0;
      case 2:
        var range2 = searchRange(classDefTable.ranges, glyphIndex);
        return range2 ? range2.classId : 0;
    }
  },
  /**
   * Find a glyph in a coverage table
   * https://docs.microsoft.com/en-us/typography/opentype/spec/chapter2#coverage-table
   * @param {object} coverageTable - an OpenType Layout coverage table
   * @param {number} glyphIndex - the index of the glyph to find
   * @returns {number} -1 if not found
   */
  getCoverageIndex: function(coverageTable, glyphIndex) {
    switch (coverageTable.format) {
      case 1:
        var index = binSearch(coverageTable.glyphs, glyphIndex);
        return index >= 0 ? index : -1;
      case 2:
        var range2 = searchRange(coverageTable.ranges, glyphIndex);
        return range2 ? range2.index + glyphIndex - range2.start : -1;
    }
  },
  /**
   * Returns the list of glyph indexes of a coverage table.
   * Format 1: the list is stored raw
   * Format 2: compact list as range records.
   * @instance
   * @param  {Object} coverageTable
   * @return {Array}
   */
  expandCoverage: function(coverageTable) {
    if (coverageTable.format === 1) {
      return coverageTable.glyphs;
    } else {
      var glyphs = [];
      var ranges = coverageTable.ranges;
      for (var i3 = 0; i3 < ranges.length; i3++) {
        var range2 = ranges[i3];
        var start = range2.start;
        var end = range2.end;
        for (var j = start; j <= end; j++) {
          glyphs.push(j);
        }
      }
      return glyphs;
    }
  }
};
function Position(font) {
  Layout.call(this, font, "gpos");
}
Position.prototype = Layout.prototype;
Position.prototype.init = function() {
  var script = this.getDefaultScriptName();
  this.defaultKerningTables = this.getKerningTables(script);
};
Position.prototype.getKerningValue = function(kerningLookups, leftIndex, rightIndex) {
  for (var i3 = 0; i3 < kerningLookups.length; i3++) {
    var subtables = kerningLookups[i3].subtables;
    for (var j = 0; j < subtables.length; j++) {
      var subtable = subtables[j];
      var covIndex = this.getCoverageIndex(subtable.coverage, leftIndex);
      if (covIndex < 0) {
        continue;
      }
      switch (subtable.posFormat) {
        case 1:
          var pairSet = subtable.pairSets[covIndex];
          for (var k = 0; k < pairSet.length; k++) {
            var pair = pairSet[k];
            if (pair.secondGlyph === rightIndex) {
              return pair.value1 && pair.value1.xAdvance || 0;
            }
          }
          break;
        case 2:
          var class1 = this.getGlyphClass(subtable.classDef1, leftIndex);
          var class2 = this.getGlyphClass(subtable.classDef2, rightIndex);
          var pair$1 = subtable.classRecords[class1][class2];
          return pair$1.value1 && pair$1.value1.xAdvance || 0;
      }
    }
  }
  return 0;
};
Position.prototype.getKerningTables = function(script, language) {
  if (this.font.tables.gpos) {
    return this.getLookupTables(script, language, "kern", 2);
  }
};
function Substitution(font) {
  Layout.call(this, font, "gsub");
}
function arraysEqual(ar1, ar2) {
  var n = ar1.length;
  if (n !== ar2.length) {
    return false;
  }
  for (var i3 = 0; i3 < n; i3++) {
    if (ar1[i3] !== ar2[i3]) {
      return false;
    }
  }
  return true;
}
function getSubstFormat(lookupTable, format, defaultSubtable) {
  var subtables = lookupTable.subtables;
  for (var i3 = 0; i3 < subtables.length; i3++) {
    var subtable = subtables[i3];
    if (subtable.substFormat === format) {
      return subtable;
    }
  }
  if (defaultSubtable) {
    subtables.push(defaultSubtable);
    return defaultSubtable;
  }
  return void 0;
}
Substitution.prototype = Layout.prototype;
Substitution.prototype.createDefaultTable = function() {
  return {
    version: 1,
    scripts: [{
      tag: "DFLT",
      script: {
        defaultLangSys: { reserved: 0, reqFeatureIndex: 65535, featureIndexes: [] },
        langSysRecords: []
      }
    }],
    features: [],
    lookups: []
  };
};
Substitution.prototype.getSingle = function(feature, script, language) {
  var substitutions = [];
  var lookupTables = this.getLookupTables(script, language, feature, 1);
  for (var idx = 0; idx < lookupTables.length; idx++) {
    var subtables = lookupTables[idx].subtables;
    for (var i3 = 0; i3 < subtables.length; i3++) {
      var subtable = subtables[i3];
      var glyphs = this.expandCoverage(subtable.coverage);
      var j = void 0;
      if (subtable.substFormat === 1) {
        var delta = subtable.deltaGlyphId;
        for (j = 0; j < glyphs.length; j++) {
          var glyph = glyphs[j];
          substitutions.push({ sub: glyph, by: glyph + delta });
        }
      } else {
        var substitute = subtable.substitute;
        for (j = 0; j < glyphs.length; j++) {
          substitutions.push({ sub: glyphs[j], by: substitute[j] });
        }
      }
    }
  }
  return substitutions;
};
Substitution.prototype.getMultiple = function(feature, script, language) {
  var substitutions = [];
  var lookupTables = this.getLookupTables(script, language, feature, 2);
  for (var idx = 0; idx < lookupTables.length; idx++) {
    var subtables = lookupTables[idx].subtables;
    for (var i3 = 0; i3 < subtables.length; i3++) {
      var subtable = subtables[i3];
      var glyphs = this.expandCoverage(subtable.coverage);
      var j = void 0;
      for (j = 0; j < glyphs.length; j++) {
        var glyph = glyphs[j];
        var replacements = subtable.sequences[j];
        substitutions.push({ sub: glyph, by: replacements });
      }
    }
  }
  return substitutions;
};
Substitution.prototype.getAlternates = function(feature, script, language) {
  var alternates = [];
  var lookupTables = this.getLookupTables(script, language, feature, 3);
  for (var idx = 0; idx < lookupTables.length; idx++) {
    var subtables = lookupTables[idx].subtables;
    for (var i3 = 0; i3 < subtables.length; i3++) {
      var subtable = subtables[i3];
      var glyphs = this.expandCoverage(subtable.coverage);
      var alternateSets = subtable.alternateSets;
      for (var j = 0; j < glyphs.length; j++) {
        alternates.push({ sub: glyphs[j], by: alternateSets[j] });
      }
    }
  }
  return alternates;
};
Substitution.prototype.getLigatures = function(feature, script, language) {
  var ligatures = [];
  var lookupTables = this.getLookupTables(script, language, feature, 4);
  for (var idx = 0; idx < lookupTables.length; idx++) {
    var subtables = lookupTables[idx].subtables;
    for (var i3 = 0; i3 < subtables.length; i3++) {
      var subtable = subtables[i3];
      var glyphs = this.expandCoverage(subtable.coverage);
      var ligatureSets = subtable.ligatureSets;
      for (var j = 0; j < glyphs.length; j++) {
        var startGlyph = glyphs[j];
        var ligSet = ligatureSets[j];
        for (var k = 0; k < ligSet.length; k++) {
          var lig = ligSet[k];
          ligatures.push({
            sub: [startGlyph].concat(lig.components),
            by: lig.ligGlyph
          });
        }
      }
    }
  }
  return ligatures;
};
Substitution.prototype.addSingle = function(feature, substitution, script, language) {
  var lookupTable = this.getLookupTables(script, language, feature, 1, true)[0];
  var subtable = getSubstFormat(lookupTable, 2, {
    // lookup type 1 subtable, format 2, coverage format 1
    substFormat: 2,
    coverage: { format: 1, glyphs: [] },
    substitute: []
  });
  check.assert(subtable.coverage.format === 1, "Single: unable to modify coverage table format " + subtable.coverage.format);
  var coverageGlyph = substitution.sub;
  var pos = this.binSearch(subtable.coverage.glyphs, coverageGlyph);
  if (pos < 0) {
    pos = -1 - pos;
    subtable.coverage.glyphs.splice(pos, 0, coverageGlyph);
    subtable.substitute.splice(pos, 0, 0);
  }
  subtable.substitute[pos] = substitution.by;
};
Substitution.prototype.addMultiple = function(feature, substitution, script, language) {
  check.assert(substitution.by instanceof Array && substitution.by.length > 1, 'Multiple: "by" must be an array of two or more ids');
  var lookupTable = this.getLookupTables(script, language, feature, 2, true)[0];
  var subtable = getSubstFormat(lookupTable, 1, {
    // lookup type 2 subtable, format 1, coverage format 1
    substFormat: 1,
    coverage: { format: 1, glyphs: [] },
    sequences: []
  });
  check.assert(subtable.coverage.format === 1, "Multiple: unable to modify coverage table format " + subtable.coverage.format);
  var coverageGlyph = substitution.sub;
  var pos = this.binSearch(subtable.coverage.glyphs, coverageGlyph);
  if (pos < 0) {
    pos = -1 - pos;
    subtable.coverage.glyphs.splice(pos, 0, coverageGlyph);
    subtable.sequences.splice(pos, 0, 0);
  }
  subtable.sequences[pos] = substitution.by;
};
Substitution.prototype.addAlternate = function(feature, substitution, script, language) {
  var lookupTable = this.getLookupTables(script, language, feature, 3, true)[0];
  var subtable = getSubstFormat(lookupTable, 1, {
    // lookup type 3 subtable, format 1, coverage format 1
    substFormat: 1,
    coverage: { format: 1, glyphs: [] },
    alternateSets: []
  });
  check.assert(subtable.coverage.format === 1, "Alternate: unable to modify coverage table format " + subtable.coverage.format);
  var coverageGlyph = substitution.sub;
  var pos = this.binSearch(subtable.coverage.glyphs, coverageGlyph);
  if (pos < 0) {
    pos = -1 - pos;
    subtable.coverage.glyphs.splice(pos, 0, coverageGlyph);
    subtable.alternateSets.splice(pos, 0, 0);
  }
  subtable.alternateSets[pos] = substitution.by;
};
Substitution.prototype.addLigature = function(feature, ligature, script, language) {
  var lookupTable = this.getLookupTables(script, language, feature, 4, true)[0];
  var subtable = lookupTable.subtables[0];
  if (!subtable) {
    subtable = {
      // lookup type 4 subtable, format 1, coverage format 1
      substFormat: 1,
      coverage: { format: 1, glyphs: [] },
      ligatureSets: []
    };
    lookupTable.subtables[0] = subtable;
  }
  check.assert(subtable.coverage.format === 1, "Ligature: unable to modify coverage table format " + subtable.coverage.format);
  var coverageGlyph = ligature.sub[0];
  var ligComponents = ligature.sub.slice(1);
  var ligatureTable = {
    ligGlyph: ligature.by,
    components: ligComponents
  };
  var pos = this.binSearch(subtable.coverage.glyphs, coverageGlyph);
  if (pos >= 0) {
    var ligatureSet = subtable.ligatureSets[pos];
    for (var i3 = 0; i3 < ligatureSet.length; i3++) {
      if (arraysEqual(ligatureSet[i3].components, ligComponents)) {
        return;
      }
    }
    ligatureSet.push(ligatureTable);
  } else {
    pos = -1 - pos;
    subtable.coverage.glyphs.splice(pos, 0, coverageGlyph);
    subtable.ligatureSets.splice(pos, 0, [ligatureTable]);
  }
};
Substitution.prototype.getFeature = function(feature, script, language) {
  if (/ss\d\d/.test(feature)) {
    return this.getSingle(feature, script, language);
  }
  switch (feature) {
    case "aalt":
    case "salt":
      return this.getSingle(feature, script, language).concat(this.getAlternates(feature, script, language));
    case "dlig":
    case "liga":
    case "rlig":
      return this.getLigatures(feature, script, language);
    case "ccmp":
      return this.getMultiple(feature, script, language).concat(this.getLigatures(feature, script, language));
    case "stch":
      return this.getMultiple(feature, script, language);
  }
  return void 0;
};
Substitution.prototype.add = function(feature, sub, script, language) {
  if (/ss\d\d/.test(feature)) {
    return this.addSingle(feature, sub, script, language);
  }
  switch (feature) {
    case "aalt":
    case "salt":
      if (typeof sub.by === "number") {
        return this.addSingle(feature, sub, script, language);
      }
      return this.addAlternate(feature, sub, script, language);
    case "dlig":
    case "liga":
    case "rlig":
      return this.addLigature(feature, sub, script, language);
    case "ccmp":
      if (sub.by instanceof Array) {
        return this.addMultiple(feature, sub, script, language);
      }
      return this.addLigature(feature, sub, script, language);
  }
  return void 0;
};
function isBrowser() {
  return typeof window !== "undefined";
}
function nodeBufferToArrayBuffer(buffer) {
  var ab3 = new ArrayBuffer(buffer.length);
  var view = new Uint8Array(ab3);
  for (var i3 = 0; i3 < buffer.length; ++i3) {
    view[i3] = buffer[i3];
  }
  return ab3;
}
function arrayBufferToNodeBuffer(ab3) {
  var buffer = new Buffer(ab3.byteLength);
  var view = new Uint8Array(ab3);
  for (var i3 = 0; i3 < buffer.length; ++i3) {
    buffer[i3] = view[i3];
  }
  return buffer;
}
function checkArgument(expression, message) {
  if (!expression) {
    throw message;
  }
}
function parseGlyphCoordinate(p, flag, previousValue, shortVectorBitMask, sameBitMask) {
  var v;
  if ((flag & shortVectorBitMask) > 0) {
    v = p.parseByte();
    if ((flag & sameBitMask) === 0) {
      v = -v;
    }
    v = previousValue + v;
  } else {
    if ((flag & sameBitMask) > 0) {
      v = previousValue;
    } else {
      v = previousValue + p.parseShort();
    }
  }
  return v;
}
function parseGlyph(glyph, data, start) {
  var p = new parse.Parser(data, start);
  glyph.numberOfContours = p.parseShort();
  glyph._xMin = p.parseShort();
  glyph._yMin = p.parseShort();
  glyph._xMax = p.parseShort();
  glyph._yMax = p.parseShort();
  var flags;
  var flag;
  if (glyph.numberOfContours > 0) {
    var endPointIndices = glyph.endPointIndices = [];
    for (var i3 = 0; i3 < glyph.numberOfContours; i3 += 1) {
      endPointIndices.push(p.parseUShort());
    }
    glyph.instructionLength = p.parseUShort();
    glyph.instructions = [];
    for (var i$1 = 0; i$1 < glyph.instructionLength; i$1 += 1) {
      glyph.instructions.push(p.parseByte());
    }
    var numberOfCoordinates = endPointIndices[endPointIndices.length - 1] + 1;
    flags = [];
    for (var i$2 = 0; i$2 < numberOfCoordinates; i$2 += 1) {
      flag = p.parseByte();
      flags.push(flag);
      if ((flag & 8) > 0) {
        var repeatCount = p.parseByte();
        for (var j = 0; j < repeatCount; j += 1) {
          flags.push(flag);
          i$2 += 1;
        }
      }
    }
    check.argument(flags.length === numberOfCoordinates, "Bad flags.");
    if (endPointIndices.length > 0) {
      var points = [];
      var point;
      if (numberOfCoordinates > 0) {
        for (var i$3 = 0; i$3 < numberOfCoordinates; i$3 += 1) {
          flag = flags[i$3];
          point = {};
          point.onCurve = !!(flag & 1);
          point.lastPointOfContour = endPointIndices.indexOf(i$3) >= 0;
          points.push(point);
        }
        var px = 0;
        for (var i$4 = 0; i$4 < numberOfCoordinates; i$4 += 1) {
          flag = flags[i$4];
          point = points[i$4];
          point.x = parseGlyphCoordinate(p, flag, px, 2, 16);
          px = point.x;
        }
        var py = 0;
        for (var i$5 = 0; i$5 < numberOfCoordinates; i$5 += 1) {
          flag = flags[i$5];
          point = points[i$5];
          point.y = parseGlyphCoordinate(p, flag, py, 4, 32);
          py = point.y;
        }
      }
      glyph.points = points;
    } else {
      glyph.points = [];
    }
  } else if (glyph.numberOfContours === 0) {
    glyph.points = [];
  } else {
    glyph.isComposite = true;
    glyph.points = [];
    glyph.components = [];
    var moreComponents = true;
    while (moreComponents) {
      flags = p.parseUShort();
      var component = {
        glyphIndex: p.parseUShort(),
        xScale: 1,
        scale01: 0,
        scale10: 0,
        yScale: 1,
        dx: 0,
        dy: 0
      };
      if ((flags & 1) > 0) {
        if ((flags & 2) > 0) {
          component.dx = p.parseShort();
          component.dy = p.parseShort();
        } else {
          component.matchedPoints = [p.parseUShort(), p.parseUShort()];
        }
      } else {
        if ((flags & 2) > 0) {
          component.dx = p.parseChar();
          component.dy = p.parseChar();
        } else {
          component.matchedPoints = [p.parseByte(), p.parseByte()];
        }
      }
      if ((flags & 8) > 0) {
        component.xScale = component.yScale = p.parseF2Dot14();
      } else if ((flags & 64) > 0) {
        component.xScale = p.parseF2Dot14();
        component.yScale = p.parseF2Dot14();
      } else if ((flags & 128) > 0) {
        component.xScale = p.parseF2Dot14();
        component.scale01 = p.parseF2Dot14();
        component.scale10 = p.parseF2Dot14();
        component.yScale = p.parseF2Dot14();
      }
      glyph.components.push(component);
      moreComponents = !!(flags & 32);
    }
    if (flags & 256) {
      glyph.instructionLength = p.parseUShort();
      glyph.instructions = [];
      for (var i$6 = 0; i$6 < glyph.instructionLength; i$6 += 1) {
        glyph.instructions.push(p.parseByte());
      }
    }
  }
}
function transformPoints(points, transform) {
  var newPoints = [];
  for (var i3 = 0; i3 < points.length; i3 += 1) {
    var pt = points[i3];
    var newPt = {
      x: transform.xScale * pt.x + transform.scale01 * pt.y + transform.dx,
      y: transform.scale10 * pt.x + transform.yScale * pt.y + transform.dy,
      onCurve: pt.onCurve,
      lastPointOfContour: pt.lastPointOfContour
    };
    newPoints.push(newPt);
  }
  return newPoints;
}
function getContours(points) {
  var contours = [];
  var currentContour = [];
  for (var i3 = 0; i3 < points.length; i3 += 1) {
    var pt = points[i3];
    currentContour.push(pt);
    if (pt.lastPointOfContour) {
      contours.push(currentContour);
      currentContour = [];
    }
  }
  check.argument(currentContour.length === 0, "There are still points left in the current contour.");
  return contours;
}
function getPath(points) {
  var p = new Path2();
  if (!points) {
    return p;
  }
  var contours = getContours(points);
  for (var contourIndex = 0; contourIndex < contours.length; ++contourIndex) {
    var contour = contours[contourIndex];
    var prev = null;
    var curr = contour[contour.length - 1];
    var next = contour[0];
    if (curr.onCurve) {
      p.moveTo(curr.x, curr.y);
    } else {
      if (next.onCurve) {
        p.moveTo(next.x, next.y);
      } else {
        var start = { x: (curr.x + next.x) * 0.5, y: (curr.y + next.y) * 0.5 };
        p.moveTo(start.x, start.y);
      }
    }
    for (var i3 = 0; i3 < contour.length; ++i3) {
      prev = curr;
      curr = next;
      next = contour[(i3 + 1) % contour.length];
      if (curr.onCurve) {
        p.lineTo(curr.x, curr.y);
      } else {
        var prev2 = prev;
        var next2 = next;
        if (!prev.onCurve) {
          prev2 = { x: (curr.x + prev.x) * 0.5, y: (curr.y + prev.y) * 0.5 };
        }
        if (!next.onCurve) {
          next2 = { x: (curr.x + next.x) * 0.5, y: (curr.y + next.y) * 0.5 };
        }
        p.quadraticCurveTo(curr.x, curr.y, next2.x, next2.y);
      }
    }
    p.closePath();
  }
  return p;
}
function buildPath(glyphs, glyph) {
  if (glyph.isComposite) {
    for (var j = 0; j < glyph.components.length; j += 1) {
      var component = glyph.components[j];
      var componentGlyph = glyphs.get(component.glyphIndex);
      componentGlyph.getPath();
      if (componentGlyph.points) {
        var transformedPoints = void 0;
        if (component.matchedPoints === void 0) {
          transformedPoints = transformPoints(componentGlyph.points, component);
        } else {
          if (component.matchedPoints[0] > glyph.points.length - 1 || component.matchedPoints[1] > componentGlyph.points.length - 1) {
            throw Error("Matched points out of range in " + glyph.name);
          }
          var firstPt = glyph.points[component.matchedPoints[0]];
          var secondPt = componentGlyph.points[component.matchedPoints[1]];
          var transform = {
            xScale: component.xScale,
            scale01: component.scale01,
            scale10: component.scale10,
            yScale: component.yScale,
            dx: 0,
            dy: 0
          };
          secondPt = transformPoints([secondPt], transform)[0];
          transform.dx = firstPt.x - secondPt.x;
          transform.dy = firstPt.y - secondPt.y;
          transformedPoints = transformPoints(componentGlyph.points, transform);
        }
        glyph.points = glyph.points.concat(transformedPoints);
      }
    }
  }
  return getPath(glyph.points);
}
function parseGlyfTableAll(data, start, loca2, font) {
  var glyphs = new glyphset.GlyphSet(font);
  for (var i3 = 0; i3 < loca2.length - 1; i3 += 1) {
    var offset = loca2[i3];
    var nextOffset = loca2[i3 + 1];
    if (offset !== nextOffset) {
      glyphs.push(i3, glyphset.ttfGlyphLoader(font, i3, parseGlyph, data, start + offset, buildPath));
    } else {
      glyphs.push(i3, glyphset.glyphLoader(font, i3));
    }
  }
  return glyphs;
}
function parseGlyfTableOnLowMemory(data, start, loca2, font) {
  var glyphs = new glyphset.GlyphSet(font);
  font._push = function(i3) {
    var offset = loca2[i3];
    var nextOffset = loca2[i3 + 1];
    if (offset !== nextOffset) {
      glyphs.push(i3, glyphset.ttfGlyphLoader(font, i3, parseGlyph, data, start + offset, buildPath));
    } else {
      glyphs.push(i3, glyphset.glyphLoader(font, i3));
    }
  };
  return glyphs;
}
function parseGlyfTable(data, start, loca2, font, opt) {
  if (opt.lowMemory) {
    return parseGlyfTableOnLowMemory(data, start, loca2, font);
  } else {
    return parseGlyfTableAll(data, start, loca2, font);
  }
}
var glyf = { getPath, parse: parseGlyfTable };
var instructionTable;
var exec;
var execGlyph;
var execComponent;
function Hinting(font) {
  this.font = font;
  this.getCommands = function(hPoints) {
    return glyf.getPath(hPoints).commands;
  };
  this._fpgmState = this._prepState = void 0;
  this._errorState = 0;
}
function roundOff(v) {
  return v;
}
function roundToGrid(v) {
  return Math.sign(v) * Math.round(Math.abs(v));
}
function roundToDoubleGrid(v) {
  return Math.sign(v) * Math.round(Math.abs(v * 2)) / 2;
}
function roundToHalfGrid(v) {
  return Math.sign(v) * (Math.round(Math.abs(v) + 0.5) - 0.5);
}
function roundUpToGrid(v) {
  return Math.sign(v) * Math.ceil(Math.abs(v));
}
function roundDownToGrid(v) {
  return Math.sign(v) * Math.floor(Math.abs(v));
}
var roundSuper = function(v) {
  var period = this.srPeriod;
  var phase = this.srPhase;
  var threshold = this.srThreshold;
  var sign = 1;
  if (v < 0) {
    v = -v;
    sign = -1;
  }
  v += threshold - phase;
  v = Math.trunc(v / period) * period;
  v += phase;
  if (v < 0) {
    return phase * sign;
  }
  return v * sign;
};
var xUnitVector = {
  x: 1,
  y: 0,
  axis: "x",
  // Gets the projected distance between two points.
  // o1/o2 ... if true, respective original position is used.
  distance: function(p1, p2, o1, o2) {
    return (o1 ? p1.xo : p1.x) - (o2 ? p2.xo : p2.x);
  },
  // Moves point p so the moved position has the same relative
  // position to the moved positions of rp1 and rp2 than the
  // original positions had.
  //
  // See APPENDIX on INTERPOLATE at the bottom of this file.
  interpolate: function(p, rp1, rp2, pv) {
    var do1;
    var do2;
    var doa1;
    var doa2;
    var dm1;
    var dm2;
    var dt;
    if (!pv || pv === this) {
      do1 = p.xo - rp1.xo;
      do2 = p.xo - rp2.xo;
      dm1 = rp1.x - rp1.xo;
      dm2 = rp2.x - rp2.xo;
      doa1 = Math.abs(do1);
      doa2 = Math.abs(do2);
      dt = doa1 + doa2;
      if (dt === 0) {
        p.x = p.xo + (dm1 + dm2) / 2;
        return;
      }
      p.x = p.xo + (dm1 * doa2 + dm2 * doa1) / dt;
      return;
    }
    do1 = pv.distance(p, rp1, true, true);
    do2 = pv.distance(p, rp2, true, true);
    dm1 = pv.distance(rp1, rp1, false, true);
    dm2 = pv.distance(rp2, rp2, false, true);
    doa1 = Math.abs(do1);
    doa2 = Math.abs(do2);
    dt = doa1 + doa2;
    if (dt === 0) {
      xUnitVector.setRelative(p, p, (dm1 + dm2) / 2, pv, true);
      return;
    }
    xUnitVector.setRelative(p, p, (dm1 * doa2 + dm2 * doa1) / dt, pv, true);
  },
  // Slope of line normal to this
  normalSlope: Number.NEGATIVE_INFINITY,
  // Sets the point 'p' relative to point 'rp'
  // by the distance 'd'.
  //
  // See APPENDIX on SETRELATIVE at the bottom of this file.
  //
  // p   ... point to set
  // rp  ... reference point
  // d   ... distance on projection vector
  // pv  ... projection vector (undefined = this)
  // org ... if true, uses the original position of rp as reference.
  setRelative: function(p, rp, d, pv, org) {
    if (!pv || pv === this) {
      p.x = (org ? rp.xo : rp.x) + d;
      return;
    }
    var rpx = org ? rp.xo : rp.x;
    var rpy = org ? rp.yo : rp.y;
    var rpdx = rpx + d * pv.x;
    var rpdy = rpy + d * pv.y;
    p.x = rpdx + (p.y - rpdy) / pv.normalSlope;
  },
  // Slope of vector line.
  slope: 0,
  // Touches the point p.
  touch: function(p) {
    p.xTouched = true;
  },
  // Tests if a point p is touched.
  touched: function(p) {
    return p.xTouched;
  },
  // Untouches the point p.
  untouch: function(p) {
    p.xTouched = false;
  }
};
var yUnitVector = {
  x: 0,
  y: 1,
  axis: "y",
  // Gets the projected distance between two points.
  // o1/o2 ... if true, respective original position is used.
  distance: function(p1, p2, o1, o2) {
    return (o1 ? p1.yo : p1.y) - (o2 ? p2.yo : p2.y);
  },
  // Moves point p so the moved position has the same relative
  // position to the moved positions of rp1 and rp2 than the
  // original positions had.
  //
  // See APPENDIX on INTERPOLATE at the bottom of this file.
  interpolate: function(p, rp1, rp2, pv) {
    var do1;
    var do2;
    var doa1;
    var doa2;
    var dm1;
    var dm2;
    var dt;
    if (!pv || pv === this) {
      do1 = p.yo - rp1.yo;
      do2 = p.yo - rp2.yo;
      dm1 = rp1.y - rp1.yo;
      dm2 = rp2.y - rp2.yo;
      doa1 = Math.abs(do1);
      doa2 = Math.abs(do2);
      dt = doa1 + doa2;
      if (dt === 0) {
        p.y = p.yo + (dm1 + dm2) / 2;
        return;
      }
      p.y = p.yo + (dm1 * doa2 + dm2 * doa1) / dt;
      return;
    }
    do1 = pv.distance(p, rp1, true, true);
    do2 = pv.distance(p, rp2, true, true);
    dm1 = pv.distance(rp1, rp1, false, true);
    dm2 = pv.distance(rp2, rp2, false, true);
    doa1 = Math.abs(do1);
    doa2 = Math.abs(do2);
    dt = doa1 + doa2;
    if (dt === 0) {
      yUnitVector.setRelative(p, p, (dm1 + dm2) / 2, pv, true);
      return;
    }
    yUnitVector.setRelative(p, p, (dm1 * doa2 + dm2 * doa1) / dt, pv, true);
  },
  // Slope of line normal to this.
  normalSlope: 0,
  // Sets the point 'p' relative to point 'rp'
  // by the distance 'd'
  //
  // See APPENDIX on SETRELATIVE at the bottom of this file.
  //
  // p   ... point to set
  // rp  ... reference point
  // d   ... distance on projection vector
  // pv  ... projection vector (undefined = this)
  // org ... if true, uses the original position of rp as reference.
  setRelative: function(p, rp, d, pv, org) {
    if (!pv || pv === this) {
      p.y = (org ? rp.yo : rp.y) + d;
      return;
    }
    var rpx = org ? rp.xo : rp.x;
    var rpy = org ? rp.yo : rp.y;
    var rpdx = rpx + d * pv.x;
    var rpdy = rpy + d * pv.y;
    p.y = rpdy + pv.normalSlope * (p.x - rpdx);
  },
  // Slope of vector line.
  slope: Number.POSITIVE_INFINITY,
  // Touches the point p.
  touch: function(p) {
    p.yTouched = true;
  },
  // Tests if a point p is touched.
  touched: function(p) {
    return p.yTouched;
  },
  // Untouches the point p.
  untouch: function(p) {
    p.yTouched = false;
  }
};
Object.freeze(xUnitVector);
Object.freeze(yUnitVector);
function UnitVector(x, y) {
  this.x = x;
  this.y = y;
  this.axis = void 0;
  this.slope = y / x;
  this.normalSlope = -x / y;
  Object.freeze(this);
}
UnitVector.prototype.distance = function(p1, p2, o1, o2) {
  return this.x * xUnitVector.distance(p1, p2, o1, o2) + this.y * yUnitVector.distance(p1, p2, o1, o2);
};
UnitVector.prototype.interpolate = function(p, rp1, rp2, pv) {
  var dm1;
  var dm2;
  var do1;
  var do2;
  var doa1;
  var doa2;
  var dt;
  do1 = pv.distance(p, rp1, true, true);
  do2 = pv.distance(p, rp2, true, true);
  dm1 = pv.distance(rp1, rp1, false, true);
  dm2 = pv.distance(rp2, rp2, false, true);
  doa1 = Math.abs(do1);
  doa2 = Math.abs(do2);
  dt = doa1 + doa2;
  if (dt === 0) {
    this.setRelative(p, p, (dm1 + dm2) / 2, pv, true);
    return;
  }
  this.setRelative(p, p, (dm1 * doa2 + dm2 * doa1) / dt, pv, true);
};
UnitVector.prototype.setRelative = function(p, rp, d, pv, org) {
  pv = pv || this;
  var rpx = org ? rp.xo : rp.x;
  var rpy = org ? rp.yo : rp.y;
  var rpdx = rpx + d * pv.x;
  var rpdy = rpy + d * pv.y;
  var pvns = pv.normalSlope;
  var fvs = this.slope;
  var px = p.x;
  var py = p.y;
  p.x = (fvs * px - pvns * rpdx + rpdy - py) / (fvs - pvns);
  p.y = fvs * (p.x - px) + py;
};
UnitVector.prototype.touch = function(p) {
  p.xTouched = true;
  p.yTouched = true;
};
function getUnitVector(x, y) {
  var d = Math.sqrt(x * x + y * y);
  x /= d;
  y /= d;
  if (x === 1 && y === 0) {
    return xUnitVector;
  } else if (x === 0 && y === 1) {
    return yUnitVector;
  } else {
    return new UnitVector(x, y);
  }
}
function HPoint(x, y, lastPointOfContour, onCurve) {
  this.x = this.xo = Math.round(x * 64) / 64;
  this.y = this.yo = Math.round(y * 64) / 64;
  this.lastPointOfContour = lastPointOfContour;
  this.onCurve = onCurve;
  this.prevPointOnContour = void 0;
  this.nextPointOnContour = void 0;
  this.xTouched = false;
  this.yTouched = false;
  Object.preventExtensions(this);
}
HPoint.prototype.nextTouched = function(v) {
  var p = this.nextPointOnContour;
  while (!v.touched(p) && p !== this) {
    p = p.nextPointOnContour;
  }
  return p;
};
HPoint.prototype.prevTouched = function(v) {
  var p = this.prevPointOnContour;
  while (!v.touched(p) && p !== this) {
    p = p.prevPointOnContour;
  }
  return p;
};
var HPZero = Object.freeze(new HPoint(0, 0));
var defaultState = {
  cvCutIn: 17 / 16,
  // control value cut in
  deltaBase: 9,
  deltaShift: 0.125,
  loop: 1,
  // loops some instructions
  minDis: 1,
  // minimum distance
  autoFlip: true
};
function State(env, prog) {
  this.env = env;
  this.stack = [];
  this.prog = prog;
  switch (env) {
    case "glyf":
      this.zp0 = this.zp1 = this.zp2 = 1;
      this.rp0 = this.rp1 = this.rp2 = 0;
    case "prep":
      this.fv = this.pv = this.dpv = xUnitVector;
      this.round = roundToGrid;
  }
}
Hinting.prototype.exec = function(glyph, ppem) {
  if (typeof ppem !== "number") {
    throw new Error("Point size is not a number!");
  }
  if (this._errorState > 2) {
    return;
  }
  var font = this.font;
  var prepState = this._prepState;
  if (!prepState || prepState.ppem !== ppem) {
    var fpgmState = this._fpgmState;
    if (!fpgmState) {
      State.prototype = defaultState;
      fpgmState = this._fpgmState = new State("fpgm", font.tables.fpgm);
      fpgmState.funcs = [];
      fpgmState.font = font;
      if (exports.DEBUG) {
        console.log("---EXEC FPGM---");
        fpgmState.step = -1;
      }
      try {
        exec(fpgmState);
      } catch (e) {
        console.log("Hinting error in FPGM:" + e);
        this._errorState = 3;
        return;
      }
    }
    State.prototype = fpgmState;
    prepState = this._prepState = new State("prep", font.tables.prep);
    prepState.ppem = ppem;
    var oCvt = font.tables.cvt;
    if (oCvt) {
      var cvt = prepState.cvt = new Array(oCvt.length);
      var scale = ppem / font.unitsPerEm;
      for (var c3 = 0; c3 < oCvt.length; c3++) {
        cvt[c3] = oCvt[c3] * scale;
      }
    } else {
      prepState.cvt = [];
    }
    if (exports.DEBUG) {
      console.log("---EXEC PREP---");
      prepState.step = -1;
    }
    try {
      exec(prepState);
    } catch (e) {
      if (this._errorState < 2) {
        console.log("Hinting error in PREP:" + e);
      }
      this._errorState = 2;
    }
  }
  if (this._errorState > 1) {
    return;
  }
  try {
    return execGlyph(glyph, prepState);
  } catch (e) {
    if (this._errorState < 1) {
      console.log("Hinting error:" + e);
      console.log("Note: further hinting errors are silenced");
    }
    this._errorState = 1;
    return void 0;
  }
};
execGlyph = function(glyph, prepState) {
  var xScale = prepState.ppem / prepState.font.unitsPerEm;
  var yScale = xScale;
  var components = glyph.components;
  var contours;
  var gZone;
  var state;
  State.prototype = prepState;
  if (!components) {
    state = new State("glyf", glyph.instructions);
    if (exports.DEBUG) {
      console.log("---EXEC GLYPH---");
      state.step = -1;
    }
    execComponent(glyph, state, xScale, yScale);
    gZone = state.gZone;
  } else {
    var font = prepState.font;
    gZone = [];
    contours = [];
    for (var i3 = 0; i3 < components.length; i3++) {
      var c3 = components[i3];
      var cg = font.glyphs.get(c3.glyphIndex);
      state = new State("glyf", cg.instructions);
      if (exports.DEBUG) {
        console.log("---EXEC COMP " + i3 + "---");
        state.step = -1;
      }
      execComponent(cg, state, xScale, yScale);
      var dx = Math.round(c3.dx * xScale);
      var dy = Math.round(c3.dy * yScale);
      var gz = state.gZone;
      var cc = state.contours;
      for (var pi = 0; pi < gz.length; pi++) {
        var p = gz[pi];
        p.xTouched = p.yTouched = false;
        p.xo = p.x = p.x + dx;
        p.yo = p.y = p.y + dy;
      }
      var gLen = gZone.length;
      gZone.push.apply(gZone, gz);
      for (var j = 0; j < cc.length; j++) {
        contours.push(cc[j] + gLen);
      }
    }
    if (glyph.instructions && !state.inhibitGridFit) {
      state = new State("glyf", glyph.instructions);
      state.gZone = state.z0 = state.z1 = state.z2 = gZone;
      state.contours = contours;
      gZone.push(
        new HPoint(0, 0),
        new HPoint(Math.round(glyph.advanceWidth * xScale), 0)
      );
      if (exports.DEBUG) {
        console.log("---EXEC COMPOSITE---");
        state.step = -1;
      }
      exec(state);
      gZone.length -= 2;
    }
  }
  return gZone;
};
execComponent = function(glyph, state, xScale, yScale) {
  var points = glyph.points || [];
  var pLen = points.length;
  var gZone = state.gZone = state.z0 = state.z1 = state.z2 = [];
  var contours = state.contours = [];
  var cp;
  for (var i3 = 0; i3 < pLen; i3++) {
    cp = points[i3];
    gZone[i3] = new HPoint(
      cp.x * xScale,
      cp.y * yScale,
      cp.lastPointOfContour,
      cp.onCurve
    );
  }
  var sp;
  var np;
  for (var i$1 = 0; i$1 < pLen; i$1++) {
    cp = gZone[i$1];
    if (!sp) {
      sp = cp;
      contours.push(i$1);
    }
    if (cp.lastPointOfContour) {
      cp.nextPointOnContour = sp;
      sp.prevPointOnContour = cp;
      sp = void 0;
    } else {
      np = gZone[i$1 + 1];
      cp.nextPointOnContour = np;
      np.prevPointOnContour = cp;
    }
  }
  if (state.inhibitGridFit) {
    return;
  }
  if (exports.DEBUG) {
    console.log("PROCESSING GLYPH", state.stack);
    for (var i$2 = 0; i$2 < pLen; i$2++) {
      console.log(i$2, gZone[i$2].x, gZone[i$2].y);
    }
  }
  gZone.push(
    new HPoint(0, 0),
    new HPoint(Math.round(glyph.advanceWidth * xScale), 0)
  );
  exec(state);
  gZone.length -= 2;
  if (exports.DEBUG) {
    console.log("FINISHED GLYPH", state.stack);
    for (var i$3 = 0; i$3 < pLen; i$3++) {
      console.log(i$3, gZone[i$3].x, gZone[i$3].y);
    }
  }
};
exec = function(state) {
  var prog = state.prog;
  if (!prog) {
    return;
  }
  var pLen = prog.length;
  var ins;
  for (state.ip = 0; state.ip < pLen; state.ip++) {
    if (exports.DEBUG) {
      state.step++;
    }
    ins = instructionTable[prog[state.ip]];
    if (!ins) {
      throw new Error(
        "unknown instruction: 0x" + Number(prog[state.ip]).toString(16)
      );
    }
    ins(state);
  }
};
function initTZone(state) {
  var tZone = state.tZone = new Array(state.gZone.length);
  for (var i3 = 0; i3 < tZone.length; i3++) {
    tZone[i3] = new HPoint(0, 0);
  }
}
function skip(state, handleElse) {
  var prog = state.prog;
  var ip = state.ip;
  var nesting = 1;
  var ins;
  do {
    ins = prog[++ip];
    if (ins === 88) {
      nesting++;
    } else if (ins === 89) {
      nesting--;
    } else if (ins === 64) {
      ip += prog[ip + 1] + 1;
    } else if (ins === 65) {
      ip += 2 * prog[ip + 1] + 1;
    } else if (ins >= 176 && ins <= 183) {
      ip += ins - 176 + 1;
    } else if (ins >= 184 && ins <= 191) {
      ip += (ins - 184 + 1) * 2;
    } else if (handleElse && nesting === 1 && ins === 27) {
      break;
    }
  } while (nesting > 0);
  state.ip = ip;
}
function SVTCA(v, state) {
  if (exports.DEBUG) {
    console.log(state.step, "SVTCA[" + v.axis + "]");
  }
  state.fv = state.pv = state.dpv = v;
}
function SPVTCA(v, state) {
  if (exports.DEBUG) {
    console.log(state.step, "SPVTCA[" + v.axis + "]");
  }
  state.pv = state.dpv = v;
}
function SFVTCA(v, state) {
  if (exports.DEBUG) {
    console.log(state.step, "SFVTCA[" + v.axis + "]");
  }
  state.fv = v;
}
function SPVTL(a4, state) {
  var stack = state.stack;
  var p2i = stack.pop();
  var p1i = stack.pop();
  var p2 = state.z2[p2i];
  var p1 = state.z1[p1i];
  if (exports.DEBUG) {
    console.log("SPVTL[" + a4 + "]", p2i, p1i);
  }
  var dx;
  var dy;
  if (!a4) {
    dx = p1.x - p2.x;
    dy = p1.y - p2.y;
  } else {
    dx = p2.y - p1.y;
    dy = p1.x - p2.x;
  }
  state.pv = state.dpv = getUnitVector(dx, dy);
}
function SFVTL(a4, state) {
  var stack = state.stack;
  var p2i = stack.pop();
  var p1i = stack.pop();
  var p2 = state.z2[p2i];
  var p1 = state.z1[p1i];
  if (exports.DEBUG) {
    console.log("SFVTL[" + a4 + "]", p2i, p1i);
  }
  var dx;
  var dy;
  if (!a4) {
    dx = p1.x - p2.x;
    dy = p1.y - p2.y;
  } else {
    dx = p2.y - p1.y;
    dy = p1.x - p2.x;
  }
  state.fv = getUnitVector(dx, dy);
}
function SPVFS(state) {
  var stack = state.stack;
  var y = stack.pop();
  var x = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "SPVFS[]", y, x);
  }
  state.pv = state.dpv = getUnitVector(x, y);
}
function SFVFS(state) {
  var stack = state.stack;
  var y = stack.pop();
  var x = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "SPVFS[]", y, x);
  }
  state.fv = getUnitVector(x, y);
}
function GPV(state) {
  var stack = state.stack;
  var pv = state.pv;
  if (exports.DEBUG) {
    console.log(state.step, "GPV[]");
  }
  stack.push(pv.x * 16384);
  stack.push(pv.y * 16384);
}
function GFV(state) {
  var stack = state.stack;
  var fv = state.fv;
  if (exports.DEBUG) {
    console.log(state.step, "GFV[]");
  }
  stack.push(fv.x * 16384);
  stack.push(fv.y * 16384);
}
function SFVTPV(state) {
  state.fv = state.pv;
  if (exports.DEBUG) {
    console.log(state.step, "SFVTPV[]");
  }
}
function ISECT(state) {
  var stack = state.stack;
  var pa0i = stack.pop();
  var pa1i = stack.pop();
  var pb0i = stack.pop();
  var pb1i = stack.pop();
  var pi = stack.pop();
  var z0 = state.z0;
  var z1 = state.z1;
  var pa0 = z0[pa0i];
  var pa1 = z0[pa1i];
  var pb0 = z1[pb0i];
  var pb1 = z1[pb1i];
  var p = state.z2[pi];
  if (exports.DEBUG) {
    console.log("ISECT[], ", pa0i, pa1i, pb0i, pb1i, pi);
  }
  var x1 = pa0.x;
  var y1 = pa0.y;
  var x2 = pa1.x;
  var y2 = pa1.y;
  var x3 = pb0.x;
  var y3 = pb0.y;
  var x4 = pb1.x;
  var y4 = pb1.y;
  var div = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
  var f1 = x1 * y2 - y1 * x2;
  var f2 = x3 * y4 - y3 * x4;
  p.x = (f1 * (x3 - x4) - f2 * (x1 - x2)) / div;
  p.y = (f1 * (y3 - y4) - f2 * (y1 - y2)) / div;
}
function SRP0(state) {
  state.rp0 = state.stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "SRP0[]", state.rp0);
  }
}
function SRP1(state) {
  state.rp1 = state.stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "SRP1[]", state.rp1);
  }
}
function SRP2(state) {
  state.rp2 = state.stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "SRP2[]", state.rp2);
  }
}
function SZP0(state) {
  var n = state.stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "SZP0[]", n);
  }
  state.zp0 = n;
  switch (n) {
    case 0:
      if (!state.tZone) {
        initTZone(state);
      }
      state.z0 = state.tZone;
      break;
    case 1:
      state.z0 = state.gZone;
      break;
    default:
      throw new Error("Invalid zone pointer");
  }
}
function SZP1(state) {
  var n = state.stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "SZP1[]", n);
  }
  state.zp1 = n;
  switch (n) {
    case 0:
      if (!state.tZone) {
        initTZone(state);
      }
      state.z1 = state.tZone;
      break;
    case 1:
      state.z1 = state.gZone;
      break;
    default:
      throw new Error("Invalid zone pointer");
  }
}
function SZP2(state) {
  var n = state.stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "SZP2[]", n);
  }
  state.zp2 = n;
  switch (n) {
    case 0:
      if (!state.tZone) {
        initTZone(state);
      }
      state.z2 = state.tZone;
      break;
    case 1:
      state.z2 = state.gZone;
      break;
    default:
      throw new Error("Invalid zone pointer");
  }
}
function SZPS(state) {
  var n = state.stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "SZPS[]", n);
  }
  state.zp0 = state.zp1 = state.zp2 = n;
  switch (n) {
    case 0:
      if (!state.tZone) {
        initTZone(state);
      }
      state.z0 = state.z1 = state.z2 = state.tZone;
      break;
    case 1:
      state.z0 = state.z1 = state.z2 = state.gZone;
      break;
    default:
      throw new Error("Invalid zone pointer");
  }
}
function SLOOP(state) {
  state.loop = state.stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "SLOOP[]", state.loop);
  }
}
function RTG(state) {
  if (exports.DEBUG) {
    console.log(state.step, "RTG[]");
  }
  state.round = roundToGrid;
}
function RTHG(state) {
  if (exports.DEBUG) {
    console.log(state.step, "RTHG[]");
  }
  state.round = roundToHalfGrid;
}
function SMD(state) {
  var d = state.stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "SMD[]", d);
  }
  state.minDis = d / 64;
}
function ELSE(state) {
  if (exports.DEBUG) {
    console.log(state.step, "ELSE[]");
  }
  skip(state, false);
}
function JMPR(state) {
  var o = state.stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "JMPR[]", o);
  }
  state.ip += o - 1;
}
function SCVTCI(state) {
  var n = state.stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "SCVTCI[]", n);
  }
  state.cvCutIn = n / 64;
}
function DUP(state) {
  var stack = state.stack;
  if (exports.DEBUG) {
    console.log(state.step, "DUP[]");
  }
  stack.push(stack[stack.length - 1]);
}
function POP(state) {
  if (exports.DEBUG) {
    console.log(state.step, "POP[]");
  }
  state.stack.pop();
}
function CLEAR(state) {
  if (exports.DEBUG) {
    console.log(state.step, "CLEAR[]");
  }
  state.stack.length = 0;
}
function SWAP(state) {
  var stack = state.stack;
  var a4 = stack.pop();
  var b5 = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "SWAP[]");
  }
  stack.push(a4);
  stack.push(b5);
}
function DEPTH(state) {
  var stack = state.stack;
  if (exports.DEBUG) {
    console.log(state.step, "DEPTH[]");
  }
  stack.push(stack.length);
}
function LOOPCALL(state) {
  var stack = state.stack;
  var fn = stack.pop();
  var c3 = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "LOOPCALL[]", fn, c3);
  }
  var cip = state.ip;
  var cprog = state.prog;
  state.prog = state.funcs[fn];
  for (var i3 = 0; i3 < c3; i3++) {
    exec(state);
    if (exports.DEBUG) {
      console.log(
        ++state.step,
        i3 + 1 < c3 ? "next loopcall" : "done loopcall",
        i3
      );
    }
  }
  state.ip = cip;
  state.prog = cprog;
}
function CALL(state) {
  var fn = state.stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "CALL[]", fn);
  }
  var cip = state.ip;
  var cprog = state.prog;
  state.prog = state.funcs[fn];
  exec(state);
  state.ip = cip;
  state.prog = cprog;
  if (exports.DEBUG) {
    console.log(++state.step, "returning from", fn);
  }
}
function CINDEX(state) {
  var stack = state.stack;
  var k = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "CINDEX[]", k);
  }
  stack.push(stack[stack.length - k]);
}
function MINDEX(state) {
  var stack = state.stack;
  var k = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "MINDEX[]", k);
  }
  stack.push(stack.splice(stack.length - k, 1)[0]);
}
function FDEF(state) {
  if (state.env !== "fpgm") {
    throw new Error("FDEF not allowed here");
  }
  var stack = state.stack;
  var prog = state.prog;
  var ip = state.ip;
  var fn = stack.pop();
  var ipBegin = ip;
  if (exports.DEBUG) {
    console.log(state.step, "FDEF[]", fn);
  }
  while (prog[++ip] !== 45) {
  }
  state.ip = ip;
  state.funcs[fn] = prog.slice(ipBegin + 1, ip);
}
function MDAP(round, state) {
  var pi = state.stack.pop();
  var p = state.z0[pi];
  var fv = state.fv;
  var pv = state.pv;
  if (exports.DEBUG) {
    console.log(state.step, "MDAP[" + round + "]", pi);
  }
  var d = pv.distance(p, HPZero);
  if (round) {
    d = state.round(d);
  }
  fv.setRelative(p, HPZero, d, pv);
  fv.touch(p);
  state.rp0 = state.rp1 = pi;
}
function IUP(v, state) {
  var z2 = state.z2;
  var pLen = z2.length - 2;
  var cp;
  var pp;
  var np;
  if (exports.DEBUG) {
    console.log(state.step, "IUP[" + v.axis + "]");
  }
  for (var i3 = 0; i3 < pLen; i3++) {
    cp = z2[i3];
    if (v.touched(cp)) {
      continue;
    }
    pp = cp.prevTouched(v);
    if (pp === cp) {
      continue;
    }
    np = cp.nextTouched(v);
    if (pp === np) {
      v.setRelative(cp, cp, v.distance(pp, pp, false, true), v, true);
    }
    v.interpolate(cp, pp, np, v);
  }
}
function SHP(a4, state) {
  var stack = state.stack;
  var rpi = a4 ? state.rp1 : state.rp2;
  var rp = (a4 ? state.z0 : state.z1)[rpi];
  var fv = state.fv;
  var pv = state.pv;
  var loop = state.loop;
  var z2 = state.z2;
  while (loop--) {
    var pi = stack.pop();
    var p = z2[pi];
    var d = pv.distance(rp, rp, false, true);
    fv.setRelative(p, p, d, pv);
    fv.touch(p);
    if (exports.DEBUG) {
      console.log(
        state.step,
        (state.loop > 1 ? "loop " + (state.loop - loop) + ": " : "") + "SHP[" + (a4 ? "rp1" : "rp2") + "]",
        pi
      );
    }
  }
  state.loop = 1;
}
function SHC(a4, state) {
  var stack = state.stack;
  var rpi = a4 ? state.rp1 : state.rp2;
  var rp = (a4 ? state.z0 : state.z1)[rpi];
  var fv = state.fv;
  var pv = state.pv;
  var ci = stack.pop();
  var sp = state.z2[state.contours[ci]];
  var p = sp;
  if (exports.DEBUG) {
    console.log(state.step, "SHC[" + a4 + "]", ci);
  }
  var d = pv.distance(rp, rp, false, true);
  do {
    if (p !== rp) {
      fv.setRelative(p, p, d, pv);
    }
    p = p.nextPointOnContour;
  } while (p !== sp);
}
function SHZ(a4, state) {
  var stack = state.stack;
  var rpi = a4 ? state.rp1 : state.rp2;
  var rp = (a4 ? state.z0 : state.z1)[rpi];
  var fv = state.fv;
  var pv = state.pv;
  var e = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "SHZ[" + a4 + "]", e);
  }
  var z;
  switch (e) {
    case 0:
      z = state.tZone;
      break;
    case 1:
      z = state.gZone;
      break;
    default:
      throw new Error("Invalid zone");
  }
  var p;
  var d = pv.distance(rp, rp, false, true);
  var pLen = z.length - 2;
  for (var i3 = 0; i3 < pLen; i3++) {
    p = z[i3];
    fv.setRelative(p, p, d, pv);
  }
}
function SHPIX(state) {
  var stack = state.stack;
  var loop = state.loop;
  var fv = state.fv;
  var d = stack.pop() / 64;
  var z2 = state.z2;
  while (loop--) {
    var pi = stack.pop();
    var p = z2[pi];
    if (exports.DEBUG) {
      console.log(
        state.step,
        (state.loop > 1 ? "loop " + (state.loop - loop) + ": " : "") + "SHPIX[]",
        pi,
        d
      );
    }
    fv.setRelative(p, p, d);
    fv.touch(p);
  }
  state.loop = 1;
}
function IP(state) {
  var stack = state.stack;
  var rp1i = state.rp1;
  var rp2i = state.rp2;
  var loop = state.loop;
  var rp1 = state.z0[rp1i];
  var rp2 = state.z1[rp2i];
  var fv = state.fv;
  var pv = state.dpv;
  var z2 = state.z2;
  while (loop--) {
    var pi = stack.pop();
    var p = z2[pi];
    if (exports.DEBUG) {
      console.log(
        state.step,
        (state.loop > 1 ? "loop " + (state.loop - loop) + ": " : "") + "IP[]",
        pi,
        rp1i,
        "<->",
        rp2i
      );
    }
    fv.interpolate(p, rp1, rp2, pv);
    fv.touch(p);
  }
  state.loop = 1;
}
function MSIRP(a4, state) {
  var stack = state.stack;
  var d = stack.pop() / 64;
  var pi = stack.pop();
  var p = state.z1[pi];
  var rp0 = state.z0[state.rp0];
  var fv = state.fv;
  var pv = state.pv;
  fv.setRelative(p, rp0, d, pv);
  fv.touch(p);
  if (exports.DEBUG) {
    console.log(state.step, "MSIRP[" + a4 + "]", d, pi);
  }
  state.rp1 = state.rp0;
  state.rp2 = pi;
  if (a4) {
    state.rp0 = pi;
  }
}
function ALIGNRP(state) {
  var stack = state.stack;
  var rp0i = state.rp0;
  var rp0 = state.z0[rp0i];
  var loop = state.loop;
  var fv = state.fv;
  var pv = state.pv;
  var z1 = state.z1;
  while (loop--) {
    var pi = stack.pop();
    var p = z1[pi];
    if (exports.DEBUG) {
      console.log(
        state.step,
        (state.loop > 1 ? "loop " + (state.loop - loop) + ": " : "") + "ALIGNRP[]",
        pi
      );
    }
    fv.setRelative(p, rp0, 0, pv);
    fv.touch(p);
  }
  state.loop = 1;
}
function RTDG(state) {
  if (exports.DEBUG) {
    console.log(state.step, "RTDG[]");
  }
  state.round = roundToDoubleGrid;
}
function MIAP(round, state) {
  var stack = state.stack;
  var n = stack.pop();
  var pi = stack.pop();
  var p = state.z0[pi];
  var fv = state.fv;
  var pv = state.pv;
  var cv = state.cvt[n];
  if (exports.DEBUG) {
    console.log(
      state.step,
      "MIAP[" + round + "]",
      n,
      "(",
      cv,
      ")",
      pi
    );
  }
  var d = pv.distance(p, HPZero);
  if (round) {
    if (Math.abs(d - cv) < state.cvCutIn) {
      d = cv;
    }
    d = state.round(d);
  }
  fv.setRelative(p, HPZero, d, pv);
  if (state.zp0 === 0) {
    p.xo = p.x;
    p.yo = p.y;
  }
  fv.touch(p);
  state.rp0 = state.rp1 = pi;
}
function NPUSHB(state) {
  var prog = state.prog;
  var ip = state.ip;
  var stack = state.stack;
  var n = prog[++ip];
  if (exports.DEBUG) {
    console.log(state.step, "NPUSHB[]", n);
  }
  for (var i3 = 0; i3 < n; i3++) {
    stack.push(prog[++ip]);
  }
  state.ip = ip;
}
function NPUSHW(state) {
  var ip = state.ip;
  var prog = state.prog;
  var stack = state.stack;
  var n = prog[++ip];
  if (exports.DEBUG) {
    console.log(state.step, "NPUSHW[]", n);
  }
  for (var i3 = 0; i3 < n; i3++) {
    var w = prog[++ip] << 8 | prog[++ip];
    if (w & 32768) {
      w = -((w ^ 65535) + 1);
    }
    stack.push(w);
  }
  state.ip = ip;
}
function WS(state) {
  var stack = state.stack;
  var store = state.store;
  if (!store) {
    store = state.store = [];
  }
  var v = stack.pop();
  var l = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "WS", v, l);
  }
  store[l] = v;
}
function RS(state) {
  var stack = state.stack;
  var store = state.store;
  var l = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "RS", l);
  }
  var v = store && store[l] || 0;
  stack.push(v);
}
function WCVTP(state) {
  var stack = state.stack;
  var v = stack.pop();
  var l = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "WCVTP", v, l);
  }
  state.cvt[l] = v / 64;
}
function RCVT(state) {
  var stack = state.stack;
  var cvte = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "RCVT", cvte);
  }
  stack.push(state.cvt[cvte] * 64);
}
function GC(a4, state) {
  var stack = state.stack;
  var pi = stack.pop();
  var p = state.z2[pi];
  if (exports.DEBUG) {
    console.log(state.step, "GC[" + a4 + "]", pi);
  }
  stack.push(state.dpv.distance(p, HPZero, a4, false) * 64);
}
function MD(a4, state) {
  var stack = state.stack;
  var pi2 = stack.pop();
  var pi1 = stack.pop();
  var p2 = state.z1[pi2];
  var p1 = state.z0[pi1];
  var d = state.dpv.distance(p1, p2, a4, a4);
  if (exports.DEBUG) {
    console.log(state.step, "MD[" + a4 + "]", pi2, pi1, "->", d);
  }
  state.stack.push(Math.round(d * 64));
}
function MPPEM(state) {
  if (exports.DEBUG) {
    console.log(state.step, "MPPEM[]");
  }
  state.stack.push(state.ppem);
}
function FLIPON(state) {
  if (exports.DEBUG) {
    console.log(state.step, "FLIPON[]");
  }
  state.autoFlip = true;
}
function LT(state) {
  var stack = state.stack;
  var e2 = stack.pop();
  var e1 = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "LT[]", e2, e1);
  }
  stack.push(e1 < e2 ? 1 : 0);
}
function LTEQ(state) {
  var stack = state.stack;
  var e2 = stack.pop();
  var e1 = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "LTEQ[]", e2, e1);
  }
  stack.push(e1 <= e2 ? 1 : 0);
}
function GT(state) {
  var stack = state.stack;
  var e2 = stack.pop();
  var e1 = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "GT[]", e2, e1);
  }
  stack.push(e1 > e2 ? 1 : 0);
}
function GTEQ(state) {
  var stack = state.stack;
  var e2 = stack.pop();
  var e1 = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "GTEQ[]", e2, e1);
  }
  stack.push(e1 >= e2 ? 1 : 0);
}
function EQ(state) {
  var stack = state.stack;
  var e2 = stack.pop();
  var e1 = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "EQ[]", e2, e1);
  }
  stack.push(e2 === e1 ? 1 : 0);
}
function NEQ(state) {
  var stack = state.stack;
  var e2 = stack.pop();
  var e1 = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "NEQ[]", e2, e1);
  }
  stack.push(e2 !== e1 ? 1 : 0);
}
function ODD(state) {
  var stack = state.stack;
  var n = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "ODD[]", n);
  }
  stack.push(Math.trunc(n) % 2 ? 1 : 0);
}
function EVEN(state) {
  var stack = state.stack;
  var n = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "EVEN[]", n);
  }
  stack.push(Math.trunc(n) % 2 ? 0 : 1);
}
function IF(state) {
  var test = state.stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "IF[]", test);
  }
  if (!test) {
    skip(state, true);
    if (exports.DEBUG) {
      console.log(state.step, "EIF[]");
    }
  }
}
function EIF(state) {
  if (exports.DEBUG) {
    console.log(state.step, "EIF[]");
  }
}
function AND(state) {
  var stack = state.stack;
  var e2 = stack.pop();
  var e1 = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "AND[]", e2, e1);
  }
  stack.push(e2 && e1 ? 1 : 0);
}
function OR(state) {
  var stack = state.stack;
  var e2 = stack.pop();
  var e1 = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "OR[]", e2, e1);
  }
  stack.push(e2 || e1 ? 1 : 0);
}
function NOT(state) {
  var stack = state.stack;
  var e = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "NOT[]", e);
  }
  stack.push(e ? 0 : 1);
}
function DELTAP123(b5, state) {
  var stack = state.stack;
  var n = stack.pop();
  var fv = state.fv;
  var pv = state.pv;
  var ppem = state.ppem;
  var base = state.deltaBase + (b5 - 1) * 16;
  var ds = state.deltaShift;
  var z0 = state.z0;
  if (exports.DEBUG) {
    console.log(state.step, "DELTAP[" + b5 + "]", n, stack);
  }
  for (var i3 = 0; i3 < n; i3++) {
    var pi = stack.pop();
    var arg = stack.pop();
    var appem = base + ((arg & 240) >> 4);
    if (appem !== ppem) {
      continue;
    }
    var mag = (arg & 15) - 8;
    if (mag >= 0) {
      mag++;
    }
    if (exports.DEBUG) {
      console.log(state.step, "DELTAPFIX", pi, "by", mag * ds);
    }
    var p = z0[pi];
    fv.setRelative(p, p, mag * ds, pv);
  }
}
function SDB(state) {
  var stack = state.stack;
  var n = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "SDB[]", n);
  }
  state.deltaBase = n;
}
function SDS(state) {
  var stack = state.stack;
  var n = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "SDS[]", n);
  }
  state.deltaShift = Math.pow(0.5, n);
}
function ADD(state) {
  var stack = state.stack;
  var n2 = stack.pop();
  var n1 = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "ADD[]", n2, n1);
  }
  stack.push(n1 + n2);
}
function SUB(state) {
  var stack = state.stack;
  var n2 = stack.pop();
  var n1 = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "SUB[]", n2, n1);
  }
  stack.push(n1 - n2);
}
function DIV(state) {
  var stack = state.stack;
  var n2 = stack.pop();
  var n1 = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "DIV[]", n2, n1);
  }
  stack.push(n1 * 64 / n2);
}
function MUL(state) {
  var stack = state.stack;
  var n2 = stack.pop();
  var n1 = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "MUL[]", n2, n1);
  }
  stack.push(n1 * n2 / 64);
}
function ABS(state) {
  var stack = state.stack;
  var n = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "ABS[]", n);
  }
  stack.push(Math.abs(n));
}
function NEG(state) {
  var stack = state.stack;
  var n = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "NEG[]", n);
  }
  stack.push(-n);
}
function FLOOR(state) {
  var stack = state.stack;
  var n = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "FLOOR[]", n);
  }
  stack.push(Math.floor(n / 64) * 64);
}
function CEILING(state) {
  var stack = state.stack;
  var n = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "CEILING[]", n);
  }
  stack.push(Math.ceil(n / 64) * 64);
}
function ROUND(dt, state) {
  var stack = state.stack;
  var n = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "ROUND[]");
  }
  stack.push(state.round(n / 64) * 64);
}
function WCVTF(state) {
  var stack = state.stack;
  var v = stack.pop();
  var l = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "WCVTF[]", v, l);
  }
  state.cvt[l] = v * state.ppem / state.font.unitsPerEm;
}
function DELTAC123(b5, state) {
  var stack = state.stack;
  var n = stack.pop();
  var ppem = state.ppem;
  var base = state.deltaBase + (b5 - 1) * 16;
  var ds = state.deltaShift;
  if (exports.DEBUG) {
    console.log(state.step, "DELTAC[" + b5 + "]", n, stack);
  }
  for (var i3 = 0; i3 < n; i3++) {
    var c3 = stack.pop();
    var arg = stack.pop();
    var appem = base + ((arg & 240) >> 4);
    if (appem !== ppem) {
      continue;
    }
    var mag = (arg & 15) - 8;
    if (mag >= 0) {
      mag++;
    }
    var delta = mag * ds;
    if (exports.DEBUG) {
      console.log(state.step, "DELTACFIX", c3, "by", delta);
    }
    state.cvt[c3] += delta;
  }
}
function SROUND(state) {
  var n = state.stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "SROUND[]", n);
  }
  state.round = roundSuper;
  var period;
  switch (n & 192) {
    case 0:
      period = 0.5;
      break;
    case 64:
      period = 1;
      break;
    case 128:
      period = 2;
      break;
    default:
      throw new Error("invalid SROUND value");
  }
  state.srPeriod = period;
  switch (n & 48) {
    case 0:
      state.srPhase = 0;
      break;
    case 16:
      state.srPhase = 0.25 * period;
      break;
    case 32:
      state.srPhase = 0.5 * period;
      break;
    case 48:
      state.srPhase = 0.75 * period;
      break;
    default:
      throw new Error("invalid SROUND value");
  }
  n &= 15;
  if (n === 0) {
    state.srThreshold = 0;
  } else {
    state.srThreshold = (n / 8 - 0.5) * period;
  }
}
function S45ROUND(state) {
  var n = state.stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "S45ROUND[]", n);
  }
  state.round = roundSuper;
  var period;
  switch (n & 192) {
    case 0:
      period = Math.sqrt(2) / 2;
      break;
    case 64:
      period = Math.sqrt(2);
      break;
    case 128:
      period = 2 * Math.sqrt(2);
      break;
    default:
      throw new Error("invalid S45ROUND value");
  }
  state.srPeriod = period;
  switch (n & 48) {
    case 0:
      state.srPhase = 0;
      break;
    case 16:
      state.srPhase = 0.25 * period;
      break;
    case 32:
      state.srPhase = 0.5 * period;
      break;
    case 48:
      state.srPhase = 0.75 * period;
      break;
    default:
      throw new Error("invalid S45ROUND value");
  }
  n &= 15;
  if (n === 0) {
    state.srThreshold = 0;
  } else {
    state.srThreshold = (n / 8 - 0.5) * period;
  }
}
function ROFF(state) {
  if (exports.DEBUG) {
    console.log(state.step, "ROFF[]");
  }
  state.round = roundOff;
}
function RUTG(state) {
  if (exports.DEBUG) {
    console.log(state.step, "RUTG[]");
  }
  state.round = roundUpToGrid;
}
function RDTG(state) {
  if (exports.DEBUG) {
    console.log(state.step, "RDTG[]");
  }
  state.round = roundDownToGrid;
}
function SCANCTRL(state) {
  var n = state.stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "SCANCTRL[]", n);
  }
}
function SDPVTL(a4, state) {
  var stack = state.stack;
  var p2i = stack.pop();
  var p1i = stack.pop();
  var p2 = state.z2[p2i];
  var p1 = state.z1[p1i];
  if (exports.DEBUG) {
    console.log(state.step, "SDPVTL[" + a4 + "]", p2i, p1i);
  }
  var dx;
  var dy;
  if (!a4) {
    dx = p1.x - p2.x;
    dy = p1.y - p2.y;
  } else {
    dx = p2.y - p1.y;
    dy = p1.x - p2.x;
  }
  state.dpv = getUnitVector(dx, dy);
}
function GETINFO(state) {
  var stack = state.stack;
  var sel = stack.pop();
  var r = 0;
  if (exports.DEBUG) {
    console.log(state.step, "GETINFO[]", sel);
  }
  if (sel & 1) {
    r = 35;
  }
  if (sel & 32) {
    r |= 4096;
  }
  stack.push(r);
}
function ROLL(state) {
  var stack = state.stack;
  var a4 = stack.pop();
  var b5 = stack.pop();
  var c3 = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "ROLL[]");
  }
  stack.push(b5);
  stack.push(a4);
  stack.push(c3);
}
function MAX(state) {
  var stack = state.stack;
  var e2 = stack.pop();
  var e1 = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "MAX[]", e2, e1);
  }
  stack.push(Math.max(e1, e2));
}
function MIN(state) {
  var stack = state.stack;
  var e2 = stack.pop();
  var e1 = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "MIN[]", e2, e1);
  }
  stack.push(Math.min(e1, e2));
}
function SCANTYPE(state) {
  var n = state.stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "SCANTYPE[]", n);
  }
}
function INSTCTRL(state) {
  var s = state.stack.pop();
  var v = state.stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "INSTCTRL[]", s, v);
  }
  switch (s) {
    case 1:
      state.inhibitGridFit = !!v;
      return;
    case 2:
      state.ignoreCvt = !!v;
      return;
    default:
      throw new Error("invalid INSTCTRL[] selector");
  }
}
function PUSHB(n, state) {
  var stack = state.stack;
  var prog = state.prog;
  var ip = state.ip;
  if (exports.DEBUG) {
    console.log(state.step, "PUSHB[" + n + "]");
  }
  for (var i3 = 0; i3 < n; i3++) {
    stack.push(prog[++ip]);
  }
  state.ip = ip;
}
function PUSHW(n, state) {
  var ip = state.ip;
  var prog = state.prog;
  var stack = state.stack;
  if (exports.DEBUG) {
    console.log(state.ip, "PUSHW[" + n + "]");
  }
  for (var i3 = 0; i3 < n; i3++) {
    var w = prog[++ip] << 8 | prog[++ip];
    if (w & 32768) {
      w = -((w ^ 65535) + 1);
    }
    stack.push(w);
  }
  state.ip = ip;
}
function MDRP_MIRP(indirect, setRp0, keepD, ro, dt, state) {
  var stack = state.stack;
  var cvte = indirect && stack.pop();
  var pi = stack.pop();
  var rp0i = state.rp0;
  var rp = state.z0[rp0i];
  var p = state.z1[pi];
  var md = state.minDis;
  var fv = state.fv;
  var pv = state.dpv;
  var od;
  var d;
  var sign;
  var cv;
  d = od = pv.distance(p, rp, true, true);
  sign = d >= 0 ? 1 : -1;
  d = Math.abs(d);
  if (indirect) {
    cv = state.cvt[cvte];
    if (ro && Math.abs(d - cv) < state.cvCutIn) {
      d = cv;
    }
  }
  if (keepD && d < md) {
    d = md;
  }
  if (ro) {
    d = state.round(d);
  }
  fv.setRelative(p, rp, sign * d, pv);
  fv.touch(p);
  if (exports.DEBUG) {
    console.log(
      state.step,
      (indirect ? "MIRP[" : "MDRP[") + (setRp0 ? "M" : "m") + (keepD ? ">" : "_") + (ro ? "R" : "_") + (dt === 0 ? "Gr" : dt === 1 ? "Bl" : dt === 2 ? "Wh" : "") + "]",
      indirect ? cvte + "(" + state.cvt[cvte] + "," + cv + ")" : "",
      pi,
      "(d =",
      od,
      "->",
      sign * d,
      ")"
    );
  }
  state.rp1 = state.rp0;
  state.rp2 = pi;
  if (setRp0) {
    state.rp0 = pi;
  }
}
instructionTable = [
  /* 0x00 */
  SVTCA.bind(void 0, yUnitVector),
  /* 0x01 */
  SVTCA.bind(void 0, xUnitVector),
  /* 0x02 */
  SPVTCA.bind(void 0, yUnitVector),
  /* 0x03 */
  SPVTCA.bind(void 0, xUnitVector),
  /* 0x04 */
  SFVTCA.bind(void 0, yUnitVector),
  /* 0x05 */
  SFVTCA.bind(void 0, xUnitVector),
  /* 0x06 */
  SPVTL.bind(void 0, 0),
  /* 0x07 */
  SPVTL.bind(void 0, 1),
  /* 0x08 */
  SFVTL.bind(void 0, 0),
  /* 0x09 */
  SFVTL.bind(void 0, 1),
  /* 0x0A */
  SPVFS,
  /* 0x0B */
  SFVFS,
  /* 0x0C */
  GPV,
  /* 0x0D */
  GFV,
  /* 0x0E */
  SFVTPV,
  /* 0x0F */
  ISECT,
  /* 0x10 */
  SRP0,
  /* 0x11 */
  SRP1,
  /* 0x12 */
  SRP2,
  /* 0x13 */
  SZP0,
  /* 0x14 */
  SZP1,
  /* 0x15 */
  SZP2,
  /* 0x16 */
  SZPS,
  /* 0x17 */
  SLOOP,
  /* 0x18 */
  RTG,
  /* 0x19 */
  RTHG,
  /* 0x1A */
  SMD,
  /* 0x1B */
  ELSE,
  /* 0x1C */
  JMPR,
  /* 0x1D */
  SCVTCI,
  /* 0x1E */
  void 0,
  // TODO SSWCI
  /* 0x1F */
  void 0,
  // TODO SSW
  /* 0x20 */
  DUP,
  /* 0x21 */
  POP,
  /* 0x22 */
  CLEAR,
  /* 0x23 */
  SWAP,
  /* 0x24 */
  DEPTH,
  /* 0x25 */
  CINDEX,
  /* 0x26 */
  MINDEX,
  /* 0x27 */
  void 0,
  // TODO ALIGNPTS
  /* 0x28 */
  void 0,
  /* 0x29 */
  void 0,
  // TODO UTP
  /* 0x2A */
  LOOPCALL,
  /* 0x2B */
  CALL,
  /* 0x2C */
  FDEF,
  /* 0x2D */
  void 0,
  // ENDF (eaten by FDEF)
  /* 0x2E */
  MDAP.bind(void 0, 0),
  /* 0x2F */
  MDAP.bind(void 0, 1),
  /* 0x30 */
  IUP.bind(void 0, yUnitVector),
  /* 0x31 */
  IUP.bind(void 0, xUnitVector),
  /* 0x32 */
  SHP.bind(void 0, 0),
  /* 0x33 */
  SHP.bind(void 0, 1),
  /* 0x34 */
  SHC.bind(void 0, 0),
  /* 0x35 */
  SHC.bind(void 0, 1),
  /* 0x36 */
  SHZ.bind(void 0, 0),
  /* 0x37 */
  SHZ.bind(void 0, 1),
  /* 0x38 */
  SHPIX,
  /* 0x39 */
  IP,
  /* 0x3A */
  MSIRP.bind(void 0, 0),
  /* 0x3B */
  MSIRP.bind(void 0, 1),
  /* 0x3C */
  ALIGNRP,
  /* 0x3D */
  RTDG,
  /* 0x3E */
  MIAP.bind(void 0, 0),
  /* 0x3F */
  MIAP.bind(void 0, 1),
  /* 0x40 */
  NPUSHB,
  /* 0x41 */
  NPUSHW,
  /* 0x42 */
  WS,
  /* 0x43 */
  RS,
  /* 0x44 */
  WCVTP,
  /* 0x45 */
  RCVT,
  /* 0x46 */
  GC.bind(void 0, 0),
  /* 0x47 */
  GC.bind(void 0, 1),
  /* 0x48 */
  void 0,
  // TODO SCFS
  /* 0x49 */
  MD.bind(void 0, 0),
  /* 0x4A */
  MD.bind(void 0, 1),
  /* 0x4B */
  MPPEM,
  /* 0x4C */
  void 0,
  // TODO MPS
  /* 0x4D */
  FLIPON,
  /* 0x4E */
  void 0,
  // TODO FLIPOFF
  /* 0x4F */
  void 0,
  // TODO DEBUG
  /* 0x50 */
  LT,
  /* 0x51 */
  LTEQ,
  /* 0x52 */
  GT,
  /* 0x53 */
  GTEQ,
  /* 0x54 */
  EQ,
  /* 0x55 */
  NEQ,
  /* 0x56 */
  ODD,
  /* 0x57 */
  EVEN,
  /* 0x58 */
  IF,
  /* 0x59 */
  EIF,
  /* 0x5A */
  AND,
  /* 0x5B */
  OR,
  /* 0x5C */
  NOT,
  /* 0x5D */
  DELTAP123.bind(void 0, 1),
  /* 0x5E */
  SDB,
  /* 0x5F */
  SDS,
  /* 0x60 */
  ADD,
  /* 0x61 */
  SUB,
  /* 0x62 */
  DIV,
  /* 0x63 */
  MUL,
  /* 0x64 */
  ABS,
  /* 0x65 */
  NEG,
  /* 0x66 */
  FLOOR,
  /* 0x67 */
  CEILING,
  /* 0x68 */
  ROUND.bind(void 0, 0),
  /* 0x69 */
  ROUND.bind(void 0, 1),
  /* 0x6A */
  ROUND.bind(void 0, 2),
  /* 0x6B */
  ROUND.bind(void 0, 3),
  /* 0x6C */
  void 0,
  // TODO NROUND[ab]
  /* 0x6D */
  void 0,
  // TODO NROUND[ab]
  /* 0x6E */
  void 0,
  // TODO NROUND[ab]
  /* 0x6F */
  void 0,
  // TODO NROUND[ab]
  /* 0x70 */
  WCVTF,
  /* 0x71 */
  DELTAP123.bind(void 0, 2),
  /* 0x72 */
  DELTAP123.bind(void 0, 3),
  /* 0x73 */
  DELTAC123.bind(void 0, 1),
  /* 0x74 */
  DELTAC123.bind(void 0, 2),
  /* 0x75 */
  DELTAC123.bind(void 0, 3),
  /* 0x76 */
  SROUND,
  /* 0x77 */
  S45ROUND,
  /* 0x78 */
  void 0,
  // TODO JROT[]
  /* 0x79 */
  void 0,
  // TODO JROF[]
  /* 0x7A */
  ROFF,
  /* 0x7B */
  void 0,
  /* 0x7C */
  RUTG,
  /* 0x7D */
  RDTG,
  /* 0x7E */
  POP,
  // actually SANGW, supposed to do only a pop though
  /* 0x7F */
  POP,
  // actually AA, supposed to do only a pop though
  /* 0x80 */
  void 0,
  // TODO FLIPPT
  /* 0x81 */
  void 0,
  // TODO FLIPRGON
  /* 0x82 */
  void 0,
  // TODO FLIPRGOFF
  /* 0x83 */
  void 0,
  /* 0x84 */
  void 0,
  /* 0x85 */
  SCANCTRL,
  /* 0x86 */
  SDPVTL.bind(void 0, 0),
  /* 0x87 */
  SDPVTL.bind(void 0, 1),
  /* 0x88 */
  GETINFO,
  /* 0x89 */
  void 0,
  // TODO IDEF
  /* 0x8A */
  ROLL,
  /* 0x8B */
  MAX,
  /* 0x8C */
  MIN,
  /* 0x8D */
  SCANTYPE,
  /* 0x8E */
  INSTCTRL,
  /* 0x8F */
  void 0,
  /* 0x90 */
  void 0,
  /* 0x91 */
  void 0,
  /* 0x92 */
  void 0,
  /* 0x93 */
  void 0,
  /* 0x94 */
  void 0,
  /* 0x95 */
  void 0,
  /* 0x96 */
  void 0,
  /* 0x97 */
  void 0,
  /* 0x98 */
  void 0,
  /* 0x99 */
  void 0,
  /* 0x9A */
  void 0,
  /* 0x9B */
  void 0,
  /* 0x9C */
  void 0,
  /* 0x9D */
  void 0,
  /* 0x9E */
  void 0,
  /* 0x9F */
  void 0,
  /* 0xA0 */
  void 0,
  /* 0xA1 */
  void 0,
  /* 0xA2 */
  void 0,
  /* 0xA3 */
  void 0,
  /* 0xA4 */
  void 0,
  /* 0xA5 */
  void 0,
  /* 0xA6 */
  void 0,
  /* 0xA7 */
  void 0,
  /* 0xA8 */
  void 0,
  /* 0xA9 */
  void 0,
  /* 0xAA */
  void 0,
  /* 0xAB */
  void 0,
  /* 0xAC */
  void 0,
  /* 0xAD */
  void 0,
  /* 0xAE */
  void 0,
  /* 0xAF */
  void 0,
  /* 0xB0 */
  PUSHB.bind(void 0, 1),
  /* 0xB1 */
  PUSHB.bind(void 0, 2),
  /* 0xB2 */
  PUSHB.bind(void 0, 3),
  /* 0xB3 */
  PUSHB.bind(void 0, 4),
  /* 0xB4 */
  PUSHB.bind(void 0, 5),
  /* 0xB5 */
  PUSHB.bind(void 0, 6),
  /* 0xB6 */
  PUSHB.bind(void 0, 7),
  /* 0xB7 */
  PUSHB.bind(void 0, 8),
  /* 0xB8 */
  PUSHW.bind(void 0, 1),
  /* 0xB9 */
  PUSHW.bind(void 0, 2),
  /* 0xBA */
  PUSHW.bind(void 0, 3),
  /* 0xBB */
  PUSHW.bind(void 0, 4),
  /* 0xBC */
  PUSHW.bind(void 0, 5),
  /* 0xBD */
  PUSHW.bind(void 0, 6),
  /* 0xBE */
  PUSHW.bind(void 0, 7),
  /* 0xBF */
  PUSHW.bind(void 0, 8),
  /* 0xC0 */
  MDRP_MIRP.bind(void 0, 0, 0, 0, 0, 0),
  /* 0xC1 */
  MDRP_MIRP.bind(void 0, 0, 0, 0, 0, 1),
  /* 0xC2 */
  MDRP_MIRP.bind(void 0, 0, 0, 0, 0, 2),
  /* 0xC3 */
  MDRP_MIRP.bind(void 0, 0, 0, 0, 0, 3),
  /* 0xC4 */
  MDRP_MIRP.bind(void 0, 0, 0, 0, 1, 0),
  /* 0xC5 */
  MDRP_MIRP.bind(void 0, 0, 0, 0, 1, 1),
  /* 0xC6 */
  MDRP_MIRP.bind(void 0, 0, 0, 0, 1, 2),
  /* 0xC7 */
  MDRP_MIRP.bind(void 0, 0, 0, 0, 1, 3),
  /* 0xC8 */
  MDRP_MIRP.bind(void 0, 0, 0, 1, 0, 0),
  /* 0xC9 */
  MDRP_MIRP.bind(void 0, 0, 0, 1, 0, 1),
  /* 0xCA */
  MDRP_MIRP.bind(void 0, 0, 0, 1, 0, 2),
  /* 0xCB */
  MDRP_MIRP.bind(void 0, 0, 0, 1, 0, 3),
  /* 0xCC */
  MDRP_MIRP.bind(void 0, 0, 0, 1, 1, 0),
  /* 0xCD */
  MDRP_MIRP.bind(void 0, 0, 0, 1, 1, 1),
  /* 0xCE */
  MDRP_MIRP.bind(void 0, 0, 0, 1, 1, 2),
  /* 0xCF */
  MDRP_MIRP.bind(void 0, 0, 0, 1, 1, 3),
  /* 0xD0 */
  MDRP_MIRP.bind(void 0, 0, 1, 0, 0, 0),
  /* 0xD1 */
  MDRP_MIRP.bind(void 0, 0, 1, 0, 0, 1),
  /* 0xD2 */
  MDRP_MIRP.bind(void 0, 0, 1, 0, 0, 2),
  /* 0xD3 */
  MDRP_MIRP.bind(void 0, 0, 1, 0, 0, 3),
  /* 0xD4 */
  MDRP_MIRP.bind(void 0, 0, 1, 0, 1, 0),
  /* 0xD5 */
  MDRP_MIRP.bind(void 0, 0, 1, 0, 1, 1),
  /* 0xD6 */
  MDRP_MIRP.bind(void 0, 0, 1, 0, 1, 2),
  /* 0xD7 */
  MDRP_MIRP.bind(void 0, 0, 1, 0, 1, 3),
  /* 0xD8 */
  MDRP_MIRP.bind(void 0, 0, 1, 1, 0, 0),
  /* 0xD9 */
  MDRP_MIRP.bind(void 0, 0, 1, 1, 0, 1),
  /* 0xDA */
  MDRP_MIRP.bind(void 0, 0, 1, 1, 0, 2),
  /* 0xDB */
  MDRP_MIRP.bind(void 0, 0, 1, 1, 0, 3),
  /* 0xDC */
  MDRP_MIRP.bind(void 0, 0, 1, 1, 1, 0),
  /* 0xDD */
  MDRP_MIRP.bind(void 0, 0, 1, 1, 1, 1),
  /* 0xDE */
  MDRP_MIRP.bind(void 0, 0, 1, 1, 1, 2),
  /* 0xDF */
  MDRP_MIRP.bind(void 0, 0, 1, 1, 1, 3),
  /* 0xE0 */
  MDRP_MIRP.bind(void 0, 1, 0, 0, 0, 0),
  /* 0xE1 */
  MDRP_MIRP.bind(void 0, 1, 0, 0, 0, 1),
  /* 0xE2 */
  MDRP_MIRP.bind(void 0, 1, 0, 0, 0, 2),
  /* 0xE3 */
  MDRP_MIRP.bind(void 0, 1, 0, 0, 0, 3),
  /* 0xE4 */
  MDRP_MIRP.bind(void 0, 1, 0, 0, 1, 0),
  /* 0xE5 */
  MDRP_MIRP.bind(void 0, 1, 0, 0, 1, 1),
  /* 0xE6 */
  MDRP_MIRP.bind(void 0, 1, 0, 0, 1, 2),
  /* 0xE7 */
  MDRP_MIRP.bind(void 0, 1, 0, 0, 1, 3),
  /* 0xE8 */
  MDRP_MIRP.bind(void 0, 1, 0, 1, 0, 0),
  /* 0xE9 */
  MDRP_MIRP.bind(void 0, 1, 0, 1, 0, 1),
  /* 0xEA */
  MDRP_MIRP.bind(void 0, 1, 0, 1, 0, 2),
  /* 0xEB */
  MDRP_MIRP.bind(void 0, 1, 0, 1, 0, 3),
  /* 0xEC */
  MDRP_MIRP.bind(void 0, 1, 0, 1, 1, 0),
  /* 0xED */
  MDRP_MIRP.bind(void 0, 1, 0, 1, 1, 1),
  /* 0xEE */
  MDRP_MIRP.bind(void 0, 1, 0, 1, 1, 2),
  /* 0xEF */
  MDRP_MIRP.bind(void 0, 1, 0, 1, 1, 3),
  /* 0xF0 */
  MDRP_MIRP.bind(void 0, 1, 1, 0, 0, 0),
  /* 0xF1 */
  MDRP_MIRP.bind(void 0, 1, 1, 0, 0, 1),
  /* 0xF2 */
  MDRP_MIRP.bind(void 0, 1, 1, 0, 0, 2),
  /* 0xF3 */
  MDRP_MIRP.bind(void 0, 1, 1, 0, 0, 3),
  /* 0xF4 */
  MDRP_MIRP.bind(void 0, 1, 1, 0, 1, 0),
  /* 0xF5 */
  MDRP_MIRP.bind(void 0, 1, 1, 0, 1, 1),
  /* 0xF6 */
  MDRP_MIRP.bind(void 0, 1, 1, 0, 1, 2),
  /* 0xF7 */
  MDRP_MIRP.bind(void 0, 1, 1, 0, 1, 3),
  /* 0xF8 */
  MDRP_MIRP.bind(void 0, 1, 1, 1, 0, 0),
  /* 0xF9 */
  MDRP_MIRP.bind(void 0, 1, 1, 1, 0, 1),
  /* 0xFA */
  MDRP_MIRP.bind(void 0, 1, 1, 1, 0, 2),
  /* 0xFB */
  MDRP_MIRP.bind(void 0, 1, 1, 1, 0, 3),
  /* 0xFC */
  MDRP_MIRP.bind(void 0, 1, 1, 1, 1, 0),
  /* 0xFD */
  MDRP_MIRP.bind(void 0, 1, 1, 1, 1, 1),
  /* 0xFE */
  MDRP_MIRP.bind(void 0, 1, 1, 1, 1, 2),
  /* 0xFF */
  MDRP_MIRP.bind(void 0, 1, 1, 1, 1, 3)
];
function Token(char) {
  this.char = char;
  this.state = {};
  this.activeState = null;
}
function ContextRange(startIndex, endOffset, contextName) {
  this.contextName = contextName;
  this.startIndex = startIndex;
  this.endOffset = endOffset;
}
function ContextChecker(contextName, checkStart, checkEnd) {
  this.contextName = contextName;
  this.openRange = null;
  this.ranges = [];
  this.checkStart = checkStart;
  this.checkEnd = checkEnd;
}
function ContextParams(context3, currentIndex) {
  this.context = context3;
  this.index = currentIndex;
  this.length = context3.length;
  this.current = context3[currentIndex];
  this.backtrack = context3.slice(0, currentIndex);
  this.lookahead = context3.slice(currentIndex + 1);
}
function Event(eventId) {
  this.eventId = eventId;
  this.subscribers = [];
}
function initializeCoreEvents(events2) {
  var this$1 = this;
  var coreEvents = [
    "start",
    "end",
    "next",
    "newToken",
    "contextStart",
    "contextEnd",
    "insertToken",
    "removeToken",
    "removeRange",
    "replaceToken",
    "replaceRange",
    "composeRUD",
    "updateContextsRanges"
  ];
  coreEvents.forEach(function(eventId) {
    Object.defineProperty(this$1.events, eventId, {
      value: new Event(eventId)
    });
  });
  if (!!events2) {
    coreEvents.forEach(function(eventId) {
      var event = events2[eventId];
      if (typeof event === "function") {
        this$1.events[eventId].subscribe(event);
      }
    });
  }
  var requiresContextUpdate = [
    "insertToken",
    "removeToken",
    "removeRange",
    "replaceToken",
    "replaceRange",
    "composeRUD"
  ];
  requiresContextUpdate.forEach(function(eventId) {
    this$1.events[eventId].subscribe(
      this$1.updateContextsRanges
    );
  });
}
function Tokenizer(events2) {
  this.tokens = [];
  this.registeredContexts = {};
  this.contextCheckers = [];
  this.events = {};
  this.registeredModifiers = [];
  initializeCoreEvents.call(this, events2);
}
Token.prototype.setState = function(key, value) {
  this.state[key] = value;
  this.activeState = { key, value: this.state[key] };
  return this.activeState;
};
Token.prototype.getState = function(stateId) {
  return this.state[stateId] || null;
};
Tokenizer.prototype.inboundIndex = function(index) {
  return index >= 0 && index < this.tokens.length;
};
Tokenizer.prototype.composeRUD = function(RUDs) {
  var this$1 = this;
  var silent = true;
  var state = RUDs.map(function(RUD) {
    return this$1[RUD[0]].apply(this$1, RUD.slice(1).concat(silent));
  });
  var hasFAILObject = function(obj) {
    return typeof obj === "object" && obj.hasOwnProperty("FAIL");
  };
  if (state.every(hasFAILObject)) {
    return {
      FAIL: "composeRUD: one or more operations hasn't completed successfully",
      report: state.filter(hasFAILObject)
    };
  }
  this.dispatch("composeRUD", [state.filter(function(op) {
    return !hasFAILObject(op);
  })]);
};
Tokenizer.prototype.replaceRange = function(startIndex, offset, tokens, silent) {
  offset = offset !== null ? offset : this.tokens.length;
  var isTokenType = tokens.every(function(token) {
    return token instanceof Token;
  });
  if (!isNaN(startIndex) && this.inboundIndex(startIndex) && isTokenType) {
    var replaced = this.tokens.splice.apply(
      this.tokens,
      [startIndex, offset].concat(tokens)
    );
    if (!silent) {
      this.dispatch("replaceToken", [startIndex, offset, tokens]);
    }
    return [replaced, tokens];
  } else {
    return { FAIL: "replaceRange: invalid tokens or startIndex." };
  }
};
Tokenizer.prototype.replaceToken = function(index, token, silent) {
  if (!isNaN(index) && this.inboundIndex(index) && token instanceof Token) {
    var replaced = this.tokens.splice(index, 1, token);
    if (!silent) {
      this.dispatch("replaceToken", [index, token]);
    }
    return [replaced[0], token];
  } else {
    return { FAIL: "replaceToken: invalid token or index." };
  }
};
Tokenizer.prototype.removeRange = function(startIndex, offset, silent) {
  offset = !isNaN(offset) ? offset : this.tokens.length;
  var tokens = this.tokens.splice(startIndex, offset);
  if (!silent) {
    this.dispatch("removeRange", [tokens, startIndex, offset]);
  }
  return tokens;
};
Tokenizer.prototype.removeToken = function(index, silent) {
  if (!isNaN(index) && this.inboundIndex(index)) {
    var token = this.tokens.splice(index, 1);
    if (!silent) {
      this.dispatch("removeToken", [token, index]);
    }
    return token;
  } else {
    return { FAIL: "removeToken: invalid token index." };
  }
};
Tokenizer.prototype.insertToken = function(tokens, index, silent) {
  var tokenType = tokens.every(
    function(token) {
      return token instanceof Token;
    }
  );
  if (tokenType) {
    this.tokens.splice.apply(
      this.tokens,
      [index, 0].concat(tokens)
    );
    if (!silent) {
      this.dispatch("insertToken", [tokens, index]);
    }
    return tokens;
  } else {
    return { FAIL: "insertToken: invalid token(s)." };
  }
};
Tokenizer.prototype.registerModifier = function(modifierId, condition, modifier) {
  this.events.newToken.subscribe(function(token, contextParams) {
    var conditionParams = [token, contextParams];
    var canApplyModifier = condition === null || condition.apply(this, conditionParams) === true;
    var modifierParams = [token, contextParams];
    if (canApplyModifier) {
      var newStateValue = modifier.apply(this, modifierParams);
      token.setState(modifierId, newStateValue);
    }
  });
  this.registeredModifiers.push(modifierId);
};
Event.prototype.subscribe = function(eventHandler) {
  if (typeof eventHandler === "function") {
    return this.subscribers.push(eventHandler) - 1;
  } else {
    return { FAIL: "invalid '" + this.eventId + "' event handler" };
  }
};
Event.prototype.unsubscribe = function(subsId) {
  this.subscribers.splice(subsId, 1);
};
ContextParams.prototype.setCurrentIndex = function(index) {
  this.index = index;
  this.current = this.context[index];
  this.backtrack = this.context.slice(0, index);
  this.lookahead = this.context.slice(index + 1);
};
ContextParams.prototype.get = function(offset) {
  switch (true) {
    case offset === 0:
      return this.current;
    case (offset < 0 && Math.abs(offset) <= this.backtrack.length):
      return this.backtrack.slice(offset)[0];
    case (offset > 0 && offset <= this.lookahead.length):
      return this.lookahead[offset - 1];
    default:
      return null;
  }
};
Tokenizer.prototype.rangeToText = function(range2) {
  if (range2 instanceof ContextRange) {
    return this.getRangeTokens(range2).map(function(token) {
      return token.char;
    }).join("");
  }
};
Tokenizer.prototype.getText = function() {
  return this.tokens.map(function(token) {
    return token.char;
  }).join("");
};
Tokenizer.prototype.getContext = function(contextName) {
  var context3 = this.registeredContexts[contextName];
  return !!context3 ? context3 : null;
};
Tokenizer.prototype.on = function(eventName, eventHandler) {
  var event = this.events[eventName];
  if (!!event) {
    return event.subscribe(eventHandler);
  } else {
    return null;
  }
};
Tokenizer.prototype.dispatch = function(eventName, args) {
  var this$1 = this;
  var event = this.events[eventName];
  if (event instanceof Event) {
    event.subscribers.forEach(function(subscriber) {
      subscriber.apply(this$1, args || []);
    });
  }
};
Tokenizer.prototype.registerContextChecker = function(contextName, contextStartCheck, contextEndCheck) {
  if (!!this.getContext(contextName)) {
    return {
      FAIL: "context name '" + contextName + "' is already registered."
    };
  }
  if (typeof contextStartCheck !== "function") {
    return {
      FAIL: "missing context start check."
    };
  }
  if (typeof contextEndCheck !== "function") {
    return {
      FAIL: "missing context end check."
    };
  }
  var contextCheckers = new ContextChecker(
    contextName,
    contextStartCheck,
    contextEndCheck
  );
  this.registeredContexts[contextName] = contextCheckers;
  this.contextCheckers.push(contextCheckers);
  return contextCheckers;
};
Tokenizer.prototype.getRangeTokens = function(range2) {
  var endIndex = range2.startIndex + range2.endOffset;
  return [].concat(
    this.tokens.slice(range2.startIndex, endIndex)
  );
};
Tokenizer.prototype.getContextRanges = function(contextName) {
  var context3 = this.getContext(contextName);
  if (!!context3) {
    return context3.ranges;
  } else {
    return { FAIL: "context checker '" + contextName + "' is not registered." };
  }
};
Tokenizer.prototype.resetContextsRanges = function() {
  var registeredContexts = this.registeredContexts;
  for (var contextName in registeredContexts) {
    if (registeredContexts.hasOwnProperty(contextName)) {
      var context3 = registeredContexts[contextName];
      context3.ranges = [];
    }
  }
};
Tokenizer.prototype.updateContextsRanges = function() {
  this.resetContextsRanges();
  var chars = this.tokens.map(function(token) {
    return token.char;
  });
  for (var i3 = 0; i3 < chars.length; i3++) {
    var contextParams = new ContextParams(chars, i3);
    this.runContextCheck(contextParams);
  }
  this.dispatch("updateContextsRanges", [this.registeredContexts]);
};
Tokenizer.prototype.setEndOffset = function(offset, contextName) {
  var startIndex = this.getContext(contextName).openRange.startIndex;
  var range2 = new ContextRange(startIndex, offset, contextName);
  var ranges = this.getContext(contextName).ranges;
  range2.rangeId = contextName + "." + ranges.length;
  ranges.push(range2);
  this.getContext(contextName).openRange = null;
  return range2;
};
Tokenizer.prototype.runContextCheck = function(contextParams) {
  var this$1 = this;
  var index = contextParams.index;
  this.contextCheckers.forEach(function(contextChecker) {
    var contextName = contextChecker.contextName;
    var openRange = this$1.getContext(contextName).openRange;
    if (!openRange && contextChecker.checkStart(contextParams)) {
      openRange = new ContextRange(index, null, contextName);
      this$1.getContext(contextName).openRange = openRange;
      this$1.dispatch("contextStart", [contextName, index]);
    }
    if (!!openRange && contextChecker.checkEnd(contextParams)) {
      var offset = index - openRange.startIndex + 1;
      var range2 = this$1.setEndOffset(offset, contextName);
      this$1.dispatch("contextEnd", [contextName, range2]);
    }
  });
};
Tokenizer.prototype.tokenize = function(text) {
  this.tokens = [];
  this.resetContextsRanges();
  var chars = Array.from(text);
  this.dispatch("start");
  for (var i3 = 0; i3 < chars.length; i3++) {
    var char = chars[i3];
    var contextParams = new ContextParams(chars, i3);
    this.dispatch("next", [contextParams]);
    this.runContextCheck(contextParams);
    var token = new Token(char);
    this.tokens.push(token);
    this.dispatch("newToken", [token, contextParams]);
  }
  this.dispatch("end", [this.tokens]);
  return this.tokens;
};
function isArabicChar(c3) {
  return /[\u0600-\u065F\u066A-\u06D2\u06FA-\u06FF]/.test(c3);
}
function isIsolatedArabicChar(char) {
  return /[\u0630\u0690\u0621\u0631\u0661\u0671\u0622\u0632\u0672\u0692\u06C2\u0623\u0673\u0693\u06C3\u0624\u0694\u06C4\u0625\u0675\u0695\u06C5\u06E5\u0676\u0696\u06C6\u0627\u0677\u0697\u06C7\u0648\u0688\u0698\u06C8\u0689\u0699\u06C9\u068A\u06CA\u066B\u068B\u06CB\u068C\u068D\u06CD\u06FD\u068E\u06EE\u06FE\u062F\u068F\u06CF\u06EF]/.test(char);
}
function isTashkeelArabicChar(char) {
  return /[\u0600-\u0605\u060C-\u060E\u0610-\u061B\u061E\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED]/.test(char);
}
function isLatinChar(c3) {
  return /[A-z]/.test(c3);
}
function isWhiteSpace(c3) {
  return /\s/.test(c3);
}
function FeatureQuery(font) {
  this.font = font;
  this.features = {};
}
function SubstitutionAction(action) {
  this.id = action.id;
  this.tag = action.tag;
  this.substitution = action.substitution;
}
function lookupCoverage(glyphIndex, coverage) {
  if (!glyphIndex) {
    return -1;
  }
  switch (coverage.format) {
    case 1:
      return coverage.glyphs.indexOf(glyphIndex);
    case 2:
      var ranges = coverage.ranges;
      for (var i3 = 0; i3 < ranges.length; i3++) {
        var range2 = ranges[i3];
        if (glyphIndex >= range2.start && glyphIndex <= range2.end) {
          var offset = glyphIndex - range2.start;
          return range2.index + offset;
        }
      }
      break;
    default:
      return -1;
  }
  return -1;
}
function singleSubstitutionFormat1(glyphIndex, subtable) {
  var substituteIndex = lookupCoverage(glyphIndex, subtable.coverage);
  if (substituteIndex === -1) {
    return null;
  }
  return glyphIndex + subtable.deltaGlyphId;
}
function singleSubstitutionFormat2(glyphIndex, subtable) {
  var substituteIndex = lookupCoverage(glyphIndex, subtable.coverage);
  if (substituteIndex === -1) {
    return null;
  }
  return subtable.substitute[substituteIndex];
}
function lookupCoverageList(coverageList, contextParams) {
  var lookupList = [];
  for (var i3 = 0; i3 < coverageList.length; i3++) {
    var coverage = coverageList[i3];
    var glyphIndex = contextParams.current;
    glyphIndex = Array.isArray(glyphIndex) ? glyphIndex[0] : glyphIndex;
    var lookupIndex = lookupCoverage(glyphIndex, coverage);
    if (lookupIndex !== -1) {
      lookupList.push(lookupIndex);
    }
  }
  if (lookupList.length !== coverageList.length) {
    return -1;
  }
  return lookupList;
}
function chainingSubstitutionFormat3(contextParams, subtable) {
  var lookupsCount = subtable.inputCoverage.length + subtable.lookaheadCoverage.length + subtable.backtrackCoverage.length;
  if (contextParams.context.length < lookupsCount) {
    return [];
  }
  var inputLookups = lookupCoverageList(
    subtable.inputCoverage,
    contextParams
  );
  if (inputLookups === -1) {
    return [];
  }
  var lookaheadOffset = subtable.inputCoverage.length - 1;
  if (contextParams.lookahead.length < subtable.lookaheadCoverage.length) {
    return [];
  }
  var lookaheadContext = contextParams.lookahead.slice(lookaheadOffset);
  while (lookaheadContext.length && isTashkeelArabicChar(lookaheadContext[0].char)) {
    lookaheadContext.shift();
  }
  var lookaheadParams = new ContextParams(lookaheadContext, 0);
  var lookaheadLookups = lookupCoverageList(
    subtable.lookaheadCoverage,
    lookaheadParams
  );
  var backtrackContext = [].concat(contextParams.backtrack);
  backtrackContext.reverse();
  while (backtrackContext.length && isTashkeelArabicChar(backtrackContext[0].char)) {
    backtrackContext.shift();
  }
  if (backtrackContext.length < subtable.backtrackCoverage.length) {
    return [];
  }
  var backtrackParams = new ContextParams(backtrackContext, 0);
  var backtrackLookups = lookupCoverageList(
    subtable.backtrackCoverage,
    backtrackParams
  );
  var contextRulesMatch = inputLookups.length === subtable.inputCoverage.length && lookaheadLookups.length === subtable.lookaheadCoverage.length && backtrackLookups.length === subtable.backtrackCoverage.length;
  var substitutions = [];
  if (contextRulesMatch) {
    for (var i3 = 0; i3 < subtable.lookupRecords.length; i3++) {
      var lookupRecord = subtable.lookupRecords[i3];
      var lookupListIndex = lookupRecord.lookupListIndex;
      var lookupTable = this.getLookupByIndex(lookupListIndex);
      for (var s = 0; s < lookupTable.subtables.length; s++) {
        var subtable$1 = lookupTable.subtables[s];
        var lookup = this.getLookupMethod(lookupTable, subtable$1);
        var substitutionType = this.getSubstitutionType(lookupTable, subtable$1);
        if (substitutionType === "12") {
          for (var n = 0; n < inputLookups.length; n++) {
            var glyphIndex = contextParams.get(n);
            var substitution = lookup(glyphIndex);
            if (substitution) {
              substitutions.push(substitution);
            }
          }
        }
      }
    }
  }
  return substitutions;
}
function ligatureSubstitutionFormat1(contextParams, subtable) {
  var glyphIndex = contextParams.current;
  var ligSetIndex = lookupCoverage(glyphIndex, subtable.coverage);
  if (ligSetIndex === -1) {
    return null;
  }
  var ligature;
  var ligatureSet = subtable.ligatureSets[ligSetIndex];
  for (var s = 0; s < ligatureSet.length; s++) {
    ligature = ligatureSet[s];
    for (var l = 0; l < ligature.components.length; l++) {
      var lookaheadItem = contextParams.lookahead[l];
      var component = ligature.components[l];
      if (lookaheadItem !== component) {
        break;
      }
      if (l === ligature.components.length - 1) {
        return ligature;
      }
    }
  }
  return null;
}
function decompositionSubstitutionFormat1(glyphIndex, subtable) {
  var substituteIndex = lookupCoverage(glyphIndex, subtable.coverage);
  if (substituteIndex === -1) {
    return null;
  }
  return subtable.sequences[substituteIndex];
}
FeatureQuery.prototype.getDefaultScriptFeaturesIndexes = function() {
  var scripts = this.font.tables.gsub.scripts;
  for (var s = 0; s < scripts.length; s++) {
    var script = scripts[s];
    if (script.tag === "DFLT") {
      return script.script.defaultLangSys.featureIndexes;
    }
  }
  return [];
};
FeatureQuery.prototype.getScriptFeaturesIndexes = function(scriptTag) {
  var tables = this.font.tables;
  if (!tables.gsub) {
    return [];
  }
  if (!scriptTag) {
    return this.getDefaultScriptFeaturesIndexes();
  }
  var scripts = this.font.tables.gsub.scripts;
  for (var i3 = 0; i3 < scripts.length; i3++) {
    var script = scripts[i3];
    if (script.tag === scriptTag && script.script.defaultLangSys) {
      return script.script.defaultLangSys.featureIndexes;
    } else {
      var langSysRecords = script.langSysRecords;
      if (!!langSysRecords) {
        for (var j = 0; j < langSysRecords.length; j++) {
          var langSysRecord = langSysRecords[j];
          if (langSysRecord.tag === scriptTag) {
            var langSys = langSysRecord.langSys;
            return langSys.featureIndexes;
          }
        }
      }
    }
  }
  return this.getDefaultScriptFeaturesIndexes();
};
FeatureQuery.prototype.mapTagsToFeatures = function(features, scriptTag) {
  var tags = {};
  for (var i3 = 0; i3 < features.length; i3++) {
    var tag = features[i3].tag;
    var feature = features[i3].feature;
    tags[tag] = feature;
  }
  this.features[scriptTag].tags = tags;
};
FeatureQuery.prototype.getScriptFeatures = function(scriptTag) {
  var features = this.features[scriptTag];
  if (this.features.hasOwnProperty(scriptTag)) {
    return features;
  }
  var featuresIndexes = this.getScriptFeaturesIndexes(scriptTag);
  if (!featuresIndexes) {
    return null;
  }
  var gsub2 = this.font.tables.gsub;
  features = featuresIndexes.map(function(index) {
    return gsub2.features[index];
  });
  this.features[scriptTag] = features;
  this.mapTagsToFeatures(features, scriptTag);
  return features;
};
FeatureQuery.prototype.getSubstitutionType = function(lookupTable, subtable) {
  var lookupType = lookupTable.lookupType.toString();
  var substFormat = subtable.substFormat.toString();
  return lookupType + substFormat;
};
FeatureQuery.prototype.getLookupMethod = function(lookupTable, subtable) {
  var this$1 = this;
  var substitutionType = this.getSubstitutionType(lookupTable, subtable);
  switch (substitutionType) {
    case "11":
      return function(glyphIndex) {
        return singleSubstitutionFormat1.apply(
          this$1,
          [glyphIndex, subtable]
        );
      };
    case "12":
      return function(glyphIndex) {
        return singleSubstitutionFormat2.apply(
          this$1,
          [glyphIndex, subtable]
        );
      };
    case "63":
      return function(contextParams) {
        return chainingSubstitutionFormat3.apply(
          this$1,
          [contextParams, subtable]
        );
      };
    case "41":
      return function(contextParams) {
        return ligatureSubstitutionFormat1.apply(
          this$1,
          [contextParams, subtable]
        );
      };
    case "21":
      return function(glyphIndex) {
        return decompositionSubstitutionFormat1.apply(
          this$1,
          [glyphIndex, subtable]
        );
      };
    default:
      throw new Error(
        "lookupType: " + lookupTable.lookupType + " - substFormat: " + subtable.substFormat + " is not yet supported"
      );
  }
};
FeatureQuery.prototype.lookupFeature = function(query) {
  var contextParams = query.contextParams;
  var currentIndex = contextParams.index;
  var feature = this.getFeature({
    tag: query.tag,
    script: query.script
  });
  if (!feature) {
    return new Error(
      "font '" + this.font.names.fullName.en + "' doesn't support feature '" + query.tag + "' for script '" + query.script + "'."
    );
  }
  var lookups = this.getFeatureLookups(feature);
  var substitutions = [].concat(contextParams.context);
  for (var l = 0; l < lookups.length; l++) {
    var lookupTable = lookups[l];
    var subtables = this.getLookupSubtables(lookupTable);
    for (var s = 0; s < subtables.length; s++) {
      var subtable = subtables[s];
      var substType = this.getSubstitutionType(lookupTable, subtable);
      var lookup = this.getLookupMethod(lookupTable, subtable);
      var substitution = void 0;
      switch (substType) {
        case "11":
          substitution = lookup(contextParams.current);
          if (substitution) {
            substitutions.splice(currentIndex, 1, new SubstitutionAction({
              id: 11,
              tag: query.tag,
              substitution
            }));
          }
          break;
        case "12":
          substitution = lookup(contextParams.current);
          if (substitution) {
            substitutions.splice(currentIndex, 1, new SubstitutionAction({
              id: 12,
              tag: query.tag,
              substitution
            }));
          }
          break;
        case "63":
          substitution = lookup(contextParams);
          if (Array.isArray(substitution) && substitution.length) {
            substitutions.splice(currentIndex, 1, new SubstitutionAction({
              id: 63,
              tag: query.tag,
              substitution
            }));
          }
          break;
        case "41":
          substitution = lookup(contextParams);
          if (substitution) {
            substitutions.splice(currentIndex, 1, new SubstitutionAction({
              id: 41,
              tag: query.tag,
              substitution
            }));
          }
          break;
        case "21":
          substitution = lookup(contextParams.current);
          if (substitution) {
            substitutions.splice(currentIndex, 1, new SubstitutionAction({
              id: 21,
              tag: query.tag,
              substitution
            }));
          }
          break;
      }
      contextParams = new ContextParams(substitutions, currentIndex);
      if (Array.isArray(substitution) && !substitution.length) {
        continue;
      }
      substitution = null;
    }
  }
  return substitutions.length ? substitutions : null;
};
FeatureQuery.prototype.supports = function(query) {
  if (!query.script) {
    return false;
  }
  this.getScriptFeatures(query.script);
  var supportedScript = this.features.hasOwnProperty(query.script);
  if (!query.tag) {
    return supportedScript;
  }
  var supportedFeature = this.features[query.script].some(function(feature) {
    return feature.tag === query.tag;
  });
  return supportedScript && supportedFeature;
};
FeatureQuery.prototype.getLookupSubtables = function(lookupTable) {
  return lookupTable.subtables || null;
};
FeatureQuery.prototype.getLookupByIndex = function(index) {
  var lookups = this.font.tables.gsub.lookups;
  return lookups[index] || null;
};
FeatureQuery.prototype.getFeatureLookups = function(feature) {
  return feature.lookupListIndexes.map(this.getLookupByIndex.bind(this));
};
FeatureQuery.prototype.getFeature = function getFeature(query) {
  if (!this.font) {
    return { FAIL: "No font was found" };
  }
  if (!this.features.hasOwnProperty(query.script)) {
    this.getScriptFeatures(query.script);
  }
  var scriptFeatures = this.features[query.script];
  if (!scriptFeatures) {
    return { FAIL: "No feature for script " + query.script };
  }
  if (!scriptFeatures.tags[query.tag]) {
    return null;
  }
  return this.features[query.script].tags[query.tag];
};
function arabicWordStartCheck(contextParams) {
  var char = contextParams.current;
  var prevChar = contextParams.get(-1);
  return (
    // ? arabic first char
    prevChar === null && isArabicChar(char) || // ? arabic char preceded with a non arabic char
    !isArabicChar(prevChar) && isArabicChar(char)
  );
}
function arabicWordEndCheck(contextParams) {
  var nextChar = contextParams.get(1);
  return (
    // ? last arabic char
    nextChar === null || // ? next char is not arabic
    !isArabicChar(nextChar)
  );
}
var arabicWordCheck = {
  startCheck: arabicWordStartCheck,
  endCheck: arabicWordEndCheck
};
function arabicSentenceStartCheck(contextParams) {
  var char = contextParams.current;
  var prevChar = contextParams.get(-1);
  return (
    // ? an arabic char preceded with a non arabic char
    (isArabicChar(char) || isTashkeelArabicChar(char)) && !isArabicChar(prevChar)
  );
}
function arabicSentenceEndCheck(contextParams) {
  var nextChar = contextParams.get(1);
  switch (true) {
    case nextChar === null:
      return true;
    case (!isArabicChar(nextChar) && !isTashkeelArabicChar(nextChar)):
      var nextIsWhitespace = isWhiteSpace(nextChar);
      if (!nextIsWhitespace) {
        return true;
      }
      if (nextIsWhitespace) {
        var arabicCharAhead = false;
        arabicCharAhead = contextParams.lookahead.some(
          function(c3) {
            return isArabicChar(c3) || isTashkeelArabicChar(c3);
          }
        );
        if (!arabicCharAhead) {
          return true;
        }
      }
      break;
    default:
      return false;
  }
}
var arabicSentenceCheck = {
  startCheck: arabicSentenceStartCheck,
  endCheck: arabicSentenceEndCheck
};
function singleSubstitutionFormat1$1(action, tokens, index) {
  tokens[index].setState(action.tag, action.substitution);
}
function singleSubstitutionFormat2$1(action, tokens, index) {
  tokens[index].setState(action.tag, action.substitution);
}
function chainingSubstitutionFormat3$1(action, tokens, index) {
  action.substitution.forEach(function(subst, offset) {
    var token = tokens[index + offset];
    token.setState(action.tag, subst);
  });
}
function ligatureSubstitutionFormat1$1(action, tokens, index) {
  var token = tokens[index];
  token.setState(action.tag, action.substitution.ligGlyph);
  var compsCount = action.substitution.components.length;
  for (var i3 = 0; i3 < compsCount; i3++) {
    token = tokens[index + i3 + 1];
    token.setState("deleted", true);
  }
}
var SUBSTITUTIONS = {
  11: singleSubstitutionFormat1$1,
  12: singleSubstitutionFormat2$1,
  63: chainingSubstitutionFormat3$1,
  41: ligatureSubstitutionFormat1$1
};
function applySubstitution(action, tokens, index) {
  if (action instanceof SubstitutionAction && SUBSTITUTIONS[action.id]) {
    SUBSTITUTIONS[action.id](action, tokens, index);
  }
}
function willConnectPrev(charContextParams) {
  var backtrack = [].concat(charContextParams.backtrack);
  for (var i3 = backtrack.length - 1; i3 >= 0; i3--) {
    var prevChar = backtrack[i3];
    var isolated = isIsolatedArabicChar(prevChar);
    var tashkeel = isTashkeelArabicChar(prevChar);
    if (!isolated && !tashkeel) {
      return true;
    }
    if (isolated) {
      return false;
    }
  }
  return false;
}
function willConnectNext(charContextParams) {
  if (isIsolatedArabicChar(charContextParams.current)) {
    return false;
  }
  for (var i3 = 0; i3 < charContextParams.lookahead.length; i3++) {
    var nextChar = charContextParams.lookahead[i3];
    var tashkeel = isTashkeelArabicChar(nextChar);
    if (!tashkeel) {
      return true;
    }
  }
  return false;
}
function arabicPresentationForms(range2) {
  var this$1 = this;
  var script = "arab";
  var tags = this.featuresTags[script];
  var tokens = this.tokenizer.getRangeTokens(range2);
  if (tokens.length === 1) {
    return;
  }
  var contextParams = new ContextParams(
    tokens.map(
      function(token) {
        return token.getState("glyphIndex");
      }
    ),
    0
  );
  var charContextParams = new ContextParams(
    tokens.map(
      function(token) {
        return token.char;
      }
    ),
    0
  );
  tokens.forEach(function(token, index) {
    if (isTashkeelArabicChar(token.char)) {
      return;
    }
    contextParams.setCurrentIndex(index);
    charContextParams.setCurrentIndex(index);
    var CONNECT = 0;
    if (willConnectPrev(charContextParams)) {
      CONNECT |= 1;
    }
    if (willConnectNext(charContextParams)) {
      CONNECT |= 2;
    }
    var tag;
    switch (CONNECT) {
      case 1:
        tag = "fina";
        break;
      case 2:
        tag = "init";
        break;
      case 3:
        tag = "medi";
        break;
    }
    if (tags.indexOf(tag) === -1) {
      return;
    }
    var substitutions = this$1.query.lookupFeature({
      tag,
      script,
      contextParams
    });
    if (substitutions instanceof Error) {
      return console.info(substitutions.message);
    }
    substitutions.forEach(function(action, index2) {
      if (action instanceof SubstitutionAction) {
        applySubstitution(action, tokens, index2);
        contextParams.context[index2] = action.substitution;
      }
    });
  });
}
function getContextParams(tokens, index) {
  var context3 = tokens.map(function(token) {
    return token.activeState.value;
  });
  return new ContextParams(context3, index || 0);
}
function arabicRequiredLigatures(range2) {
  var this$1 = this;
  var script = "arab";
  var tokens = this.tokenizer.getRangeTokens(range2);
  var contextParams = getContextParams(tokens);
  contextParams.context.forEach(function(glyphIndex, index) {
    contextParams.setCurrentIndex(index);
    var substitutions = this$1.query.lookupFeature({
      tag: "rlig",
      script,
      contextParams
    });
    if (substitutions.length) {
      substitutions.forEach(
        function(action) {
          return applySubstitution(action, tokens, index);
        }
      );
      contextParams = getContextParams(tokens);
    }
  });
}
function latinWordStartCheck(contextParams) {
  var char = contextParams.current;
  var prevChar = contextParams.get(-1);
  return (
    // ? latin first char
    prevChar === null && isLatinChar(char) || // ? latin char preceded with a non latin char
    !isLatinChar(prevChar) && isLatinChar(char)
  );
}
function latinWordEndCheck(contextParams) {
  var nextChar = contextParams.get(1);
  return (
    // ? last latin char
    nextChar === null || // ? next char is not latin
    !isLatinChar(nextChar)
  );
}
var latinWordCheck = {
  startCheck: latinWordStartCheck,
  endCheck: latinWordEndCheck
};
function getContextParams$1(tokens, index) {
  var context3 = tokens.map(function(token) {
    return token.activeState.value;
  });
  return new ContextParams(context3, index || 0);
}
function latinLigature(range2) {
  var this$1 = this;
  var script = "latn";
  var tokens = this.tokenizer.getRangeTokens(range2);
  var contextParams = getContextParams$1(tokens);
  contextParams.context.forEach(function(glyphIndex, index) {
    contextParams.setCurrentIndex(index);
    var substitutions = this$1.query.lookupFeature({
      tag: "liga",
      script,
      contextParams
    });
    if (substitutions.length) {
      substitutions.forEach(
        function(action) {
          return applySubstitution(action, tokens, index);
        }
      );
      contextParams = getContextParams$1(tokens);
    }
  });
}
function Bidi(baseDir) {
  this.baseDir = baseDir || "ltr";
  this.tokenizer = new Tokenizer();
  this.featuresTags = {};
}
Bidi.prototype.setText = function(text) {
  this.text = text;
};
Bidi.prototype.contextChecks = {
  latinWordCheck,
  arabicWordCheck,
  arabicSentenceCheck
};
function registerContextChecker(checkId) {
  var check2 = this.contextChecks[checkId + "Check"];
  return this.tokenizer.registerContextChecker(
    checkId,
    check2.startCheck,
    check2.endCheck
  );
}
function tokenizeText() {
  registerContextChecker.call(this, "latinWord");
  registerContextChecker.call(this, "arabicWord");
  registerContextChecker.call(this, "arabicSentence");
  return this.tokenizer.tokenize(this.text);
}
function reverseArabicSentences() {
  var this$1 = this;
  var ranges = this.tokenizer.getContextRanges("arabicSentence");
  ranges.forEach(function(range2) {
    var rangeTokens = this$1.tokenizer.getRangeTokens(range2);
    this$1.tokenizer.replaceRange(
      range2.startIndex,
      range2.endOffset,
      rangeTokens.reverse()
    );
  });
}
Bidi.prototype.registerFeatures = function(script, tags) {
  var this$1 = this;
  var supportedTags = tags.filter(
    function(tag) {
      return this$1.query.supports({ script, tag });
    }
  );
  if (!this.featuresTags.hasOwnProperty(script)) {
    this.featuresTags[script] = supportedTags;
  } else {
    this.featuresTags[script] = this.featuresTags[script].concat(supportedTags);
  }
};
Bidi.prototype.applyFeatures = function(font, features) {
  if (!font) {
    throw new Error(
      "No valid font was provided to apply features"
    );
  }
  if (!this.query) {
    this.query = new FeatureQuery(font);
  }
  for (var f = 0; f < features.length; f++) {
    var feature = features[f];
    if (!this.query.supports({ script: feature.script })) {
      continue;
    }
    this.registerFeatures(feature.script, feature.tags);
  }
};
Bidi.prototype.registerModifier = function(modifierId, condition, modifier) {
  this.tokenizer.registerModifier(modifierId, condition, modifier);
};
function checkGlyphIndexStatus() {
  if (this.tokenizer.registeredModifiers.indexOf("glyphIndex") === -1) {
    throw new Error(
      "glyphIndex modifier is required to apply arabic presentation features."
    );
  }
}
function applyArabicPresentationForms() {
  var this$1 = this;
  var script = "arab";
  if (!this.featuresTags.hasOwnProperty(script)) {
    return;
  }
  checkGlyphIndexStatus.call(this);
  var ranges = this.tokenizer.getContextRanges("arabicWord");
  ranges.forEach(function(range2) {
    arabicPresentationForms.call(this$1, range2);
  });
}
function applyArabicRequireLigatures() {
  var this$1 = this;
  var script = "arab";
  if (!this.featuresTags.hasOwnProperty(script)) {
    return;
  }
  var tags = this.featuresTags[script];
  if (tags.indexOf("rlig") === -1) {
    return;
  }
  checkGlyphIndexStatus.call(this);
  var ranges = this.tokenizer.getContextRanges("arabicWord");
  ranges.forEach(function(range2) {
    arabicRequiredLigatures.call(this$1, range2);
  });
}
function applyLatinLigatures() {
  var this$1 = this;
  var script = "latn";
  if (!this.featuresTags.hasOwnProperty(script)) {
    return;
  }
  var tags = this.featuresTags[script];
  if (tags.indexOf("liga") === -1) {
    return;
  }
  checkGlyphIndexStatus.call(this);
  var ranges = this.tokenizer.getContextRanges("latinWord");
  ranges.forEach(function(range2) {
    latinLigature.call(this$1, range2);
  });
}
Bidi.prototype.checkContextReady = function(contextId) {
  return !!this.tokenizer.getContext(contextId);
};
Bidi.prototype.applyFeaturesToContexts = function() {
  if (this.checkContextReady("arabicWord")) {
    applyArabicPresentationForms.call(this);
    applyArabicRequireLigatures.call(this);
  }
  if (this.checkContextReady("latinWord")) {
    applyLatinLigatures.call(this);
  }
  if (this.checkContextReady("arabicSentence")) {
    reverseArabicSentences.call(this);
  }
};
Bidi.prototype.processText = function(text) {
  if (!this.text || this.text !== text) {
    this.setText(text);
    tokenizeText.call(this);
    this.applyFeaturesToContexts();
  }
};
Bidi.prototype.getBidiText = function(text) {
  this.processText(text);
  return this.tokenizer.getText();
};
Bidi.prototype.getTextGlyphs = function(text) {
  this.processText(text);
  var indexes = [];
  for (var i3 = 0; i3 < this.tokenizer.tokens.length; i3++) {
    var token = this.tokenizer.tokens[i3];
    if (token.state.deleted) {
      continue;
    }
    var index = token.activeState.value;
    indexes.push(Array.isArray(index) ? index[0] : index);
  }
  return indexes;
};
function Font2(options) {
  options = options || {};
  options.tables = options.tables || {};
  if (!options.empty) {
    checkArgument(options.familyName, "When creating a new Font object, familyName is required.");
    checkArgument(options.styleName, "When creating a new Font object, styleName is required.");
    checkArgument(options.unitsPerEm, "When creating a new Font object, unitsPerEm is required.");
    checkArgument(options.ascender, "When creating a new Font object, ascender is required.");
    checkArgument(options.descender <= 0, "When creating a new Font object, negative descender value is required.");
    this.names = {
      fontFamily: { en: options.familyName || " " },
      fontSubfamily: { en: options.styleName || " " },
      fullName: { en: options.fullName || options.familyName + " " + options.styleName },
      // postScriptName may not contain any whitespace
      postScriptName: { en: options.postScriptName || (options.familyName + options.styleName).replace(/\s/g, "") },
      designer: { en: options.designer || " " },
      designerURL: { en: options.designerURL || " " },
      manufacturer: { en: options.manufacturer || " " },
      manufacturerURL: { en: options.manufacturerURL || " " },
      license: { en: options.license || " " },
      licenseURL: { en: options.licenseURL || " " },
      version: { en: options.version || "Version 0.1" },
      description: { en: options.description || " " },
      copyright: { en: options.copyright || " " },
      trademark: { en: options.trademark || " " }
    };
    this.unitsPerEm = options.unitsPerEm || 1e3;
    this.ascender = options.ascender;
    this.descender = options.descender;
    this.createdTimestamp = options.createdTimestamp;
    this.tables = Object.assign(options.tables, {
      os2: Object.assign({
        usWeightClass: options.weightClass || this.usWeightClasses.MEDIUM,
        usWidthClass: options.widthClass || this.usWidthClasses.MEDIUM,
        fsSelection: options.fsSelection || this.fsSelectionValues.REGULAR
      }, options.tables.os2)
    });
  }
  this.supported = true;
  this.glyphs = new glyphset.GlyphSet(this, options.glyphs || []);
  this.encoding = new DefaultEncoding(this);
  this.position = new Position(this);
  this.substitution = new Substitution(this);
  this.tables = this.tables || {};
  this._push = null;
  this._hmtxTableData = {};
  Object.defineProperty(this, "hinting", {
    get: function() {
      if (this._hinting) {
        return this._hinting;
      }
      if (this.outlinesFormat === "truetype") {
        return this._hinting = new Hinting(this);
      }
    }
  });
}
Font2.prototype.hasChar = function(c3) {
  return this.encoding.charToGlyphIndex(c3) !== null;
};
Font2.prototype.charToGlyphIndex = function(s) {
  return this.encoding.charToGlyphIndex(s);
};
Font2.prototype.charToGlyph = function(c3) {
  var glyphIndex = this.charToGlyphIndex(c3);
  var glyph = this.glyphs.get(glyphIndex);
  if (!glyph) {
    glyph = this.glyphs.get(0);
  }
  return glyph;
};
Font2.prototype.updateFeatures = function(options) {
  return this.defaultRenderOptions.features.map(function(feature) {
    if (feature.script === "latn") {
      return {
        script: "latn",
        tags: feature.tags.filter(function(tag) {
          return options[tag];
        })
      };
    } else {
      return feature;
    }
  });
};
Font2.prototype.stringToGlyphs = function(s, options) {
  var this$1 = this;
  var bidi = new Bidi();
  var charToGlyphIndexMod = function(token) {
    return this$1.charToGlyphIndex(token.char);
  };
  bidi.registerModifier("glyphIndex", null, charToGlyphIndexMod);
  var features = options ? this.updateFeatures(options.features) : this.defaultRenderOptions.features;
  bidi.applyFeatures(this, features);
  var indexes = bidi.getTextGlyphs(s);
  var length = indexes.length;
  var glyphs = new Array(length);
  var notdef = this.glyphs.get(0);
  for (var i3 = 0; i3 < length; i3 += 1) {
    glyphs[i3] = this.glyphs.get(indexes[i3]) || notdef;
  }
  return glyphs;
};
Font2.prototype.nameToGlyphIndex = function(name) {
  return this.glyphNames.nameToGlyphIndex(name);
};
Font2.prototype.nameToGlyph = function(name) {
  var glyphIndex = this.nameToGlyphIndex(name);
  var glyph = this.glyphs.get(glyphIndex);
  if (!glyph) {
    glyph = this.glyphs.get(0);
  }
  return glyph;
};
Font2.prototype.glyphIndexToName = function(gid) {
  if (!this.glyphNames.glyphIndexToName) {
    return "";
  }
  return this.glyphNames.glyphIndexToName(gid);
};
Font2.prototype.getKerningValue = function(leftGlyph, rightGlyph) {
  leftGlyph = leftGlyph.index || leftGlyph;
  rightGlyph = rightGlyph.index || rightGlyph;
  var gposKerning = this.position.defaultKerningTables;
  if (gposKerning) {
    return this.position.getKerningValue(gposKerning, leftGlyph, rightGlyph);
  }
  return this.kerningPairs[leftGlyph + "," + rightGlyph] || 0;
};
Font2.prototype.defaultRenderOptions = {
  kerning: true,
  features: [
    /**
     * these 4 features are required to render Arabic text properly
     * and shouldn't be turned off when rendering arabic text.
     */
    { script: "arab", tags: ["init", "medi", "fina", "rlig"] },
    { script: "latn", tags: ["liga", "rlig"] }
  ]
};
Font2.prototype.forEachGlyph = function(text, x, y, fontSize, options, callback) {
  x = x !== void 0 ? x : 0;
  y = y !== void 0 ? y : 0;
  fontSize = fontSize !== void 0 ? fontSize : 72;
  options = Object.assign({}, this.defaultRenderOptions, options);
  var fontScale = 1 / this.unitsPerEm * fontSize;
  var glyphs = this.stringToGlyphs(text, options);
  var kerningLookups;
  if (options.kerning) {
    var script = options.script || this.position.getDefaultScriptName();
    kerningLookups = this.position.getKerningTables(script, options.language);
  }
  for (var i3 = 0; i3 < glyphs.length; i3 += 1) {
    var glyph = glyphs[i3];
    callback.call(this, glyph, x, y, fontSize, options);
    if (glyph.advanceWidth) {
      x += glyph.advanceWidth * fontScale;
    }
    if (options.kerning && i3 < glyphs.length - 1) {
      var kerningValue = kerningLookups ? this.position.getKerningValue(kerningLookups, glyph.index, glyphs[i3 + 1].index) : this.getKerningValue(glyph, glyphs[i3 + 1]);
      x += kerningValue * fontScale;
    }
    if (options.letterSpacing) {
      x += options.letterSpacing * fontSize;
    } else if (options.tracking) {
      x += options.tracking / 1e3 * fontSize;
    }
  }
  return x;
};
Font2.prototype.getPath = function(text, x, y, fontSize, options) {
  var fullPath = new Path2();
  this.forEachGlyph(text, x, y, fontSize, options, function(glyph, gX, gY, gFontSize) {
    var glyphPath = glyph.getPath(gX, gY, gFontSize, options, this);
    fullPath.extend(glyphPath);
  });
  return fullPath;
};
Font2.prototype.getPaths = function(text, x, y, fontSize, options) {
  var glyphPaths = [];
  this.forEachGlyph(text, x, y, fontSize, options, function(glyph, gX, gY, gFontSize) {
    var glyphPath = glyph.getPath(gX, gY, gFontSize, options, this);
    glyphPaths.push(glyphPath);
  });
  return glyphPaths;
};
Font2.prototype.getAdvanceWidth = function(text, fontSize, options) {
  return this.forEachGlyph(text, 0, 0, fontSize, options, function() {
  });
};
Font2.prototype.draw = function(ctx, text, x, y, fontSize, options) {
  this.getPath(text, x, y, fontSize, options).draw(ctx);
};
Font2.prototype.drawPoints = function(ctx, text, x, y, fontSize, options) {
  this.forEachGlyph(text, x, y, fontSize, options, function(glyph, gX, gY, gFontSize) {
    glyph.drawPoints(ctx, gX, gY, gFontSize);
  });
};
Font2.prototype.drawMetrics = function(ctx, text, x, y, fontSize, options) {
  this.forEachGlyph(text, x, y, fontSize, options, function(glyph, gX, gY, gFontSize) {
    glyph.drawMetrics(ctx, gX, gY, gFontSize);
  });
};
Font2.prototype.getEnglishName = function(name) {
  var translations = this.names[name];
  if (translations) {
    return translations.en;
  }
};
Font2.prototype.validate = function() {
  var _this = this;
  function assert(predicate, message) {
  }
  function assertNamePresent(name) {
    var englishName = _this.getEnglishName(name);
    assert(englishName && englishName.trim().length > 0);
  }
  assertNamePresent("fontFamily");
  assertNamePresent("weightName");
  assertNamePresent("manufacturer");
  assertNamePresent("copyright");
  assertNamePresent("version");
  assert(this.unitsPerEm > 0);
};
Font2.prototype.toTables = function() {
  return sfnt.fontToTable(this);
};
Font2.prototype.toBuffer = function() {
  console.warn("Font.toBuffer is deprecated. Use Font.toArrayBuffer instead.");
  return this.toArrayBuffer();
};
Font2.prototype.toArrayBuffer = function() {
  var sfntTable = this.toTables();
  var bytes = sfntTable.encode();
  var buffer = new ArrayBuffer(bytes.length);
  var intArray = new Uint8Array(buffer);
  for (var i3 = 0; i3 < bytes.length; i3++) {
    intArray[i3] = bytes[i3];
  }
  return buffer;
};
Font2.prototype.download = function(fileName) {
  var familyName = this.getEnglishName("fontFamily");
  var styleName = this.getEnglishName("fontSubfamily");
  fileName = fileName || familyName.replace(/\s/g, "") + "-" + styleName + ".otf";
  var arrayBuffer = this.toArrayBuffer();
  if (isBrowser()) {
    window.URL = window.URL || window.webkitURL;
    if (window.URL) {
      var dataView = new DataView(arrayBuffer);
      var blob = new Blob([dataView], { type: "font/opentype" });
      var link = document.createElement("a");
      link.href = window.URL.createObjectURL(blob);
      link.download = fileName;
      var event = document.createEvent("MouseEvents");
      event.initEvent("click", true, false);
      link.dispatchEvent(event);
    } else {
      console.warn("Font file could not be downloaded. Try using a different browser.");
    }
  } else {
    var fs = require_fs();
    var buffer = arrayBufferToNodeBuffer(arrayBuffer);
    fs.writeFileSync(fileName, buffer);
  }
};
Font2.prototype.fsSelectionValues = {
  ITALIC: 1,
  //1
  UNDERSCORE: 2,
  //2
  NEGATIVE: 4,
  //4
  OUTLINED: 8,
  //8
  STRIKEOUT: 16,
  //16
  BOLD: 32,
  //32
  REGULAR: 64,
  //64
  USER_TYPO_METRICS: 128,
  //128
  WWS: 256,
  //256
  OBLIQUE: 512
  //512
};
Font2.prototype.usWidthClasses = {
  ULTRA_CONDENSED: 1,
  EXTRA_CONDENSED: 2,
  CONDENSED: 3,
  SEMI_CONDENSED: 4,
  MEDIUM: 5,
  SEMI_EXPANDED: 6,
  EXPANDED: 7,
  EXTRA_EXPANDED: 8,
  ULTRA_EXPANDED: 9
};
Font2.prototype.usWeightClasses = {
  THIN: 100,
  EXTRA_LIGHT: 200,
  LIGHT: 300,
  NORMAL: 400,
  MEDIUM: 500,
  SEMI_BOLD: 600,
  BOLD: 700,
  EXTRA_BOLD: 800,
  BLACK: 900
};
function addName(name, names) {
  var nameString = JSON.stringify(name);
  var nameID = 256;
  for (var nameKey in names) {
    var n = parseInt(nameKey);
    if (!n || n < 256) {
      continue;
    }
    if (JSON.stringify(names[nameKey]) === nameString) {
      return n;
    }
    if (nameID <= n) {
      nameID = n + 1;
    }
  }
  names[nameID] = name;
  return nameID;
}
function makeFvarAxis(n, axis, names) {
  var nameID = addName(axis.name, names);
  return [
    { name: "tag_" + n, type: "TAG", value: axis.tag },
    { name: "minValue_" + n, type: "FIXED", value: axis.minValue << 16 },
    { name: "defaultValue_" + n, type: "FIXED", value: axis.defaultValue << 16 },
    { name: "maxValue_" + n, type: "FIXED", value: axis.maxValue << 16 },
    { name: "flags_" + n, type: "USHORT", value: 0 },
    { name: "nameID_" + n, type: "USHORT", value: nameID }
  ];
}
function parseFvarAxis(data, start, names) {
  var axis = {};
  var p = new parse.Parser(data, start);
  axis.tag = p.parseTag();
  axis.minValue = p.parseFixed();
  axis.defaultValue = p.parseFixed();
  axis.maxValue = p.parseFixed();
  p.skip("uShort", 1);
  axis.name = names[p.parseUShort()] || {};
  return axis;
}
function makeFvarInstance(n, inst, axes, names) {
  var nameID = addName(inst.name, names);
  var fields = [
    { name: "nameID_" + n, type: "USHORT", value: nameID },
    { name: "flags_" + n, type: "USHORT", value: 0 }
  ];
  for (var i3 = 0; i3 < axes.length; ++i3) {
    var axisTag = axes[i3].tag;
    fields.push({
      name: "axis_" + n + " " + axisTag,
      type: "FIXED",
      value: inst.coordinates[axisTag] << 16
    });
  }
  return fields;
}
function parseFvarInstance(data, start, axes, names) {
  var inst = {};
  var p = new parse.Parser(data, start);
  inst.name = names[p.parseUShort()] || {};
  p.skip("uShort", 1);
  inst.coordinates = {};
  for (var i3 = 0; i3 < axes.length; ++i3) {
    inst.coordinates[axes[i3].tag] = p.parseFixed();
  }
  return inst;
}
function makeFvarTable(fvar2, names) {
  var result = new table.Table("fvar", [
    { name: "version", type: "ULONG", value: 65536 },
    { name: "offsetToData", type: "USHORT", value: 0 },
    { name: "countSizePairs", type: "USHORT", value: 2 },
    { name: "axisCount", type: "USHORT", value: fvar2.axes.length },
    { name: "axisSize", type: "USHORT", value: 20 },
    { name: "instanceCount", type: "USHORT", value: fvar2.instances.length },
    { name: "instanceSize", type: "USHORT", value: 4 + fvar2.axes.length * 4 }
  ]);
  result.offsetToData = result.sizeOf();
  for (var i3 = 0; i3 < fvar2.axes.length; i3++) {
    result.fields = result.fields.concat(makeFvarAxis(i3, fvar2.axes[i3], names));
  }
  for (var j = 0; j < fvar2.instances.length; j++) {
    result.fields = result.fields.concat(makeFvarInstance(j, fvar2.instances[j], fvar2.axes, names));
  }
  return result;
}
function parseFvarTable(data, start, names) {
  var p = new parse.Parser(data, start);
  var tableVersion = p.parseULong();
  check.argument(tableVersion === 65536, "Unsupported fvar table version.");
  var offsetToData = p.parseOffset16();
  p.skip("uShort", 1);
  var axisCount = p.parseUShort();
  var axisSize = p.parseUShort();
  var instanceCount = p.parseUShort();
  var instanceSize = p.parseUShort();
  var axes = [];
  for (var i3 = 0; i3 < axisCount; i3++) {
    axes.push(parseFvarAxis(data, start + offsetToData + i3 * axisSize, names));
  }
  var instances = [];
  var instanceStart = start + offsetToData + axisCount * axisSize;
  for (var j = 0; j < instanceCount; j++) {
    instances.push(parseFvarInstance(data, instanceStart + j * instanceSize, axes, names));
  }
  return { axes, instances };
}
var fvar = { make: makeFvarTable, parse: parseFvarTable };
var attachList = function() {
  return {
    coverage: this.parsePointer(Parser3.coverage),
    attachPoints: this.parseList(Parser3.pointer(Parser3.uShortList))
  };
};
var caretValue = function() {
  var format = this.parseUShort();
  check.argument(
    format === 1 || format === 2 || format === 3,
    "Unsupported CaretValue table version."
  );
  if (format === 1) {
    return { coordinate: this.parseShort() };
  } else if (format === 2) {
    return { pointindex: this.parseShort() };
  } else if (format === 3) {
    return { coordinate: this.parseShort() };
  }
};
var ligGlyph = function() {
  return this.parseList(Parser3.pointer(caretValue));
};
var ligCaretList = function() {
  return {
    coverage: this.parsePointer(Parser3.coverage),
    ligGlyphs: this.parseList(Parser3.pointer(ligGlyph))
  };
};
var markGlyphSets = function() {
  this.parseUShort();
  return this.parseList(Parser3.pointer(Parser3.coverage));
};
function parseGDEFTable(data, start) {
  start = start || 0;
  var p = new Parser3(data, start);
  var tableVersion = p.parseVersion(1);
  check.argument(
    tableVersion === 1 || tableVersion === 1.2 || tableVersion === 1.3,
    "Unsupported GDEF table version."
  );
  var gdef2 = {
    version: tableVersion,
    classDef: p.parsePointer(Parser3.classDef),
    attachList: p.parsePointer(attachList),
    ligCaretList: p.parsePointer(ligCaretList),
    markAttachClassDef: p.parsePointer(Parser3.classDef)
  };
  if (tableVersion >= 1.2) {
    gdef2.markGlyphSets = p.parsePointer(markGlyphSets);
  }
  return gdef2;
}
var gdef = { parse: parseGDEFTable };
var subtableParsers$1 = new Array(10);
subtableParsers$1[1] = function parseLookup12() {
  var start = this.offset + this.relativeOffset;
  var posformat = this.parseUShort();
  if (posformat === 1) {
    return {
      posFormat: 1,
      coverage: this.parsePointer(Parser3.coverage),
      value: this.parseValueRecord()
    };
  } else if (posformat === 2) {
    return {
      posFormat: 2,
      coverage: this.parsePointer(Parser3.coverage),
      values: this.parseValueRecordList()
    };
  }
  check.assert(false, "0x" + start.toString(16) + ": GPOS lookup type 1 format must be 1 or 2.");
};
subtableParsers$1[2] = function parseLookup22() {
  var start = this.offset + this.relativeOffset;
  var posFormat = this.parseUShort();
  check.assert(posFormat === 1 || posFormat === 2, "0x" + start.toString(16) + ": GPOS lookup type 2 format must be 1 or 2.");
  var coverage = this.parsePointer(Parser3.coverage);
  var valueFormat1 = this.parseUShort();
  var valueFormat2 = this.parseUShort();
  if (posFormat === 1) {
    return {
      posFormat,
      coverage,
      valueFormat1,
      valueFormat2,
      pairSets: this.parseList(Parser3.pointer(Parser3.list(function() {
        return {
          // pairValueRecord
          secondGlyph: this.parseUShort(),
          value1: this.parseValueRecord(valueFormat1),
          value2: this.parseValueRecord(valueFormat2)
        };
      })))
    };
  } else if (posFormat === 2) {
    var classDef1 = this.parsePointer(Parser3.classDef);
    var classDef2 = this.parsePointer(Parser3.classDef);
    var class1Count = this.parseUShort();
    var class2Count = this.parseUShort();
    return {
      // Class Pair Adjustment
      posFormat,
      coverage,
      valueFormat1,
      valueFormat2,
      classDef1,
      classDef2,
      class1Count,
      class2Count,
      classRecords: this.parseList(class1Count, Parser3.list(class2Count, function() {
        return {
          value1: this.parseValueRecord(valueFormat1),
          value2: this.parseValueRecord(valueFormat2)
        };
      }))
    };
  }
};
subtableParsers$1[3] = function parseLookup32() {
  return { error: "GPOS Lookup 3 not supported" };
};
subtableParsers$1[4] = function parseLookup42() {
  return { error: "GPOS Lookup 4 not supported" };
};
subtableParsers$1[5] = function parseLookup52() {
  return { error: "GPOS Lookup 5 not supported" };
};
subtableParsers$1[6] = function parseLookup62() {
  return { error: "GPOS Lookup 6 not supported" };
};
subtableParsers$1[7] = function parseLookup72() {
  return { error: "GPOS Lookup 7 not supported" };
};
subtableParsers$1[8] = function parseLookup82() {
  return { error: "GPOS Lookup 8 not supported" };
};
subtableParsers$1[9] = function parseLookup9() {
  return { error: "GPOS Lookup 9 not supported" };
};
function parseGposTable(data, start) {
  start = start || 0;
  var p = new Parser3(data, start);
  var tableVersion = p.parseVersion(1);
  check.argument(tableVersion === 1 || tableVersion === 1.1, "Unsupported GPOS table version " + tableVersion);
  if (tableVersion === 1) {
    return {
      version: tableVersion,
      scripts: p.parseScriptList(),
      features: p.parseFeatureList(),
      lookups: p.parseLookupList(subtableParsers$1)
    };
  } else {
    return {
      version: tableVersion,
      scripts: p.parseScriptList(),
      features: p.parseFeatureList(),
      lookups: p.parseLookupList(subtableParsers$1),
      variations: p.parseFeatureVariationsList()
    };
  }
}
var subtableMakers$1 = new Array(10);
function makeGposTable(gpos2) {
  return new table.Table("GPOS", [
    { name: "version", type: "ULONG", value: 65536 },
    { name: "scripts", type: "TABLE", value: new table.ScriptList(gpos2.scripts) },
    { name: "features", type: "TABLE", value: new table.FeatureList(gpos2.features) },
    { name: "lookups", type: "TABLE", value: new table.LookupList(gpos2.lookups, subtableMakers$1) }
  ]);
}
var gpos = { parse: parseGposTable, make: makeGposTable };
function parseWindowsKernTable(p) {
  var pairs = {};
  p.skip("uShort");
  var subtableVersion = p.parseUShort();
  check.argument(subtableVersion === 0, "Unsupported kern sub-table version.");
  p.skip("uShort", 2);
  var nPairs = p.parseUShort();
  p.skip("uShort", 3);
  for (var i3 = 0; i3 < nPairs; i3 += 1) {
    var leftIndex = p.parseUShort();
    var rightIndex = p.parseUShort();
    var value = p.parseShort();
    pairs[leftIndex + "," + rightIndex] = value;
  }
  return pairs;
}
function parseMacKernTable(p) {
  var pairs = {};
  p.skip("uShort");
  var nTables = p.parseULong();
  if (nTables > 1) {
    console.warn("Only the first kern subtable is supported.");
  }
  p.skip("uLong");
  var coverage = p.parseUShort();
  var subtableVersion = coverage & 255;
  p.skip("uShort");
  if (subtableVersion === 0) {
    var nPairs = p.parseUShort();
    p.skip("uShort", 3);
    for (var i3 = 0; i3 < nPairs; i3 += 1) {
      var leftIndex = p.parseUShort();
      var rightIndex = p.parseUShort();
      var value = p.parseShort();
      pairs[leftIndex + "," + rightIndex] = value;
    }
  }
  return pairs;
}
function parseKernTable(data, start) {
  var p = new parse.Parser(data, start);
  var tableVersion = p.parseUShort();
  if (tableVersion === 0) {
    return parseWindowsKernTable(p);
  } else if (tableVersion === 1) {
    return parseMacKernTable(p);
  } else {
    throw new Error("Unsupported kern table version (" + tableVersion + ").");
  }
}
var kern = { parse: parseKernTable };
function parseLocaTable(data, start, numGlyphs, shortVersion) {
  var p = new parse.Parser(data, start);
  var parseFn = shortVersion ? p.parseUShort : p.parseULong;
  var glyphOffsets = [];
  for (var i3 = 0; i3 < numGlyphs + 1; i3 += 1) {
    var glyphOffset = parseFn.call(p);
    if (shortVersion) {
      glyphOffset *= 2;
    }
    glyphOffsets.push(glyphOffset);
  }
  return glyphOffsets;
}
var loca = { parse: parseLocaTable };
function loadFromFile(path, callback) {
  var fs = require_fs();
  fs.readFile(path, function(err, buffer) {
    if (err) {
      return callback(err.message);
    }
    callback(null, nodeBufferToArrayBuffer(buffer));
  });
}
function loadFromUrl(url, callback) {
  var request = new XMLHttpRequest();
  request.open("get", url, true);
  request.responseType = "arraybuffer";
  request.onload = function() {
    if (request.response) {
      return callback(null, request.response);
    } else {
      return callback("Font could not be loaded: " + request.statusText);
    }
  };
  request.onerror = function() {
    callback("Font could not be loaded");
  };
  request.send();
}
function parseOpenTypeTableEntries(data, numTables) {
  var tableEntries = [];
  var p = 12;
  for (var i3 = 0; i3 < numTables; i3 += 1) {
    var tag = parse.getTag(data, p);
    var checksum = parse.getULong(data, p + 4);
    var offset = parse.getULong(data, p + 8);
    var length = parse.getULong(data, p + 12);
    tableEntries.push({ tag, checksum, offset, length, compression: false });
    p += 16;
  }
  return tableEntries;
}
function parseWOFFTableEntries(data, numTables) {
  var tableEntries = [];
  var p = 44;
  for (var i3 = 0; i3 < numTables; i3 += 1) {
    var tag = parse.getTag(data, p);
    var offset = parse.getULong(data, p + 4);
    var compLength = parse.getULong(data, p + 8);
    var origLength = parse.getULong(data, p + 12);
    var compression = void 0;
    if (compLength < origLength) {
      compression = "WOFF";
    } else {
      compression = false;
    }
    tableEntries.push({
      tag,
      offset,
      compression,
      compressedLength: compLength,
      length: origLength
    });
    p += 20;
  }
  return tableEntries;
}
function uncompressTable(data, tableEntry) {
  if (tableEntry.compression === "WOFF") {
    var inBuffer = new Uint8Array(data.buffer, tableEntry.offset + 2, tableEntry.compressedLength - 2);
    var outBuffer = new Uint8Array(tableEntry.length);
    tinyInflate(inBuffer, outBuffer);
    if (outBuffer.byteLength !== tableEntry.length) {
      throw new Error("Decompression error: " + tableEntry.tag + " decompressed length doesn't match recorded length");
    }
    var view = new DataView(outBuffer.buffer, 0);
    return { data: view, offset: 0 };
  } else {
    return { data, offset: tableEntry.offset };
  }
}
function parseBuffer(buffer, opt) {
  opt = opt === void 0 || opt === null ? {} : opt;
  var indexToLocFormat;
  var ltagTable;
  var font = new Font2({ empty: true });
  var data = new DataView(buffer, 0);
  var numTables;
  var tableEntries = [];
  var signature = parse.getTag(data, 0);
  if (signature === String.fromCharCode(0, 1, 0, 0) || signature === "true" || signature === "typ1") {
    font.outlinesFormat = "truetype";
    numTables = parse.getUShort(data, 4);
    tableEntries = parseOpenTypeTableEntries(data, numTables);
  } else if (signature === "OTTO") {
    font.outlinesFormat = "cff";
    numTables = parse.getUShort(data, 4);
    tableEntries = parseOpenTypeTableEntries(data, numTables);
  } else if (signature === "wOFF") {
    var flavor = parse.getTag(data, 4);
    if (flavor === String.fromCharCode(0, 1, 0, 0)) {
      font.outlinesFormat = "truetype";
    } else if (flavor === "OTTO") {
      font.outlinesFormat = "cff";
    } else {
      throw new Error("Unsupported OpenType flavor " + signature);
    }
    numTables = parse.getUShort(data, 12);
    tableEntries = parseWOFFTableEntries(data, numTables);
  } else {
    throw new Error("Unsupported OpenType signature " + signature);
  }
  var cffTableEntry;
  var fvarTableEntry;
  var glyfTableEntry;
  var gdefTableEntry;
  var gposTableEntry;
  var gsubTableEntry;
  var hmtxTableEntry;
  var kernTableEntry;
  var locaTableEntry;
  var nameTableEntry;
  var metaTableEntry;
  var p;
  for (var i3 = 0; i3 < numTables; i3 += 1) {
    var tableEntry = tableEntries[i3];
    var table2 = void 0;
    switch (tableEntry.tag) {
      case "cmap":
        table2 = uncompressTable(data, tableEntry);
        font.tables.cmap = cmap.parse(table2.data, table2.offset);
        font.encoding = new CmapEncoding(font.tables.cmap);
        break;
      case "cvt ":
        table2 = uncompressTable(data, tableEntry);
        p = new parse.Parser(table2.data, table2.offset);
        font.tables.cvt = p.parseShortList(tableEntry.length / 2);
        break;
      case "fvar":
        fvarTableEntry = tableEntry;
        break;
      case "fpgm":
        table2 = uncompressTable(data, tableEntry);
        p = new parse.Parser(table2.data, table2.offset);
        font.tables.fpgm = p.parseByteList(tableEntry.length);
        break;
      case "head":
        table2 = uncompressTable(data, tableEntry);
        font.tables.head = head.parse(table2.data, table2.offset);
        font.unitsPerEm = font.tables.head.unitsPerEm;
        indexToLocFormat = font.tables.head.indexToLocFormat;
        break;
      case "hhea":
        table2 = uncompressTable(data, tableEntry);
        font.tables.hhea = hhea.parse(table2.data, table2.offset);
        font.ascender = font.tables.hhea.ascender;
        font.descender = font.tables.hhea.descender;
        font.numberOfHMetrics = font.tables.hhea.numberOfHMetrics;
        break;
      case "hmtx":
        hmtxTableEntry = tableEntry;
        break;
      case "ltag":
        table2 = uncompressTable(data, tableEntry);
        ltagTable = ltag.parse(table2.data, table2.offset);
        break;
      case "maxp":
        table2 = uncompressTable(data, tableEntry);
        font.tables.maxp = maxp.parse(table2.data, table2.offset);
        font.numGlyphs = font.tables.maxp.numGlyphs;
        break;
      case "name":
        nameTableEntry = tableEntry;
        break;
      case "OS/2":
        table2 = uncompressTable(data, tableEntry);
        font.tables.os2 = os2.parse(table2.data, table2.offset);
        break;
      case "post":
        table2 = uncompressTable(data, tableEntry);
        font.tables.post = post.parse(table2.data, table2.offset);
        font.glyphNames = new GlyphNames(font.tables.post);
        break;
      case "prep":
        table2 = uncompressTable(data, tableEntry);
        p = new parse.Parser(table2.data, table2.offset);
        font.tables.prep = p.parseByteList(tableEntry.length);
        break;
      case "glyf":
        glyfTableEntry = tableEntry;
        break;
      case "loca":
        locaTableEntry = tableEntry;
        break;
      case "CFF ":
        cffTableEntry = tableEntry;
        break;
      case "kern":
        kernTableEntry = tableEntry;
        break;
      case "GDEF":
        gdefTableEntry = tableEntry;
        break;
      case "GPOS":
        gposTableEntry = tableEntry;
        break;
      case "GSUB":
        gsubTableEntry = tableEntry;
        break;
      case "meta":
        metaTableEntry = tableEntry;
        break;
    }
  }
  var nameTable = uncompressTable(data, nameTableEntry);
  font.tables.name = _name.parse(nameTable.data, nameTable.offset, ltagTable);
  font.names = font.tables.name;
  if (glyfTableEntry && locaTableEntry) {
    var shortVersion = indexToLocFormat === 0;
    var locaTable = uncompressTable(data, locaTableEntry);
    var locaOffsets = loca.parse(locaTable.data, locaTable.offset, font.numGlyphs, shortVersion);
    var glyfTable = uncompressTable(data, glyfTableEntry);
    font.glyphs = glyf.parse(glyfTable.data, glyfTable.offset, locaOffsets, font, opt);
  } else if (cffTableEntry) {
    var cffTable = uncompressTable(data, cffTableEntry);
    cff.parse(cffTable.data, cffTable.offset, font, opt);
  } else {
    throw new Error("Font doesn't contain TrueType or CFF outlines.");
  }
  var hmtxTable = uncompressTable(data, hmtxTableEntry);
  hmtx.parse(font, hmtxTable.data, hmtxTable.offset, font.numberOfHMetrics, font.numGlyphs, font.glyphs, opt);
  addGlyphNames(font, opt);
  if (kernTableEntry) {
    var kernTable = uncompressTable(data, kernTableEntry);
    font.kerningPairs = kern.parse(kernTable.data, kernTable.offset);
  } else {
    font.kerningPairs = {};
  }
  if (gdefTableEntry) {
    var gdefTable = uncompressTable(data, gdefTableEntry);
    font.tables.gdef = gdef.parse(gdefTable.data, gdefTable.offset);
  }
  if (gposTableEntry) {
    var gposTable = uncompressTable(data, gposTableEntry);
    font.tables.gpos = gpos.parse(gposTable.data, gposTable.offset);
    font.position.init();
  }
  if (gsubTableEntry) {
    var gsubTable = uncompressTable(data, gsubTableEntry);
    font.tables.gsub = gsub.parse(gsubTable.data, gsubTable.offset);
  }
  if (fvarTableEntry) {
    var fvarTable = uncompressTable(data, fvarTableEntry);
    font.tables.fvar = fvar.parse(fvarTable.data, fvarTable.offset, font.names);
  }
  if (metaTableEntry) {
    var metaTable = uncompressTable(data, metaTableEntry);
    font.tables.meta = meta.parse(metaTable.data, metaTable.offset);
    font.metas = font.tables.meta;
  }
  return font;
}
function load(url, callback, opt) {
  opt = opt === void 0 || opt === null ? {} : opt;
  var isNode = typeof window === "undefined";
  var loadFn = isNode && !opt.isUrl ? loadFromFile : loadFromUrl;
  return new Promise(function(resolve, reject) {
    loadFn(url, function(err, arrayBuffer) {
      if (err) {
        if (callback) {
          return callback(err);
        } else {
          reject(err);
        }
      }
      var font;
      try {
        font = parseBuffer(arrayBuffer, opt);
      } catch (e) {
        if (callback) {
          return callback(e, null);
        } else {
          reject(e);
        }
      }
      if (callback) {
        return callback(null, font);
      } else {
        resolve(font);
      }
    });
  });
}
function loadSync(url, opt) {
  var fs = require_fs();
  var buffer = fs.readFileSync(url);
  return parseBuffer(nodeBufferToArrayBuffer(buffer), opt);
}
var opentype = Object.freeze({
  __proto__: null,
  Font: Font2,
  Glyph,
  Path: Path2,
  BoundingBox,
  _parse: parse,
  parse: parseBuffer,
  load,
  loadSync
});

// node_modules/three-stdlib/loaders/RGBELoader.js
var RGBELoader = class extends DataTextureLoader {
  constructor(manager) {
    super(manager);
    this.type = HalfFloatType;
  }
  // adapted from http://www.graphics.cornell.edu/~bjw/rgbe.html
  parse(buffer) {
    const RGBE_RETURN_FAILURE = -1, rgbe_read_error = 1, rgbe_write_error = 2, rgbe_format_error = 3, rgbe_memory_error = 4, rgbe_error = function(rgbe_error_code, msg) {
      switch (rgbe_error_code) {
        case rgbe_read_error:
          console.error("THREE.RGBELoader Read Error: " + (msg || ""));
          break;
        case rgbe_write_error:
          console.error("THREE.RGBELoader Write Error: " + (msg || ""));
          break;
        case rgbe_format_error:
          console.error("THREE.RGBELoader Bad File Format: " + (msg || ""));
          break;
        default:
        case rgbe_memory_error:
          console.error("THREE.RGBELoader: Error: " + (msg || ""));
      }
      return RGBE_RETURN_FAILURE;
    }, RGBE_VALID_PROGRAMTYPE = 1, RGBE_VALID_FORMAT = 2, RGBE_VALID_DIMENSIONS = 4, NEWLINE = "\n", fgets = function(buffer2, lineLimit, consume) {
      const chunkSize = 128;
      lineLimit = !lineLimit ? 1024 : lineLimit;
      let p = buffer2.pos, i3 = -1, len = 0, s = "", chunk = String.fromCharCode.apply(null, new Uint16Array(buffer2.subarray(p, p + chunkSize)));
      while (0 > (i3 = chunk.indexOf(NEWLINE)) && len < lineLimit && p < buffer2.byteLength) {
        s += chunk;
        len += chunk.length;
        p += chunkSize;
        chunk += String.fromCharCode.apply(null, new Uint16Array(buffer2.subarray(p, p + chunkSize)));
      }
      if (-1 < i3) {
        if (false !== consume)
          buffer2.pos += len + i3 + 1;
        return s + chunk.slice(0, i3);
      }
      return false;
    }, RGBE_ReadHeader = function(buffer2) {
      const magic_token_re = /^#\?(\S+)/, gamma_re = /^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/, exposure_re = /^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/, format_re = /^\s*FORMAT=(\S+)\s*$/, dimensions_re = /^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/, header = {
        valid: 0,
        string: "",
        comments: "",
        programtype: "RGBE",
        format: "",
        gamma: 1,
        exposure: 1,
        width: 0,
        height: 0
      };
      let line2, match;
      if (buffer2.pos >= buffer2.byteLength || !(line2 = fgets(buffer2))) {
        return rgbe_error(rgbe_read_error, "no header found");
      }
      if (!(match = line2.match(magic_token_re))) {
        return rgbe_error(rgbe_format_error, "bad initial token");
      }
      header.valid |= RGBE_VALID_PROGRAMTYPE;
      header.programtype = match[1];
      header.string += line2 + "\n";
      while (true) {
        line2 = fgets(buffer2);
        if (false === line2)
          break;
        header.string += line2 + "\n";
        if ("#" === line2.charAt(0)) {
          header.comments += line2 + "\n";
          continue;
        }
        if (match = line2.match(gamma_re)) {
          header.gamma = parseFloat(match[1]);
        }
        if (match = line2.match(exposure_re)) {
          header.exposure = parseFloat(match[1]);
        }
        if (match = line2.match(format_re)) {
          header.valid |= RGBE_VALID_FORMAT;
          header.format = match[1];
        }
        if (match = line2.match(dimensions_re)) {
          header.valid |= RGBE_VALID_DIMENSIONS;
          header.height = parseInt(match[1], 10);
          header.width = parseInt(match[2], 10);
        }
        if (header.valid & RGBE_VALID_FORMAT && header.valid & RGBE_VALID_DIMENSIONS)
          break;
      }
      if (!(header.valid & RGBE_VALID_FORMAT)) {
        return rgbe_error(rgbe_format_error, "missing format specifier");
      }
      if (!(header.valid & RGBE_VALID_DIMENSIONS)) {
        return rgbe_error(rgbe_format_error, "missing image size specifier");
      }
      return header;
    }, RGBE_ReadPixels_RLE = function(buffer2, w, h) {
      const scanline_width = w;
      if (
        // run length encoding is not allowed so read flat
        scanline_width < 8 || scanline_width > 32767 || // this file is not run length encoded
        2 !== buffer2[0] || 2 !== buffer2[1] || buffer2[2] & 128
      ) {
        return new Uint8Array(buffer2);
      }
      if (scanline_width !== (buffer2[2] << 8 | buffer2[3])) {
        return rgbe_error(rgbe_format_error, "wrong scanline width");
      }
      const data_rgba = new Uint8Array(4 * w * h);
      if (!data_rgba.length) {
        return rgbe_error(rgbe_memory_error, "unable to allocate buffer space");
      }
      let offset = 0, pos = 0;
      const ptr_end = 4 * scanline_width;
      const rgbeStart = new Uint8Array(4);
      const scanline_buffer = new Uint8Array(ptr_end);
      let num_scanlines = h;
      while (num_scanlines > 0 && pos < buffer2.byteLength) {
        if (pos + 4 > buffer2.byteLength) {
          return rgbe_error(rgbe_read_error);
        }
        rgbeStart[0] = buffer2[pos++];
        rgbeStart[1] = buffer2[pos++];
        rgbeStart[2] = buffer2[pos++];
        rgbeStart[3] = buffer2[pos++];
        if (2 != rgbeStart[0] || 2 != rgbeStart[1] || (rgbeStart[2] << 8 | rgbeStart[3]) != scanline_width) {
          return rgbe_error(rgbe_format_error, "bad rgbe scanline format");
        }
        let ptr = 0, count;
        while (ptr < ptr_end && pos < buffer2.byteLength) {
          count = buffer2[pos++];
          const isEncodedRun = count > 128;
          if (isEncodedRun)
            count -= 128;
          if (0 === count || ptr + count > ptr_end) {
            return rgbe_error(rgbe_format_error, "bad scanline data");
          }
          if (isEncodedRun) {
            const byteValue = buffer2[pos++];
            for (let i3 = 0; i3 < count; i3++) {
              scanline_buffer[ptr++] = byteValue;
            }
          } else {
            scanline_buffer.set(buffer2.subarray(pos, pos + count), ptr);
            ptr += count;
            pos += count;
          }
        }
        const l = scanline_width;
        for (let i3 = 0; i3 < l; i3++) {
          let off = 0;
          data_rgba[offset] = scanline_buffer[i3 + off];
          off += scanline_width;
          data_rgba[offset + 1] = scanline_buffer[i3 + off];
          off += scanline_width;
          data_rgba[offset + 2] = scanline_buffer[i3 + off];
          off += scanline_width;
          data_rgba[offset + 3] = scanline_buffer[i3 + off];
          offset += 4;
        }
        num_scanlines--;
      }
      return data_rgba;
    };
    const RGBEByteToRGBFloat = function(sourceArray, sourceOffset, destArray, destOffset) {
      const e = sourceArray[sourceOffset + 3];
      const scale = Math.pow(2, e - 128) / 255;
      destArray[destOffset + 0] = sourceArray[sourceOffset + 0] * scale;
      destArray[destOffset + 1] = sourceArray[sourceOffset + 1] * scale;
      destArray[destOffset + 2] = sourceArray[sourceOffset + 2] * scale;
      destArray[destOffset + 3] = 1;
    };
    const RGBEByteToRGBHalf = function(sourceArray, sourceOffset, destArray, destOffset) {
      const e = sourceArray[sourceOffset + 3];
      const scale = Math.pow(2, e - 128) / 255;
      destArray[destOffset + 0] = DataUtils.toHalfFloat(Math.min(sourceArray[sourceOffset + 0] * scale, 65504));
      destArray[destOffset + 1] = DataUtils.toHalfFloat(Math.min(sourceArray[sourceOffset + 1] * scale, 65504));
      destArray[destOffset + 2] = DataUtils.toHalfFloat(Math.min(sourceArray[sourceOffset + 2] * scale, 65504));
      destArray[destOffset + 3] = DataUtils.toHalfFloat(1);
    };
    const byteArray = new Uint8Array(buffer);
    byteArray.pos = 0;
    const rgbe_header_info = RGBE_ReadHeader(byteArray);
    if (RGBE_RETURN_FAILURE !== rgbe_header_info) {
      const w = rgbe_header_info.width, h = rgbe_header_info.height, image_rgba_data = RGBE_ReadPixels_RLE(byteArray.subarray(byteArray.pos), w, h);
      if (RGBE_RETURN_FAILURE !== image_rgba_data) {
        let data, type;
        let numElements;
        switch (this.type) {
          case FloatType:
            numElements = image_rgba_data.length / 4;
            const floatArray = new Float32Array(numElements * 4);
            for (let j = 0; j < numElements; j++) {
              RGBEByteToRGBFloat(image_rgba_data, j * 4, floatArray, j * 4);
            }
            data = floatArray;
            type = FloatType;
            break;
          case HalfFloatType:
            numElements = image_rgba_data.length / 4;
            const halfArray = new Uint16Array(numElements * 4);
            for (let j = 0; j < numElements; j++) {
              RGBEByteToRGBHalf(image_rgba_data, j * 4, halfArray, j * 4);
            }
            data = halfArray;
            type = HalfFloatType;
            break;
          default:
            console.error("THREE.RGBELoader: unsupported type: ", this.type);
            break;
        }
        return {
          width: w,
          height: h,
          data,
          header: rgbe_header_info.string,
          gamma: rgbe_header_info.gamma,
          exposure: rgbe_header_info.exposure,
          type
        };
      }
    }
    return null;
  }
  setDataType(value) {
    this.type = value;
    return this;
  }
  load(url, onLoad, onProgress, onError) {
    function onLoadCallback(texture, texData) {
      switch (texture.type) {
        case FloatType:
        case HalfFloatType:
          if ("colorSpace" in texture)
            texture.colorSpace = "srgb-linear";
          else
            texture.encoding = 3e3;
          texture.minFilter = LinearFilter;
          texture.magFilter = LinearFilter;
          texture.generateMipmaps = false;
          texture.flipY = true;
          break;
      }
      if (onLoad)
        onLoad(texture, texData);
    }
    return super.load(url, onLoadCallback, onProgress, onError);
  }
};

// node_modules/three-stdlib/loaders/EXRLoader.js
var hasColorSpace = "colorSpace" in new Texture();
var EXRLoader = class extends DataTextureLoader {
  constructor(manager) {
    super(manager);
    this.type = HalfFloatType;
  }
  parse(buffer) {
    const USHORT_RANGE = 1 << 16;
    const BITMAP_SIZE = USHORT_RANGE >> 3;
    const HUF_ENCBITS = 16;
    const HUF_DECBITS = 14;
    const HUF_ENCSIZE = (1 << HUF_ENCBITS) + 1;
    const HUF_DECSIZE = 1 << HUF_DECBITS;
    const HUF_DECMASK = HUF_DECSIZE - 1;
    const NBITS = 16;
    const A_OFFSET = 1 << NBITS - 1;
    const MOD_MASK = (1 << NBITS) - 1;
    const SHORT_ZEROCODE_RUN = 59;
    const LONG_ZEROCODE_RUN = 63;
    const SHORTEST_LONG_RUN = 2 + LONG_ZEROCODE_RUN - SHORT_ZEROCODE_RUN;
    const ULONG_SIZE = 8;
    const FLOAT32_SIZE = 4;
    const INT32_SIZE = 4;
    const INT16_SIZE = 2;
    const INT8_SIZE = 1;
    const STATIC_HUFFMAN = 0;
    const DEFLATE = 1;
    const UNKNOWN = 0;
    const LOSSY_DCT = 1;
    const RLE = 2;
    const logBase = Math.pow(2.7182818, 2.2);
    function reverseLutFromBitmap(bitmap, lut) {
      var k = 0;
      for (var i3 = 0; i3 < USHORT_RANGE; ++i3) {
        if (i3 == 0 || bitmap[i3 >> 3] & 1 << (i3 & 7)) {
          lut[k++] = i3;
        }
      }
      var n = k - 1;
      while (k < USHORT_RANGE)
        lut[k++] = 0;
      return n;
    }
    function hufClearDecTable(hdec) {
      for (var i3 = 0; i3 < HUF_DECSIZE; i3++) {
        hdec[i3] = {};
        hdec[i3].len = 0;
        hdec[i3].lit = 0;
        hdec[i3].p = null;
      }
    }
    const getBitsReturn = { l: 0, c: 0, lc: 0 };
    function getBits(nBits, c3, lc3, uInt8Array2, inOffset) {
      while (lc3 < nBits) {
        c3 = c3 << 8 | parseUint8Array(uInt8Array2, inOffset);
        lc3 += 8;
      }
      lc3 -= nBits;
      getBitsReturn.l = c3 >> lc3 & (1 << nBits) - 1;
      getBitsReturn.c = c3;
      getBitsReturn.lc = lc3;
    }
    const hufTableBuffer = new Array(59);
    function hufCanonicalCodeTable(hcode) {
      for (var i3 = 0; i3 <= 58; ++i3)
        hufTableBuffer[i3] = 0;
      for (var i3 = 0; i3 < HUF_ENCSIZE; ++i3)
        hufTableBuffer[hcode[i3]] += 1;
      var c3 = 0;
      for (var i3 = 58; i3 > 0; --i3) {
        var nc = c3 + hufTableBuffer[i3] >> 1;
        hufTableBuffer[i3] = c3;
        c3 = nc;
      }
      for (var i3 = 0; i3 < HUF_ENCSIZE; ++i3) {
        var l = hcode[i3];
        if (l > 0)
          hcode[i3] = l | hufTableBuffer[l]++ << 6;
      }
    }
    function hufUnpackEncTable(uInt8Array2, inDataView, inOffset, ni, im, iM, hcode) {
      var p = inOffset;
      var c3 = 0;
      var lc3 = 0;
      for (; im <= iM; im++) {
        if (p.value - inOffset.value > ni)
          return false;
        getBits(6, c3, lc3, uInt8Array2, p);
        var l = getBitsReturn.l;
        c3 = getBitsReturn.c;
        lc3 = getBitsReturn.lc;
        hcode[im] = l;
        if (l == LONG_ZEROCODE_RUN) {
          if (p.value - inOffset.value > ni) {
            throw "Something wrong with hufUnpackEncTable";
          }
          getBits(8, c3, lc3, uInt8Array2, p);
          var zerun = getBitsReturn.l + SHORTEST_LONG_RUN;
          c3 = getBitsReturn.c;
          lc3 = getBitsReturn.lc;
          if (im + zerun > iM + 1) {
            throw "Something wrong with hufUnpackEncTable";
          }
          while (zerun--)
            hcode[im++] = 0;
          im--;
        } else if (l >= SHORT_ZEROCODE_RUN) {
          var zerun = l - SHORT_ZEROCODE_RUN + 2;
          if (im + zerun > iM + 1) {
            throw "Something wrong with hufUnpackEncTable";
          }
          while (zerun--)
            hcode[im++] = 0;
          im--;
        }
      }
      hufCanonicalCodeTable(hcode);
    }
    function hufLength(code) {
      return code & 63;
    }
    function hufCode(code) {
      return code >> 6;
    }
    function hufBuildDecTable(hcode, im, iM, hdecod) {
      for (; im <= iM; im++) {
        var c3 = hufCode(hcode[im]);
        var l = hufLength(hcode[im]);
        if (c3 >> l) {
          throw "Invalid table entry";
        }
        if (l > HUF_DECBITS) {
          var pl = hdecod[c3 >> l - HUF_DECBITS];
          if (pl.len) {
            throw "Invalid table entry";
          }
          pl.lit++;
          if (pl.p) {
            var p = pl.p;
            pl.p = new Array(pl.lit);
            for (var i3 = 0; i3 < pl.lit - 1; ++i3) {
              pl.p[i3] = p[i3];
            }
          } else {
            pl.p = new Array(1);
          }
          pl.p[pl.lit - 1] = im;
        } else if (l) {
          var plOffset = 0;
          for (var i3 = 1 << HUF_DECBITS - l; i3 > 0; i3--) {
            var pl = hdecod[(c3 << HUF_DECBITS - l) + plOffset];
            if (pl.len || pl.p) {
              throw "Invalid table entry";
            }
            pl.len = l;
            pl.lit = im;
            plOffset++;
          }
        }
      }
      return true;
    }
    const getCharReturn = { c: 0, lc: 0 };
    function getChar(c3, lc3, uInt8Array2, inOffset) {
      c3 = c3 << 8 | parseUint8Array(uInt8Array2, inOffset);
      lc3 += 8;
      getCharReturn.c = c3;
      getCharReturn.lc = lc3;
    }
    const getCodeReturn = { c: 0, lc: 0 };
    function getCode(po, rlc, c3, lc3, uInt8Array2, inDataView, inOffset, outBuffer, outBufferOffset, outBufferEndOffset) {
      if (po == rlc) {
        if (lc3 < 8) {
          getChar(c3, lc3, uInt8Array2, inOffset);
          c3 = getCharReturn.c;
          lc3 = getCharReturn.lc;
        }
        lc3 -= 8;
        var cs = c3 >> lc3;
        var cs = new Uint8Array([cs])[0];
        if (outBufferOffset.value + cs > outBufferEndOffset) {
          return false;
        }
        var s = outBuffer[outBufferOffset.value - 1];
        while (cs-- > 0) {
          outBuffer[outBufferOffset.value++] = s;
        }
      } else if (outBufferOffset.value < outBufferEndOffset) {
        outBuffer[outBufferOffset.value++] = po;
      } else {
        return false;
      }
      getCodeReturn.c = c3;
      getCodeReturn.lc = lc3;
    }
    function UInt16(value) {
      return value & 65535;
    }
    function Int16(value) {
      var ref = UInt16(value);
      return ref > 32767 ? ref - 65536 : ref;
    }
    const wdec14Return = { a: 0, b: 0 };
    function wdec14(l, h) {
      var ls = Int16(l);
      var hs = Int16(h);
      var hi = hs;
      var ai = ls + (hi & 1) + (hi >> 1);
      var as = ai;
      var bs = ai - hi;
      wdec14Return.a = as;
      wdec14Return.b = bs;
    }
    function wdec16(l, h) {
      var m = UInt16(l);
      var d = UInt16(h);
      var bb = m - (d >> 1) & MOD_MASK;
      var aa = d + bb - A_OFFSET & MOD_MASK;
      wdec14Return.a = aa;
      wdec14Return.b = bb;
    }
    function wav2Decode(buffer2, j, nx, ox, ny, oy, mx) {
      var w14 = mx < 1 << 14;
      var n = nx > ny ? ny : nx;
      var p = 1;
      var p2;
      while (p <= n)
        p <<= 1;
      p >>= 1;
      p2 = p;
      p >>= 1;
      while (p >= 1) {
        var py = 0;
        var ey = py + oy * (ny - p2);
        var oy1 = oy * p;
        var oy2 = oy * p2;
        var ox1 = ox * p;
        var ox2 = ox * p2;
        var i00, i01, i10, i11;
        for (; py <= ey; py += oy2) {
          var px = py;
          var ex = py + ox * (nx - p2);
          for (; px <= ex; px += ox2) {
            var p01 = px + ox1;
            var p10 = px + oy1;
            var p11 = p10 + ox1;
            if (w14) {
              wdec14(buffer2[px + j], buffer2[p10 + j]);
              i00 = wdec14Return.a;
              i10 = wdec14Return.b;
              wdec14(buffer2[p01 + j], buffer2[p11 + j]);
              i01 = wdec14Return.a;
              i11 = wdec14Return.b;
              wdec14(i00, i01);
              buffer2[px + j] = wdec14Return.a;
              buffer2[p01 + j] = wdec14Return.b;
              wdec14(i10, i11);
              buffer2[p10 + j] = wdec14Return.a;
              buffer2[p11 + j] = wdec14Return.b;
            } else {
              wdec16(buffer2[px + j], buffer2[p10 + j]);
              i00 = wdec14Return.a;
              i10 = wdec14Return.b;
              wdec16(buffer2[p01 + j], buffer2[p11 + j]);
              i01 = wdec14Return.a;
              i11 = wdec14Return.b;
              wdec16(i00, i01);
              buffer2[px + j] = wdec14Return.a;
              buffer2[p01 + j] = wdec14Return.b;
              wdec16(i10, i11);
              buffer2[p10 + j] = wdec14Return.a;
              buffer2[p11 + j] = wdec14Return.b;
            }
          }
          if (nx & p) {
            var p10 = px + oy1;
            if (w14)
              wdec14(buffer2[px + j], buffer2[p10 + j]);
            else
              wdec16(buffer2[px + j], buffer2[p10 + j]);
            i00 = wdec14Return.a;
            buffer2[p10 + j] = wdec14Return.b;
            buffer2[px + j] = i00;
          }
        }
        if (ny & p) {
          var px = py;
          var ex = py + ox * (nx - p2);
          for (; px <= ex; px += ox2) {
            var p01 = px + ox1;
            if (w14)
              wdec14(buffer2[px + j], buffer2[p01 + j]);
            else
              wdec16(buffer2[px + j], buffer2[p01 + j]);
            i00 = wdec14Return.a;
            buffer2[p01 + j] = wdec14Return.b;
            buffer2[px + j] = i00;
          }
        }
        p2 = p;
        p >>= 1;
      }
      return py;
    }
    function hufDecode(encodingTable, decodingTable, uInt8Array2, inDataView, inOffset, ni, rlc, no, outBuffer, outOffset) {
      var c3 = 0;
      var lc3 = 0;
      var outBufferEndOffset = no;
      var inOffsetEnd = Math.trunc(inOffset.value + (ni + 7) / 8);
      while (inOffset.value < inOffsetEnd) {
        getChar(c3, lc3, uInt8Array2, inOffset);
        c3 = getCharReturn.c;
        lc3 = getCharReturn.lc;
        while (lc3 >= HUF_DECBITS) {
          var index = c3 >> lc3 - HUF_DECBITS & HUF_DECMASK;
          var pl = decodingTable[index];
          if (pl.len) {
            lc3 -= pl.len;
            getCode(pl.lit, rlc, c3, lc3, uInt8Array2, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset);
            c3 = getCodeReturn.c;
            lc3 = getCodeReturn.lc;
          } else {
            if (!pl.p) {
              throw "hufDecode issues";
            }
            var j;
            for (j = 0; j < pl.lit; j++) {
              var l = hufLength(encodingTable[pl.p[j]]);
              while (lc3 < l && inOffset.value < inOffsetEnd) {
                getChar(c3, lc3, uInt8Array2, inOffset);
                c3 = getCharReturn.c;
                lc3 = getCharReturn.lc;
              }
              if (lc3 >= l) {
                if (hufCode(encodingTable[pl.p[j]]) == (c3 >> lc3 - l & (1 << l) - 1)) {
                  lc3 -= l;
                  getCode(
                    pl.p[j],
                    rlc,
                    c3,
                    lc3,
                    uInt8Array2,
                    inDataView,
                    inOffset,
                    outBuffer,
                    outOffset,
                    outBufferEndOffset
                  );
                  c3 = getCodeReturn.c;
                  lc3 = getCodeReturn.lc;
                  break;
                }
              }
            }
            if (j == pl.lit) {
              throw "hufDecode issues";
            }
          }
        }
      }
      var i3 = 8 - ni & 7;
      c3 >>= i3;
      lc3 -= i3;
      while (lc3 > 0) {
        var pl = decodingTable[c3 << HUF_DECBITS - lc3 & HUF_DECMASK];
        if (pl.len) {
          lc3 -= pl.len;
          getCode(pl.lit, rlc, c3, lc3, uInt8Array2, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset);
          c3 = getCodeReturn.c;
          lc3 = getCodeReturn.lc;
        } else {
          throw "hufDecode issues";
        }
      }
      return true;
    }
    function hufUncompress(uInt8Array2, inDataView, inOffset, nCompressed, outBuffer, nRaw) {
      var outOffset = { value: 0 };
      var initialInOffset = inOffset.value;
      var im = parseUint32(inDataView, inOffset);
      var iM = parseUint32(inDataView, inOffset);
      inOffset.value += 4;
      var nBits = parseUint32(inDataView, inOffset);
      inOffset.value += 4;
      if (im < 0 || im >= HUF_ENCSIZE || iM < 0 || iM >= HUF_ENCSIZE) {
        throw "Something wrong with HUF_ENCSIZE";
      }
      var freq = new Array(HUF_ENCSIZE);
      var hdec = new Array(HUF_DECSIZE);
      hufClearDecTable(hdec);
      var ni = nCompressed - (inOffset.value - initialInOffset);
      hufUnpackEncTable(uInt8Array2, inDataView, inOffset, ni, im, iM, freq);
      if (nBits > 8 * (nCompressed - (inOffset.value - initialInOffset))) {
        throw "Something wrong with hufUncompress";
      }
      hufBuildDecTable(freq, im, iM, hdec);
      hufDecode(freq, hdec, uInt8Array2, inDataView, inOffset, nBits, iM, nRaw, outBuffer, outOffset);
    }
    function applyLut(lut, data, nData) {
      for (var i3 = 0; i3 < nData; ++i3) {
        data[i3] = lut[data[i3]];
      }
    }
    function predictor(source) {
      for (var t2 = 1; t2 < source.length; t2++) {
        var d = source[t2 - 1] + source[t2] - 128;
        source[t2] = d;
      }
    }
    function interleaveScalar(source, out) {
      var t1 = 0;
      var t2 = Math.floor((source.length + 1) / 2);
      var s = 0;
      var stop = source.length - 1;
      while (true) {
        if (s > stop)
          break;
        out[s++] = source[t1++];
        if (s > stop)
          break;
        out[s++] = source[t2++];
      }
    }
    function decodeRunLength(source) {
      var size2 = source.byteLength;
      var out = new Array();
      var p = 0;
      var reader = new DataView(source);
      while (size2 > 0) {
        var l = reader.getInt8(p++);
        if (l < 0) {
          var count = -l;
          size2 -= count + 1;
          for (var i3 = 0; i3 < count; i3++) {
            out.push(reader.getUint8(p++));
          }
        } else {
          var count = l;
          size2 -= 2;
          var value = reader.getUint8(p++);
          for (var i3 = 0; i3 < count + 1; i3++) {
            out.push(value);
          }
        }
      }
      return out;
    }
    function lossyDctDecode(cscSet, rowPtrs, channelData, acBuffer, dcBuffer, outBuffer) {
      var dataView = new DataView(outBuffer.buffer);
      var width = channelData[cscSet.idx[0]].width;
      var height = channelData[cscSet.idx[0]].height;
      var numComp = 3;
      var numFullBlocksX = Math.floor(width / 8);
      var numBlocksX = Math.ceil(width / 8);
      var numBlocksY = Math.ceil(height / 8);
      var leftoverX = width - (numBlocksX - 1) * 8;
      var leftoverY = height - (numBlocksY - 1) * 8;
      var currAcComp = { value: 0 };
      var currDcComp = new Array(numComp);
      var dctData = new Array(numComp);
      var halfZigBlock = new Array(numComp);
      var rowBlock = new Array(numComp);
      var rowOffsets = new Array(numComp);
      for (let comp2 = 0; comp2 < numComp; ++comp2) {
        rowOffsets[comp2] = rowPtrs[cscSet.idx[comp2]];
        currDcComp[comp2] = comp2 < 1 ? 0 : currDcComp[comp2 - 1] + numBlocksX * numBlocksY;
        dctData[comp2] = new Float32Array(64);
        halfZigBlock[comp2] = new Uint16Array(64);
        rowBlock[comp2] = new Uint16Array(numBlocksX * 64);
      }
      for (let blocky = 0; blocky < numBlocksY; ++blocky) {
        var maxY = 8;
        if (blocky == numBlocksY - 1)
          maxY = leftoverY;
        var maxX = 8;
        for (let blockx = 0; blockx < numBlocksX; ++blockx) {
          if (blockx == numBlocksX - 1)
            maxX = leftoverX;
          for (let comp2 = 0; comp2 < numComp; ++comp2) {
            halfZigBlock[comp2].fill(0);
            halfZigBlock[comp2][0] = dcBuffer[currDcComp[comp2]++];
            unRleAC(currAcComp, acBuffer, halfZigBlock[comp2]);
            unZigZag(halfZigBlock[comp2], dctData[comp2]);
            dctInverse(dctData[comp2]);
          }
          if (numComp == 3) {
            csc709Inverse(dctData);
          }
          for (let comp2 = 0; comp2 < numComp; ++comp2) {
            convertToHalf(dctData[comp2], rowBlock[comp2], blockx * 64);
          }
        }
        let offset2 = 0;
        for (let comp2 = 0; comp2 < numComp; ++comp2) {
          const type2 = channelData[cscSet.idx[comp2]].type;
          for (let y2 = 8 * blocky; y2 < 8 * blocky + maxY; ++y2) {
            offset2 = rowOffsets[comp2][y2];
            for (let blockx = 0; blockx < numFullBlocksX; ++blockx) {
              const src = blockx * 64 + (y2 & 7) * 8;
              dataView.setUint16(offset2 + 0 * INT16_SIZE * type2, rowBlock[comp2][src + 0], true);
              dataView.setUint16(offset2 + 1 * INT16_SIZE * type2, rowBlock[comp2][src + 1], true);
              dataView.setUint16(offset2 + 2 * INT16_SIZE * type2, rowBlock[comp2][src + 2], true);
              dataView.setUint16(offset2 + 3 * INT16_SIZE * type2, rowBlock[comp2][src + 3], true);
              dataView.setUint16(offset2 + 4 * INT16_SIZE * type2, rowBlock[comp2][src + 4], true);
              dataView.setUint16(offset2 + 5 * INT16_SIZE * type2, rowBlock[comp2][src + 5], true);
              dataView.setUint16(offset2 + 6 * INT16_SIZE * type2, rowBlock[comp2][src + 6], true);
              dataView.setUint16(offset2 + 7 * INT16_SIZE * type2, rowBlock[comp2][src + 7], true);
              offset2 += 8 * INT16_SIZE * type2;
            }
          }
          if (numFullBlocksX != numBlocksX) {
            for (let y2 = 8 * blocky; y2 < 8 * blocky + maxY; ++y2) {
              const offset3 = rowOffsets[comp2][y2] + 8 * numFullBlocksX * INT16_SIZE * type2;
              const src = numFullBlocksX * 64 + (y2 & 7) * 8;
              for (let x2 = 0; x2 < maxX; ++x2) {
                dataView.setUint16(offset3 + x2 * INT16_SIZE * type2, rowBlock[comp2][src + x2], true);
              }
            }
          }
        }
      }
      var halfRow = new Uint16Array(width);
      var dataView = new DataView(outBuffer.buffer);
      for (var comp = 0; comp < numComp; ++comp) {
        channelData[cscSet.idx[comp]].decoded = true;
        var type = channelData[cscSet.idx[comp]].type;
        if (channelData[comp].type != 2)
          continue;
        for (var y = 0; y < height; ++y) {
          const offset2 = rowOffsets[comp][y];
          for (var x = 0; x < width; ++x) {
            halfRow[x] = dataView.getUint16(offset2 + x * INT16_SIZE * type, true);
          }
          for (var x = 0; x < width; ++x) {
            dataView.setFloat32(offset2 + x * INT16_SIZE * type, decodeFloat16(halfRow[x]), true);
          }
        }
      }
    }
    function unRleAC(currAcComp, acBuffer, halfZigBlock) {
      var acValue;
      var dctComp = 1;
      while (dctComp < 64) {
        acValue = acBuffer[currAcComp.value];
        if (acValue == 65280) {
          dctComp = 64;
        } else if (acValue >> 8 == 255) {
          dctComp += acValue & 255;
        } else {
          halfZigBlock[dctComp] = acValue;
          dctComp++;
        }
        currAcComp.value++;
      }
    }
    function unZigZag(src, dst) {
      dst[0] = decodeFloat16(src[0]);
      dst[1] = decodeFloat16(src[1]);
      dst[2] = decodeFloat16(src[5]);
      dst[3] = decodeFloat16(src[6]);
      dst[4] = decodeFloat16(src[14]);
      dst[5] = decodeFloat16(src[15]);
      dst[6] = decodeFloat16(src[27]);
      dst[7] = decodeFloat16(src[28]);
      dst[8] = decodeFloat16(src[2]);
      dst[9] = decodeFloat16(src[4]);
      dst[10] = decodeFloat16(src[7]);
      dst[11] = decodeFloat16(src[13]);
      dst[12] = decodeFloat16(src[16]);
      dst[13] = decodeFloat16(src[26]);
      dst[14] = decodeFloat16(src[29]);
      dst[15] = decodeFloat16(src[42]);
      dst[16] = decodeFloat16(src[3]);
      dst[17] = decodeFloat16(src[8]);
      dst[18] = decodeFloat16(src[12]);
      dst[19] = decodeFloat16(src[17]);
      dst[20] = decodeFloat16(src[25]);
      dst[21] = decodeFloat16(src[30]);
      dst[22] = decodeFloat16(src[41]);
      dst[23] = decodeFloat16(src[43]);
      dst[24] = decodeFloat16(src[9]);
      dst[25] = decodeFloat16(src[11]);
      dst[26] = decodeFloat16(src[18]);
      dst[27] = decodeFloat16(src[24]);
      dst[28] = decodeFloat16(src[31]);
      dst[29] = decodeFloat16(src[40]);
      dst[30] = decodeFloat16(src[44]);
      dst[31] = decodeFloat16(src[53]);
      dst[32] = decodeFloat16(src[10]);
      dst[33] = decodeFloat16(src[19]);
      dst[34] = decodeFloat16(src[23]);
      dst[35] = decodeFloat16(src[32]);
      dst[36] = decodeFloat16(src[39]);
      dst[37] = decodeFloat16(src[45]);
      dst[38] = decodeFloat16(src[52]);
      dst[39] = decodeFloat16(src[54]);
      dst[40] = decodeFloat16(src[20]);
      dst[41] = decodeFloat16(src[22]);
      dst[42] = decodeFloat16(src[33]);
      dst[43] = decodeFloat16(src[38]);
      dst[44] = decodeFloat16(src[46]);
      dst[45] = decodeFloat16(src[51]);
      dst[46] = decodeFloat16(src[55]);
      dst[47] = decodeFloat16(src[60]);
      dst[48] = decodeFloat16(src[21]);
      dst[49] = decodeFloat16(src[34]);
      dst[50] = decodeFloat16(src[37]);
      dst[51] = decodeFloat16(src[47]);
      dst[52] = decodeFloat16(src[50]);
      dst[53] = decodeFloat16(src[56]);
      dst[54] = decodeFloat16(src[59]);
      dst[55] = decodeFloat16(src[61]);
      dst[56] = decodeFloat16(src[35]);
      dst[57] = decodeFloat16(src[36]);
      dst[58] = decodeFloat16(src[48]);
      dst[59] = decodeFloat16(src[49]);
      dst[60] = decodeFloat16(src[57]);
      dst[61] = decodeFloat16(src[58]);
      dst[62] = decodeFloat16(src[62]);
      dst[63] = decodeFloat16(src[63]);
    }
    function dctInverse(data) {
      const a4 = 0.5 * Math.cos(3.14159 / 4);
      const b5 = 0.5 * Math.cos(3.14159 / 16);
      const c3 = 0.5 * Math.cos(3.14159 / 8);
      const d = 0.5 * Math.cos(3 * 3.14159 / 16);
      const e = 0.5 * Math.cos(5 * 3.14159 / 16);
      const f = 0.5 * Math.cos(3 * 3.14159 / 8);
      const g2 = 0.5 * Math.cos(7 * 3.14159 / 16);
      var alpha = new Array(4);
      var beta = new Array(4);
      var theta = new Array(4);
      var gamma = new Array(4);
      for (var row = 0; row < 8; ++row) {
        var rowPtr = row * 8;
        alpha[0] = c3 * data[rowPtr + 2];
        alpha[1] = f * data[rowPtr + 2];
        alpha[2] = c3 * data[rowPtr + 6];
        alpha[3] = f * data[rowPtr + 6];
        beta[0] = b5 * data[rowPtr + 1] + d * data[rowPtr + 3] + e * data[rowPtr + 5] + g2 * data[rowPtr + 7];
        beta[1] = d * data[rowPtr + 1] - g2 * data[rowPtr + 3] - b5 * data[rowPtr + 5] - e * data[rowPtr + 7];
        beta[2] = e * data[rowPtr + 1] - b5 * data[rowPtr + 3] + g2 * data[rowPtr + 5] + d * data[rowPtr + 7];
        beta[3] = g2 * data[rowPtr + 1] - e * data[rowPtr + 3] + d * data[rowPtr + 5] - b5 * data[rowPtr + 7];
        theta[0] = a4 * (data[rowPtr + 0] + data[rowPtr + 4]);
        theta[3] = a4 * (data[rowPtr + 0] - data[rowPtr + 4]);
        theta[1] = alpha[0] + alpha[3];
        theta[2] = alpha[1] - alpha[2];
        gamma[0] = theta[0] + theta[1];
        gamma[1] = theta[3] + theta[2];
        gamma[2] = theta[3] - theta[2];
        gamma[3] = theta[0] - theta[1];
        data[rowPtr + 0] = gamma[0] + beta[0];
        data[rowPtr + 1] = gamma[1] + beta[1];
        data[rowPtr + 2] = gamma[2] + beta[2];
        data[rowPtr + 3] = gamma[3] + beta[3];
        data[rowPtr + 4] = gamma[3] - beta[3];
        data[rowPtr + 5] = gamma[2] - beta[2];
        data[rowPtr + 6] = gamma[1] - beta[1];
        data[rowPtr + 7] = gamma[0] - beta[0];
      }
      for (var column = 0; column < 8; ++column) {
        alpha[0] = c3 * data[16 + column];
        alpha[1] = f * data[16 + column];
        alpha[2] = c3 * data[48 + column];
        alpha[3] = f * data[48 + column];
        beta[0] = b5 * data[8 + column] + d * data[24 + column] + e * data[40 + column] + g2 * data[56 + column];
        beta[1] = d * data[8 + column] - g2 * data[24 + column] - b5 * data[40 + column] - e * data[56 + column];
        beta[2] = e * data[8 + column] - b5 * data[24 + column] + g2 * data[40 + column] + d * data[56 + column];
        beta[3] = g2 * data[8 + column] - e * data[24 + column] + d * data[40 + column] - b5 * data[56 + column];
        theta[0] = a4 * (data[column] + data[32 + column]);
        theta[3] = a4 * (data[column] - data[32 + column]);
        theta[1] = alpha[0] + alpha[3];
        theta[2] = alpha[1] - alpha[2];
        gamma[0] = theta[0] + theta[1];
        gamma[1] = theta[3] + theta[2];
        gamma[2] = theta[3] - theta[2];
        gamma[3] = theta[0] - theta[1];
        data[0 + column] = gamma[0] + beta[0];
        data[8 + column] = gamma[1] + beta[1];
        data[16 + column] = gamma[2] + beta[2];
        data[24 + column] = gamma[3] + beta[3];
        data[32 + column] = gamma[3] - beta[3];
        data[40 + column] = gamma[2] - beta[2];
        data[48 + column] = gamma[1] - beta[1];
        data[56 + column] = gamma[0] - beta[0];
      }
    }
    function csc709Inverse(data) {
      for (var i3 = 0; i3 < 64; ++i3) {
        var y = data[0][i3];
        var cb3 = data[1][i3];
        var cr = data[2][i3];
        data[0][i3] = y + 1.5747 * cr;
        data[1][i3] = y - 0.1873 * cb3 - 0.4682 * cr;
        data[2][i3] = y + 1.8556 * cb3;
      }
    }
    function convertToHalf(src, dst, idx) {
      for (var i3 = 0; i3 < 64; ++i3) {
        dst[idx + i3] = DataUtils.toHalfFloat(toLinear(src[i3]));
      }
    }
    function toLinear(float) {
      if (float <= 1) {
        return Math.sign(float) * Math.pow(Math.abs(float), 2.2);
      } else {
        return Math.sign(float) * Math.pow(logBase, Math.abs(float) - 1);
      }
    }
    function uncompressRAW(info) {
      return new DataView(info.array.buffer, info.offset.value, info.size);
    }
    function uncompressRLE(info) {
      var compressed = info.viewer.buffer.slice(info.offset.value, info.offset.value + info.size);
      var rawBuffer = new Uint8Array(decodeRunLength(compressed));
      var tmpBuffer = new Uint8Array(rawBuffer.length);
      predictor(rawBuffer);
      interleaveScalar(rawBuffer, tmpBuffer);
      return new DataView(tmpBuffer.buffer);
    }
    function uncompressZIP(info) {
      var compressed = info.array.slice(info.offset.value, info.offset.value + info.size);
      var rawBuffer = unzlibSync(compressed);
      var tmpBuffer = new Uint8Array(rawBuffer.length);
      predictor(rawBuffer);
      interleaveScalar(rawBuffer, tmpBuffer);
      return new DataView(tmpBuffer.buffer);
    }
    function uncompressPIZ(info) {
      var inDataView = info.viewer;
      var inOffset = { value: info.offset.value };
      var outBuffer = new Uint16Array(info.width * info.scanlineBlockSize * (info.channels * info.type));
      var bitmap = new Uint8Array(BITMAP_SIZE);
      var outBufferEnd = 0;
      var pizChannelData = new Array(info.channels);
      for (var i3 = 0; i3 < info.channels; i3++) {
        pizChannelData[i3] = {};
        pizChannelData[i3]["start"] = outBufferEnd;
        pizChannelData[i3]["end"] = pizChannelData[i3]["start"];
        pizChannelData[i3]["nx"] = info.width;
        pizChannelData[i3]["ny"] = info.lines;
        pizChannelData[i3]["size"] = info.type;
        outBufferEnd += pizChannelData[i3].nx * pizChannelData[i3].ny * pizChannelData[i3].size;
      }
      var minNonZero = parseUint16(inDataView, inOffset);
      var maxNonZero = parseUint16(inDataView, inOffset);
      if (maxNonZero >= BITMAP_SIZE) {
        throw "Something is wrong with PIZ_COMPRESSION BITMAP_SIZE";
      }
      if (minNonZero <= maxNonZero) {
        for (var i3 = 0; i3 < maxNonZero - minNonZero + 1; i3++) {
          bitmap[i3 + minNonZero] = parseUint8(inDataView, inOffset);
        }
      }
      var lut = new Uint16Array(USHORT_RANGE);
      var maxValue = reverseLutFromBitmap(bitmap, lut);
      var length = parseUint32(inDataView, inOffset);
      hufUncompress(info.array, inDataView, inOffset, length, outBuffer, outBufferEnd);
      for (var i3 = 0; i3 < info.channels; ++i3) {
        var cd = pizChannelData[i3];
        for (var j = 0; j < pizChannelData[i3].size; ++j) {
          wav2Decode(outBuffer, cd.start + j, cd.nx, cd.size, cd.ny, cd.nx * cd.size, maxValue);
        }
      }
      applyLut(lut, outBuffer, outBufferEnd);
      var tmpOffset2 = 0;
      var tmpBuffer = new Uint8Array(outBuffer.buffer.byteLength);
      for (var y = 0; y < info.lines; y++) {
        for (var c3 = 0; c3 < info.channels; c3++) {
          var cd = pizChannelData[c3];
          var n = cd.nx * cd.size;
          var cp = new Uint8Array(outBuffer.buffer, cd.end * INT16_SIZE, n * INT16_SIZE);
          tmpBuffer.set(cp, tmpOffset2);
          tmpOffset2 += n * INT16_SIZE;
          cd.end += n;
        }
      }
      return new DataView(tmpBuffer.buffer);
    }
    function uncompressPXR(info) {
      var compressed = info.array.slice(info.offset.value, info.offset.value + info.size);
      var rawBuffer = unzlibSync(compressed);
      const sz = info.lines * info.channels * info.width;
      const tmpBuffer = info.type == 1 ? new Uint16Array(sz) : new Uint32Array(sz);
      let tmpBufferEnd = 0;
      let writePtr = 0;
      const ptr = new Array(4);
      for (let y = 0; y < info.lines; y++) {
        for (let c3 = 0; c3 < info.channels; c3++) {
          let pixel = 0;
          switch (info.type) {
            case 1:
              ptr[0] = tmpBufferEnd;
              ptr[1] = ptr[0] + info.width;
              tmpBufferEnd = ptr[1] + info.width;
              for (let j = 0; j < info.width; ++j) {
                const diff = rawBuffer[ptr[0]++] << 8 | rawBuffer[ptr[1]++];
                pixel += diff;
                tmpBuffer[writePtr] = pixel;
                writePtr++;
              }
              break;
            case 2:
              ptr[0] = tmpBufferEnd;
              ptr[1] = ptr[0] + info.width;
              ptr[2] = ptr[1] + info.width;
              tmpBufferEnd = ptr[2] + info.width;
              for (let j = 0; j < info.width; ++j) {
                const diff = rawBuffer[ptr[0]++] << 24 | rawBuffer[ptr[1]++] << 16 | rawBuffer[ptr[2]++] << 8;
                pixel += diff;
                tmpBuffer[writePtr] = pixel;
                writePtr++;
              }
              break;
          }
        }
      }
      return new DataView(tmpBuffer.buffer);
    }
    function uncompressDWA(info) {
      var inDataView = info.viewer;
      var inOffset = { value: info.offset.value };
      var outBuffer = new Uint8Array(info.width * info.lines * (info.channels * info.type * INT16_SIZE));
      var dwaHeader = {
        version: parseInt64(inDataView, inOffset),
        unknownUncompressedSize: parseInt64(inDataView, inOffset),
        unknownCompressedSize: parseInt64(inDataView, inOffset),
        acCompressedSize: parseInt64(inDataView, inOffset),
        dcCompressedSize: parseInt64(inDataView, inOffset),
        rleCompressedSize: parseInt64(inDataView, inOffset),
        rleUncompressedSize: parseInt64(inDataView, inOffset),
        rleRawSize: parseInt64(inDataView, inOffset),
        totalAcUncompressedCount: parseInt64(inDataView, inOffset),
        totalDcUncompressedCount: parseInt64(inDataView, inOffset),
        acCompression: parseInt64(inDataView, inOffset)
      };
      if (dwaHeader.version < 2) {
        throw "EXRLoader.parse: " + EXRHeader.compression + " version " + dwaHeader.version + " is unsupported";
      }
      var channelRules = new Array();
      var ruleSize = parseUint16(inDataView, inOffset) - INT16_SIZE;
      while (ruleSize > 0) {
        var name = parseNullTerminatedString(inDataView.buffer, inOffset);
        var value = parseUint8(inDataView, inOffset);
        var compression = value >> 2 & 3;
        var csc = (value >> 4) - 1;
        var index = new Int8Array([csc])[0];
        var type = parseUint8(inDataView, inOffset);
        channelRules.push({
          name,
          index,
          type,
          compression
        });
        ruleSize -= name.length + 3;
      }
      var channels = EXRHeader.channels;
      var channelData = new Array(info.channels);
      for (var i3 = 0; i3 < info.channels; ++i3) {
        var cd = channelData[i3] = {};
        var channel = channels[i3];
        cd.name = channel.name;
        cd.compression = UNKNOWN;
        cd.decoded = false;
        cd.type = channel.pixelType;
        cd.pLinear = channel.pLinear;
        cd.width = info.width;
        cd.height = info.lines;
      }
      var cscSet = {
        idx: new Array(3)
      };
      for (var offset2 = 0; offset2 < info.channels; ++offset2) {
        var cd = channelData[offset2];
        for (var i3 = 0; i3 < channelRules.length; ++i3) {
          var rule = channelRules[i3];
          if (cd.name == rule.name) {
            cd.compression = rule.compression;
            if (rule.index >= 0) {
              cscSet.idx[rule.index] = offset2;
            }
            cd.offset = offset2;
          }
        }
      }
      if (dwaHeader.acCompressedSize > 0) {
        switch (dwaHeader.acCompression) {
          case STATIC_HUFFMAN:
            var acBuffer = new Uint16Array(dwaHeader.totalAcUncompressedCount);
            hufUncompress(
              info.array,
              inDataView,
              inOffset,
              dwaHeader.acCompressedSize,
              acBuffer,
              dwaHeader.totalAcUncompressedCount
            );
            break;
          case DEFLATE:
            var compressed = info.array.slice(inOffset.value, inOffset.value + dwaHeader.totalAcUncompressedCount);
            var data = unzlibSync(compressed);
            var acBuffer = new Uint16Array(data.buffer);
            inOffset.value += dwaHeader.totalAcUncompressedCount;
            break;
        }
      }
      if (dwaHeader.dcCompressedSize > 0) {
        var zlibInfo = {
          array: info.array,
          offset: inOffset,
          size: dwaHeader.dcCompressedSize
        };
        var dcBuffer = new Uint16Array(uncompressZIP(zlibInfo).buffer);
        inOffset.value += dwaHeader.dcCompressedSize;
      }
      if (dwaHeader.rleRawSize > 0) {
        var compressed = info.array.slice(inOffset.value, inOffset.value + dwaHeader.rleCompressedSize);
        var data = unzlibSync(compressed);
        var rleBuffer = decodeRunLength(data.buffer);
        inOffset.value += dwaHeader.rleCompressedSize;
      }
      var outBufferEnd = 0;
      var rowOffsets = new Array(channelData.length);
      for (var i3 = 0; i3 < rowOffsets.length; ++i3) {
        rowOffsets[i3] = new Array();
      }
      for (var y = 0; y < info.lines; ++y) {
        for (var chan = 0; chan < channelData.length; ++chan) {
          rowOffsets[chan].push(outBufferEnd);
          outBufferEnd += channelData[chan].width * info.type * INT16_SIZE;
        }
      }
      lossyDctDecode(cscSet, rowOffsets, channelData, acBuffer, dcBuffer, outBuffer);
      for (var i3 = 0; i3 < channelData.length; ++i3) {
        var cd = channelData[i3];
        if (cd.decoded)
          continue;
        switch (cd.compression) {
          case RLE:
            var row = 0;
            var rleOffset = 0;
            for (var y = 0; y < info.lines; ++y) {
              var rowOffsetBytes = rowOffsets[i3][row];
              for (var x = 0; x < cd.width; ++x) {
                for (var byte = 0; byte < INT16_SIZE * cd.type; ++byte) {
                  outBuffer[rowOffsetBytes++] = rleBuffer[rleOffset + byte * cd.width * cd.height];
                }
                rleOffset++;
              }
              row++;
            }
            break;
          case LOSSY_DCT:
          default:
            throw "EXRLoader.parse: unsupported channel compression";
        }
      }
      return new DataView(outBuffer.buffer);
    }
    function parseNullTerminatedString(buffer2, offset2) {
      var uintBuffer = new Uint8Array(buffer2);
      var endOffset = 0;
      while (uintBuffer[offset2.value + endOffset] != 0) {
        endOffset += 1;
      }
      var stringValue = new TextDecoder().decode(uintBuffer.slice(offset2.value, offset2.value + endOffset));
      offset2.value = offset2.value + endOffset + 1;
      return stringValue;
    }
    function parseFixedLengthString(buffer2, offset2, size2) {
      var stringValue = new TextDecoder().decode(new Uint8Array(buffer2).slice(offset2.value, offset2.value + size2));
      offset2.value = offset2.value + size2;
      return stringValue;
    }
    function parseRational(dataView, offset2) {
      var x = parseInt32(dataView, offset2);
      var y = parseUint32(dataView, offset2);
      return [x, y];
    }
    function parseTimecode(dataView, offset2) {
      var x = parseUint32(dataView, offset2);
      var y = parseUint32(dataView, offset2);
      return [x, y];
    }
    function parseInt32(dataView, offset2) {
      var Int32 = dataView.getInt32(offset2.value, true);
      offset2.value = offset2.value + INT32_SIZE;
      return Int32;
    }
    function parseUint32(dataView, offset2) {
      var Uint32 = dataView.getUint32(offset2.value, true);
      offset2.value = offset2.value + INT32_SIZE;
      return Uint32;
    }
    function parseUint8Array(uInt8Array2, offset2) {
      var Uint8 = uInt8Array2[offset2.value];
      offset2.value = offset2.value + INT8_SIZE;
      return Uint8;
    }
    function parseUint8(dataView, offset2) {
      var Uint8 = dataView.getUint8(offset2.value);
      offset2.value = offset2.value + INT8_SIZE;
      return Uint8;
    }
    const parseInt64 = function(dataView, offset2) {
      let int;
      if ("getBigInt64" in DataView.prototype) {
        int = Number(dataView.getBigInt64(offset2.value, true));
      } else {
        int = dataView.getUint32(offset2.value + 4, true) + Number(dataView.getUint32(offset2.value, true) << 32);
      }
      offset2.value += ULONG_SIZE;
      return int;
    };
    function parseFloat32(dataView, offset2) {
      var float = dataView.getFloat32(offset2.value, true);
      offset2.value += FLOAT32_SIZE;
      return float;
    }
    function decodeFloat32(dataView, offset2) {
      return DataUtils.toHalfFloat(parseFloat32(dataView, offset2));
    }
    function decodeFloat16(binary) {
      var exponent = (binary & 31744) >> 10, fraction = binary & 1023;
      return (binary >> 15 ? -1 : 1) * (exponent ? exponent === 31 ? fraction ? NaN : Infinity : Math.pow(2, exponent - 15) * (1 + fraction / 1024) : 6103515625e-14 * (fraction / 1024));
    }
    function parseUint16(dataView, offset2) {
      var Uint16 = dataView.getUint16(offset2.value, true);
      offset2.value += INT16_SIZE;
      return Uint16;
    }
    function parseFloat16(buffer2, offset2) {
      return decodeFloat16(parseUint16(buffer2, offset2));
    }
    function parseChlist(dataView, buffer2, offset2, size2) {
      var startOffset = offset2.value;
      var channels = [];
      while (offset2.value < startOffset + size2 - 1) {
        var name = parseNullTerminatedString(buffer2, offset2);
        var pixelType = parseInt32(dataView, offset2);
        var pLinear = parseUint8(dataView, offset2);
        offset2.value += 3;
        var xSampling = parseInt32(dataView, offset2);
        var ySampling = parseInt32(dataView, offset2);
        channels.push({
          name,
          pixelType,
          pLinear,
          xSampling,
          ySampling
        });
      }
      offset2.value += 1;
      return channels;
    }
    function parseChromaticities(dataView, offset2) {
      var redX = parseFloat32(dataView, offset2);
      var redY = parseFloat32(dataView, offset2);
      var greenX = parseFloat32(dataView, offset2);
      var greenY = parseFloat32(dataView, offset2);
      var blueX = parseFloat32(dataView, offset2);
      var blueY = parseFloat32(dataView, offset2);
      var whiteX = parseFloat32(dataView, offset2);
      var whiteY = parseFloat32(dataView, offset2);
      return {
        redX,
        redY,
        greenX,
        greenY,
        blueX,
        blueY,
        whiteX,
        whiteY
      };
    }
    function parseCompression(dataView, offset2) {
      var compressionCodes = [
        "NO_COMPRESSION",
        "RLE_COMPRESSION",
        "ZIPS_COMPRESSION",
        "ZIP_COMPRESSION",
        "PIZ_COMPRESSION",
        "PXR24_COMPRESSION",
        "B44_COMPRESSION",
        "B44A_COMPRESSION",
        "DWAA_COMPRESSION",
        "DWAB_COMPRESSION"
      ];
      var compression = parseUint8(dataView, offset2);
      return compressionCodes[compression];
    }
    function parseBox2i(dataView, offset2) {
      var xMin = parseUint32(dataView, offset2);
      var yMin = parseUint32(dataView, offset2);
      var xMax = parseUint32(dataView, offset2);
      var yMax = parseUint32(dataView, offset2);
      return { xMin, yMin, xMax, yMax };
    }
    function parseLineOrder(dataView, offset2) {
      var lineOrders = ["INCREASING_Y"];
      var lineOrder = parseUint8(dataView, offset2);
      return lineOrders[lineOrder];
    }
    function parseV2f(dataView, offset2) {
      var x = parseFloat32(dataView, offset2);
      var y = parseFloat32(dataView, offset2);
      return [x, y];
    }
    function parseV3f(dataView, offset2) {
      var x = parseFloat32(dataView, offset2);
      var y = parseFloat32(dataView, offset2);
      var z = parseFloat32(dataView, offset2);
      return [x, y, z];
    }
    function parseValue(dataView, buffer2, offset2, type, size2) {
      if (type === "string" || type === "stringvector" || type === "iccProfile") {
        return parseFixedLengthString(buffer2, offset2, size2);
      } else if (type === "chlist") {
        return parseChlist(dataView, buffer2, offset2, size2);
      } else if (type === "chromaticities") {
        return parseChromaticities(dataView, offset2);
      } else if (type === "compression") {
        return parseCompression(dataView, offset2);
      } else if (type === "box2i") {
        return parseBox2i(dataView, offset2);
      } else if (type === "lineOrder") {
        return parseLineOrder(dataView, offset2);
      } else if (type === "float") {
        return parseFloat32(dataView, offset2);
      } else if (type === "v2f") {
        return parseV2f(dataView, offset2);
      } else if (type === "v3f") {
        return parseV3f(dataView, offset2);
      } else if (type === "int") {
        return parseInt32(dataView, offset2);
      } else if (type === "rational") {
        return parseRational(dataView, offset2);
      } else if (type === "timecode") {
        return parseTimecode(dataView, offset2);
      } else if (type === "preview") {
        offset2.value += size2;
        return "skipped";
      } else {
        offset2.value += size2;
        return void 0;
      }
    }
    function parseHeader(dataView, buffer2, offset2) {
      const EXRHeader2 = {};
      if (dataView.getUint32(0, true) != 20000630) {
        throw "THREE.EXRLoader: provided file doesn't appear to be in OpenEXR format.";
      }
      EXRHeader2.version = dataView.getUint8(4);
      const spec = dataView.getUint8(5);
      EXRHeader2.spec = {
        singleTile: !!(spec & 2),
        longName: !!(spec & 4),
        deepFormat: !!(spec & 8),
        multiPart: !!(spec & 16)
      };
      offset2.value = 8;
      var keepReading = true;
      while (keepReading) {
        var attributeName = parseNullTerminatedString(buffer2, offset2);
        if (attributeName == 0) {
          keepReading = false;
        } else {
          var attributeType = parseNullTerminatedString(buffer2, offset2);
          var attributeSize = parseUint32(dataView, offset2);
          var attributeValue = parseValue(dataView, buffer2, offset2, attributeType, attributeSize);
          if (attributeValue === void 0) {
            console.warn(`EXRLoader.parse: skipped unknown header attribute type '${attributeType}'.`);
          } else {
            EXRHeader2[attributeName] = attributeValue;
          }
        }
      }
      if (spec != 0) {
        console.error("EXRHeader:", EXRHeader2);
        throw "THREE.EXRLoader: provided file is currently unsupported.";
      }
      return EXRHeader2;
    }
    function setupDecoder(EXRHeader2, dataView, uInt8Array2, offset2, outputType) {
      const EXRDecoder2 = {
        size: 0,
        viewer: dataView,
        array: uInt8Array2,
        offset: offset2,
        width: EXRHeader2.dataWindow.xMax - EXRHeader2.dataWindow.xMin + 1,
        height: EXRHeader2.dataWindow.yMax - EXRHeader2.dataWindow.yMin + 1,
        channels: EXRHeader2.channels.length,
        bytesPerLine: null,
        lines: null,
        inputSize: null,
        type: EXRHeader2.channels[0].pixelType,
        uncompress: null,
        getter: null,
        format: null,
        [hasColorSpace ? "colorSpace" : "encoding"]: null
      };
      switch (EXRHeader2.compression) {
        case "NO_COMPRESSION":
          EXRDecoder2.lines = 1;
          EXRDecoder2.uncompress = uncompressRAW;
          break;
        case "RLE_COMPRESSION":
          EXRDecoder2.lines = 1;
          EXRDecoder2.uncompress = uncompressRLE;
          break;
        case "ZIPS_COMPRESSION":
          EXRDecoder2.lines = 1;
          EXRDecoder2.uncompress = uncompressZIP;
          break;
        case "ZIP_COMPRESSION":
          EXRDecoder2.lines = 16;
          EXRDecoder2.uncompress = uncompressZIP;
          break;
        case "PIZ_COMPRESSION":
          EXRDecoder2.lines = 32;
          EXRDecoder2.uncompress = uncompressPIZ;
          break;
        case "PXR24_COMPRESSION":
          EXRDecoder2.lines = 16;
          EXRDecoder2.uncompress = uncompressPXR;
          break;
        case "DWAA_COMPRESSION":
          EXRDecoder2.lines = 32;
          EXRDecoder2.uncompress = uncompressDWA;
          break;
        case "DWAB_COMPRESSION":
          EXRDecoder2.lines = 256;
          EXRDecoder2.uncompress = uncompressDWA;
          break;
        default:
          throw "EXRLoader.parse: " + EXRHeader2.compression + " is unsupported";
      }
      EXRDecoder2.scanlineBlockSize = EXRDecoder2.lines;
      if (EXRDecoder2.type == 1) {
        switch (outputType) {
          case FloatType:
            EXRDecoder2.getter = parseFloat16;
            EXRDecoder2.inputSize = INT16_SIZE;
            break;
          case HalfFloatType:
            EXRDecoder2.getter = parseUint16;
            EXRDecoder2.inputSize = INT16_SIZE;
            break;
        }
      } else if (EXRDecoder2.type == 2) {
        switch (outputType) {
          case FloatType:
            EXRDecoder2.getter = parseFloat32;
            EXRDecoder2.inputSize = FLOAT32_SIZE;
            break;
          case HalfFloatType:
            EXRDecoder2.getter = decodeFloat32;
            EXRDecoder2.inputSize = FLOAT32_SIZE;
        }
      } else {
        throw "EXRLoader.parse: unsupported pixelType " + EXRDecoder2.type + " for " + EXRHeader2.compression + ".";
      }
      EXRDecoder2.blockCount = (EXRHeader2.dataWindow.yMax + 1) / EXRDecoder2.scanlineBlockSize;
      for (var i3 = 0; i3 < EXRDecoder2.blockCount; i3++)
        parseInt64(dataView, offset2);
      EXRDecoder2.outputChannels = EXRDecoder2.channels == 3 ? 4 : EXRDecoder2.channels;
      const size2 = EXRDecoder2.width * EXRDecoder2.height * EXRDecoder2.outputChannels;
      switch (outputType) {
        case FloatType:
          EXRDecoder2.byteArray = new Float32Array(size2);
          if (EXRDecoder2.channels < EXRDecoder2.outputChannels)
            EXRDecoder2.byteArray.fill(1, 0, size2);
          break;
        case HalfFloatType:
          EXRDecoder2.byteArray = new Uint16Array(size2);
          if (EXRDecoder2.channels < EXRDecoder2.outputChannels)
            EXRDecoder2.byteArray.fill(15360, 0, size2);
          break;
        default:
          console.error("THREE.EXRLoader: unsupported type: ", outputType);
          break;
      }
      EXRDecoder2.bytesPerLine = EXRDecoder2.width * EXRDecoder2.inputSize * EXRDecoder2.channels;
      if (EXRDecoder2.outputChannels == 4)
        EXRDecoder2.format = RGBAFormat;
      else
        EXRDecoder2.format = RedFormat;
      if (hasColorSpace)
        EXRDecoder2.colorSpace = "srgb-linear";
      else
        EXRDecoder2.encoding = 3e3;
      return EXRDecoder2;
    }
    const bufferDataView = new DataView(buffer);
    const uInt8Array = new Uint8Array(buffer);
    const offset = { value: 0 };
    const EXRHeader = parseHeader(bufferDataView, buffer, offset);
    const EXRDecoder = setupDecoder(EXRHeader, bufferDataView, uInt8Array, offset, this.type);
    const tmpOffset = { value: 0 };
    const channelOffsets = { R: 0, G: 1, B: 2, A: 3, Y: 0 };
    for (let scanlineBlockIdx = 0; scanlineBlockIdx < EXRDecoder.height / EXRDecoder.scanlineBlockSize; scanlineBlockIdx++) {
      const line2 = parseUint32(bufferDataView, offset);
      EXRDecoder.size = parseUint32(bufferDataView, offset);
      EXRDecoder.lines = line2 + EXRDecoder.scanlineBlockSize > EXRDecoder.height ? EXRDecoder.height - line2 : EXRDecoder.scanlineBlockSize;
      const isCompressed = EXRDecoder.size < EXRDecoder.lines * EXRDecoder.bytesPerLine;
      const viewer = isCompressed ? EXRDecoder.uncompress(EXRDecoder) : uncompressRAW(EXRDecoder);
      offset.value += EXRDecoder.size;
      for (let line_y = 0; line_y < EXRDecoder.scanlineBlockSize; line_y++) {
        const true_y = line_y + scanlineBlockIdx * EXRDecoder.scanlineBlockSize;
        if (true_y >= EXRDecoder.height)
          break;
        for (let channelID = 0; channelID < EXRDecoder.channels; channelID++) {
          const cOff = channelOffsets[EXRHeader.channels[channelID].name];
          for (let x = 0; x < EXRDecoder.width; x++) {
            tmpOffset.value = (line_y * (EXRDecoder.channels * EXRDecoder.width) + channelID * EXRDecoder.width + x) * EXRDecoder.inputSize;
            const outIndex = (EXRDecoder.height - 1 - true_y) * (EXRDecoder.width * EXRDecoder.outputChannels) + x * EXRDecoder.outputChannels + cOff;
            EXRDecoder.byteArray[outIndex] = EXRDecoder.getter(viewer, tmpOffset);
          }
        }
      }
    }
    return {
      header: EXRHeader,
      width: EXRDecoder.width,
      height: EXRDecoder.height,
      data: EXRDecoder.byteArray,
      format: EXRDecoder.format,
      [hasColorSpace ? "colorSpace" : "encoding"]: EXRDecoder[hasColorSpace ? "colorSpace" : "encoding"],
      type: this.type
    };
  }
  setDataType(value) {
    this.type = value;
    return this;
  }
  load(url, onLoad, onProgress, onError) {
    function onLoadCallback(texture, texData) {
      if (hasColorSpace)
        texture.colorSpace = texData.colorSpace;
      else
        texture.encoding = texData.encoding;
      texture.minFilter = LinearFilter;
      texture.magFilter = LinearFilter;
      texture.generateMipmaps = false;
      texture.flipY = false;
      if (onLoad)
        onLoad(texture, texData);
    }
    return super.load(url, onLoadCallback, onProgress, onError);
  }
};

// node_modules/three-stdlib/loaders/BasisTextureLoader.js
var __defProp23 = Object.defineProperty;
var __defNormalProp23 = (obj, key, value) => key in obj ? __defProp23(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField24 = (obj, key, value) => {
  __defNormalProp23(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var _taskCache2 = /* @__PURE__ */ new WeakMap();
var _BasisTextureLoader = class extends Loader {
  constructor(manager) {
    super(manager);
    this.transcoderPath = "";
    this.transcoderBinary = null;
    this.transcoderPending = null;
    this.workerLimit = 4;
    this.workerPool = [];
    this.workerNextTaskID = 1;
    this.workerSourceURL = "";
    this.workerConfig = null;
  }
  setTranscoderPath(path) {
    this.transcoderPath = path;
    return this;
  }
  setWorkerLimit(workerLimit) {
    this.workerLimit = workerLimit;
    return this;
  }
  detectSupport(renderer) {
    this.workerConfig = {
      astcSupported: renderer.extensions.has("WEBGL_compressed_texture_astc"),
      etc1Supported: renderer.extensions.has("WEBGL_compressed_texture_etc1"),
      etc2Supported: renderer.extensions.has("WEBGL_compressed_texture_etc"),
      dxtSupported: renderer.extensions.has("WEBGL_compressed_texture_s3tc"),
      bptcSupported: renderer.extensions.has("EXT_texture_compression_bptc"),
      pvrtcSupported: renderer.extensions.has("WEBGL_compressed_texture_pvrtc") || renderer.extensions.has("WEBKIT_WEBGL_compressed_texture_pvrtc")
    };
    return this;
  }
  load(url, onLoad, onProgress, onError) {
    const loader = new FileLoader(this.manager);
    loader.setResponseType("arraybuffer");
    loader.setWithCredentials(this.withCredentials);
    const texture = new CompressedTexture();
    loader.load(
      url,
      (buffer) => {
        if (_taskCache2.has(buffer)) {
          const cachedTask = _taskCache2.get(buffer);
          return cachedTask.promise.then(onLoad).catch(onError);
        }
        this._createTexture([buffer]).then(function(_texture) {
          texture.copy(_texture);
          texture.needsUpdate = true;
          if (onLoad)
            onLoad(texture);
        }).catch(onError);
      },
      onProgress,
      onError
    );
    return texture;
  }
  /** Low-level transcoding API, exposed for use by KTX2Loader. */
  parseInternalAsync(options) {
    const { levels } = options;
    const buffers = /* @__PURE__ */ new Set();
    for (let i3 = 0; i3 < levels.length; i3++) {
      buffers.add(levels[i3].data.buffer);
    }
    return this._createTexture(Array.from(buffers), { ...options, lowLevel: true });
  }
  /**
   * @param {ArrayBuffer[]} buffers
   * @param {object?} config
   * @return {Promise<CompressedTexture>}
   */
  _createTexture(buffers, config3 = {}) {
    let worker;
    let taskID;
    const taskConfig = config3;
    let taskCost = 0;
    for (let i3 = 0; i3 < buffers.length; i3++) {
      taskCost += buffers[i3].byteLength;
    }
    const texturePending = this._allocateWorker(taskCost).then((_worker) => {
      worker = _worker;
      taskID = this.workerNextTaskID++;
      return new Promise((resolve, reject) => {
        worker._callbacks[taskID] = { resolve, reject };
        worker.postMessage({ type: "transcode", id: taskID, buffers, taskConfig }, buffers);
      });
    }).then((message) => {
      const { mipmaps, width, height, format } = message;
      const texture = new CompressedTexture(mipmaps, width, height, format, UnsignedByteType);
      texture.minFilter = mipmaps.length === 1 ? LinearFilter : LinearMipmapLinearFilter;
      texture.magFilter = LinearFilter;
      texture.generateMipmaps = false;
      texture.needsUpdate = true;
      return texture;
    });
    texturePending.catch(() => true).then(() => {
      if (worker && taskID) {
        worker._taskLoad -= taskCost;
        delete worker._callbacks[taskID];
      }
    });
    _taskCache2.set(buffers[0], { promise: texturePending });
    return texturePending;
  }
  _initTranscoder() {
    if (!this.transcoderPending) {
      const jsLoader = new FileLoader(this.manager);
      jsLoader.setPath(this.transcoderPath);
      jsLoader.setWithCredentials(this.withCredentials);
      const jsContent = new Promise((resolve, reject) => {
        jsLoader.load("basis_transcoder.js", resolve, void 0, reject);
      });
      const binaryLoader = new FileLoader(this.manager);
      binaryLoader.setPath(this.transcoderPath);
      binaryLoader.setResponseType("arraybuffer");
      binaryLoader.setWithCredentials(this.withCredentials);
      const binaryContent = new Promise((resolve, reject) => {
        binaryLoader.load("basis_transcoder.wasm", resolve, void 0, reject);
      });
      this.transcoderPending = Promise.all([jsContent, binaryContent]).then(([jsContent2, binaryContent2]) => {
        const fn = _BasisTextureLoader.BasisWorker.toString();
        const body = [
          "/* constants */",
          "let _EngineFormat = " + JSON.stringify(_BasisTextureLoader.EngineFormat),
          "let _TranscoderFormat = " + JSON.stringify(_BasisTextureLoader.TranscoderFormat),
          "let _BasisFormat = " + JSON.stringify(_BasisTextureLoader.BasisFormat),
          "/* basis_transcoder.js */",
          jsContent2,
          "/* worker */",
          fn.substring(fn.indexOf("{") + 1, fn.lastIndexOf("}"))
        ].join("\n");
        this.workerSourceURL = URL.createObjectURL(new Blob([body]));
        this.transcoderBinary = binaryContent2;
      });
    }
    return this.transcoderPending;
  }
  _allocateWorker(taskCost) {
    return this._initTranscoder().then(() => {
      if (this.workerPool.length < this.workerLimit) {
        const worker2 = new Worker(this.workerSourceURL);
        worker2._callbacks = {};
        worker2._taskLoad = 0;
        worker2.postMessage({
          type: "init",
          config: this.workerConfig,
          transcoderBinary: this.transcoderBinary
        });
        worker2.onmessage = function(e) {
          const message = e.data;
          switch (message.type) {
            case "transcode":
              worker2._callbacks[message.id].resolve(message);
              break;
            case "error":
              worker2._callbacks[message.id].reject(message);
              break;
            default:
              console.error('THREE.BasisTextureLoader: Unexpected message, "' + message.type + '"');
          }
        };
        this.workerPool.push(worker2);
      } else {
        this.workerPool.sort(function(a4, b5) {
          return a4._taskLoad > b5._taskLoad ? -1 : 1;
        });
      }
      const worker = this.workerPool[this.workerPool.length - 1];
      worker._taskLoad += taskCost;
      return worker;
    });
  }
  dispose() {
    for (let i3 = 0; i3 < this.workerPool.length; i3++) {
      this.workerPool[i3].terminate();
    }
    this.workerPool.length = 0;
    return this;
  }
};
var BasisTextureLoader = _BasisTextureLoader;
__publicField24(BasisTextureLoader, "BasisFormat", {
  ETC1S: 0,
  UASTC_4x4: 1
});
__publicField24(BasisTextureLoader, "TranscoderFormat", {
  ETC1: 0,
  ETC2: 1,
  BC1: 2,
  BC3: 3,
  BC4: 4,
  BC5: 5,
  BC7_M6_OPAQUE_ONLY: 6,
  BC7_M5: 7,
  PVRTC1_4_RGB: 8,
  PVRTC1_4_RGBA: 9,
  ASTC_4x4: 10,
  ATC_RGB: 11,
  ATC_RGBA_INTERPOLATED_ALPHA: 12,
  RGBA32: 13,
  RGB565: 14,
  BGR565: 15,
  RGBA4444: 16
});
__publicField24(BasisTextureLoader, "EngineFormat", {
  RGBAFormat,
  RGBA_ASTC_4x4_Format,
  RGBA_BPTC_Format,
  RGBA_ETC2_EAC_Format,
  RGBA_PVRTC_4BPPV1_Format,
  RGBA_S3TC_DXT5_Format,
  RGB_ETC1_Format,
  RGB_ETC2_Format,
  RGB_PVRTC_4BPPV1_Format,
  RGB_S3TC_DXT1_Format
});
__publicField24(BasisTextureLoader, "BasisWorker", function() {
  let config3;
  let transcoderPending;
  let BasisModule;
  const EngineFormat = _EngineFormat;
  const TranscoderFormat = _TranscoderFormat;
  const BasisFormat = _BasisFormat;
  onmessage = function(e) {
    const message = e.data;
    switch (message.type) {
      case "init":
        config3 = message.config;
        init5(message.transcoderBinary);
        break;
      case "transcode":
        transcoderPending.then(() => {
          try {
            const { width, height, hasAlpha, mipmaps, format } = message.taskConfig.lowLevel ? transcodeLowLevel(message.taskConfig) : transcode(message.buffers[0]);
            const buffers = [];
            for (let i3 = 0; i3 < mipmaps.length; ++i3) {
              buffers.push(mipmaps[i3].data.buffer);
            }
            self.postMessage({ type: "transcode", id: message.id, width, height, hasAlpha, mipmaps, format }, buffers);
          } catch (error) {
            console.error(error);
            self.postMessage({ type: "error", id: message.id, error: error.message });
          }
        });
        break;
    }
  };
  function init5(wasmBinary) {
    transcoderPending = new Promise((resolve) => {
      BasisModule = { wasmBinary, onRuntimeInitialized: resolve };
      BASIS(BasisModule);
    }).then(() => {
      BasisModule.initializeBasis();
    });
  }
  function transcodeLowLevel(taskConfig) {
    const { basisFormat, width, height, hasAlpha } = taskConfig;
    const { transcoderFormat, engineFormat } = getTranscoderFormat(basisFormat, width, height, hasAlpha);
    const blockByteLength = BasisModule.getBytesPerBlockOrPixel(transcoderFormat);
    assert(BasisModule.isFormatSupported(transcoderFormat), "THREE.BasisTextureLoader: Unsupported format.");
    const mipmaps = [];
    if (basisFormat === BasisFormat.ETC1S) {
      const transcoder = new BasisModule.LowLevelETC1SImageTranscoder();
      const { endpointCount, endpointsData, selectorCount, selectorsData, tablesData } = taskConfig.globalData;
      try {
        let ok;
        ok = transcoder.decodePalettes(endpointCount, endpointsData, selectorCount, selectorsData);
        assert(ok, "THREE.BasisTextureLoader: decodePalettes() failed.");
        ok = transcoder.decodeTables(tablesData);
        assert(ok, "THREE.BasisTextureLoader: decodeTables() failed.");
        for (let i3 = 0; i3 < taskConfig.levels.length; i3++) {
          const level = taskConfig.levels[i3];
          const imageDesc = taskConfig.globalData.imageDescs[i3];
          const dstByteLength = getTranscodedImageByteLength(transcoderFormat, level.width, level.height);
          const dst = new Uint8Array(dstByteLength);
          ok = transcoder.transcodeImage(
            transcoderFormat,
            dst,
            dstByteLength / blockByteLength,
            level.data,
            getWidthInBlocks(transcoderFormat, level.width),
            getHeightInBlocks(transcoderFormat, level.height),
            level.width,
            level.height,
            level.index,
            imageDesc.rgbSliceByteOffset,
            imageDesc.rgbSliceByteLength,
            imageDesc.alphaSliceByteOffset,
            imageDesc.alphaSliceByteLength,
            imageDesc.imageFlags,
            hasAlpha,
            false,
            0,
            0
          );
          assert(ok, "THREE.BasisTextureLoader: transcodeImage() failed for level " + level.index + ".");
          mipmaps.push({ data: dst, width: level.width, height: level.height });
        }
      } finally {
        transcoder.delete();
      }
    } else {
      for (let i3 = 0; i3 < taskConfig.levels.length; i3++) {
        const level = taskConfig.levels[i3];
        const dstByteLength = getTranscodedImageByteLength(transcoderFormat, level.width, level.height);
        const dst = new Uint8Array(dstByteLength);
        const ok = BasisModule.transcodeUASTCImage(
          transcoderFormat,
          dst,
          dstByteLength / blockByteLength,
          level.data,
          getWidthInBlocks(transcoderFormat, level.width),
          getHeightInBlocks(transcoderFormat, level.height),
          level.width,
          level.height,
          level.index,
          0,
          level.data.byteLength,
          0,
          hasAlpha,
          false,
          0,
          0,
          -1,
          -1
        );
        assert(ok, "THREE.BasisTextureLoader: transcodeUASTCImage() failed for level " + level.index + ".");
        mipmaps.push({ data: dst, width: level.width, height: level.height });
      }
    }
    return { width, height, hasAlpha, mipmaps, format: engineFormat };
  }
  function transcode(buffer) {
    const basisFile = new BasisModule.BasisFile(new Uint8Array(buffer));
    const basisFormat = basisFile.isUASTC() ? BasisFormat.UASTC_4x4 : BasisFormat.ETC1S;
    const width = basisFile.getImageWidth(0, 0);
    const height = basisFile.getImageHeight(0, 0);
    const levels = basisFile.getNumLevels(0);
    const hasAlpha = basisFile.getHasAlpha();
    function cleanup() {
      basisFile.close();
      basisFile.delete();
    }
    const { transcoderFormat, engineFormat } = getTranscoderFormat(basisFormat, width, height, hasAlpha);
    if (!width || !height || !levels) {
      cleanup();
      throw new Error("THREE.BasisTextureLoader:	Invalid texture");
    }
    if (!basisFile.startTranscoding()) {
      cleanup();
      throw new Error("THREE.BasisTextureLoader: .startTranscoding failed");
    }
    const mipmaps = [];
    for (let mip = 0; mip < levels; mip++) {
      const mipWidth = basisFile.getImageWidth(0, mip);
      const mipHeight = basisFile.getImageHeight(0, mip);
      const dst = new Uint8Array(basisFile.getImageTranscodedSizeInBytes(0, mip, transcoderFormat));
      const status = basisFile.transcodeImage(dst, 0, mip, transcoderFormat, 0, hasAlpha);
      if (!status) {
        cleanup();
        throw new Error("THREE.BasisTextureLoader: .transcodeImage failed.");
      }
      mipmaps.push({ data: dst, width: mipWidth, height: mipHeight });
    }
    cleanup();
    return { width, height, hasAlpha, mipmaps, format: engineFormat };
  }
  const FORMAT_OPTIONS = [
    {
      if: "astcSupported",
      basisFormat: [BasisFormat.UASTC_4x4],
      transcoderFormat: [TranscoderFormat.ASTC_4x4, TranscoderFormat.ASTC_4x4],
      engineFormat: [EngineFormat.RGBA_ASTC_4x4_Format, EngineFormat.RGBA_ASTC_4x4_Format],
      priorityETC1S: Infinity,
      priorityUASTC: 1,
      needsPowerOfTwo: false
    },
    {
      if: "bptcSupported",
      basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],
      transcoderFormat: [TranscoderFormat.BC7_M5, TranscoderFormat.BC7_M5],
      engineFormat: [EngineFormat.RGBA_BPTC_Format, EngineFormat.RGBA_BPTC_Format],
      priorityETC1S: 3,
      priorityUASTC: 2,
      needsPowerOfTwo: false
    },
    {
      if: "dxtSupported",
      basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],
      transcoderFormat: [TranscoderFormat.BC1, TranscoderFormat.BC3],
      engineFormat: [EngineFormat.RGB_S3TC_DXT1_Format, EngineFormat.RGBA_S3TC_DXT5_Format],
      priorityETC1S: 4,
      priorityUASTC: 5,
      needsPowerOfTwo: false
    },
    {
      if: "etc2Supported",
      basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],
      transcoderFormat: [TranscoderFormat.ETC1, TranscoderFormat.ETC2],
      engineFormat: [EngineFormat.RGB_ETC2_Format, EngineFormat.RGBA_ETC2_EAC_Format],
      priorityETC1S: 1,
      priorityUASTC: 3,
      needsPowerOfTwo: false
    },
    {
      if: "etc1Supported",
      basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],
      transcoderFormat: [TranscoderFormat.ETC1, TranscoderFormat.ETC1],
      engineFormat: [EngineFormat.RGB_ETC1_Format, EngineFormat.RGB_ETC1_Format],
      priorityETC1S: 2,
      priorityUASTC: 4,
      needsPowerOfTwo: false
    },
    {
      if: "pvrtcSupported",
      basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],
      transcoderFormat: [TranscoderFormat.PVRTC1_4_RGB, TranscoderFormat.PVRTC1_4_RGBA],
      engineFormat: [EngineFormat.RGB_PVRTC_4BPPV1_Format, EngineFormat.RGBA_PVRTC_4BPPV1_Format],
      priorityETC1S: 5,
      priorityUASTC: 6,
      needsPowerOfTwo: true
    }
  ];
  const ETC1S_OPTIONS = FORMAT_OPTIONS.sort(function(a4, b5) {
    return a4.priorityETC1S - b5.priorityETC1S;
  });
  const UASTC_OPTIONS = FORMAT_OPTIONS.sort(function(a4, b5) {
    return a4.priorityUASTC - b5.priorityUASTC;
  });
  function getTranscoderFormat(basisFormat, width, height, hasAlpha) {
    let transcoderFormat;
    let engineFormat;
    const options = basisFormat === BasisFormat.ETC1S ? ETC1S_OPTIONS : UASTC_OPTIONS;
    for (let i3 = 0; i3 < options.length; i3++) {
      const opt = options[i3];
      if (!config3[opt.if])
        continue;
      if (!opt.basisFormat.includes(basisFormat))
        continue;
      if (opt.needsPowerOfTwo && !(isPowerOfTwo(width) && isPowerOfTwo(height)))
        continue;
      transcoderFormat = opt.transcoderFormat[hasAlpha ? 1 : 0];
      engineFormat = opt.engineFormat[hasAlpha ? 1 : 0];
      return { transcoderFormat, engineFormat };
    }
    console.warn("THREE.BasisTextureLoader: No suitable compressed texture format found. Decoding to RGBA32.");
    transcoderFormat = TranscoderFormat.RGBA32;
    engineFormat = EngineFormat.RGBAFormat;
    return { transcoderFormat, engineFormat };
  }
  function assert(ok, message) {
    if (!ok)
      throw new Error(message);
  }
  function getWidthInBlocks(transcoderFormat, width) {
    return Math.ceil(width / BasisModule.getFormatBlockWidth(transcoderFormat));
  }
  function getHeightInBlocks(transcoderFormat, height) {
    return Math.ceil(height / BasisModule.getFormatBlockHeight(transcoderFormat));
  }
  function getTranscodedImageByteLength(transcoderFormat, width, height) {
    const blockByteLength = BasisModule.getBytesPerBlockOrPixel(transcoderFormat);
    if (BasisModule.formatIsUncompressed(transcoderFormat)) {
      return width * height * blockByteLength;
    }
    if (transcoderFormat === TranscoderFormat.PVRTC1_4_RGB || transcoderFormat === TranscoderFormat.PVRTC1_4_RGBA) {
      const paddedWidth = width + 3 & ~3;
      const paddedHeight = height + 3 & ~3;
      return (Math.max(8, paddedWidth) * Math.max(8, paddedHeight) * 4 + 7) / 8;
    }
    return getWidthInBlocks(transcoderFormat, width) * getHeightInBlocks(transcoderFormat, height) * blockByteLength;
  }
  function isPowerOfTwo(value) {
    if (value <= 2)
      return true;
    return (value & value - 1) === 0 && value !== 0;
  }
});

// node_modules/three-stdlib/loaders/LDrawLoader.js
var _tempVec0 = new Vector3();
var _tempVec1 = new Vector3();
var _ray = new Ray();

// node_modules/three-stdlib/loaders/SVGLoader.js
var SVGLoader = class extends Loader {
  constructor(manager) {
    super(manager);
    this.defaultDPI = 90;
    this.defaultUnit = "px";
  }
  load(url, onLoad, onProgress, onError) {
    const scope = this;
    const loader = new FileLoader(scope.manager);
    loader.setPath(scope.path);
    loader.setRequestHeader(scope.requestHeader);
    loader.setWithCredentials(scope.withCredentials);
    loader.load(
      url,
      function(text) {
        try {
          onLoad(scope.parse(text));
        } catch (e) {
          if (onError) {
            onError(e);
          } else {
            console.error(e);
          }
          scope.manager.itemError(url);
        }
      },
      onProgress,
      onError
    );
  }
  parse(text) {
    const scope = this;
    function parseNode(node, style) {
      if (node.nodeType !== 1)
        return;
      const transform = getNodeTransform(node);
      let traverseChildNodes = true;
      let path = null;
      switch (node.nodeName) {
        case "svg":
          break;
        case "style":
          parseCSSStylesheet(node);
          break;
        case "g":
          style = parseStyle(node, style);
          break;
        case "path":
          style = parseStyle(node, style);
          if (node.hasAttribute("d"))
            path = parsePathNode(node);
          break;
        case "rect":
          style = parseStyle(node, style);
          path = parseRectNode(node);
          break;
        case "polygon":
          style = parseStyle(node, style);
          path = parsePolygonNode(node);
          break;
        case "polyline":
          style = parseStyle(node, style);
          path = parsePolylineNode(node);
          break;
        case "circle":
          style = parseStyle(node, style);
          path = parseCircleNode(node);
          break;
        case "ellipse":
          style = parseStyle(node, style);
          path = parseEllipseNode(node);
          break;
        case "line":
          style = parseStyle(node, style);
          path = parseLineNode(node);
          break;
        case "defs":
          traverseChildNodes = false;
          break;
        case "mask":
          traverseChildNodes = false;
          break;
        case "use":
          style = parseStyle(node, style);
          const usedNodeId = node.href.baseVal.substring(1);
          const usedNode = node.viewportElement.getElementById(usedNodeId);
          if (usedNode) {
            parseNode(usedNode, style);
          } else {
            console.warn("SVGLoader: 'use node' references non-existent node id: " + usedNodeId);
          }
          break;
        default:
      }
      if (path) {
        if (style.fill !== void 0 && style.fill !== "none") {
          path.color.setStyle(style.fill);
        }
        transformPath(path, currentTransform);
        paths.push(path);
        path.userData = { node, style };
      }
      if (traverseChildNodes) {
        const nodes = node.childNodes;
        for (let i3 = 0; i3 < nodes.length; i3++) {
          parseNode(nodes[i3], style);
        }
      }
      if (transform) {
        transformStack.pop();
        if (transformStack.length > 0) {
          currentTransform.copy(transformStack[transformStack.length - 1]);
        } else {
          currentTransform.identity();
        }
      }
    }
    function parsePathNode(node) {
      const path = new ShapePath();
      const point = new Vector2();
      const control = new Vector2();
      const firstPoint = new Vector2();
      let isFirstPoint = true;
      let doSetFirstPoint = false;
      const d = node.getAttribute("d");
      const commands = d.match(/[a-df-z][^a-df-z]*/gi);
      for (let i3 = 0, l = commands.length; i3 < l; i3++) {
        const command = commands[i3];
        const type = command.charAt(0);
        const data2 = command.substr(1).trim();
        if (isFirstPoint === true) {
          doSetFirstPoint = true;
          isFirstPoint = false;
        }
        let numbers;
        switch (type) {
          case "M":
            numbers = parseFloats(data2);
            for (let j = 0, jl = numbers.length; j < jl; j += 2) {
              point.x = numbers[j + 0];
              point.y = numbers[j + 1];
              control.x = point.x;
              control.y = point.y;
              if (j === 0) {
                path.moveTo(point.x, point.y);
              } else {
                path.lineTo(point.x, point.y);
              }
              if (j === 0)
                firstPoint.copy(point);
            }
            break;
          case "H":
            numbers = parseFloats(data2);
            for (let j = 0, jl = numbers.length; j < jl; j++) {
              point.x = numbers[j];
              control.x = point.x;
              control.y = point.y;
              path.lineTo(point.x, point.y);
              if (j === 0 && doSetFirstPoint === true)
                firstPoint.copy(point);
            }
            break;
          case "V":
            numbers = parseFloats(data2);
            for (let j = 0, jl = numbers.length; j < jl; j++) {
              point.y = numbers[j];
              control.x = point.x;
              control.y = point.y;
              path.lineTo(point.x, point.y);
              if (j === 0 && doSetFirstPoint === true)
                firstPoint.copy(point);
            }
            break;
          case "L":
            numbers = parseFloats(data2);
            for (let j = 0, jl = numbers.length; j < jl; j += 2) {
              point.x = numbers[j + 0];
              point.y = numbers[j + 1];
              control.x = point.x;
              control.y = point.y;
              path.lineTo(point.x, point.y);
              if (j === 0 && doSetFirstPoint === true)
                firstPoint.copy(point);
            }
            break;
          case "C":
            numbers = parseFloats(data2);
            for (let j = 0, jl = numbers.length; j < jl; j += 6) {
              path.bezierCurveTo(
                numbers[j + 0],
                numbers[j + 1],
                numbers[j + 2],
                numbers[j + 3],
                numbers[j + 4],
                numbers[j + 5]
              );
              control.x = numbers[j + 2];
              control.y = numbers[j + 3];
              point.x = numbers[j + 4];
              point.y = numbers[j + 5];
              if (j === 0 && doSetFirstPoint === true)
                firstPoint.copy(point);
            }
            break;
          case "S":
            numbers = parseFloats(data2);
            for (let j = 0, jl = numbers.length; j < jl; j += 4) {
              path.bezierCurveTo(
                getReflection(point.x, control.x),
                getReflection(point.y, control.y),
                numbers[j + 0],
                numbers[j + 1],
                numbers[j + 2],
                numbers[j + 3]
              );
              control.x = numbers[j + 0];
              control.y = numbers[j + 1];
              point.x = numbers[j + 2];
              point.y = numbers[j + 3];
              if (j === 0 && doSetFirstPoint === true)
                firstPoint.copy(point);
            }
            break;
          case "Q":
            numbers = parseFloats(data2);
            for (let j = 0, jl = numbers.length; j < jl; j += 4) {
              path.quadraticCurveTo(numbers[j + 0], numbers[j + 1], numbers[j + 2], numbers[j + 3]);
              control.x = numbers[j + 0];
              control.y = numbers[j + 1];
              point.x = numbers[j + 2];
              point.y = numbers[j + 3];
              if (j === 0 && doSetFirstPoint === true)
                firstPoint.copy(point);
            }
            break;
          case "T":
            numbers = parseFloats(data2);
            for (let j = 0, jl = numbers.length; j < jl; j += 2) {
              const rx = getReflection(point.x, control.x);
              const ry = getReflection(point.y, control.y);
              path.quadraticCurveTo(rx, ry, numbers[j + 0], numbers[j + 1]);
              control.x = rx;
              control.y = ry;
              point.x = numbers[j + 0];
              point.y = numbers[j + 1];
              if (j === 0 && doSetFirstPoint === true)
                firstPoint.copy(point);
            }
            break;
          case "A":
            numbers = parseFloats(data2, [3, 4], 7);
            for (let j = 0, jl = numbers.length; j < jl; j += 7) {
              if (numbers[j + 5] == point.x && numbers[j + 6] == point.y)
                continue;
              const start = point.clone();
              point.x = numbers[j + 5];
              point.y = numbers[j + 6];
              control.x = point.x;
              control.y = point.y;
              parseArcCommand(
                path,
                numbers[j],
                numbers[j + 1],
                numbers[j + 2],
                numbers[j + 3],
                numbers[j + 4],
                start,
                point
              );
              if (j === 0 && doSetFirstPoint === true)
                firstPoint.copy(point);
            }
            break;
          case "m":
            numbers = parseFloats(data2);
            for (let j = 0, jl = numbers.length; j < jl; j += 2) {
              point.x += numbers[j + 0];
              point.y += numbers[j + 1];
              control.x = point.x;
              control.y = point.y;
              if (j === 0) {
                path.moveTo(point.x, point.y);
              } else {
                path.lineTo(point.x, point.y);
              }
              if (j === 0)
                firstPoint.copy(point);
            }
            break;
          case "h":
            numbers = parseFloats(data2);
            for (let j = 0, jl = numbers.length; j < jl; j++) {
              point.x += numbers[j];
              control.x = point.x;
              control.y = point.y;
              path.lineTo(point.x, point.y);
              if (j === 0 && doSetFirstPoint === true)
                firstPoint.copy(point);
            }
            break;
          case "v":
            numbers = parseFloats(data2);
            for (let j = 0, jl = numbers.length; j < jl; j++) {
              point.y += numbers[j];
              control.x = point.x;
              control.y = point.y;
              path.lineTo(point.x, point.y);
              if (j === 0 && doSetFirstPoint === true)
                firstPoint.copy(point);
            }
            break;
          case "l":
            numbers = parseFloats(data2);
            for (let j = 0, jl = numbers.length; j < jl; j += 2) {
              point.x += numbers[j + 0];
              point.y += numbers[j + 1];
              control.x = point.x;
              control.y = point.y;
              path.lineTo(point.x, point.y);
              if (j === 0 && doSetFirstPoint === true)
                firstPoint.copy(point);
            }
            break;
          case "c":
            numbers = parseFloats(data2);
            for (let j = 0, jl = numbers.length; j < jl; j += 6) {
              path.bezierCurveTo(
                point.x + numbers[j + 0],
                point.y + numbers[j + 1],
                point.x + numbers[j + 2],
                point.y + numbers[j + 3],
                point.x + numbers[j + 4],
                point.y + numbers[j + 5]
              );
              control.x = point.x + numbers[j + 2];
              control.y = point.y + numbers[j + 3];
              point.x += numbers[j + 4];
              point.y += numbers[j + 5];
              if (j === 0 && doSetFirstPoint === true)
                firstPoint.copy(point);
            }
            break;
          case "s":
            numbers = parseFloats(data2);
            for (let j = 0, jl = numbers.length; j < jl; j += 4) {
              path.bezierCurveTo(
                getReflection(point.x, control.x),
                getReflection(point.y, control.y),
                point.x + numbers[j + 0],
                point.y + numbers[j + 1],
                point.x + numbers[j + 2],
                point.y + numbers[j + 3]
              );
              control.x = point.x + numbers[j + 0];
              control.y = point.y + numbers[j + 1];
              point.x += numbers[j + 2];
              point.y += numbers[j + 3];
              if (j === 0 && doSetFirstPoint === true)
                firstPoint.copy(point);
            }
            break;
          case "q":
            numbers = parseFloats(data2);
            for (let j = 0, jl = numbers.length; j < jl; j += 4) {
              path.quadraticCurveTo(
                point.x + numbers[j + 0],
                point.y + numbers[j + 1],
                point.x + numbers[j + 2],
                point.y + numbers[j + 3]
              );
              control.x = point.x + numbers[j + 0];
              control.y = point.y + numbers[j + 1];
              point.x += numbers[j + 2];
              point.y += numbers[j + 3];
              if (j === 0 && doSetFirstPoint === true)
                firstPoint.copy(point);
            }
            break;
          case "t":
            numbers = parseFloats(data2);
            for (let j = 0, jl = numbers.length; j < jl; j += 2) {
              const rx = getReflection(point.x, control.x);
              const ry = getReflection(point.y, control.y);
              path.quadraticCurveTo(rx, ry, point.x + numbers[j + 0], point.y + numbers[j + 1]);
              control.x = rx;
              control.y = ry;
              point.x = point.x + numbers[j + 0];
              point.y = point.y + numbers[j + 1];
              if (j === 0 && doSetFirstPoint === true)
                firstPoint.copy(point);
            }
            break;
          case "a":
            numbers = parseFloats(data2, [3, 4], 7);
            for (let j = 0, jl = numbers.length; j < jl; j += 7) {
              if (numbers[j + 5] == 0 && numbers[j + 6] == 0)
                continue;
              const start = point.clone();
              point.x += numbers[j + 5];
              point.y += numbers[j + 6];
              control.x = point.x;
              control.y = point.y;
              parseArcCommand(
                path,
                numbers[j],
                numbers[j + 1],
                numbers[j + 2],
                numbers[j + 3],
                numbers[j + 4],
                start,
                point
              );
              if (j === 0 && doSetFirstPoint === true)
                firstPoint.copy(point);
            }
            break;
          case "Z":
          case "z":
            path.currentPath.autoClose = true;
            if (path.currentPath.curves.length > 0) {
              point.copy(firstPoint);
              path.currentPath.currentPoint.copy(point);
              isFirstPoint = true;
            }
            break;
          default:
            console.warn(command);
        }
        doSetFirstPoint = false;
      }
      return path;
    }
    function parseCSSStylesheet(node) {
      if (!node.sheet || !node.sheet.cssRules || !node.sheet.cssRules.length)
        return;
      for (let i3 = 0; i3 < node.sheet.cssRules.length; i3++) {
        const stylesheet = node.sheet.cssRules[i3];
        if (stylesheet.type !== 1)
          continue;
        const selectorList = stylesheet.selectorText.split(/,/gm).filter(Boolean).map((i22) => i22.trim());
        for (let j = 0; j < selectorList.length; j++) {
          stylesheets[selectorList[j]] = Object.assign(stylesheets[selectorList[j]] || {}, stylesheet.style);
        }
      }
    }
    function parseArcCommand(path, rx, ry, x_axis_rotation, large_arc_flag, sweep_flag, start, end) {
      if (rx == 0 || ry == 0) {
        path.lineTo(end.x, end.y);
        return;
      }
      x_axis_rotation = x_axis_rotation * Math.PI / 180;
      rx = Math.abs(rx);
      ry = Math.abs(ry);
      const dx2 = (start.x - end.x) / 2;
      const dy2 = (start.y - end.y) / 2;
      const x1p = Math.cos(x_axis_rotation) * dx2 + Math.sin(x_axis_rotation) * dy2;
      const y1p = -Math.sin(x_axis_rotation) * dx2 + Math.cos(x_axis_rotation) * dy2;
      let rxs = rx * rx;
      let rys = ry * ry;
      const x1ps = x1p * x1p;
      const y1ps = y1p * y1p;
      const cr = x1ps / rxs + y1ps / rys;
      if (cr > 1) {
        const s = Math.sqrt(cr);
        rx = s * rx;
        ry = s * ry;
        rxs = rx * rx;
        rys = ry * ry;
      }
      const dq = rxs * y1ps + rys * x1ps;
      const pq = (rxs * rys - dq) / dq;
      let q = Math.sqrt(Math.max(0, pq));
      if (large_arc_flag === sweep_flag)
        q = -q;
      const cxp = q * rx * y1p / ry;
      const cyp = -q * ry * x1p / rx;
      const cx = Math.cos(x_axis_rotation) * cxp - Math.sin(x_axis_rotation) * cyp + (start.x + end.x) / 2;
      const cy = Math.sin(x_axis_rotation) * cxp + Math.cos(x_axis_rotation) * cyp + (start.y + end.y) / 2;
      const theta = svgAngle(1, 0, (x1p - cxp) / rx, (y1p - cyp) / ry);
      const delta = svgAngle((x1p - cxp) / rx, (y1p - cyp) / ry, (-x1p - cxp) / rx, (-y1p - cyp) / ry) % (Math.PI * 2);
      path.currentPath.absellipse(cx, cy, rx, ry, theta, theta + delta, sweep_flag === 0, x_axis_rotation);
    }
    function svgAngle(ux, uy, vx, vy) {
      const dot = ux * vx + uy * vy;
      const len = Math.sqrt(ux * ux + uy * uy) * Math.sqrt(vx * vx + vy * vy);
      let ang = Math.acos(Math.max(-1, Math.min(1, dot / len)));
      if (ux * vy - uy * vx < 0)
        ang = -ang;
      return ang;
    }
    function parseRectNode(node) {
      const x = parseFloatWithUnits(node.getAttribute("x") || 0);
      const y = parseFloatWithUnits(node.getAttribute("y") || 0);
      const rx = parseFloatWithUnits(node.getAttribute("rx") || node.getAttribute("ry") || 0);
      const ry = parseFloatWithUnits(node.getAttribute("ry") || node.getAttribute("rx") || 0);
      const w = parseFloatWithUnits(node.getAttribute("width"));
      const h = parseFloatWithUnits(node.getAttribute("height"));
      const bci = 1 - 0.551915024494;
      const path = new ShapePath();
      path.moveTo(x + rx, y);
      path.lineTo(x + w - rx, y);
      if (rx !== 0 || ry !== 0) {
        path.bezierCurveTo(x + w - rx * bci, y, x + w, y + ry * bci, x + w, y + ry);
      }
      path.lineTo(x + w, y + h - ry);
      if (rx !== 0 || ry !== 0) {
        path.bezierCurveTo(x + w, y + h - ry * bci, x + w - rx * bci, y + h, x + w - rx, y + h);
      }
      path.lineTo(x + rx, y + h);
      if (rx !== 0 || ry !== 0) {
        path.bezierCurveTo(x + rx * bci, y + h, x, y + h - ry * bci, x, y + h - ry);
      }
      path.lineTo(x, y + ry);
      if (rx !== 0 || ry !== 0) {
        path.bezierCurveTo(x, y + ry * bci, x + rx * bci, y, x + rx, y);
      }
      return path;
    }
    function parsePolygonNode(node) {
      function iterator(match, a4, b5) {
        const x = parseFloatWithUnits(a4);
        const y = parseFloatWithUnits(b5);
        if (index === 0) {
          path.moveTo(x, y);
        } else {
          path.lineTo(x, y);
        }
        index++;
      }
      const regex = /(-?[\d\.?]+)[,|\s](-?[\d\.?]+)/g;
      const path = new ShapePath();
      let index = 0;
      node.getAttribute("points").replace(regex, iterator);
      path.currentPath.autoClose = true;
      return path;
    }
    function parsePolylineNode(node) {
      function iterator(match, a4, b5) {
        const x = parseFloatWithUnits(a4);
        const y = parseFloatWithUnits(b5);
        if (index === 0) {
          path.moveTo(x, y);
        } else {
          path.lineTo(x, y);
        }
        index++;
      }
      const regex = /(-?[\d\.?]+)[,|\s](-?[\d\.?]+)/g;
      const path = new ShapePath();
      let index = 0;
      node.getAttribute("points").replace(regex, iterator);
      path.currentPath.autoClose = false;
      return path;
    }
    function parseCircleNode(node) {
      const x = parseFloatWithUnits(node.getAttribute("cx") || 0);
      const y = parseFloatWithUnits(node.getAttribute("cy") || 0);
      const r = parseFloatWithUnits(node.getAttribute("r") || 0);
      const subpath = new Path();
      subpath.absarc(x, y, r, 0, Math.PI * 2);
      const path = new ShapePath();
      path.subPaths.push(subpath);
      return path;
    }
    function parseEllipseNode(node) {
      const x = parseFloatWithUnits(node.getAttribute("cx") || 0);
      const y = parseFloatWithUnits(node.getAttribute("cy") || 0);
      const rx = parseFloatWithUnits(node.getAttribute("rx") || 0);
      const ry = parseFloatWithUnits(node.getAttribute("ry") || 0);
      const subpath = new Path();
      subpath.absellipse(x, y, rx, ry, 0, Math.PI * 2);
      const path = new ShapePath();
      path.subPaths.push(subpath);
      return path;
    }
    function parseLineNode(node) {
      const x1 = parseFloatWithUnits(node.getAttribute("x1") || 0);
      const y1 = parseFloatWithUnits(node.getAttribute("y1") || 0);
      const x2 = parseFloatWithUnits(node.getAttribute("x2") || 0);
      const y2 = parseFloatWithUnits(node.getAttribute("y2") || 0);
      const path = new ShapePath();
      path.moveTo(x1, y1);
      path.lineTo(x2, y2);
      path.currentPath.autoClose = false;
      return path;
    }
    function parseStyle(node, style) {
      style = Object.assign({}, style);
      let stylesheetStyles = {};
      if (node.hasAttribute("class")) {
        const classSelectors = node.getAttribute("class").split(/\s/).filter(Boolean).map((i3) => i3.trim());
        for (let i3 = 0; i3 < classSelectors.length; i3++) {
          stylesheetStyles = Object.assign(stylesheetStyles, stylesheets["." + classSelectors[i3]]);
        }
      }
      if (node.hasAttribute("id")) {
        stylesheetStyles = Object.assign(stylesheetStyles, stylesheets["#" + node.getAttribute("id")]);
      }
      function addStyle(svgName, jsName, adjustFunction) {
        if (adjustFunction === void 0) {
          adjustFunction = function copy(v) {
            if (v.startsWith("url"))
              console.warn("SVGLoader: url access in attributes is not implemented.");
            return v;
          };
        }
        if (node.hasAttribute(svgName))
          style[jsName] = adjustFunction(node.getAttribute(svgName));
        if (stylesheetStyles[svgName])
          style[jsName] = adjustFunction(stylesheetStyles[svgName]);
        if (node.style && node.style[svgName] !== "")
          style[jsName] = adjustFunction(node.style[svgName]);
      }
      function clamp5(v) {
        return Math.max(0, Math.min(1, parseFloatWithUnits(v)));
      }
      function positive(v) {
        return Math.max(0, parseFloatWithUnits(v));
      }
      addStyle("fill", "fill");
      addStyle("fill-opacity", "fillOpacity", clamp5);
      addStyle("fill-rule", "fillRule");
      addStyle("opacity", "opacity", clamp5);
      addStyle("stroke", "stroke");
      addStyle("stroke-opacity", "strokeOpacity", clamp5);
      addStyle("stroke-width", "strokeWidth", positive);
      addStyle("stroke-linejoin", "strokeLineJoin");
      addStyle("stroke-linecap", "strokeLineCap");
      addStyle("stroke-miterlimit", "strokeMiterLimit", positive);
      addStyle("visibility", "visibility");
      return style;
    }
    function getReflection(a4, b5) {
      return a4 - (b5 - a4);
    }
    function parseFloats(input, flags, stride) {
      if (typeof input !== "string") {
        throw new TypeError("Invalid input: " + typeof input);
      }
      const RE = {
        SEPARATOR: /[ \t\r\n\,.\-+]/,
        WHITESPACE: /[ \t\r\n]/,
        DIGIT: /[\d]/,
        SIGN: /[-+]/,
        POINT: /\./,
        COMMA: /,/,
        EXP: /e/i,
        FLAGS: /[01]/
      };
      const SEP = 0;
      const INT = 1;
      const FLOAT = 2;
      const EXP = 3;
      let state = SEP;
      let seenComma = true;
      let number = "", exponent = "";
      const result = [];
      function throwSyntaxError(current2, i3, partial) {
        const error = new SyntaxError('Unexpected character "' + current2 + '" at index ' + i3 + ".");
        error.partial = partial;
        throw error;
      }
      function newNumber() {
        if (number !== "") {
          if (exponent === "")
            result.push(Number(number));
          else
            result.push(Number(number) * Math.pow(10, Number(exponent)));
        }
        number = "";
        exponent = "";
      }
      let current;
      const length = input.length;
      for (let i3 = 0; i3 < length; i3++) {
        current = input[i3];
        if (Array.isArray(flags) && flags.includes(result.length % stride) && RE.FLAGS.test(current)) {
          state = INT;
          number = current;
          newNumber();
          continue;
        }
        if (state === SEP) {
          if (RE.WHITESPACE.test(current)) {
            continue;
          }
          if (RE.DIGIT.test(current) || RE.SIGN.test(current)) {
            state = INT;
            number = current;
            continue;
          }
          if (RE.POINT.test(current)) {
            state = FLOAT;
            number = current;
            continue;
          }
          if (RE.COMMA.test(current)) {
            if (seenComma) {
              throwSyntaxError(current, i3, result);
            }
            seenComma = true;
          }
        }
        if (state === INT) {
          if (RE.DIGIT.test(current)) {
            number += current;
            continue;
          }
          if (RE.POINT.test(current)) {
            number += current;
            state = FLOAT;
            continue;
          }
          if (RE.EXP.test(current)) {
            state = EXP;
            continue;
          }
          if (RE.SIGN.test(current) && number.length === 1 && RE.SIGN.test(number[0])) {
            throwSyntaxError(current, i3, result);
          }
        }
        if (state === FLOAT) {
          if (RE.DIGIT.test(current)) {
            number += current;
            continue;
          }
          if (RE.EXP.test(current)) {
            state = EXP;
            continue;
          }
          if (RE.POINT.test(current) && number[number.length - 1] === ".") {
            throwSyntaxError(current, i3, result);
          }
        }
        if (state === EXP) {
          if (RE.DIGIT.test(current)) {
            exponent += current;
            continue;
          }
          if (RE.SIGN.test(current)) {
            if (exponent === "") {
              exponent += current;
              continue;
            }
            if (exponent.length === 1 && RE.SIGN.test(exponent)) {
              throwSyntaxError(current, i3, result);
            }
          }
        }
        if (RE.WHITESPACE.test(current)) {
          newNumber();
          state = SEP;
          seenComma = false;
        } else if (RE.COMMA.test(current)) {
          newNumber();
          state = SEP;
          seenComma = true;
        } else if (RE.SIGN.test(current)) {
          newNumber();
          state = INT;
          number = current;
        } else if (RE.POINT.test(current)) {
          newNumber();
          state = FLOAT;
          number = current;
        } else {
          throwSyntaxError(current, i3, result);
        }
      }
      newNumber();
      return result;
    }
    const units = ["mm", "cm", "in", "pt", "pc", "px"];
    const unitConversion = {
      mm: {
        mm: 1,
        cm: 0.1,
        in: 1 / 25.4,
        pt: 72 / 25.4,
        pc: 6 / 25.4,
        px: -1
      },
      cm: {
        mm: 10,
        cm: 1,
        in: 1 / 2.54,
        pt: 72 / 2.54,
        pc: 6 / 2.54,
        px: -1
      },
      in: {
        mm: 25.4,
        cm: 2.54,
        in: 1,
        pt: 72,
        pc: 6,
        px: -1
      },
      pt: {
        mm: 25.4 / 72,
        cm: 2.54 / 72,
        in: 1 / 72,
        pt: 1,
        pc: 6 / 72,
        px: -1
      },
      pc: {
        mm: 25.4 / 6,
        cm: 2.54 / 6,
        in: 1 / 6,
        pt: 72 / 6,
        pc: 1,
        px: -1
      },
      px: {
        px: 1
      }
    };
    function parseFloatWithUnits(string) {
      let theUnit = "px";
      if (typeof string === "string" || string instanceof String) {
        for (let i3 = 0, n = units.length; i3 < n; i3++) {
          const u = units[i3];
          if (string.endsWith(u)) {
            theUnit = u;
            string = string.substring(0, string.length - u.length);
            break;
          }
        }
      }
      let scale = void 0;
      if (theUnit === "px" && scope.defaultUnit !== "px") {
        scale = unitConversion["in"][scope.defaultUnit] / scope.defaultDPI;
      } else {
        scale = unitConversion[theUnit][scope.defaultUnit];
        if (scale < 0) {
          scale = unitConversion[theUnit]["in"] * scope.defaultDPI;
        }
      }
      return scale * parseFloat(string);
    }
    function getNodeTransform(node) {
      if (!(node.hasAttribute("transform") || node.nodeName === "use" && (node.hasAttribute("x") || node.hasAttribute("y")))) {
        return null;
      }
      const transform = parseNodeTransform(node);
      if (transformStack.length > 0) {
        transform.premultiply(transformStack[transformStack.length - 1]);
      }
      currentTransform.copy(transform);
      transformStack.push(transform);
      return transform;
    }
    function parseNodeTransform(node) {
      const transform = new Matrix3();
      const currentTransform2 = tempTransform0;
      if (node.nodeName === "use" && (node.hasAttribute("x") || node.hasAttribute("y"))) {
        const tx = parseFloatWithUnits(node.getAttribute("x"));
        const ty = parseFloatWithUnits(node.getAttribute("y"));
        transform.translate(tx, ty);
      }
      if (node.hasAttribute("transform")) {
        const transformsTexts = node.getAttribute("transform").split(")");
        for (let tIndex = transformsTexts.length - 1; tIndex >= 0; tIndex--) {
          const transformText = transformsTexts[tIndex].trim();
          if (transformText === "")
            continue;
          const openParPos = transformText.indexOf("(");
          const closeParPos = transformText.length;
          if (openParPos > 0 && openParPos < closeParPos) {
            const transformType = transformText.substr(0, openParPos);
            const array = parseFloats(transformText.substr(openParPos + 1, closeParPos - openParPos - 1));
            currentTransform2.identity();
            switch (transformType) {
              case "translate":
                if (array.length >= 1) {
                  const tx = array[0];
                  let ty = tx;
                  if (array.length >= 2) {
                    ty = array[1];
                  }
                  currentTransform2.translate(tx, ty);
                }
                break;
              case "rotate":
                if (array.length >= 1) {
                  let angle2 = 0;
                  let cx = 0;
                  let cy = 0;
                  angle2 = -array[0] * Math.PI / 180;
                  if (array.length >= 3) {
                    cx = array[1];
                    cy = array[2];
                  }
                  tempTransform1.identity().translate(-cx, -cy);
                  tempTransform2.identity().rotate(angle2);
                  tempTransform3.multiplyMatrices(tempTransform2, tempTransform1);
                  tempTransform1.identity().translate(cx, cy);
                  currentTransform2.multiplyMatrices(tempTransform1, tempTransform3);
                }
                break;
              case "scale":
                if (array.length >= 1) {
                  const scaleX = array[0];
                  let scaleY = scaleX;
                  if (array.length >= 2) {
                    scaleY = array[1];
                  }
                  currentTransform2.scale(scaleX, scaleY);
                }
                break;
              case "skewX":
                if (array.length === 1) {
                  currentTransform2.set(1, Math.tan(array[0] * Math.PI / 180), 0, 0, 1, 0, 0, 0, 1);
                }
                break;
              case "skewY":
                if (array.length === 1) {
                  currentTransform2.set(1, 0, 0, Math.tan(array[0] * Math.PI / 180), 1, 0, 0, 0, 1);
                }
                break;
              case "matrix":
                if (array.length === 6) {
                  currentTransform2.set(array[0], array[2], array[4], array[1], array[3], array[5], 0, 0, 1);
                }
                break;
            }
          }
          transform.premultiply(currentTransform2);
        }
      }
      return transform;
    }
    function transformPath(path, m) {
      function transfVec2(v23) {
        tempV3.set(v23.x, v23.y, 1).applyMatrix3(m);
        v23.set(tempV3.x, tempV3.y);
      }
      const isRotated = isTransformRotated(m);
      const subPaths = path.subPaths;
      for (let i3 = 0, n = subPaths.length; i3 < n; i3++) {
        const subPath = subPaths[i3];
        const curves = subPath.curves;
        for (let j = 0; j < curves.length; j++) {
          const curve = curves[j];
          if (curve.isLineCurve) {
            transfVec2(curve.v1);
            transfVec2(curve.v2);
          } else if (curve.isCubicBezierCurve) {
            transfVec2(curve.v0);
            transfVec2(curve.v1);
            transfVec2(curve.v2);
            transfVec2(curve.v3);
          } else if (curve.isQuadraticBezierCurve) {
            transfVec2(curve.v0);
            transfVec2(curve.v1);
            transfVec2(curve.v2);
          } else if (curve.isEllipseCurve) {
            if (isRotated) {
              console.warn("SVGLoader: Elliptic arc or ellipse rotation or skewing is not implemented.");
            }
            tempV2.set(curve.aX, curve.aY);
            transfVec2(tempV2);
            curve.aX = tempV2.x;
            curve.aY = tempV2.y;
            curve.xRadius *= getTransformScaleX(m);
            curve.yRadius *= getTransformScaleY(m);
          }
        }
      }
    }
    function isTransformRotated(m) {
      return m.elements[1] !== 0 || m.elements[3] !== 0;
    }
    function getTransformScaleX(m) {
      const te3 = m.elements;
      return Math.sqrt(te3[0] * te3[0] + te3[1] * te3[1]);
    }
    function getTransformScaleY(m) {
      const te3 = m.elements;
      return Math.sqrt(te3[3] * te3[3] + te3[4] * te3[4]);
    }
    const paths = [];
    const stylesheets = {};
    const transformStack = [];
    const tempTransform0 = new Matrix3();
    const tempTransform1 = new Matrix3();
    const tempTransform2 = new Matrix3();
    const tempTransform3 = new Matrix3();
    const tempV2 = new Vector2();
    const tempV3 = new Vector3();
    const currentTransform = new Matrix3();
    const xml = new DOMParser().parseFromString(text, "image/svg+xml");
    parseNode(xml.documentElement, {
      fill: "#000",
      fillOpacity: 1,
      strokeOpacity: 1,
      strokeWidth: 1,
      strokeLineJoin: "miter",
      strokeLineCap: "butt",
      strokeMiterLimit: 4
    });
    const data = { paths, xml: xml.documentElement };
    return data;
  }
  static createShapes(shapePath) {
    const BIGNUMBER = 999999999;
    const IntersectionLocationType = {
      ORIGIN: 0,
      DESTINATION: 1,
      BETWEEN: 2,
      LEFT: 3,
      RIGHT: 4,
      BEHIND: 5,
      BEYOND: 6
    };
    const classifyResult = {
      loc: IntersectionLocationType.ORIGIN,
      t: 0
    };
    function findEdgeIntersection(a0, a1, b0, b1) {
      const x1 = a0.x;
      const x2 = a1.x;
      const x3 = b0.x;
      const x4 = b1.x;
      const y1 = a0.y;
      const y2 = a1.y;
      const y3 = b0.y;
      const y4 = b1.y;
      const nom1 = (x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3);
      const nom2 = (x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3);
      const denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
      const t1 = nom1 / denom;
      const t2 = nom2 / denom;
      if (denom === 0 && nom1 !== 0 || t1 <= 0 || t1 >= 1 || t2 < 0 || t2 > 1) {
        return null;
      } else if (nom1 === 0 && denom === 0) {
        for (let i3 = 0; i3 < 2; i3++) {
          classifyPoint(i3 === 0 ? b0 : b1, a0, a1);
          if (classifyResult.loc == IntersectionLocationType.ORIGIN) {
            const point = i3 === 0 ? b0 : b1;
            return { x: point.x, y: point.y, t: classifyResult.t };
          } else if (classifyResult.loc == IntersectionLocationType.BETWEEN) {
            const x = +(x1 + classifyResult.t * (x2 - x1)).toPrecision(10);
            const y = +(y1 + classifyResult.t * (y2 - y1)).toPrecision(10);
            return { x, y, t: classifyResult.t };
          }
        }
        return null;
      } else {
        for (let i3 = 0; i3 < 2; i3++) {
          classifyPoint(i3 === 0 ? b0 : b1, a0, a1);
          if (classifyResult.loc == IntersectionLocationType.ORIGIN) {
            const point = i3 === 0 ? b0 : b1;
            return { x: point.x, y: point.y, t: classifyResult.t };
          }
        }
        const x = +(x1 + t1 * (x2 - x1)).toPrecision(10);
        const y = +(y1 + t1 * (y2 - y1)).toPrecision(10);
        return { x, y, t: t1 };
      }
    }
    function classifyPoint(p, edgeStart, edgeEnd) {
      const ax = edgeEnd.x - edgeStart.x;
      const ay = edgeEnd.y - edgeStart.y;
      const bx = p.x - edgeStart.x;
      const by = p.y - edgeStart.y;
      const sa = ax * by - bx * ay;
      if (p.x === edgeStart.x && p.y === edgeStart.y) {
        classifyResult.loc = IntersectionLocationType.ORIGIN;
        classifyResult.t = 0;
        return;
      }
      if (p.x === edgeEnd.x && p.y === edgeEnd.y) {
        classifyResult.loc = IntersectionLocationType.DESTINATION;
        classifyResult.t = 1;
        return;
      }
      if (sa < -Number.EPSILON) {
        classifyResult.loc = IntersectionLocationType.LEFT;
        return;
      }
      if (sa > Number.EPSILON) {
        classifyResult.loc = IntersectionLocationType.RIGHT;
        return;
      }
      if (ax * bx < 0 || ay * by < 0) {
        classifyResult.loc = IntersectionLocationType.BEHIND;
        return;
      }
      if (Math.sqrt(ax * ax + ay * ay) < Math.sqrt(bx * bx + by * by)) {
        classifyResult.loc = IntersectionLocationType.BEYOND;
        return;
      }
      let t2;
      if (ax !== 0) {
        t2 = bx / ax;
      } else {
        t2 = by / ay;
      }
      classifyResult.loc = IntersectionLocationType.BETWEEN;
      classifyResult.t = t2;
    }
    function getIntersections(path1, path2) {
      const intersectionsRaw = [];
      const intersections = [];
      for (let index = 1; index < path1.length; index++) {
        const path1EdgeStart = path1[index - 1];
        const path1EdgeEnd = path1[index];
        for (let index2 = 1; index2 < path2.length; index2++) {
          const path2EdgeStart = path2[index2 - 1];
          const path2EdgeEnd = path2[index2];
          const intersection = findEdgeIntersection(path1EdgeStart, path1EdgeEnd, path2EdgeStart, path2EdgeEnd);
          if (intersection !== null && intersectionsRaw.find(
            (i3) => i3.t <= intersection.t + Number.EPSILON && i3.t >= intersection.t - Number.EPSILON
          ) === void 0) {
            intersectionsRaw.push(intersection);
            intersections.push(new Vector2(intersection.x, intersection.y));
          }
        }
      }
      return intersections;
    }
    function getScanlineIntersections(scanline, boundingBox, paths) {
      const center2 = new Vector2();
      boundingBox.getCenter(center2);
      const allIntersections = [];
      paths.forEach((path) => {
        if (path.boundingBox.containsPoint(center2)) {
          const intersections = getIntersections(scanline, path.points);
          intersections.forEach((p) => {
            allIntersections.push({ identifier: path.identifier, isCW: path.isCW, point: p });
          });
        }
      });
      allIntersections.sort((i1, i22) => {
        return i1.point.x - i22.point.x;
      });
      return allIntersections;
    }
    function isHoleTo(simplePath, allPaths, scanlineMinX2, scanlineMaxX2, _fillRule) {
      if (_fillRule === null || _fillRule === void 0 || _fillRule === "") {
        _fillRule = "nonzero";
      }
      const centerBoundingBox = new Vector2();
      simplePath.boundingBox.getCenter(centerBoundingBox);
      const scanline = [new Vector2(scanlineMinX2, centerBoundingBox.y), new Vector2(scanlineMaxX2, centerBoundingBox.y)];
      const scanlineIntersections = getScanlineIntersections(scanline, simplePath.boundingBox, allPaths);
      scanlineIntersections.sort((i1, i22) => {
        return i1.point.x - i22.point.x;
      });
      const baseIntersections = [];
      const otherIntersections = [];
      scanlineIntersections.forEach((i22) => {
        if (i22.identifier === simplePath.identifier) {
          baseIntersections.push(i22);
        } else {
          otherIntersections.push(i22);
        }
      });
      const firstXOfPath = baseIntersections[0].point.x;
      const stack = [];
      let i3 = 0;
      while (i3 < otherIntersections.length && otherIntersections[i3].point.x < firstXOfPath) {
        if (stack.length > 0 && stack[stack.length - 1] === otherIntersections[i3].identifier) {
          stack.pop();
        } else {
          stack.push(otherIntersections[i3].identifier);
        }
        i3++;
      }
      stack.push(simplePath.identifier);
      if (_fillRule === "evenodd") {
        const isHole = stack.length % 2 === 0 ? true : false;
        const isHoleFor = stack[stack.length - 2];
        return { identifier: simplePath.identifier, isHole, for: isHoleFor };
      } else if (_fillRule === "nonzero") {
        let isHole = true;
        let isHoleFor = null;
        let lastCWValue = null;
        for (let i22 = 0; i22 < stack.length; i22++) {
          const identifier2 = stack[i22];
          if (isHole) {
            lastCWValue = allPaths[identifier2].isCW;
            isHole = false;
            isHoleFor = identifier2;
          } else if (lastCWValue !== allPaths[identifier2].isCW) {
            lastCWValue = allPaths[identifier2].isCW;
            isHole = true;
          }
        }
        return { identifier: simplePath.identifier, isHole, for: isHoleFor };
      } else {
        console.warn('fill-rule: "' + _fillRule + '" is currently not implemented.');
      }
    }
    let identifier = 0;
    let scanlineMinX = BIGNUMBER;
    let scanlineMaxX = -BIGNUMBER;
    let simplePaths = shapePath.subPaths.map((p) => {
      const points = p.getPoints();
      let maxY = -BIGNUMBER;
      let minY = BIGNUMBER;
      let maxX = -BIGNUMBER;
      let minX = BIGNUMBER;
      for (let i3 = 0; i3 < points.length; i3++) {
        const p2 = points[i3];
        if (p2.y > maxY) {
          maxY = p2.y;
        }
        if (p2.y < minY) {
          minY = p2.y;
        }
        if (p2.x > maxX) {
          maxX = p2.x;
        }
        if (p2.x < minX) {
          minX = p2.x;
        }
      }
      if (scanlineMaxX <= maxX) {
        scanlineMaxX = maxX + 1;
      }
      if (scanlineMinX >= minX) {
        scanlineMinX = minX - 1;
      }
      return {
        curves: p.curves,
        points,
        isCW: ShapeUtils.isClockWise(points),
        identifier: identifier++,
        boundingBox: new Box2(new Vector2(minX, minY), new Vector2(maxX, maxY))
      };
    });
    simplePaths = simplePaths.filter((sp) => sp.points.length > 1);
    const isAHole = simplePaths.map(
      (p) => isHoleTo(p, simplePaths, scanlineMinX, scanlineMaxX, shapePath.userData.style.fillRule)
    );
    const shapesToReturn = [];
    simplePaths.forEach((p) => {
      const amIAHole = isAHole[p.identifier];
      if (!amIAHole.isHole) {
        const shape = new Shape();
        shape.curves = p.curves;
        const holes = isAHole.filter((h) => h.isHole && h.for === p.identifier);
        holes.forEach((h) => {
          const hole = simplePaths[h.identifier];
          const path = new Path();
          path.curves = hole.curves;
          shape.holes.push(path);
        });
        shapesToReturn.push(shape);
      }
    });
    return shapesToReturn;
  }
  static getStrokeStyle(width, color, lineJoin, lineCap, miterLimit) {
    width = width !== void 0 ? width : 1;
    color = color !== void 0 ? color : "#000";
    lineJoin = lineJoin !== void 0 ? lineJoin : "miter";
    lineCap = lineCap !== void 0 ? lineCap : "butt";
    miterLimit = miterLimit !== void 0 ? miterLimit : 4;
    return {
      strokeColor: color,
      strokeWidth: width,
      strokeLineJoin: lineJoin,
      strokeLineCap: lineCap,
      strokeMiterLimit: miterLimit
    };
  }
  static pointsToStroke(points, style, arcDivisions, minDistance) {
    const vertices = [];
    const normals = [];
    const uvs = [];
    if (SVGLoader.pointsToStrokeWithBuffers(points, style, arcDivisions, minDistance, vertices, normals, uvs) === 0) {
      return null;
    }
    const geometry2 = new BufferGeometry();
    geometry2.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    geometry2.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    geometry2.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
    return geometry2;
  }
  static pointsToStrokeWithBuffers(points, style, arcDivisions, minDistance, vertices, normals, uvs, vertexOffset) {
    const tempV2_1 = new Vector2();
    const tempV2_2 = new Vector2();
    const tempV2_3 = new Vector2();
    const tempV2_4 = new Vector2();
    const tempV2_5 = new Vector2();
    const tempV2_6 = new Vector2();
    const tempV2_7 = new Vector2();
    const lastPointL = new Vector2();
    const lastPointR = new Vector2();
    const point0L = new Vector2();
    const point0R = new Vector2();
    const currentPointL = new Vector2();
    const currentPointR = new Vector2();
    const nextPointL = new Vector2();
    const nextPointR = new Vector2();
    const innerPoint = new Vector2();
    const outerPoint = new Vector2();
    arcDivisions = arcDivisions !== void 0 ? arcDivisions : 12;
    minDistance = minDistance !== void 0 ? minDistance : 1e-3;
    vertexOffset = vertexOffset !== void 0 ? vertexOffset : 0;
    points = removeDuplicatedPoints(points);
    const numPoints = points.length;
    if (numPoints < 2)
      return 0;
    const isClosed = points[0].equals(points[numPoints - 1]);
    let currentPoint;
    let previousPoint = points[0];
    let nextPoint;
    const strokeWidth2 = style.strokeWidth / 2;
    const deltaU = 1 / (numPoints - 1);
    let u0 = 0, u1;
    let innerSideModified;
    let joinIsOnLeftSide;
    let isMiter;
    let initialJoinIsOnLeftSide = false;
    let numVertices = 0;
    let currentCoordinate = vertexOffset * 3;
    let currentCoordinateUV = vertexOffset * 2;
    getNormal(points[0], points[1], tempV2_1).multiplyScalar(strokeWidth2);
    lastPointL.copy(points[0]).sub(tempV2_1);
    lastPointR.copy(points[0]).add(tempV2_1);
    point0L.copy(lastPointL);
    point0R.copy(lastPointR);
    for (let iPoint = 1; iPoint < numPoints; iPoint++) {
      currentPoint = points[iPoint];
      if (iPoint === numPoints - 1) {
        if (isClosed) {
          nextPoint = points[1];
        } else {
          nextPoint = void 0;
        }
      } else {
        nextPoint = points[iPoint + 1];
      }
      const normal1 = tempV2_1;
      getNormal(previousPoint, currentPoint, normal1);
      tempV2_3.copy(normal1).multiplyScalar(strokeWidth2);
      currentPointL.copy(currentPoint).sub(tempV2_3);
      currentPointR.copy(currentPoint).add(tempV2_3);
      u1 = u0 + deltaU;
      innerSideModified = false;
      if (nextPoint !== void 0) {
        getNormal(currentPoint, nextPoint, tempV2_2);
        tempV2_3.copy(tempV2_2).multiplyScalar(strokeWidth2);
        nextPointL.copy(currentPoint).sub(tempV2_3);
        nextPointR.copy(currentPoint).add(tempV2_3);
        joinIsOnLeftSide = true;
        tempV2_3.subVectors(nextPoint, previousPoint);
        if (normal1.dot(tempV2_3) < 0) {
          joinIsOnLeftSide = false;
        }
        if (iPoint === 1)
          initialJoinIsOnLeftSide = joinIsOnLeftSide;
        tempV2_3.subVectors(nextPoint, currentPoint);
        tempV2_3.normalize();
        const dot = Math.abs(normal1.dot(tempV2_3));
        if (dot !== 0) {
          const miterSide = strokeWidth2 / dot;
          tempV2_3.multiplyScalar(-miterSide);
          tempV2_4.subVectors(currentPoint, previousPoint);
          tempV2_5.copy(tempV2_4).setLength(miterSide).add(tempV2_3);
          innerPoint.copy(tempV2_5).negate();
          const miterLength2 = tempV2_5.length();
          const segmentLengthPrev = tempV2_4.length();
          tempV2_4.divideScalar(segmentLengthPrev);
          tempV2_6.subVectors(nextPoint, currentPoint);
          const segmentLengthNext = tempV2_6.length();
          tempV2_6.divideScalar(segmentLengthNext);
          if (tempV2_4.dot(innerPoint) < segmentLengthPrev && tempV2_6.dot(innerPoint) < segmentLengthNext) {
            innerSideModified = true;
          }
          outerPoint.copy(tempV2_5).add(currentPoint);
          innerPoint.add(currentPoint);
          isMiter = false;
          if (innerSideModified) {
            if (joinIsOnLeftSide) {
              nextPointR.copy(innerPoint);
              currentPointR.copy(innerPoint);
            } else {
              nextPointL.copy(innerPoint);
              currentPointL.copy(innerPoint);
            }
          } else {
            makeSegmentTriangles();
          }
          switch (style.strokeLineJoin) {
            case "bevel":
              makeSegmentWithBevelJoin(joinIsOnLeftSide, innerSideModified, u1);
              break;
            case "round":
              createSegmentTrianglesWithMiddleSection(joinIsOnLeftSide, innerSideModified);
              if (joinIsOnLeftSide) {
                makeCircularSector(currentPoint, currentPointL, nextPointL, u1, 0);
              } else {
                makeCircularSector(currentPoint, nextPointR, currentPointR, u1, 1);
              }
              break;
            case "miter":
            case "miter-clip":
            default:
              const miterFraction = strokeWidth2 * style.strokeMiterLimit / miterLength2;
              if (miterFraction < 1) {
                if (style.strokeLineJoin !== "miter-clip") {
                  makeSegmentWithBevelJoin(joinIsOnLeftSide, innerSideModified, u1);
                  break;
                } else {
                  createSegmentTrianglesWithMiddleSection(joinIsOnLeftSide, innerSideModified);
                  if (joinIsOnLeftSide) {
                    tempV2_6.subVectors(outerPoint, currentPointL).multiplyScalar(miterFraction).add(currentPointL);
                    tempV2_7.subVectors(outerPoint, nextPointL).multiplyScalar(miterFraction).add(nextPointL);
                    addVertex(currentPointL, u1, 0);
                    addVertex(tempV2_6, u1, 0);
                    addVertex(currentPoint, u1, 0.5);
                    addVertex(currentPoint, u1, 0.5);
                    addVertex(tempV2_6, u1, 0);
                    addVertex(tempV2_7, u1, 0);
                    addVertex(currentPoint, u1, 0.5);
                    addVertex(tempV2_7, u1, 0);
                    addVertex(nextPointL, u1, 0);
                  } else {
                    tempV2_6.subVectors(outerPoint, currentPointR).multiplyScalar(miterFraction).add(currentPointR);
                    tempV2_7.subVectors(outerPoint, nextPointR).multiplyScalar(miterFraction).add(nextPointR);
                    addVertex(currentPointR, u1, 1);
                    addVertex(tempV2_6, u1, 1);
                    addVertex(currentPoint, u1, 0.5);
                    addVertex(currentPoint, u1, 0.5);
                    addVertex(tempV2_6, u1, 1);
                    addVertex(tempV2_7, u1, 1);
                    addVertex(currentPoint, u1, 0.5);
                    addVertex(tempV2_7, u1, 1);
                    addVertex(nextPointR, u1, 1);
                  }
                }
              } else {
                if (innerSideModified) {
                  if (joinIsOnLeftSide) {
                    addVertex(lastPointR, u0, 1);
                    addVertex(lastPointL, u0, 0);
                    addVertex(outerPoint, u1, 0);
                    addVertex(lastPointR, u0, 1);
                    addVertex(outerPoint, u1, 0);
                    addVertex(innerPoint, u1, 1);
                  } else {
                    addVertex(lastPointR, u0, 1);
                    addVertex(lastPointL, u0, 0);
                    addVertex(outerPoint, u1, 1);
                    addVertex(lastPointL, u0, 0);
                    addVertex(innerPoint, u1, 0);
                    addVertex(outerPoint, u1, 1);
                  }
                  if (joinIsOnLeftSide) {
                    nextPointL.copy(outerPoint);
                  } else {
                    nextPointR.copy(outerPoint);
                  }
                } else {
                  if (joinIsOnLeftSide) {
                    addVertex(currentPointL, u1, 0);
                    addVertex(outerPoint, u1, 0);
                    addVertex(currentPoint, u1, 0.5);
                    addVertex(currentPoint, u1, 0.5);
                    addVertex(outerPoint, u1, 0);
                    addVertex(nextPointL, u1, 0);
                  } else {
                    addVertex(currentPointR, u1, 1);
                    addVertex(outerPoint, u1, 1);
                    addVertex(currentPoint, u1, 0.5);
                    addVertex(currentPoint, u1, 0.5);
                    addVertex(outerPoint, u1, 1);
                    addVertex(nextPointR, u1, 1);
                  }
                }
                isMiter = true;
              }
              break;
          }
        } else {
          makeSegmentTriangles();
        }
      } else {
        makeSegmentTriangles();
      }
      if (!isClosed && iPoint === numPoints - 1) {
        addCapGeometry(points[0], point0L, point0R, joinIsOnLeftSide, true, u0);
      }
      u0 = u1;
      previousPoint = currentPoint;
      lastPointL.copy(nextPointL);
      lastPointR.copy(nextPointR);
    }
    if (!isClosed) {
      addCapGeometry(currentPoint, currentPointL, currentPointR, joinIsOnLeftSide, false, u1);
    } else if (innerSideModified && vertices) {
      let lastOuter = outerPoint;
      let lastInner = innerPoint;
      if (initialJoinIsOnLeftSide !== joinIsOnLeftSide) {
        lastOuter = innerPoint;
        lastInner = outerPoint;
      }
      if (joinIsOnLeftSide) {
        if (isMiter || initialJoinIsOnLeftSide) {
          lastInner.toArray(vertices, 0 * 3);
          lastInner.toArray(vertices, 3 * 3);
          if (isMiter) {
            lastOuter.toArray(vertices, 1 * 3);
          }
        }
      } else {
        if (isMiter || !initialJoinIsOnLeftSide) {
          lastInner.toArray(vertices, 1 * 3);
          lastInner.toArray(vertices, 3 * 3);
          if (isMiter) {
            lastOuter.toArray(vertices, 0 * 3);
          }
        }
      }
    }
    return numVertices;
    function getNormal(p1, p2, result) {
      result.subVectors(p2, p1);
      return result.set(-result.y, result.x).normalize();
    }
    function addVertex(position, u, v) {
      if (vertices) {
        vertices[currentCoordinate] = position.x;
        vertices[currentCoordinate + 1] = position.y;
        vertices[currentCoordinate + 2] = 0;
        if (normals) {
          normals[currentCoordinate] = 0;
          normals[currentCoordinate + 1] = 0;
          normals[currentCoordinate + 2] = 1;
        }
        currentCoordinate += 3;
        if (uvs) {
          uvs[currentCoordinateUV] = u;
          uvs[currentCoordinateUV + 1] = v;
          currentCoordinateUV += 2;
        }
      }
      numVertices += 3;
    }
    function makeCircularSector(center2, p1, p2, u, v) {
      tempV2_1.copy(p1).sub(center2).normalize();
      tempV2_2.copy(p2).sub(center2).normalize();
      let angle2 = Math.PI;
      const dot = tempV2_1.dot(tempV2_2);
      if (Math.abs(dot) < 1)
        angle2 = Math.abs(Math.acos(dot));
      angle2 /= arcDivisions;
      tempV2_3.copy(p1);
      for (let i3 = 0, il = arcDivisions - 1; i3 < il; i3++) {
        tempV2_4.copy(tempV2_3).rotateAround(center2, angle2);
        addVertex(tempV2_3, u, v);
        addVertex(tempV2_4, u, v);
        addVertex(center2, u, 0.5);
        tempV2_3.copy(tempV2_4);
      }
      addVertex(tempV2_4, u, v);
      addVertex(p2, u, v);
      addVertex(center2, u, 0.5);
    }
    function makeSegmentTriangles() {
      addVertex(lastPointR, u0, 1);
      addVertex(lastPointL, u0, 0);
      addVertex(currentPointL, u1, 0);
      addVertex(lastPointR, u0, 1);
      addVertex(currentPointL, u1, 1);
      addVertex(currentPointR, u1, 0);
    }
    function makeSegmentWithBevelJoin(joinIsOnLeftSide2, innerSideModified2, u) {
      if (innerSideModified2) {
        if (joinIsOnLeftSide2) {
          addVertex(lastPointR, u0, 1);
          addVertex(lastPointL, u0, 0);
          addVertex(currentPointL, u1, 0);
          addVertex(lastPointR, u0, 1);
          addVertex(currentPointL, u1, 0);
          addVertex(innerPoint, u1, 1);
          addVertex(currentPointL, u, 0);
          addVertex(nextPointL, u, 0);
          addVertex(innerPoint, u, 0.5);
        } else {
          addVertex(lastPointR, u0, 1);
          addVertex(lastPointL, u0, 0);
          addVertex(currentPointR, u1, 1);
          addVertex(lastPointL, u0, 0);
          addVertex(innerPoint, u1, 0);
          addVertex(currentPointR, u1, 1);
          addVertex(currentPointR, u, 1);
          addVertex(nextPointR, u, 0);
          addVertex(innerPoint, u, 0.5);
        }
      } else {
        if (joinIsOnLeftSide2) {
          addVertex(currentPointL, u, 0);
          addVertex(nextPointL, u, 0);
          addVertex(currentPoint, u, 0.5);
        } else {
          addVertex(currentPointR, u, 1);
          addVertex(nextPointR, u, 0);
          addVertex(currentPoint, u, 0.5);
        }
      }
    }
    function createSegmentTrianglesWithMiddleSection(joinIsOnLeftSide2, innerSideModified2) {
      if (innerSideModified2) {
        if (joinIsOnLeftSide2) {
          addVertex(lastPointR, u0, 1);
          addVertex(lastPointL, u0, 0);
          addVertex(currentPointL, u1, 0);
          addVertex(lastPointR, u0, 1);
          addVertex(currentPointL, u1, 0);
          addVertex(innerPoint, u1, 1);
          addVertex(currentPointL, u0, 0);
          addVertex(currentPoint, u1, 0.5);
          addVertex(innerPoint, u1, 1);
          addVertex(currentPoint, u1, 0.5);
          addVertex(nextPointL, u0, 0);
          addVertex(innerPoint, u1, 1);
        } else {
          addVertex(lastPointR, u0, 1);
          addVertex(lastPointL, u0, 0);
          addVertex(currentPointR, u1, 1);
          addVertex(lastPointL, u0, 0);
          addVertex(innerPoint, u1, 0);
          addVertex(currentPointR, u1, 1);
          addVertex(currentPointR, u0, 1);
          addVertex(innerPoint, u1, 0);
          addVertex(currentPoint, u1, 0.5);
          addVertex(currentPoint, u1, 0.5);
          addVertex(innerPoint, u1, 0);
          addVertex(nextPointR, u0, 1);
        }
      }
    }
    function addCapGeometry(center2, p1, p2, joinIsOnLeftSide2, start, u) {
      switch (style.strokeLineCap) {
        case "round":
          if (start) {
            makeCircularSector(center2, p2, p1, u, 0.5);
          } else {
            makeCircularSector(center2, p1, p2, u, 0.5);
          }
          break;
        case "square":
          if (start) {
            tempV2_1.subVectors(p1, center2);
            tempV2_2.set(tempV2_1.y, -tempV2_1.x);
            tempV2_3.addVectors(tempV2_1, tempV2_2).add(center2);
            tempV2_4.subVectors(tempV2_2, tempV2_1).add(center2);
            if (joinIsOnLeftSide2) {
              tempV2_3.toArray(vertices, 1 * 3);
              tempV2_4.toArray(vertices, 0 * 3);
              tempV2_4.toArray(vertices, 3 * 3);
            } else {
              tempV2_3.toArray(vertices, 1 * 3);
              tempV2_3.toArray(vertices, 3 * 3);
              tempV2_4.toArray(vertices, 0 * 3);
            }
          } else {
            tempV2_1.subVectors(p2, center2);
            tempV2_2.set(tempV2_1.y, -tempV2_1.x);
            tempV2_3.addVectors(tempV2_1, tempV2_2).add(center2);
            tempV2_4.subVectors(tempV2_2, tempV2_1).add(center2);
            const vl = vertices.length;
            if (joinIsOnLeftSide2) {
              tempV2_3.toArray(vertices, vl - 1 * 3);
              tempV2_4.toArray(vertices, vl - 2 * 3);
              tempV2_4.toArray(vertices, vl - 4 * 3);
            } else {
              tempV2_3.toArray(vertices, vl - 2 * 3);
              tempV2_4.toArray(vertices, vl - 1 * 3);
              tempV2_4.toArray(vertices, vl - 4 * 3);
            }
          }
          break;
        case "butt":
        default:
          break;
      }
    }
    function removeDuplicatedPoints(points2) {
      let dupPoints = false;
      for (let i3 = 1, n = points2.length - 1; i3 < n; i3++) {
        if (points2[i3].distanceTo(points2[i3 + 1]) < minDistance) {
          dupPoints = true;
          break;
        }
      }
      if (!dupPoints)
        return points2;
      const newPoints = [];
      newPoints.push(points2[0]);
      for (let i3 = 1, n = points2.length - 1; i3 < n; i3++) {
        if (points2[i3].distanceTo(points2[i3 + 1]) >= minDistance) {
          newPoints.push(points2[i3]);
        }
      }
      newPoints.push(points2[points2.length - 1]);
      return newPoints;
    }
  }
};

// node_modules/three-stdlib/loaders/OBJLoader.js
var _object_pattern = /^[og]\s*(.+)?/;
var _material_library_pattern = /^mtllib /;
var _material_use_pattern = /^usemtl /;
var _map_use_pattern = /^usemap /;
var _vA = new Vector3();
var _vB = new Vector3();
var _vC = new Vector3();
var _ab = new Vector3();
var _cb = new Vector3();
function ParserState() {
  const state = {
    objects: [],
    object: {},
    vertices: [],
    normals: [],
    colors: [],
    uvs: [],
    materials: {},
    materialLibraries: [],
    startObject: function(name, fromDeclaration) {
      if (this.object && this.object.fromDeclaration === false) {
        this.object.name = name;
        this.object.fromDeclaration = fromDeclaration !== false;
        return;
      }
      const previousMaterial = this.object && typeof this.object.currentMaterial === "function" ? this.object.currentMaterial() : void 0;
      if (this.object && typeof this.object._finalize === "function") {
        this.object._finalize(true);
      }
      this.object = {
        name: name || "",
        fromDeclaration: fromDeclaration !== false,
        geometry: {
          vertices: [],
          normals: [],
          colors: [],
          uvs: [],
          hasUVIndices: false
        },
        materials: [],
        smooth: true,
        startMaterial: function(name2, libraries) {
          const previous = this._finalize(false);
          if (previous && (previous.inherited || previous.groupCount <= 0)) {
            this.materials.splice(previous.index, 1);
          }
          const material2 = {
            index: this.materials.length,
            name: name2 || "",
            mtllib: Array.isArray(libraries) && libraries.length > 0 ? libraries[libraries.length - 1] : "",
            smooth: previous !== void 0 ? previous.smooth : this.smooth,
            groupStart: previous !== void 0 ? previous.groupEnd : 0,
            groupEnd: -1,
            groupCount: -1,
            inherited: false,
            clone: function(index) {
              const cloned = {
                index: typeof index === "number" ? index : this.index,
                name: this.name,
                mtllib: this.mtllib,
                smooth: this.smooth,
                groupStart: 0,
                groupEnd: -1,
                groupCount: -1,
                inherited: false
              };
              cloned.clone = this.clone.bind(cloned);
              return cloned;
            }
          };
          this.materials.push(material2);
          return material2;
        },
        currentMaterial: function() {
          if (this.materials.length > 0) {
            return this.materials[this.materials.length - 1];
          }
          return void 0;
        },
        _finalize: function(end) {
          const lastMultiMaterial = this.currentMaterial();
          if (lastMultiMaterial && lastMultiMaterial.groupEnd === -1) {
            lastMultiMaterial.groupEnd = this.geometry.vertices.length / 3;
            lastMultiMaterial.groupCount = lastMultiMaterial.groupEnd - lastMultiMaterial.groupStart;
            lastMultiMaterial.inherited = false;
          }
          if (end && this.materials.length > 1) {
            for (let mi = this.materials.length - 1; mi >= 0; mi--) {
              if (this.materials[mi].groupCount <= 0) {
                this.materials.splice(mi, 1);
              }
            }
          }
          if (end && this.materials.length === 0) {
            this.materials.push({
              name: "",
              smooth: this.smooth
            });
          }
          return lastMultiMaterial;
        }
      };
      if (previousMaterial && previousMaterial.name && typeof previousMaterial.clone === "function") {
        const declared = previousMaterial.clone(0);
        declared.inherited = true;
        this.object.materials.push(declared);
      }
      this.objects.push(this.object);
    },
    finalize: function() {
      if (this.object && typeof this.object._finalize === "function") {
        this.object._finalize(true);
      }
    },
    parseVertexIndex: function(value, len) {
      const index = parseInt(value, 10);
      return (index >= 0 ? index - 1 : index + len / 3) * 3;
    },
    parseNormalIndex: function(value, len) {
      const index = parseInt(value, 10);
      return (index >= 0 ? index - 1 : index + len / 3) * 3;
    },
    parseUVIndex: function(value, len) {
      const index = parseInt(value, 10);
      return (index >= 0 ? index - 1 : index + len / 2) * 2;
    },
    addVertex: function(a4, b5, c3) {
      const src = this.vertices;
      const dst = this.object.geometry.vertices;
      dst.push(src[a4 + 0], src[a4 + 1], src[a4 + 2]);
      dst.push(src[b5 + 0], src[b5 + 1], src[b5 + 2]);
      dst.push(src[c3 + 0], src[c3 + 1], src[c3 + 2]);
    },
    addVertexPoint: function(a4) {
      const src = this.vertices;
      const dst = this.object.geometry.vertices;
      dst.push(src[a4 + 0], src[a4 + 1], src[a4 + 2]);
    },
    addVertexLine: function(a4) {
      const src = this.vertices;
      const dst = this.object.geometry.vertices;
      dst.push(src[a4 + 0], src[a4 + 1], src[a4 + 2]);
    },
    addNormal: function(a4, b5, c3) {
      const src = this.normals;
      const dst = this.object.geometry.normals;
      dst.push(src[a4 + 0], src[a4 + 1], src[a4 + 2]);
      dst.push(src[b5 + 0], src[b5 + 1], src[b5 + 2]);
      dst.push(src[c3 + 0], src[c3 + 1], src[c3 + 2]);
    },
    addFaceNormal: function(a4, b5, c3) {
      const src = this.vertices;
      const dst = this.object.geometry.normals;
      _vA.fromArray(src, a4);
      _vB.fromArray(src, b5);
      _vC.fromArray(src, c3);
      _cb.subVectors(_vC, _vB);
      _ab.subVectors(_vA, _vB);
      _cb.cross(_ab);
      _cb.normalize();
      dst.push(_cb.x, _cb.y, _cb.z);
      dst.push(_cb.x, _cb.y, _cb.z);
      dst.push(_cb.x, _cb.y, _cb.z);
    },
    addColor: function(a4, b5, c3) {
      const src = this.colors;
      const dst = this.object.geometry.colors;
      if (src[a4] !== void 0)
        dst.push(src[a4 + 0], src[a4 + 1], src[a4 + 2]);
      if (src[b5] !== void 0)
        dst.push(src[b5 + 0], src[b5 + 1], src[b5 + 2]);
      if (src[c3] !== void 0)
        dst.push(src[c3 + 0], src[c3 + 1], src[c3 + 2]);
    },
    addUV: function(a4, b5, c3) {
      const src = this.uvs;
      const dst = this.object.geometry.uvs;
      dst.push(src[a4 + 0], src[a4 + 1]);
      dst.push(src[b5 + 0], src[b5 + 1]);
      dst.push(src[c3 + 0], src[c3 + 1]);
    },
    addDefaultUV: function() {
      const dst = this.object.geometry.uvs;
      dst.push(0, 0);
      dst.push(0, 0);
      dst.push(0, 0);
    },
    addUVLine: function(a4) {
      const src = this.uvs;
      const dst = this.object.geometry.uvs;
      dst.push(src[a4 + 0], src[a4 + 1]);
    },
    addFace: function(a4, b5, c3, ua, ub, uc, na, nb, nc) {
      const vLen = this.vertices.length;
      let ia = this.parseVertexIndex(a4, vLen);
      let ib = this.parseVertexIndex(b5, vLen);
      let ic = this.parseVertexIndex(c3, vLen);
      this.addVertex(ia, ib, ic);
      this.addColor(ia, ib, ic);
      if (na !== void 0 && na !== "") {
        const nLen = this.normals.length;
        ia = this.parseNormalIndex(na, nLen);
        ib = this.parseNormalIndex(nb, nLen);
        ic = this.parseNormalIndex(nc, nLen);
        this.addNormal(ia, ib, ic);
      } else {
        this.addFaceNormal(ia, ib, ic);
      }
      if (ua !== void 0 && ua !== "") {
        const uvLen = this.uvs.length;
        ia = this.parseUVIndex(ua, uvLen);
        ib = this.parseUVIndex(ub, uvLen);
        ic = this.parseUVIndex(uc, uvLen);
        this.addUV(ia, ib, ic);
        this.object.geometry.hasUVIndices = true;
      } else {
        this.addDefaultUV();
      }
    },
    addPointGeometry: function(vertices) {
      this.object.geometry.type = "Points";
      const vLen = this.vertices.length;
      for (let vi = 0, l = vertices.length; vi < l; vi++) {
        const index = this.parseVertexIndex(vertices[vi], vLen);
        this.addVertexPoint(index);
        this.addColor(index);
      }
    },
    addLineGeometry: function(vertices, uvs) {
      this.object.geometry.type = "Line";
      const vLen = this.vertices.length;
      const uvLen = this.uvs.length;
      for (let vi = 0, l = vertices.length; vi < l; vi++) {
        this.addVertexLine(this.parseVertexIndex(vertices[vi], vLen));
      }
      for (let uvi = 0, l = uvs.length; uvi < l; uvi++) {
        this.addUVLine(this.parseUVIndex(uvs[uvi], uvLen));
      }
    }
  };
  state.startObject("", false);
  return state;
}
var OBJLoader = class extends Loader {
  constructor(manager) {
    super(manager);
    this.materials = null;
  }
  load(url, onLoad, onProgress, onError) {
    const scope = this;
    const loader = new FileLoader(this.manager);
    loader.setPath(this.path);
    loader.setRequestHeader(this.requestHeader);
    loader.setWithCredentials(this.withCredentials);
    loader.load(
      url,
      function(text) {
        try {
          onLoad(scope.parse(text));
        } catch (e) {
          if (onError) {
            onError(e);
          } else {
            console.error(e);
          }
          scope.manager.itemError(url);
        }
      },
      onProgress,
      onError
    );
  }
  setMaterials(materials) {
    this.materials = materials;
    return this;
  }
  parse(text) {
    const state = new ParserState();
    if (text.indexOf("\r\n") !== -1) {
      text = text.replace(/\r\n/g, "\n");
    }
    if (text.indexOf("\\\n") !== -1) {
      text = text.replace(/\\\n/g, "");
    }
    const lines = text.split("\n");
    let line2 = "", lineFirstChar = "";
    let lineLength = 0;
    let result = [];
    const trimLeft = typeof "".trimLeft === "function";
    for (let i3 = 0, l = lines.length; i3 < l; i3++) {
      line2 = lines[i3];
      line2 = trimLeft ? line2.trimLeft() : line2.trim();
      lineLength = line2.length;
      if (lineLength === 0)
        continue;
      lineFirstChar = line2.charAt(0);
      if (lineFirstChar === "#")
        continue;
      if (lineFirstChar === "v") {
        const data = line2.split(/\s+/);
        switch (data[0]) {
          case "v":
            state.vertices.push(parseFloat(data[1]), parseFloat(data[2]), parseFloat(data[3]));
            if (data.length >= 7) {
              state.colors.push(parseFloat(data[4]), parseFloat(data[5]), parseFloat(data[6]));
            } else {
              state.colors.push(void 0, void 0, void 0);
            }
            break;
          case "vn":
            state.normals.push(parseFloat(data[1]), parseFloat(data[2]), parseFloat(data[3]));
            break;
          case "vt":
            state.uvs.push(parseFloat(data[1]), parseFloat(data[2]));
            break;
        }
      } else if (lineFirstChar === "f") {
        const lineData = line2.substr(1).trim();
        const vertexData = lineData.split(/\s+/);
        const faceVertices = [];
        for (let j = 0, jl = vertexData.length; j < jl; j++) {
          const vertex = vertexData[j];
          if (vertex.length > 0) {
            const vertexParts = vertex.split("/");
            faceVertices.push(vertexParts);
          }
        }
        const v14 = faceVertices[0];
        for (let j = 1, jl = faceVertices.length - 1; j < jl; j++) {
          const v23 = faceVertices[j];
          const v32 = faceVertices[j + 1];
          state.addFace(v14[0], v23[0], v32[0], v14[1], v23[1], v32[1], v14[2], v23[2], v32[2]);
        }
      } else if (lineFirstChar === "l") {
        const lineParts = line2.substring(1).trim().split(" ");
        let lineVertices = [];
        const lineUVs = [];
        if (line2.indexOf("/") === -1) {
          lineVertices = lineParts;
        } else {
          for (let li = 0, llen = lineParts.length; li < llen; li++) {
            const parts = lineParts[li].split("/");
            if (parts[0] !== "")
              lineVertices.push(parts[0]);
            if (parts[1] !== "")
              lineUVs.push(parts[1]);
          }
        }
        state.addLineGeometry(lineVertices, lineUVs);
      } else if (lineFirstChar === "p") {
        const lineData = line2.substr(1).trim();
        const pointData = lineData.split(" ");
        state.addPointGeometry(pointData);
      } else if ((result = _object_pattern.exec(line2)) !== null) {
        const name = (" " + result[0].substr(1).trim()).substr(1);
        state.startObject(name);
      } else if (_material_use_pattern.test(line2)) {
        state.object.startMaterial(line2.substring(7).trim(), state.materialLibraries);
      } else if (_material_library_pattern.test(line2)) {
        state.materialLibraries.push(line2.substring(7).trim());
      } else if (_map_use_pattern.test(line2)) {
        console.warn(
          'THREE.OBJLoader: Rendering identifier "usemap" not supported. Textures must be defined in MTL files.'
        );
      } else if (lineFirstChar === "s") {
        result = line2.split(" ");
        if (result.length > 1) {
          const value = result[1].trim().toLowerCase();
          state.object.smooth = value !== "0" && value !== "off";
        } else {
          state.object.smooth = true;
        }
        const material2 = state.object.currentMaterial();
        if (material2)
          material2.smooth = state.object.smooth;
      } else {
        if (line2 === "\0")
          continue;
        console.warn('THREE.OBJLoader: Unexpected line: "' + line2 + '"');
      }
    }
    state.finalize();
    const container = new Group();
    container.materialLibraries = [].concat(state.materialLibraries);
    const hasPrimitives = !(state.objects.length === 1 && state.objects[0].geometry.vertices.length === 0);
    if (hasPrimitives === true) {
      for (let i3 = 0, l = state.objects.length; i3 < l; i3++) {
        const object = state.objects[i3];
        const geometry2 = object.geometry;
        const materials = object.materials;
        const isLine = geometry2.type === "Line";
        const isPoints = geometry2.type === "Points";
        let hasVertexColors = false;
        if (geometry2.vertices.length === 0)
          continue;
        const buffergeometry = new BufferGeometry();
        buffergeometry.setAttribute("position", new Float32BufferAttribute(geometry2.vertices, 3));
        if (geometry2.normals.length > 0) {
          buffergeometry.setAttribute("normal", new Float32BufferAttribute(geometry2.normals, 3));
        }
        if (geometry2.colors.length > 0) {
          hasVertexColors = true;
          buffergeometry.setAttribute("color", new Float32BufferAttribute(geometry2.colors, 3));
        }
        if (geometry2.hasUVIndices === true) {
          buffergeometry.setAttribute("uv", new Float32BufferAttribute(geometry2.uvs, 2));
        }
        const createdMaterials = [];
        for (let mi = 0, miLen = materials.length; mi < miLen; mi++) {
          const sourceMaterial = materials[mi];
          const materialHash = sourceMaterial.name + "_" + sourceMaterial.smooth + "_" + hasVertexColors;
          let material2 = state.materials[materialHash];
          if (this.materials !== null) {
            material2 = this.materials.create(sourceMaterial.name);
            if (isLine && material2 && !(material2 instanceof LineBasicMaterial)) {
              const materialLine = new LineBasicMaterial();
              Material.prototype.copy.call(materialLine, material2);
              materialLine.color.copy(material2.color);
              material2 = materialLine;
            } else if (isPoints && material2 && !(material2 instanceof PointsMaterial)) {
              const materialPoints = new PointsMaterial({ size: 10, sizeAttenuation: false });
              Material.prototype.copy.call(materialPoints, material2);
              materialPoints.color.copy(material2.color);
              materialPoints.map = material2.map;
              material2 = materialPoints;
            }
          }
          if (material2 === void 0) {
            if (isLine) {
              material2 = new LineBasicMaterial();
            } else if (isPoints) {
              material2 = new PointsMaterial({ size: 1, sizeAttenuation: false });
            } else {
              material2 = new MeshPhongMaterial();
            }
            material2.name = sourceMaterial.name;
            material2.flatShading = sourceMaterial.smooth ? false : true;
            material2.vertexColors = hasVertexColors;
            state.materials[materialHash] = material2;
          }
          createdMaterials.push(material2);
        }
        let mesh;
        if (createdMaterials.length > 1) {
          for (let mi = 0, miLen = materials.length; mi < miLen; mi++) {
            const sourceMaterial = materials[mi];
            buffergeometry.addGroup(sourceMaterial.groupStart, sourceMaterial.groupCount, mi);
          }
          if (isLine) {
            mesh = new LineSegments(buffergeometry, createdMaterials);
          } else if (isPoints) {
            mesh = new Points(buffergeometry, createdMaterials);
          } else {
            mesh = new Mesh(buffergeometry, createdMaterials);
          }
        } else {
          if (isLine) {
            mesh = new LineSegments(buffergeometry, createdMaterials[0]);
          } else if (isPoints) {
            mesh = new Points(buffergeometry, createdMaterials[0]);
          } else {
            mesh = new Mesh(buffergeometry, createdMaterials[0]);
          }
        }
        mesh.name = object.name;
        container.add(mesh);
      }
    } else {
      if (state.vertices.length > 0) {
        const material2 = new PointsMaterial({ size: 1, sizeAttenuation: false });
        const buffergeometry = new BufferGeometry();
        buffergeometry.setAttribute("position", new Float32BufferAttribute(state.vertices, 3));
        if (state.colors.length > 0 && state.colors[0] !== void 0) {
          buffergeometry.setAttribute("color", new Float32BufferAttribute(state.colors, 3));
          material2.vertexColors = true;
        }
        const points = new Points(buffergeometry, material2);
        container.add(points);
      }
    }
    return container;
  }
};

// node_modules/three-stdlib/loaders/KTXLoader.js
var HEADER_LEN = 12 + 13 * 4;

// node_modules/three-stdlib/loaders/DRACOLoader.js
var _taskCache3 = /* @__PURE__ */ new WeakMap();
var DRACOLoader = class extends Loader {
  constructor(manager) {
    super(manager);
    this.decoderPath = "";
    this.decoderConfig = {};
    this.decoderBinary = null;
    this.decoderPending = null;
    this.workerLimit = 4;
    this.workerPool = [];
    this.workerNextTaskID = 1;
    this.workerSourceURL = "";
    this.defaultAttributeIDs = {
      position: "POSITION",
      normal: "NORMAL",
      color: "COLOR",
      uv: "TEX_COORD"
    };
    this.defaultAttributeTypes = {
      position: "Float32Array",
      normal: "Float32Array",
      color: "Float32Array",
      uv: "Float32Array"
    };
  }
  setDecoderPath(path) {
    this.decoderPath = path;
    return this;
  }
  setDecoderConfig(config3) {
    this.decoderConfig = config3;
    return this;
  }
  setWorkerLimit(workerLimit) {
    this.workerLimit = workerLimit;
    return this;
  }
  load(url, onLoad, onProgress, onError) {
    const loader = new FileLoader(this.manager);
    loader.setPath(this.path);
    loader.setResponseType("arraybuffer");
    loader.setRequestHeader(this.requestHeader);
    loader.setWithCredentials(this.withCredentials);
    loader.load(
      url,
      (buffer) => {
        const taskConfig = {
          attributeIDs: this.defaultAttributeIDs,
          attributeTypes: this.defaultAttributeTypes,
          useUniqueIDs: false
        };
        this.decodeGeometry(buffer, taskConfig).then(onLoad).catch(onError);
      },
      onProgress,
      onError
    );
  }
  /** @deprecated Kept for backward-compatibility with previous DRACOLoader versions. */
  decodeDracoFile(buffer, callback, attributeIDs, attributeTypes) {
    const taskConfig = {
      attributeIDs: attributeIDs || this.defaultAttributeIDs,
      attributeTypes: attributeTypes || this.defaultAttributeTypes,
      useUniqueIDs: !!attributeIDs
    };
    this.decodeGeometry(buffer, taskConfig).then(callback);
  }
  decodeGeometry(buffer, taskConfig) {
    for (const attribute in taskConfig.attributeTypes) {
      const type = taskConfig.attributeTypes[attribute];
      if (type.BYTES_PER_ELEMENT !== void 0) {
        taskConfig.attributeTypes[attribute] = type.name;
      }
    }
    const taskKey = JSON.stringify(taskConfig);
    if (_taskCache3.has(buffer)) {
      const cachedTask = _taskCache3.get(buffer);
      if (cachedTask.key === taskKey) {
        return cachedTask.promise;
      } else if (buffer.byteLength === 0) {
        throw new Error(
          "THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred."
        );
      }
    }
    let worker;
    const taskID = this.workerNextTaskID++;
    const taskCost = buffer.byteLength;
    const geometryPending = this._getWorker(taskID, taskCost).then((_worker) => {
      worker = _worker;
      return new Promise((resolve, reject) => {
        worker._callbacks[taskID] = { resolve, reject };
        worker.postMessage({ type: "decode", id: taskID, taskConfig, buffer }, [buffer]);
      });
    }).then((message) => this._createGeometry(message.geometry));
    geometryPending.catch(() => true).then(() => {
      if (worker && taskID) {
        this._releaseTask(worker, taskID);
      }
    });
    _taskCache3.set(buffer, {
      key: taskKey,
      promise: geometryPending
    });
    return geometryPending;
  }
  _createGeometry(geometryData) {
    const geometry2 = new BufferGeometry();
    if (geometryData.index) {
      geometry2.setIndex(new BufferAttribute(geometryData.index.array, 1));
    }
    for (let i3 = 0; i3 < geometryData.attributes.length; i3++) {
      const attribute = geometryData.attributes[i3];
      const name = attribute.name;
      const array = attribute.array;
      const itemSize = attribute.itemSize;
      geometry2.setAttribute(name, new BufferAttribute(array, itemSize));
    }
    return geometry2;
  }
  _loadLibrary(url, responseType) {
    const loader = new FileLoader(this.manager);
    loader.setPath(this.decoderPath);
    loader.setResponseType(responseType);
    loader.setWithCredentials(this.withCredentials);
    return new Promise((resolve, reject) => {
      loader.load(url, resolve, void 0, reject);
    });
  }
  preload() {
    this._initDecoder();
    return this;
  }
  _initDecoder() {
    if (this.decoderPending)
      return this.decoderPending;
    const useJS = typeof WebAssembly !== "object" || this.decoderConfig.type === "js";
    const librariesPending = [];
    if (useJS) {
      librariesPending.push(this._loadLibrary("draco_decoder.js", "text"));
    } else {
      librariesPending.push(this._loadLibrary("draco_wasm_wrapper.js", "text"));
      librariesPending.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"));
    }
    this.decoderPending = Promise.all(librariesPending).then((libraries) => {
      const jsContent = libraries[0];
      if (!useJS) {
        this.decoderConfig.wasmBinary = libraries[1];
      }
      const fn = DRACOWorker.toString();
      const body = [
        "/* draco decoder */",
        jsContent,
        "",
        "/* worker */",
        fn.substring(fn.indexOf("{") + 1, fn.lastIndexOf("}"))
      ].join("\n");
      this.workerSourceURL = URL.createObjectURL(new Blob([body]));
    });
    return this.decoderPending;
  }
  _getWorker(taskID, taskCost) {
    return this._initDecoder().then(() => {
      if (this.workerPool.length < this.workerLimit) {
        const worker2 = new Worker(this.workerSourceURL);
        worker2._callbacks = {};
        worker2._taskCosts = {};
        worker2._taskLoad = 0;
        worker2.postMessage({ type: "init", decoderConfig: this.decoderConfig });
        worker2.onmessage = function(e) {
          const message = e.data;
          switch (message.type) {
            case "decode":
              worker2._callbacks[message.id].resolve(message);
              break;
            case "error":
              worker2._callbacks[message.id].reject(message);
              break;
            default:
              console.error('THREE.DRACOLoader: Unexpected message, "' + message.type + '"');
          }
        };
        this.workerPool.push(worker2);
      } else {
        this.workerPool.sort(function(a4, b5) {
          return a4._taskLoad > b5._taskLoad ? -1 : 1;
        });
      }
      const worker = this.workerPool[this.workerPool.length - 1];
      worker._taskCosts[taskID] = taskCost;
      worker._taskLoad += taskCost;
      return worker;
    });
  }
  _releaseTask(worker, taskID) {
    worker._taskLoad -= worker._taskCosts[taskID];
    delete worker._callbacks[taskID];
    delete worker._taskCosts[taskID];
  }
  debug() {
    console.log(
      "Task load: ",
      this.workerPool.map((worker) => worker._taskLoad)
    );
  }
  dispose() {
    for (let i3 = 0; i3 < this.workerPool.length; ++i3) {
      this.workerPool[i3].terminate();
    }
    this.workerPool.length = 0;
    return this;
  }
};
function DRACOWorker() {
  let decoderConfig;
  let decoderPending;
  onmessage = function(e) {
    const message = e.data;
    switch (message.type) {
      case "init":
        decoderConfig = message.decoderConfig;
        decoderPending = new Promise(function(resolve) {
          decoderConfig.onModuleLoaded = function(draco) {
            resolve({ draco });
          };
          DracoDecoderModule(decoderConfig);
        });
        break;
      case "decode":
        const buffer = message.buffer;
        const taskConfig = message.taskConfig;
        decoderPending.then((module2) => {
          const draco = module2.draco;
          const decoder = new draco.Decoder();
          const decoderBuffer = new draco.DecoderBuffer();
          decoderBuffer.Init(new Int8Array(buffer), buffer.byteLength);
          try {
            const geometry2 = decodeGeometry(draco, decoder, decoderBuffer, taskConfig);
            const buffers = geometry2.attributes.map((attr) => attr.array.buffer);
            if (geometry2.index)
              buffers.push(geometry2.index.array.buffer);
            self.postMessage({ type: "decode", id: message.id, geometry: geometry2 }, buffers);
          } catch (error) {
            console.error(error);
            self.postMessage({ type: "error", id: message.id, error: error.message });
          } finally {
            draco.destroy(decoderBuffer);
            draco.destroy(decoder);
          }
        });
        break;
    }
  };
  function decodeGeometry(draco, decoder, decoderBuffer, taskConfig) {
    const attributeIDs = taskConfig.attributeIDs;
    const attributeTypes = taskConfig.attributeTypes;
    let dracoGeometry;
    let decodingStatus;
    const geometryType = decoder.GetEncodedGeometryType(decoderBuffer);
    if (geometryType === draco.TRIANGULAR_MESH) {
      dracoGeometry = new draco.Mesh();
      decodingStatus = decoder.DecodeBufferToMesh(decoderBuffer, dracoGeometry);
    } else if (geometryType === draco.POINT_CLOUD) {
      dracoGeometry = new draco.PointCloud();
      decodingStatus = decoder.DecodeBufferToPointCloud(decoderBuffer, dracoGeometry);
    } else {
      throw new Error("THREE.DRACOLoader: Unexpected geometry type.");
    }
    if (!decodingStatus.ok() || dracoGeometry.ptr === 0) {
      throw new Error("THREE.DRACOLoader: Decoding failed: " + decodingStatus.error_msg());
    }
    const geometry2 = { index: null, attributes: [] };
    for (const attributeName in attributeIDs) {
      const attributeType = self[attributeTypes[attributeName]];
      let attribute;
      let attributeID;
      if (taskConfig.useUniqueIDs) {
        attributeID = attributeIDs[attributeName];
        attribute = decoder.GetAttributeByUniqueId(dracoGeometry, attributeID);
      } else {
        attributeID = decoder.GetAttributeId(dracoGeometry, draco[attributeIDs[attributeName]]);
        if (attributeID === -1)
          continue;
        attribute = decoder.GetAttribute(dracoGeometry, attributeID);
      }
      geometry2.attributes.push(decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute));
    }
    if (geometryType === draco.TRIANGULAR_MESH) {
      geometry2.index = decodeIndex(draco, decoder, dracoGeometry);
    }
    draco.destroy(dracoGeometry);
    return geometry2;
  }
  function decodeIndex(draco, decoder, dracoGeometry) {
    const numFaces = dracoGeometry.num_faces();
    const numIndices = numFaces * 3;
    const byteLength = numIndices * 4;
    const ptr = draco._malloc(byteLength);
    decoder.GetTrianglesUInt32Array(dracoGeometry, byteLength, ptr);
    const index = new Uint32Array(draco.HEAPF32.buffer, ptr, numIndices).slice();
    draco._free(ptr);
    return { array: index, itemSize: 1 };
  }
  function decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute) {
    const numComponents = attribute.num_components();
    const numPoints = dracoGeometry.num_points();
    const numValues = numPoints * numComponents;
    const byteLength = numValues * attributeType.BYTES_PER_ELEMENT;
    const dataType = getDracoDataType(draco, attributeType);
    const ptr = draco._malloc(byteLength);
    decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, dataType, byteLength, ptr);
    const array = new attributeType(draco.HEAPF32.buffer, ptr, numValues).slice();
    draco._free(ptr);
    return {
      name: attributeName,
      array,
      itemSize: numComponents
    };
  }
  function getDracoDataType(draco, attributeType) {
    switch (attributeType) {
      case Float32Array:
        return draco.DT_FLOAT32;
      case Int8Array:
        return draco.DT_INT8;
      case Int16Array:
        return draco.DT_INT16;
      case Int32Array:
        return draco.DT_INT32;
      case Uint8Array:
        return draco.DT_UINT8;
      case Uint16Array:
        return draco.DT_UINT16;
      case Uint32Array:
        return draco.DT_UINT32;
    }
  }
}

// node_modules/three-stdlib/lines/LineSegmentsGeometry.js
var _box = new Box3();
var _vector5 = new Vector3();

// node_modules/three-stdlib/lines/Wireframe.js
var _start = new Vector3();
var _end = new Vector3();

// node_modules/three-stdlib/lines/LineSegments2.js
var _start2 = new Vector3();
var _end2 = new Vector3();
var _start4 = new Vector4();
var _end4 = new Vector4();
var _ssOrigin = new Vector4();
var _ssOrigin3 = new Vector3();
var _mvMatrix = new Matrix4();
var _line = new Line3();
var _closestPoint2 = new Vector3();
var _box2 = new Box3();
var _sphere2 = new Sphere();
var _clipToWorldVector = new Vector4();

// node_modules/three-stdlib/helpers/VertexTangentsHelper.js
var _v15 = new Vector3();
var _v23 = new Vector3();

// node_modules/three-stdlib/helpers/VertexNormalsHelper.js
var _v16 = new Vector3();
var _v24 = new Vector3();
var _normalMatrix = new Matrix3();

// node_modules/three-stdlib/helpers/RectAreaLightHelper.js
var RectAreaLightHelper = class extends Line {
  constructor(light, color) {
    const positions = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0];
    const geometry2 = new BufferGeometry();
    geometry2.setAttribute("position", new Float32BufferAttribute(positions, 3));
    geometry2.computeBoundingSphere();
    const material2 = new LineBasicMaterial({ fog: false });
    super(geometry2, material2);
    this.light = light;
    this.color = color;
    this.type = "RectAreaLightHelper";
    const positions2 = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0];
    const geometry22 = new BufferGeometry();
    geometry22.setAttribute("position", new Float32BufferAttribute(positions2, 3));
    geometry22.computeBoundingSphere();
    this.add(new Mesh(geometry22, new MeshBasicMaterial({ side: BackSide, fog: false })));
  }
  updateMatrixWorld() {
    this.scale.set(0.5 * this.light.width, 0.5 * this.light.height, 1);
    if (this.color !== void 0) {
      this.material.color.set(this.color);
      this.children[0].material.color.set(this.color);
    } else {
      this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
      const c3 = this.material.color;
      const max3 = Math.max(c3.r, c3.g, c3.b);
      if (max3 > 1)
        c3.multiplyScalar(1 / max3);
      this.children[0].material.color.copy(this.material.color);
    }
    this.matrixWorld.extractRotation(this.light.matrixWorld).scale(this.scale).copyPosition(this.light.matrixWorld);
    this.children[0].matrixWorld.copy(this.matrixWorld);
  }
  dispose() {
    this.geometry.dispose();
    this.material.dispose();
    this.children[0].geometry.dispose();
    this.children[0].material.dispose();
  }
};

// node_modules/three-stdlib/deprecated/Geometry.js
var _m1 = new Matrix4();
var _obj = new Object3D();
var _offset = new Vector3();

// node_modules/kokomi.js/dist/lib/Bender/bender.js
var Bender = class {
  bend(geometry2, axis, angle2) {
    let theta = 0;
    if (angle2 !== 0) {
      const v = geometry2.attributes.position.array;
      for (let i3 = 0; i3 < v.length; i3 += 3) {
        let x = v[i3];
        let y = v[i3 + 1];
        let z = v[i3 + 2];
        switch (axis) {
          case "x":
            theta = z * angle2;
            break;
          case "y":
            theta = x * angle2;
            break;
          default:
            theta = x * angle2;
            break;
        }
        let sinTheta = Math.sin(theta);
        let cosTheta = Math.cos(theta);
        switch (axis) {
          case "x":
            v[i3] = x;
            v[i3 + 1] = (y - 1 / angle2) * cosTheta + 1 / angle2;
            v[i3 + 2] = -(y - 1 / angle2) * sinTheta;
            break;
          case "y":
            v[i3] = -(z - 1 / angle2) * sinTheta;
            v[i3 + 1] = y;
            v[i3 + 2] = (z - 1 / angle2) * cosTheta + 1 / angle2;
            break;
          default:
            v[i3] = -(y - 1 / angle2) * sinTheta;
            v[i3 + 1] = (y - 1 / angle2) * cosTheta + 1 / angle2;
            v[i3 + 2] = z;
            break;
        }
      }
      geometry2.attributes.position.needsUpdate = true;
    }
  }
};

// node_modules/kokomi.js/dist/lib/custom-mipmap-generation/mipSampleFunctions.js
var sampleFunctions = (
  /* glsl */
  `

	// Without original size argument for power of two targets
	vec4 packedTexture2DLOD( sampler2D tex, vec2 uv, int level ) {

		// the fraction of the uv space used by the target mip
		float targetSubview = 1.0 / pow( 2.0, float( level ) );
		float widthRatio = 2.0 / 3.0;
		vec2 scaledDimensions = vec2( targetSubview * widthRatio, targetSubview );

		// all levels > 0 are on the right third of the texture
		// y is offset from the bottom
		vec2 offset = vec2(
			level > 0 ? widthRatio : 0.0,
			level > 0 ? targetSubview : 0.0
		);

		vec2 samplePoint = mix( offset, offset + scaledDimensions, uv );
		return texture2D( tex, samplePoint );

	}

	vec4 packedTexture2DLOD( sampler2D tex, vec2 uv, float level ) {

		float ratio = mod( level, 1.0 );
		int minLevel = int( floor( level ) );
		int maxLevel = int( ceil( level ) );

		vec4 minValue = packedTexture2DLOD( tex, uv, minLevel );
		vec4 maxValue = packedTexture2DLOD( tex, uv, maxLevel );

		return mix( minValue, maxValue, ratio );

	}

	// With original size argument
	vec4 packedTexture2DLOD( sampler2D tex, vec2 uv, int level, vec2 originalPixelSize ) {

		float floatLevel = float( level );
		vec2 atlasSize;
		atlasSize.x = floor( originalPixelSize.x * 1.5 );
		atlasSize.y = originalPixelSize.y;

		// we stop making mip maps when one dimension == 1
		float maxLevel = min( floor( log2( originalPixelSize.x ) ), floor( log2( originalPixelSize.y ) ) );
		floatLevel = min( floatLevel, maxLevel );

		// use inverse pow of 2 to simulate right bit shift operator
		vec2 currentPixelDimensions = floor( originalPixelSize / pow( 2.0, floatLevel ) );
		vec2 pixelOffset = vec2(
			floatLevel > 0.0 ? originalPixelSize.x : 0.0,
			floatLevel > 0.0 ? currentPixelDimensions.y : 0.0
		);

		// "minPixel / atlasSize" samples the top left piece of the first pixel
		// "maxPixel / atlasSize" samples the bottom right piece of the last pixel
		vec2 minPixel = pixelOffset;
		vec2 maxPixel = pixelOffset + currentPixelDimensions;
		vec2 samplePoint = mix( minPixel, maxPixel, uv );
		samplePoint /= atlasSize;

		vec2 halfPixelSize = 1.0 / ( 2.0 * atlasSize );
		samplePoint = min( samplePoint, maxPixel / atlasSize - halfPixelSize );
		samplePoint = max( samplePoint, minPixel / atlasSize + halfPixelSize );

		return texture2D( tex, samplePoint );

	}

	vec4 packedTexture2DLOD( sampler2D tex, vec2 uv, float level, vec2 originalPixelSize ) {

		float ratio = mod( level, 1.0 );
		int minLevel = int( floor( level ) );
		int maxLevel = int( ceil( level ) );

		vec4 minValue = packedTexture2DLOD( tex, uv, minLevel, originalPixelSize );
		vec4 maxValue = packedTexture2DLOD( tex, uv, maxLevel, originalPixelSize );

		return mix( minValue, maxValue, ratio );

	}

`
);

// node_modules/kokomi.js/dist/lib/custom-mipmap-generation/MipGenerationShader.js
function clone(shader) {
  const newShader = { ...shader };
  if ("defines" in shader) {
    newShader.defines = { ...shader.defines };
  }
  if ("uniforms" in shader) {
    newShader.uniforms = UniformsUtils.clone(shader.uniforms);
  }
  return newShader;
}
var MipGenerationShader = {
  defines: {
    X_IS_EVEN: 1,
    Y_IS_EVEN: 1
  },
  uniforms: {
    map: { value: null },
    originalMapSize: { value: new Vector2() },
    parentMapSize: { value: new Vector2() },
    parentLevel: { value: 0 }
  },
  vertexShader: (
    /* glsl */
    `
		varying vec2 vUv;
		void main() {

			#include <begin_vertex>
			#include <project_vertex>
			vUv = uv;

		}
	`
  ),
  fragmentShader: (
    /* glsl */
    `
		varying vec2 vUv;
		uniform sampler2D map;
		uniform int parentLevel;
		uniform vec2 parentMapSize;
		uniform vec2 originalMapSize;

		${sampleFunctions}

		#if X_IS_EVEN && Y_IS_EVEN

		#define SAMPLES 4
		#define WIDTH 2
		#define HEIGHT 2

		#elif X_IS_EVEN

		#define SAMPLES 6
		#define WIDTH 2
		#define HEIGHT 3

		#elif Y_IS_EVEN

		#define SAMPLES 6
		#define WIDTH 3
		#define HEIGHT 2

		#else

		#define SAMPLES 9
		#define WIDTH 3
		#define HEIGHT 3

		#endif

		vec4 sampleAt( vec2 uv ) {

			return packedTexture2DLOD( map, uv, parentLevel, originalMapSize );

		}

		void main() {

			vec2 childMapSize = parentMapSize / 2.0;
			// vec2 childPixelSize = 1.0 / childMapSize;
			// vec2 halfChildPixelSize = childPixelSize / 2.0;
			vec2 childPixelPos = floor( vUv * childMapSize );

			vec2 parentPixelSize = 1.0 / parentMapSize;
			vec2 halfParentPixelSize = parentPixelSize / 2.0;
			vec2 parentPixelPos = childPixelPos * 2.0;

			vec2 baseUv = ( parentPixelPos / parentMapSize ) + halfParentPixelSize;

			vec4 samples[ SAMPLES ];
			float weights[ SAMPLES ];

			#if X_IS_EVEN && Y_IS_EVEN

			samples[ 0 ] = sampleAt( baseUv );
			samples[ 1 ] = sampleAt( baseUv + vec2( parentPixelSize.x, 0.0 ) );
			samples[ 2 ] = sampleAt( baseUv + vec2( 0.0, parentPixelSize.y ) );
			samples[ 3 ] = sampleAt( baseUv + vec2( parentPixelSize.x, parentPixelSize.y ) );

			weights[ 0 ] = 0.25;
			weights[ 1 ] = 0.25;
			weights[ 2 ] = 0.25;
			weights[ 3 ] = 0.25;

			#elif X_IS_EVEN

			float wx0 = 0.5;
			float wx1 = 0.5;

			float yden = 2.0 * parentMapSize.y + 1.0;
			float wy0 = ( parentMapSize.y - parentPixelPos.y ) / yden;
			float wy1 = ( parentMapSize.y ) / yden;
			float wy2 = ( parentPixelPos.y + 1.0 ) / yden;

			samples[ 0 ] = sampleAt( baseUv );
			samples[ 1 ] = sampleAt( baseUv + vec2( parentPixelSize.x, 0.0 ) );

			samples[ 2 ] = sampleAt( baseUv + vec2( 0.0, parentPixelSize.y ) );
			samples[ 3 ] = sampleAt( baseUv + vec2( parentPixelSize.x, parentPixelSize.y ) );

			samples[ 4 ] = sampleAt( baseUv + vec2( 0.0, 2.0 * parentPixelSize.y ) );
			samples[ 5 ] = sampleAt( baseUv + vec2( parentPixelSize.x, 2.0 * parentPixelSize.y ) );

			weights[ 0 ] = wx0 * wy0;
			weights[ 1 ] = wx1 * wy0;

			weights[ 2 ] = wx0 * wy1;
			weights[ 3 ] = wx1 * wy1;

			weights[ 4 ] = wx0 * wy2;
			weights[ 5 ] = wx1 * wy2;

			#elif Y_IS_EVEN

			float xden = 2.0 * parentMapSize.x + 1.0;
			float wx0 = ( parentMapSize.x - parentPixelPos.x ) / xden;
			float wx1 = ( parentMapSize.x ) / xden;
			float wx2 = ( parentPixelPos.x + 1.0 ) / xden;

			float wy0 = 0.5;
			float wy1 = 0.5;

			samples[ 0 ] = sampleAt( baseUv );
			samples[ 1 ] = sampleAt( baseUv + vec2( parentPixelSize.x, 0.0 ) );
			samples[ 2 ] = sampleAt( baseUv + vec2( 2.0 * parentPixelSize.x, 0.0 ) );

			samples[ 3 ] = sampleAt( baseUv + vec2( 0.0, parentPixelSize.y ) );
			samples[ 4 ] = sampleAt( baseUv + vec2( parentPixelSize.x, parentPixelSize.y ) );
			samples[ 5 ] = sampleAt( baseUv + vec2( 2.0 * parentPixelSize.x, parentPixelSize.y ) );

			weights[ 0 ] = wx0 * wy0;
			weights[ 1 ] = wx1 * wy0;
			weights[ 2 ] = wx2 * wy0;

			weights[ 3 ] = wx0 * wy1;
			weights[ 4 ] = wx1 * wy1;
			weights[ 5 ] = wx2 * wy1;

			#else

			float xden = 2.0 * parentMapSize.x + 1.0;
			float wx0 = ( parentMapSize.x - parentPixelPos.x ) / xden;
			float wx1 = ( parentMapSize.x ) / xden;
			float wx2 = ( parentPixelPos.x + 1.0 ) / xden;

			float yden = 2.0 * parentMapSize.y + 1.0;
			float wy0 = ( parentMapSize.y - parentPixelPos.y ) / yden;
			float wy1 = ( parentMapSize.y ) / yden;
			float wy2 = ( parentPixelPos.y + 1.0 ) / yden;

			samples[ 0 ] = sampleAt( baseUv );
			samples[ 1 ] = sampleAt( baseUv + vec2( parentPixelSize.x, 0.0 ) );
			samples[ 2 ] = sampleAt( baseUv + vec2( 2.0 * parentPixelSize.x, 0.0 ) );

			samples[ 3 ] = sampleAt( baseUv + vec2( 0.0, parentPixelSize.y ) );
			samples[ 4 ] = sampleAt( baseUv + vec2( parentPixelSize.x, parentPixelSize.y ) );
			samples[ 5 ] = sampleAt( baseUv + vec2( 2.0 * parentPixelSize.x, parentPixelSize.y ) );

			samples[ 6 ] = sampleAt( baseUv + vec2( 0.0, 2.0 * parentPixelSize.y ) );
			samples[ 7 ] = sampleAt( baseUv + vec2( parentPixelSize.x, 2.0 * parentPixelSize.y ) );
			samples[ 8 ] = sampleAt( baseUv + vec2( 2.0 * parentPixelSize.x, 2.0 * parentPixelSize.y ) );

			weights[ 0 ] = wx0 * wy0;
			weights[ 1 ] = wx1 * wy0;
			weights[ 2 ] = wx2 * wy0;

			weights[ 3 ] = wx0 * wy1;
			weights[ 4 ] = wx1 * wy1;
			weights[ 5 ] = wx2 * wy1;

			weights[ 6 ] = wx0 * wy2;
			weights[ 7 ] = wx1 * wy2;
			weights[ 8 ] = wx2 * wy2;

			#endif

			<mipmap_logic>

		}
	`
  )
};

// node_modules/kokomi.js/dist/lib/custom-mipmap-generation/PackedMipMapGenerator.js
var _originalClearColor = new Color();
var PackedMipMapGenerator = class {
  constructor(mipmapLogic = "") {
    __publicField(this, "_swapTarget");
    __publicField(this, "_copyQuad");
    __publicField(this, "_mipQuad");
    __publicField(this, "_mipMaterials");
    if (!mipmapLogic) {
      mipmapLogic = /* glsl */
      `

				#pragma unroll_loop
				for ( int i = 0; i < SAMPLES; i ++ ) {

					gl_FragColor += samples[ i ] * weights[ i ];

				}

			`;
    }
    const shader = clone(MipGenerationShader);
    shader.fragmentShader = shader.fragmentShader.replace(/<mipmap_logic>/g, mipmapLogic);
    const mipMaterials = new Array(4);
    mipMaterials[0] = new ShaderMaterial(clone(shader));
    mipMaterials[0].defines.X_IS_EVEN = 0;
    mipMaterials[0].defines.Y_IS_EVEN = 0;
    mipMaterials[1] = new ShaderMaterial(clone(shader));
    mipMaterials[1].defines.X_IS_EVEN = 1;
    mipMaterials[1].defines.Y_IS_EVEN = 0;
    mipMaterials[2] = new ShaderMaterial(clone(shader));
    mipMaterials[2].defines.X_IS_EVEN = 0;
    mipMaterials[2].defines.Y_IS_EVEN = 1;
    mipMaterials[3] = new ShaderMaterial(clone(shader));
    mipMaterials[3].defines.X_IS_EVEN = 1;
    mipMaterials[3].defines.Y_IS_EVEN = 1;
    const swapTarget = new WebGLRenderTarget();
    swapTarget.texture.minFilter = NearestFilter;
    swapTarget.texture.magFilter = NearestFilter;
    this._swapTarget = swapTarget;
    this._copyQuad = new FullScreenQuad(new ShaderMaterial(CopyShader));
    this._mipQuad = new FullScreenQuad(null);
    this._mipMaterials = mipMaterials;
  }
  update(texture, target, renderer, forcePowerOfTwo = false) {
    if (texture.isWebGLRenderTarget) {
      texture = texture.texture;
    }
    const originalAutoClear = renderer.autoClear;
    const originalClearAlpha = renderer.getClearAlpha();
    const originalRenderTarget = renderer.getRenderTarget();
    renderer.getClearColor(_originalClearColor);
    const copyQuad = this._copyQuad;
    const mipQuad = this._mipQuad;
    const swapTarget = this._swapTarget;
    const mipMaterials = this._mipMaterials;
    let width, height;
    if (forcePowerOfTwo) {
      width = MathUtils.floorPowerOfTwo(texture.image.width);
      height = MathUtils.floorPowerOfTwo(texture.image.height);
    } else {
      width = Math.floor(texture.image.width);
      height = Math.floor(texture.image.height);
    }
    const targetWidth = Math.floor(width * 1.5);
    const targetHeight = Math.floor(height);
    target.setSize(targetWidth, targetHeight);
    if (swapTarget.texture.type !== target.texture.type) {
      swapTarget.dispose();
      swapTarget.copy(target);
      swapTarget.texture.image = { ...swapTarget.texture.image };
    } else {
      swapTarget.setSize(targetWidth, targetHeight);
    }
    renderer.autoClear = false;
    renderer.setClearColor(0);
    renderer.setClearAlpha();
    copyQuad.material.uniforms.tDiffuse.value = texture;
    copyQuad.camera.setViewOffset(width, height, 0, 0, targetWidth, targetHeight);
    renderer.setRenderTarget(target);
    renderer.clear();
    copyQuad.render(renderer);
    renderer.setRenderTarget(swapTarget);
    renderer.clear();
    copyQuad.render(renderer);
    let currWidth = width;
    let currHeight = height;
    let mip = 0;
    while (currWidth > 1 && currHeight > 1) {
      const X_FLAG = 1 << 0;
      const Y_FLAG = 1 << 1;
      const index = (currWidth % 2 === 0 ? X_FLAG : 0) | (currHeight % 2 === 0 ? Y_FLAG : 0);
      const material2 = mipMaterials[index];
      material2.uniforms.map.value = swapTarget.texture;
      material2.uniforms.parentLevel.value = mip;
      material2.uniforms.parentMapSize.value.set(currWidth, currHeight);
      material2.uniforms.originalMapSize.value.set(width, height);
      mipQuad.material = material2;
      currWidth = Math.floor(currWidth / 2);
      currHeight = Math.floor(currHeight / 2);
      const yOffset = targetHeight - 2 * currHeight;
      renderer.setRenderTarget(target);
      mipQuad.camera.setViewOffset(currWidth, currHeight, -width, -yOffset, targetWidth, targetHeight);
      mipQuad.render(renderer);
      renderer.setRenderTarget(swapTarget);
      material2.uniforms.map.value = target.texture;
      mipQuad.render(renderer);
      mip++;
    }
    renderer.setRenderTarget(originalRenderTarget);
    renderer.setClearAlpha(originalClearAlpha);
    renderer.setClearColor(_originalClearColor);
    renderer.autoClear = originalAutoClear;
    return mip + 1;
  }
  dispose() {
    this._swapTarget.dispose();
    this._mipQuad.dispose();
    this._copyQuad.dispose();
    this._mipMaterials.forEach((m) => m.dispose());
  }
};

// node_modules/kokomi.js/dist/lib/other/MeshReflectorMaterial.js
var MeshReflectorMaterialImpl = class extends MeshStandardMaterial {
  constructor(parameters = {}) {
    super(parameters);
    __publicField(this, "_tDepth");
    __publicField(this, "_distortionMap");
    __publicField(this, "_tDiffuse");
    __publicField(this, "_tDiffuseBlur");
    __publicField(this, "_textureMatrix");
    __publicField(this, "_hasBlur");
    __publicField(this, "_mirror");
    __publicField(this, "_mixBlur");
    __publicField(this, "_blurStrength");
    __publicField(this, "_minDepthThreshold");
    __publicField(this, "_maxDepthThreshold");
    __publicField(this, "_depthScale");
    __publicField(this, "_depthToBlurRatioBias");
    __publicField(this, "_distortion");
    __publicField(this, "_mixContrast");
    this._tDepth = { value: null };
    this._distortionMap = { value: null };
    this._tDiffuse = { value: null };
    this._tDiffuseBlur = { value: null };
    this._textureMatrix = { value: null };
    this._hasBlur = { value: false };
    this._mirror = { value: 0 };
    this._mixBlur = { value: 0 };
    this._blurStrength = { value: 0.5 };
    this._minDepthThreshold = { value: 0.9 };
    this._maxDepthThreshold = { value: 1 };
    this._depthScale = { value: 0 };
    this._depthToBlurRatioBias = { value: 0.25 };
    this._distortion = { value: 1 };
    this._mixContrast = { value: 1 };
    this.setValues(parameters);
  }
  onBeforeCompile(shader) {
    var _a4;
    if (!((_a4 = shader.defines) == null ? void 0 : _a4.USE_UV)) {
      shader.defines.USE_UV = "";
    }
    shader.uniforms.hasBlur = this._hasBlur;
    shader.uniforms.tDiffuse = this._tDiffuse;
    shader.uniforms.tDepth = this._tDepth;
    shader.uniforms.distortionMap = this._distortionMap;
    shader.uniforms.tDiffuseBlur = this._tDiffuseBlur;
    shader.uniforms.textureMatrix = this._textureMatrix;
    shader.uniforms.mirror = this._mirror;
    shader.uniforms.mixBlur = this._mixBlur;
    shader.uniforms.mixStrength = this._blurStrength;
    shader.uniforms.minDepthThreshold = this._minDepthThreshold;
    shader.uniforms.maxDepthThreshold = this._maxDepthThreshold;
    shader.uniforms.depthScale = this._depthScale;
    shader.uniforms.depthToBlurRatioBias = this._depthToBlurRatioBias;
    shader.uniforms.distortion = this._distortion;
    shader.uniforms.mixContrast = this._mixContrast;
    shader.vertexShader = /* glsl */
    `
        uniform mat4 textureMatrix;
        varying vec4 my_vUv;
      ${shader.vertexShader}`;
    shader.vertexShader = shader.vertexShader.replace(
      "#include <project_vertex>",
      /* glsl */
      `#include <project_vertex>
        my_vUv = textureMatrix * vec4( position, 1.0 );
        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );`
    );
    shader.fragmentShader = /* glsl */
    `
        uniform sampler2D tDiffuse;
        uniform sampler2D tDiffuseBlur;
        uniform sampler2D tDepth;
        uniform sampler2D distortionMap;
        uniform float distortion;
        uniform float cameraNear;
			  uniform float cameraFar;
        uniform bool hasBlur;
        uniform float mixBlur;
        uniform float mirror;
        uniform float mixStrength;
        uniform float minDepthThreshold;
        uniform float maxDepthThreshold;
        uniform float mixContrast;
        uniform float depthScale;
        uniform float depthToBlurRatioBias;
        varying vec4 my_vUv;
        ${shader.fragmentShader}`;
    shader.fragmentShader = shader.fragmentShader.replace(
      "#include <emissivemap_fragment>",
      /* glsl */
      `#include <emissivemap_fragment>

      float distortionFactor = 0.0;
      #ifdef USE_DISTORTION
        distortionFactor = texture2D(distortionMap, vUv).r * distortion;
      #endif

      vec4 new_vUv = my_vUv;
      new_vUv.x += distortionFactor;
      new_vUv.y += distortionFactor;

      vec4 base = texture2DProj(tDiffuse, new_vUv);
      vec4 blur = texture2DProj(tDiffuseBlur, new_vUv);

      vec4 merge = base;

      #ifdef USE_NORMALMAP
        vec2 normal_uv = vec2(0.0);
        vec4 normalColor = texture2D(normalMap, vUv * normalScale);
        vec3 my_normal = normalize( vec3( normalColor.r * 2.0 - 1.0, normalColor.b,  normalColor.g * 2.0 - 1.0 ) );
        vec3 coord = new_vUv.xyz / new_vUv.w;
        normal_uv = coord.xy + coord.z * my_normal.xz * 0.05;
        vec4 base_normal = texture2D(tDiffuse, normal_uv);
        vec4 blur_normal = texture2D(tDiffuseBlur, normal_uv);
        merge = base_normal;
        blur = blur_normal;
      #endif

      float depthFactor = 0.0001;
      float blurFactor = 0.0;

      #ifdef USE_DEPTH
        vec4 depth = texture2DProj(tDepth, new_vUv);
        depthFactor = smoothstep(minDepthThreshold, maxDepthThreshold, 1.0-(depth.r * depth.a));
        depthFactor *= depthScale;
        depthFactor = max(0.0001, min(1.0, depthFactor));

        #ifdef USE_BLUR
          blur = blur * min(1.0, depthFactor + depthToBlurRatioBias);
          merge = merge * min(1.0, depthFactor + 0.5);
        #else
          merge = merge * depthFactor;
        #endif

      #endif

      float reflectorRoughnessFactor = roughness;
      #ifdef USE_ROUGHNESSMAP
        vec4 reflectorTexelRoughness = texture2D( roughnessMap, vUv );
        reflectorRoughnessFactor *= reflectorTexelRoughness.g;
      #endif

      #ifdef USE_BLUR
        blurFactor = min(1.0, mixBlur * reflectorRoughnessFactor);
        merge = mix(merge, blur, blurFactor);
      #endif

      vec4 newMerge = vec4(0.0, 0.0, 0.0, 1.0);
      newMerge.r = (merge.r - 0.5) * mixContrast + 0.5;
      newMerge.g = (merge.g - 0.5) * mixContrast + 0.5;
      newMerge.b = (merge.b - 0.5) * mixContrast + 0.5;

      diffuseColor.rgb = diffuseColor.rgb * ((1.0 - min(1.0, mirror)) + newMerge.rgb * mixStrength);
      `
    );
  }
  get tDiffuse() {
    var _a4;
    return (_a4 = this._tDiffuse) == null ? void 0 : _a4.value;
  }
  set tDiffuse(v) {
    this._tDiffuse.value = v;
  }
  get tDepth() {
    var _a4;
    return (_a4 = this._tDepth) == null ? void 0 : _a4.value;
  }
  set tDepth(v) {
    this._tDepth.value = v;
  }
  get distortionMap() {
    var _a4;
    return (_a4 = this._distortionMap) == null ? void 0 : _a4.value;
  }
  set distortionMap(v) {
    this._distortionMap.value = v;
  }
  get tDiffuseBlur() {
    var _a4;
    return (_a4 = this._tDiffuseBlur) == null ? void 0 : _a4.value;
  }
  set tDiffuseBlur(v) {
    this._tDiffuseBlur.value = v;
  }
  get textureMatrix() {
    var _a4;
    return (_a4 = this._textureMatrix) == null ? void 0 : _a4.value;
  }
  set textureMatrix(v) {
    this._textureMatrix.value = v;
  }
  get hasBlur() {
    var _a4;
    return (_a4 = this._hasBlur) == null ? void 0 : _a4.value;
  }
  set hasBlur(v) {
    this._hasBlur.value = v;
  }
  get mirror() {
    var _a4;
    return (_a4 = this._mirror) == null ? void 0 : _a4.value;
  }
  set mirror(v) {
    this._mirror.value = v;
  }
  get mixBlur() {
    var _a4;
    return (_a4 = this._mixBlur) == null ? void 0 : _a4.value;
  }
  set mixBlur(v) {
    this._mixBlur.value = v;
  }
  get mixStrength() {
    var _a4;
    return (_a4 = this._blurStrength) == null ? void 0 : _a4.value;
  }
  set mixStrength(v) {
    this._blurStrength.value = v;
  }
  get minDepthThreshold() {
    var _a4;
    return (_a4 = this._minDepthThreshold) == null ? void 0 : _a4.value;
  }
  set minDepthThreshold(v) {
    this._minDepthThreshold.value = v;
  }
  get maxDepthThreshold() {
    var _a4;
    return (_a4 = this._maxDepthThreshold) == null ? void 0 : _a4.value;
  }
  set maxDepthThreshold(v) {
    this._maxDepthThreshold.value = v;
  }
  get depthScale() {
    var _a4;
    return (_a4 = this._depthScale) == null ? void 0 : _a4.value;
  }
  set depthScale(v) {
    this._depthScale.value = v;
  }
  get depthToBlurRatioBias() {
    var _a4;
    return (_a4 = this._depthToBlurRatioBias) == null ? void 0 : _a4.value;
  }
  set depthToBlurRatioBias(v) {
    this._depthToBlurRatioBias.value = v;
  }
  get distortion() {
    var _a4;
    return (_a4 = this._distortion) == null ? void 0 : _a4.value;
  }
  set distortion(v) {
    this._distortion.value = v;
  }
  get mixContrast() {
    var _a4;
    return (_a4 = this._mixContrast) == null ? void 0 : _a4.value;
  }
  set mixContrast(v) {
    this._mixContrast.value = v;
  }
};

// node_modules/kokomi.js/dist/lib/THREE-CustomShaderMaterial/vanilla.js
var import_blueimp_md5 = __toESM(require_md5());

// node_modules/kokomi.js/dist/lib/THREE-CustomShaderMaterial/keywords.js
var keywords_default = {
  position: "csm_Position",
  positionRaw: "csm_PositionRaw",
  pointSize: "csm_PointSize",
  fragColor: "csm_FragColor",
  // PBR
  diffuseColor: "csm_DiffuseColor",
  normal: "csm_Normal",
  roughness: "csm_Roughness",
  metalness: "csm_Metalness",
  emissive: "csm_Emissive"
};

// node_modules/kokomi.js/dist/lib/THREE-CustomShaderMaterial/patchMaps.js
var defaultPatchMap = {
  // VERT
  [`${keywords_default.normal}`]: {
    "#include <beginnormal_vertex>": `
    vec3 objectNormal = ${keywords_default.normal};
    #ifdef USE_TANGENT
	    vec3 objectTangent = vec3( tangent.xyz );
    #endif
    `
  },
  [`${keywords_default.position}`]: {
    "#include <begin_vertex>": `
    vec3 transformed = ${keywords_default.position};
  `
  },
  [`${keywords_default.positionRaw}`]: {
    "#include <begin_vertex>": `
    vec4 csm_positionUnprojected = ${keywords_default.positionRaw};
    mat4x4 csm_unprojectMatrix = projectionMatrix * modelViewMatrix;
    #ifdef USE_INSTANCING
      csm_unprojectMatrix = csm_unprojectMatrix * instanceMatrix;
    #endif
    csm_positionUnprojected = inverse(csm_unprojectMatrix) * csm_positionUnprojected;
    vec3 transformed = csm_positionUnprojected.xyz;
  `
  },
  [`${keywords_default.pointSize}`]: {
    "gl_PointSize = size;": `
    gl_PointSize = ${keywords_default.pointSize};
    `
  },
  // FRAG
  [`${keywords_default.diffuseColor}`]: {
    "#include <color_fragment>": `
    #include <color_fragment>
    diffuseColor = ${keywords_default.diffuseColor};
  `
  },
  [`${keywords_default.fragColor}`]: {
    "#include <dithering_fragment>": `
    #include <dithering_fragment>
    gl_FragColor  = ${keywords_default.fragColor};
  `
  },
  [`${keywords_default.emissive}`]: {
    "vec3 totalEmissiveRadiance = emissive;": `
    vec3 totalEmissiveRadiance = ${keywords_default.emissive};
    `
  },
  [`${keywords_default.roughness}`]: {
    "#include <roughnessmap_fragment>": `
    #include <roughnessmap_fragment>
    roughnessFactor = ${keywords_default.roughness};
    `
  },
  [`${keywords_default.metalness}`]: {
    "#include <metalnessmap_fragment>": `
    #include <metalnessmap_fragment>
    metalnessFactor = ${keywords_default.metalness};
    `
  }
};
var shaderMaterial_PatchMap = {
  // VERT
  [`${keywords_default.position}`]: {
    "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );": `
    gl_Position = projectionMatrix * modelViewMatrix * vec4( ${keywords_default.position}, 1.0 );
  `
  },
  [`${keywords_default.positionRaw}`]: {
    "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );": `
    gl_Position = ${keywords_default.position};
  `
  },
  // FRAG
  [`${keywords_default.diffuseColor}`]: {
    "gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );": `
    gl_FragColor = ${keywords_default.diffuseColor};
  `
  },
  [`${keywords_default.fragColor}`]: {
    "gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );": `
    gl_FragColor = ${keywords_default.fragColor};
  `
  }
};

// node_modules/kokomi.js/dist/lib/THREE-CustomShaderMaterial/vanilla.js
var import_glsl_tokenizer = __toESM(require_string());
var import_glsl_token_string = __toESM(require_glsl_token_string());
var import_glsl_token_functions = __toESM(require_glsl_token_functions());

// node_modules/kokomi.js/dist/lib/THREE-CustomShaderMaterial/shaders.js
var defaultDefinitions = (
  /* glsl */
  `

#ifdef IS_VERTEX
    vec3 csm_Position = position;
    vec4 csm_PositionRaw = projectionMatrix * modelViewMatrix * vec4(position, 1.);
    vec3 csm_Normal = normal;
#else
    #if defined IS_SHADERMATERIAL || defined IS_MESHDEPTHMATERIAL || defined IS_MESHNORMALMATERIAL
        vec4 csm_DiffuseColor = vec4(1., 0., 1., 1.);
        vec4 csm_FragColor = vec4(1., 0., 1., 1.);
    #else
        #if defined IS_MESHSTANDARDMATERIAL || defined IS_MESHPHYSICALMATERIAL
            vec3 csm_Emissive = emissive;
            float csm_Roughness = roughness;
            float csm_Metalness = metalness;
        #endif
        
        #ifdef USE_MAP
            vec4 _csm_sampledDiffuseColor = texture2D(map, vUv);

            #ifdef DECODE_VIDEO_TEXTURE
            // inline sRGB decode (TODO: Remove this code when https://crbug.com/1256340 is solved)
            _csm_sampledDiffuseColor = vec4(mix(pow(_csm_sampledDiffuseColor.rgb * 0.9478672986 + vec3(0.0521327014), vec3(2.4)), _csm_sampledDiffuseColor.rgb * 0.0773993808, vec3(lessThanEqual(_csm_sampledDiffuseColor.rgb, vec3(0.04045)))), _csm_sampledDiffuseColor.w);
            #endif

            vec4 csm_DiffuseColor = vec4(diffuse, opacity) * _csm_sampledDiffuseColor;
            vec4 csm_FragColor = vec4(diffuse, opacity) * _csm_sampledDiffuseColor;
        #else
            vec4 csm_DiffuseColor = vec4(diffuse, opacity);
            vec4 csm_FragColor = vec4(diffuse, opacity);
        #endif
    #endif
#endif
`
);

// node_modules/kokomi.js/dist/lib/THREE-CustomShaderMaterial/vanilla.js
var hash = (str) => (0, import_blueimp_md5.default)(JSON.stringify(str));
var replaceAll = (str, find, rep) => str.split(find).join(rep);
var escapeRegExpMatch = function(s) {
  return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
};
var isExactMatch = (str, match) => {
  return new RegExp(`\\b${escapeRegExpMatch(match)}\\b`).test(str);
};
function isConstructor(f) {
  try {
    new f();
  } catch (err) {
    if (err.message.indexOf("is not a constructor") >= 0) {
      return false;
    }
  }
  return true;
}
var CustomShaderMaterial = class extends Material {
  constructor({ baseMaterial, fragmentShader, vertexShader, uniforms, patchMap, cacheKey, ...opts }) {
    let base;
    if (isConstructor(baseMaterial)) {
      base = new baseMaterial(opts);
    } else {
      base = baseMaterial;
      Object.assign(base, opts);
    }
    if (base.type === "RawShaderMaterial") {
      throw new Error("CustomShaderMaterial does not support RawShaderMaterial");
    }
    super();
    __publicField(this, "uniforms");
    __publicField(this, "_customPatchMap");
    __publicField(this, "_fs");
    __publicField(this, "_vs");
    __publicField(this, "_cacheKey");
    __publicField(this, "_base");
    __publicField(this, "_instanceID");
    __publicField(this, "_type");
    this.uniforms = uniforms || {};
    this._customPatchMap = patchMap || {};
    this._fs = fragmentShader || "";
    this._vs = vertexShader || "";
    this._cacheKey = cacheKey;
    this._base = baseMaterial;
    this._type = base.type;
    this._instanceID = MathUtils.generateUUID();
    for (const key in base) {
      let k = key;
      if (key.startsWith("_")) {
        k = key.split("_")[1];
      }
      if (this[k] === void 0)
        this[k] = 0;
      this[k] = base[k];
    }
    this.update({ fragmentShader, vertexShader, uniforms, cacheKey });
  }
  update(opts) {
    var _a4;
    const uniforms = (opts == null ? void 0 : opts.uniforms) || {};
    const fragmentShader = (opts == null ? void 0 : opts.fragmentShader) || this._fs;
    const vertexShader = (opts == null ? void 0 : opts.vertexShader) || this._vs;
    const serializedUniforms = Object.values(uniforms).reduce((prev, { value }) => {
      return prev + JSON.stringify(value);
    }, "");
    this.uuid = ((_a4 = opts == null ? void 0 : opts.cacheKey) == null ? void 0 : _a4.call(opts)) || hash([
      fragmentShader,
      vertexShader,
      serializedUniforms,
      this._instanceID
    ]);
    this.generateMaterial({
      fragmentShader,
      vertexShader,
      uniforms
    });
  }
  clone() {
    const c3 = new this.constructor({
      baseMaterial: this._base,
      fragmentShader: this._fs,
      vertexShader: this._vs,
      patchMap: this._customPatchMap,
      uniforms: this.uniforms,
      cacheKey: this._cacheKey
    });
    for (const key in this) {
      if (key === "uuid")
        continue;
      c3[key] = this[key];
    }
    return c3;
  }
  generateMaterial({ fragmentShader, vertexShader, uniforms }) {
    const parsedFragmentShader = this.parseShader(fragmentShader);
    const parsedVertexShader = this.parseShader(vertexShader);
    this.uniforms = uniforms || {};
    this.customProgramCacheKey = () => {
      return this.uuid;
    };
    this.onBeforeCompile = (shader) => {
      if (parsedFragmentShader) {
        const patchedFragmentShader = this.patchShader(parsedFragmentShader, shader.fragmentShader);
        shader.fragmentShader = this.getMaterialDefine() + patchedFragmentShader;
      }
      if (parsedVertexShader) {
        const patchedVertexShader = this.patchShader(parsedVertexShader, shader.vertexShader);
        shader.vertexShader = "#define IS_VERTEX;\n" + patchedVertexShader;
        shader.vertexShader = this.getMaterialDefine() + shader.vertexShader;
      }
      shader.uniforms = { ...shader.uniforms, ...this.uniforms };
      this.uniforms = shader.uniforms;
    };
    this.needsUpdate = true;
  }
  getMaterialDefine() {
    return `#define IS_${this._type.toUpperCase()};
`;
  }
  getPatchMapForMaterial() {
    switch (this._type) {
      case "ShaderMaterial":
        return shaderMaterial_PatchMap;
      default:
        return defaultPatchMap;
    }
  }
  patchShader(customShader, shader) {
    let patchedShader = shader;
    const patchMap = {
      ...this.getPatchMapForMaterial(),
      ...this._customPatchMap
    };
    Object.keys(patchMap).forEach((name) => {
      Object.keys(patchMap[name]).forEach((key) => {
        if (isExactMatch(customShader.main, name)) {
          patchedShader = replaceAll(patchedShader, key, patchMap[name][key]);
        }
      });
    });
    patchedShader = patchedShader.replace("void main() {", `
          ${customShader.header}
          void main() {
            ${defaultDefinitions}
            ${customShader.main}
          `);
    patchedShader = customShader.defines + patchedShader;
    return patchedShader;
  }
  parseShader(shader) {
    if (!shader)
      return;
    const s = shader.replace(/\/\*\*(.*?)\*\/|\/\/(.*?)\n/gm, "");
    const tokens = (0, import_glsl_tokenizer.default)(s);
    const funcs = (0, import_glsl_token_functions.default)(tokens);
    const mainIndex = funcs.map((e) => {
      return e.name;
    }).indexOf("main");
    const variables = (0, import_glsl_token_string.default)(tokens.slice(0, mainIndex >= 0 ? funcs[mainIndex].outer[0] : void 0));
    const mainBody = mainIndex >= 0 ? this.getShaderFromIndex(tokens, funcs[mainIndex].body) : "";
    return {
      defines: "",
      header: variables,
      main: mainBody
    };
  }
  getShaderFromIndex(tokens, index) {
    return (0, import_glsl_token_string.default)(tokens.slice(index[0], index[1]));
  }
};

// node_modules/kokomi.js/dist/lib/three-stdlib/objects/reflector.js
var Reflector2 = class extends Mesh {
  constructor(geometry2, options = {}) {
    super(geometry2);
    __publicField(this, "ignoreObjects");
    __publicField(this, "isReflector");
    __publicField(this, "camera");
    __publicField(this, "material");
    __publicField(this, "getRenderTarget");
    __publicField(this, "dispose");
    const ignoreObjects = options.ignoreObjects || [];
    this.ignoreObjects = ignoreObjects;
    this.isReflector = true;
    this.type = "Reflector";
    this.camera = new PerspectiveCamera();
    const scope = this;
    const color = options.color !== void 0 ? new Color(options.color) : new Color(8355711);
    const textureWidth = options.textureWidth || 512;
    const textureHeight = options.textureHeight || 512;
    const clipBias = options.clipBias || 0;
    const shader = options.shader || Reflector2.ReflectorShader;
    const multisample = options.multisample !== void 0 ? options.multisample : 4;
    const reflectorPlane = new Plane();
    const normal = new Vector3();
    const reflectorWorldPosition = new Vector3();
    const cameraWorldPosition = new Vector3();
    const rotationMatrix2 = new Matrix4();
    const lookAtPosition = new Vector3(0, 0, -1);
    const clipPlane = new Vector4();
    const view = new Vector3();
    const target = new Vector3();
    const q = new Vector4();
    const textureMatrix = new Matrix4();
    const virtualCamera = this.camera;
    const renderTarget = new WebGLRenderTarget(textureWidth, textureHeight, {
      samples: multisample,
      type: HalfFloatType
    });
    const material2 = new ShaderMaterial({
      uniforms: UniformsUtils.clone(shader.uniforms),
      fragmentShader: shader.fragmentShader,
      vertexShader: shader.vertexShader
    });
    material2.uniforms["tDiffuse"].value = renderTarget.texture;
    material2.uniforms["color"].value = color;
    material2.uniforms["textureMatrix"].value = textureMatrix;
    this.material = material2;
    this.onBeforeRender = function(renderer, scene, camera) {
      reflectorWorldPosition.setFromMatrixPosition(scope.matrixWorld);
      cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);
      rotationMatrix2.extractRotation(scope.matrixWorld);
      normal.set(0, 0, 1);
      normal.applyMatrix4(rotationMatrix2);
      view.subVectors(reflectorWorldPosition, cameraWorldPosition);
      if (view.dot(normal) > 0)
        return;
      view.reflect(normal).negate();
      view.add(reflectorWorldPosition);
      rotationMatrix2.extractRotation(camera.matrixWorld);
      lookAtPosition.set(0, 0, -1);
      lookAtPosition.applyMatrix4(rotationMatrix2);
      lookAtPosition.add(cameraWorldPosition);
      target.subVectors(reflectorWorldPosition, lookAtPosition);
      target.reflect(normal).negate();
      target.add(reflectorWorldPosition);
      virtualCamera.position.copy(view);
      virtualCamera.up.set(0, 1, 0);
      virtualCamera.up.applyMatrix4(rotationMatrix2);
      virtualCamera.up.reflect(normal);
      virtualCamera.lookAt(target);
      virtualCamera.far = camera.far;
      virtualCamera.updateMatrixWorld();
      virtualCamera.projectionMatrix.copy(camera.projectionMatrix);
      textureMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);
      textureMatrix.multiply(virtualCamera.projectionMatrix);
      textureMatrix.multiply(virtualCamera.matrixWorldInverse);
      textureMatrix.multiply(scope.matrixWorld);
      reflectorPlane.setFromNormalAndCoplanarPoint(normal, reflectorWorldPosition);
      reflectorPlane.applyMatrix4(virtualCamera.matrixWorldInverse);
      clipPlane.set(reflectorPlane.normal.x, reflectorPlane.normal.y, reflectorPlane.normal.z, reflectorPlane.constant);
      const projectionMatrix = virtualCamera.projectionMatrix;
      q.x = (Math.sign(clipPlane.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];
      q.y = (Math.sign(clipPlane.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];
      q.z = -1;
      q.w = (1 + projectionMatrix.elements[10]) / projectionMatrix.elements[14];
      clipPlane.multiplyScalar(2 / clipPlane.dot(q));
      projectionMatrix.elements[2] = clipPlane.x;
      projectionMatrix.elements[6] = clipPlane.y;
      projectionMatrix.elements[10] = clipPlane.z + 1 - clipBias;
      projectionMatrix.elements[14] = clipPlane.w;
      scope.visible = false;
      ignoreObjects.forEach((item) => {
        item.visible = false;
      });
      const currentRenderTarget = renderer.getRenderTarget();
      const currentXrEnabled = renderer.xr.enabled;
      const currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;
      const currentOutputEncoding = renderer.outputEncoding;
      const currentToneMapping = renderer.toneMapping;
      renderer.xr.enabled = false;
      renderer.shadowMap.autoUpdate = false;
      renderer.outputEncoding = LinearEncoding;
      renderer.toneMapping = NoToneMapping;
      renderer.setRenderTarget(renderTarget);
      renderer.state.buffers.depth.setMask(true);
      if (renderer.autoClear === false)
        renderer.clear();
      renderer.render(scene, virtualCamera);
      renderer.xr.enabled = currentXrEnabled;
      renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;
      renderer.outputEncoding = currentOutputEncoding;
      renderer.toneMapping = currentToneMapping;
      renderer.setRenderTarget(currentRenderTarget);
      const viewport = camera.viewport;
      if (viewport !== void 0) {
        renderer.state.viewport(viewport);
      }
      scope.visible = true;
      ignoreObjects.forEach((item) => {
        item.visible = true;
      });
    };
    this.getRenderTarget = function() {
      return renderTarget;
    };
    this.dispose = function() {
      renderTarget.dispose();
      scope.material.dispose();
    };
  }
};
Reflector2.ReflectorShader = {
  uniforms: {
    color: {
      value: null
    },
    tDiffuse: {
      value: null
    },
    textureMatrix: {
      value: null
    }
  },
  vertexShader: (
    /* glsl */
    `
		uniform mat4 textureMatrix;
		varying vec4 vUv;

		#include <common>
		#include <logdepthbuf_pars_vertex>

		void main() {

			vUv = textureMatrix * vec4( position, 1.0 );

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

			#include <logdepthbuf_vertex>

		}`
  ),
  fragmentShader: (
    /* glsl */
    `
		uniform vec3 color;
		uniform sampler2D tDiffuse;
		varying vec4 vUv;

		#include <logdepthbuf_pars_fragment>

		float blendOverlay( float base, float blend ) {

			return( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );

		}

		vec3 blendOverlay( vec3 base, vec3 blend ) {

			return vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );

		}

		void main() {

			#include <logdepthbuf_fragment>

			vec4 base = texture2DProj( tDiffuse, vUv );
			gl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );

			#include <tonemapping_fragment>
			#include <encodings_fragment>

		}`
  )
};

// node_modules/kokomi.js/dist/lib/three-stdlib/libs/fflate.js
var ch22 = {};
var durl = function(c3) {
  return URL.createObjectURL(new Blob([c3], { type: "text/javascript" }));
};
var cwk = function(u) {
  return new Worker(u);
};
try {
  URL.revokeObjectURL(durl(""));
} catch (e) {
  durl = function(c3) {
    return "data:application/javascript;charset=UTF-8," + encodeURI(c3);
  };
  cwk = function(u) {
    return new Worker(u, { type: "module" });
  };
}
var wk2 = function(c3, id, msg, transfer, cb3) {
  var w = cwk(ch22[id] || (ch22[id] = durl(c3)));
  w.onerror = function(e) {
    return cb3(e.error, null);
  };
  w.onmessage = function(e) {
    return cb3(null, e.data);
  };
  w.postMessage(msg, transfer);
  return w;
};
var u82 = Uint8Array;
var u162 = Uint16Array;
var u322 = Uint32Array;
var fleb2 = new u82([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  2,
  2,
  2,
  2,
  3,
  3,
  3,
  3,
  4,
  4,
  4,
  4,
  5,
  5,
  5,
  5,
  0,
  /* unused */
  0,
  0,
  /* impossible */
  0
]);
var fdeb2 = new u82([
  0,
  0,
  0,
  0,
  1,
  1,
  2,
  2,
  3,
  3,
  4,
  4,
  5,
  5,
  6,
  6,
  7,
  7,
  8,
  8,
  9,
  9,
  10,
  10,
  11,
  11,
  12,
  12,
  13,
  13,
  /* unused */
  0,
  0
]);
var clim2 = new u82([
  16,
  17,
  18,
  0,
  8,
  7,
  9,
  6,
  10,
  5,
  11,
  4,
  12,
  3,
  13,
  2,
  14,
  1,
  15
]);
var freb2 = function(eb, start) {
  var b5 = new u162(31);
  for (var i3 = 0; i3 < 31; ++i3) {
    b5[i3] = start += 1 << eb[i3 - 1];
  }
  var r = new u322(b5[30]);
  for (var i3 = 1; i3 < 30; ++i3) {
    for (var j = b5[i3]; j < b5[i3 + 1]; ++j) {
      r[j] = j - b5[i3] << 5 | i3;
    }
  }
  return [b5, r];
};
var _a3 = freb2(fleb2, 2);
var fl2 = _a3[0];
var revfl2 = _a3[1];
fl2[28] = 258, revfl2[258] = 28;
var _b3 = freb2(fdeb2, 0);
var fd2 = _b3[0];
var revfd2 = _b3[1];
var rev2 = new u162(32768);
for (i3 = 0; i3 < 32768; ++i3) {
  x = (i3 & 43690) >>> 1 | (i3 & 21845) << 1;
  x = (x & 52428) >>> 2 | (x & 13107) << 2;
  x = (x & 61680) >>> 4 | (x & 3855) << 4;
  rev2[i3] = ((x & 65280) >>> 8 | (x & 255) << 8) >>> 1;
}
var x;
var i3;
var hMap2 = function(cd, mb, r) {
  var s = cd.length;
  var i3 = 0;
  var l = new u162(mb);
  for (; i3 < s; ++i3)
    ++l[cd[i3] - 1];
  var le = new u162(mb);
  for (i3 = 0; i3 < mb; ++i3) {
    le[i3] = le[i3 - 1] + l[i3 - 1] << 1;
  }
  var co;
  if (r) {
    co = new u162(1 << mb);
    var rvb = 15 - mb;
    for (i3 = 0; i3 < s; ++i3) {
      if (cd[i3]) {
        var sv = i3 << 4 | cd[i3];
        var r_1 = mb - cd[i3];
        var v = le[cd[i3] - 1]++ << r_1;
        for (var m = v | (1 << r_1) - 1; v <= m; ++v) {
          co[rev2[v] >>> rvb] = sv;
        }
      }
    }
  } else {
    co = new u162(s);
    for (i3 = 0; i3 < s; ++i3) {
      if (cd[i3]) {
        co[i3] = rev2[le[cd[i3] - 1]++] >>> 15 - cd[i3];
      }
    }
  }
  return co;
};
var flt2 = new u82(288);
for (i3 = 0; i3 < 144; ++i3)
  flt2[i3] = 8;
var i3;
for (i3 = 144; i3 < 256; ++i3)
  flt2[i3] = 9;
var i3;
for (i3 = 256; i3 < 280; ++i3)
  flt2[i3] = 7;
var i3;
for (i3 = 280; i3 < 288; ++i3)
  flt2[i3] = 8;
var i3;
var fdt2 = new u82(32);
for (i3 = 0; i3 < 32; ++i3)
  fdt2[i3] = 5;
var i3;
var flm2 = hMap2(flt2, 9, 0);
var flrm2 = hMap2(flt2, 9, 1);
var fdm2 = hMap2(fdt2, 5, 0);
var fdrm2 = hMap2(fdt2, 5, 1);
var max2 = function(a4) {
  var m = a4[0];
  for (var i3 = 1; i3 < a4.length; ++i3) {
    if (a4[i3] > m)
      m = a4[i3];
  }
  return m;
};
var bits2 = function(d, p, m) {
  var o = p / 8 | 0;
  return (d[o] | d[o + 1] << 8) >> (p & 7) & m;
};
var bits162 = function(d, p) {
  var o = p / 8 | 0;
  return (d[o] | d[o + 1] << 8 | d[o + 2] << 16) >> (p & 7);
};
var shft2 = function(p) {
  return (p / 8 | 0) + (p & 7 && 1);
};
var slc2 = function(v, s, e) {
  if (s == null || s < 0)
    s = 0;
  if (e == null || e > v.length)
    e = v.length;
  var n = new (v instanceof u162 ? u162 : v instanceof u322 ? u322 : u82)(e - s);
  n.set(v.subarray(s, e));
  return n;
};
var inflt2 = function(dat, buf, st) {
  var sl = dat.length;
  if (!sl || st && !st.l && sl < 5)
    return buf || new u82(0);
  var noBuf = !buf || st;
  var noSt = !st || st.i;
  if (!st)
    st = {};
  if (!buf)
    buf = new u82(sl * 3);
  var cbuf = function(l2) {
    var bl = buf.length;
    if (l2 > bl) {
      var nbuf = new u82(Math.max(bl * 2, l2));
      nbuf.set(buf);
      buf = nbuf;
    }
  };
  var final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;
  var tbts = sl * 8;
  do {
    if (!lm) {
      st.f = final = bits2(dat, pos, 1);
      var type = bits2(dat, pos + 1, 3);
      pos += 3;
      if (!type) {
        var s = shft2(pos) + 4, l = dat[s - 4] | dat[s - 3] << 8, t2 = s + l;
        if (t2 > sl) {
          if (noSt)
            throw "unexpected EOF";
          break;
        }
        if (noBuf)
          cbuf(bt + l);
        buf.set(dat.subarray(s, t2), bt);
        st.b = bt += l, st.p = pos = t2 * 8;
        continue;
      } else if (type == 1)
        lm = flrm2, dm = fdrm2, lbt = 9, dbt = 5;
      else if (type == 2) {
        var hLit = bits2(dat, pos, 31) + 257, hcLen = bits2(dat, pos + 10, 15) + 4;
        var tl = hLit + bits2(dat, pos + 5, 31) + 1;
        pos += 14;
        var ldt = new u82(tl);
        var clt = new u82(19);
        for (var i3 = 0; i3 < hcLen; ++i3) {
          clt[clim2[i3]] = bits2(dat, pos + i3 * 3, 7);
        }
        pos += hcLen * 3;
        var clb = max2(clt), clbmsk = (1 << clb) - 1;
        var clm = hMap2(clt, clb, 1);
        for (var i3 = 0; i3 < tl; ) {
          var r = clm[bits2(dat, pos, clbmsk)];
          pos += r & 15;
          var s = r >>> 4;
          if (s < 16) {
            ldt[i3++] = s;
          } else {
            var c3 = 0, n = 0;
            if (s == 16)
              n = 3 + bits2(dat, pos, 3), pos += 2, c3 = ldt[i3 - 1];
            else if (s == 17)
              n = 3 + bits2(dat, pos, 7), pos += 3;
            else if (s == 18)
              n = 11 + bits2(dat, pos, 127), pos += 7;
            while (n--)
              ldt[i3++] = c3;
          }
        }
        var lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);
        lbt = max2(lt);
        dbt = max2(dt);
        lm = hMap2(lt, lbt, 1);
        dm = hMap2(dt, dbt, 1);
      } else
        throw "invalid block type";
      if (pos > tbts) {
        if (noSt)
          throw "unexpected EOF";
        break;
      }
    }
    if (noBuf)
      cbuf(bt + 131072);
    var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;
    var lpos = pos;
    for (; ; lpos = pos) {
      var c3 = lm[bits162(dat, pos) & lms], sym = c3 >>> 4;
      pos += c3 & 15;
      if (pos > tbts) {
        if (noSt)
          throw "unexpected EOF";
        break;
      }
      if (!c3)
        throw "invalid length/literal";
      if (sym < 256)
        buf[bt++] = sym;
      else if (sym == 256) {
        lpos = pos, lm = null;
        break;
      } else {
        var add = sym - 254;
        if (sym > 264) {
          var i3 = sym - 257, b5 = fleb2[i3];
          add = bits2(dat, pos, (1 << b5) - 1) + fl2[i3];
          pos += b5;
        }
        var d = dm[bits162(dat, pos) & dms], dsym = d >>> 4;
        if (!d)
          throw "invalid distance";
        pos += d & 15;
        var dt = fd2[dsym];
        if (dsym > 3) {
          var b5 = fdeb2[dsym];
          dt += bits162(dat, pos) & (1 << b5) - 1, pos += b5;
        }
        if (pos > tbts) {
          if (noSt)
            throw "unexpected EOF";
          break;
        }
        if (noBuf)
          cbuf(bt + 131072);
        var end = bt + add;
        for (; bt < end; bt += 4) {
          buf[bt] = buf[bt - dt];
          buf[bt + 1] = buf[bt + 1 - dt];
          buf[bt + 2] = buf[bt + 2 - dt];
          buf[bt + 3] = buf[bt + 3 - dt];
        }
        bt = end;
      }
    }
    st.l = lm, st.p = lpos, st.b = bt;
    if (lm)
      final = 1, st.m = lbt, st.d = dm, st.n = dbt;
  } while (!final);
  return bt == buf.length ? buf : slc2(buf, 0, bt);
};
var wbits2 = function(d, p, v) {
  v <<= p & 7;
  var o = p / 8 | 0;
  d[o] |= v;
  d[o + 1] |= v >>> 8;
};
var wbits162 = function(d, p, v) {
  v <<= p & 7;
  var o = p / 8 | 0;
  d[o] |= v;
  d[o + 1] |= v >>> 8;
  d[o + 2] |= v >>> 16;
};
var hTree2 = function(d, mb) {
  var t2 = [];
  for (var i3 = 0; i3 < d.length; ++i3) {
    if (d[i3])
      t2.push({ s: i3, f: d[i3] });
  }
  var s = t2.length;
  var t22 = t2.slice();
  if (!s)
    return [et2, 0];
  if (s == 1) {
    var v = new u82(t2[0].s + 1);
    v[t2[0].s] = 1;
    return [v, 1];
  }
  t2.sort(function(a4, b5) {
    return a4.f - b5.f;
  });
  t2.push({ s: -1, f: 25001 });
  var l = t2[0], r = t2[1], i0 = 0, i1 = 1, i22 = 2;
  t2[0] = { s: -1, f: l.f + r.f, l, r };
  while (i1 != s - 1) {
    l = t2[t2[i0].f < t2[i22].f ? i0++ : i22++];
    r = t2[i0 != i1 && t2[i0].f < t2[i22].f ? i0++ : i22++];
    t2[i1++] = { s: -1, f: l.f + r.f, l, r };
  }
  var maxSym = t22[0].s;
  for (var i3 = 1; i3 < s; ++i3) {
    if (t22[i3].s > maxSym)
      maxSym = t22[i3].s;
  }
  var tr = new u162(maxSym + 1);
  var mbt = ln2(t2[i1 - 1], tr, 0);
  if (mbt > mb) {
    var i3 = 0, dt = 0;
    var lft = mbt - mb, cst = 1 << lft;
    t22.sort(function(a4, b5) {
      return tr[b5.s] - tr[a4.s] || a4.f - b5.f;
    });
    for (; i3 < s; ++i3) {
      var i2_1 = t22[i3].s;
      if (tr[i2_1] > mb) {
        dt += cst - (1 << mbt - tr[i2_1]);
        tr[i2_1] = mb;
      } else
        break;
    }
    dt >>>= lft;
    while (dt > 0) {
      var i2_2 = t22[i3].s;
      if (tr[i2_2] < mb)
        dt -= 1 << mb - tr[i2_2]++ - 1;
      else
        ++i3;
    }
    for (; i3 >= 0 && dt; --i3) {
      var i2_3 = t22[i3].s;
      if (tr[i2_3] == mb) {
        --tr[i2_3];
        ++dt;
      }
    }
    mbt = mb;
  }
  return [new u82(tr), mbt];
};
var ln2 = function(n, l, d) {
  return n.s == -1 ? Math.max(ln2(n.l, l, d + 1), ln2(n.r, l, d + 1)) : l[n.s] = d;
};
var lc2 = function(c3) {
  var s = c3.length;
  while (s && !c3[--s])
    ;
  var cl = new u162(++s);
  var cli = 0, cln = c3[0], cls = 1;
  var w = function(v) {
    cl[cli++] = v;
  };
  for (var i3 = 1; i3 <= s; ++i3) {
    if (c3[i3] == cln && i3 != s)
      ++cls;
    else {
      if (!cln && cls > 2) {
        for (; cls > 138; cls -= 138)
          w(32754);
        if (cls > 2) {
          w(cls > 10 ? cls - 11 << 5 | 28690 : cls - 3 << 5 | 12305);
          cls = 0;
        }
      } else if (cls > 3) {
        w(cln), --cls;
        for (; cls > 6; cls -= 6)
          w(8304);
        if (cls > 2)
          w(cls - 3 << 5 | 8208), cls = 0;
      }
      while (cls--)
        w(cln);
      cls = 1;
      cln = c3[i3];
    }
  }
  return [cl.subarray(0, cli), s];
};
var clen2 = function(cf, cl) {
  var l = 0;
  for (var i3 = 0; i3 < cl.length; ++i3)
    l += cf[i3] * cl[i3];
  return l;
};
var wfblk2 = function(out, pos, dat) {
  var s = dat.length;
  var o = shft2(pos + 2);
  out[o] = s & 255;
  out[o + 1] = s >>> 8;
  out[o + 2] = out[o] ^ 255;
  out[o + 3] = out[o + 1] ^ 255;
  for (var i3 = 0; i3 < s; ++i3)
    out[o + i3 + 4] = dat[i3];
  return (o + 4 + s) * 8;
};
var wblk2 = function(dat, out, final, syms, lf, df, eb, li, bs, bl, p) {
  wbits2(out, p++, final);
  ++lf[256];
  var _a4 = hTree2(lf, 15), dlt = _a4[0], mlb = _a4[1];
  var _b4 = hTree2(df, 15), ddt = _b4[0], mdb = _b4[1];
  var _c = lc2(dlt), lclt = _c[0], nlc = _c[1];
  var _d = lc2(ddt), lcdt = _d[0], ndc = _d[1];
  var lcfreq = new u162(19);
  for (var i3 = 0; i3 < lclt.length; ++i3)
    lcfreq[lclt[i3] & 31]++;
  for (var i3 = 0; i3 < lcdt.length; ++i3)
    lcfreq[lcdt[i3] & 31]++;
  var _e = hTree2(lcfreq, 7), lct = _e[0], mlcb = _e[1];
  var nlcc = 19;
  for (; nlcc > 4 && !lct[clim2[nlcc - 1]]; --nlcc)
    ;
  var flen = bl + 5 << 3;
  var ftlen = clen2(lf, flt2) + clen2(df, fdt2) + eb;
  var dtlen = clen2(lf, dlt) + clen2(df, ddt) + eb + 14 + 3 * nlcc + clen2(lcfreq, lct) + (2 * lcfreq[16] + 3 * lcfreq[17] + 7 * lcfreq[18]);
  if (flen <= ftlen && flen <= dtlen)
    return wfblk2(out, p, dat.subarray(bs, bs + bl));
  var lm, ll, dm, dl;
  wbits2(out, p, 1 + (dtlen < ftlen)), p += 2;
  if (dtlen < ftlen) {
    lm = hMap2(dlt, mlb, 0), ll = dlt, dm = hMap2(ddt, mdb, 0), dl = ddt;
    var llm = hMap2(lct, mlcb, 0);
    wbits2(out, p, nlc - 257);
    wbits2(out, p + 5, ndc - 1);
    wbits2(out, p + 10, nlcc - 4);
    p += 14;
    for (var i3 = 0; i3 < nlcc; ++i3)
      wbits2(out, p + 3 * i3, lct[clim2[i3]]);
    p += 3 * nlcc;
    var lcts = [lclt, lcdt];
    for (var it = 0; it < 2; ++it) {
      var clct = lcts[it];
      for (var i3 = 0; i3 < clct.length; ++i3) {
        var len = clct[i3] & 31;
        wbits2(out, p, llm[len]), p += lct[len];
        if (len > 15)
          wbits2(out, p, clct[i3] >>> 5 & 127), p += clct[i3] >>> 12;
      }
    }
  } else {
    lm = flm2, ll = flt2, dm = fdm2, dl = fdt2;
  }
  for (var i3 = 0; i3 < li; ++i3) {
    if (syms[i3] > 255) {
      var len = syms[i3] >>> 18 & 31;
      wbits162(out, p, lm[len + 257]), p += ll[len + 257];
      if (len > 7)
        wbits2(out, p, syms[i3] >>> 23 & 31), p += fleb2[len];
      var dst = syms[i3] & 31;
      wbits162(out, p, dm[dst]), p += dl[dst];
      if (dst > 3)
        wbits162(out, p, syms[i3] >>> 5 & 8191), p += fdeb2[dst];
    } else {
      wbits162(out, p, lm[syms[i3]]), p += ll[syms[i3]];
    }
  }
  wbits162(out, p, lm[256]);
  return p + ll[256];
};
var deo2 = new u322([
  65540,
  131080,
  131088,
  131104,
  262176,
  1048704,
  1048832,
  2114560,
  2117632
]);
var et2 = new u82(0);
var dflt2 = function(dat, lvl, plvl, pre, post2, lst) {
  var s = dat.length;
  var o = new u82(pre + s + 5 * (1 + Math.ceil(s / 7e3)) + post2);
  var w = o.subarray(pre, o.length - post2);
  var pos = 0;
  if (!lvl || s < 8) {
    for (var i3 = 0; i3 <= s; i3 += 65535) {
      var e = i3 + 65535;
      if (e < s) {
        pos = wfblk2(w, pos, dat.subarray(i3, e));
      } else {
        w[i3] = lst;
        pos = wfblk2(w, pos, dat.subarray(i3, s));
      }
    }
  } else {
    var opt = deo2[lvl - 1];
    var n = opt >>> 13, c3 = opt & 8191;
    var msk_1 = (1 << plvl) - 1;
    var prev = new u162(32768), head2 = new u162(msk_1 + 1);
    var bs1_1 = Math.ceil(plvl / 3), bs2_1 = 2 * bs1_1;
    var hsh = function(i4) {
      return (dat[i4] ^ dat[i4 + 1] << bs1_1 ^ dat[i4 + 2] << bs2_1) & msk_1;
    };
    var syms = new u322(25e3);
    var lf = new u162(288), df = new u162(32);
    var lc_1 = 0, eb = 0, i3 = 0, li = 0, wi = 0, bs = 0;
    for (; i3 < s; ++i3) {
      var hv = hsh(i3);
      var imod = i3 & 32767, pimod = head2[hv];
      prev[imod] = pimod;
      head2[hv] = imod;
      if (wi <= i3) {
        var rem = s - i3;
        if ((lc_1 > 7e3 || li > 24576) && rem > 423) {
          pos = wblk2(dat, w, 0, syms, lf, df, eb, li, bs, i3 - bs, pos);
          li = lc_1 = eb = 0, bs = i3;
          for (var j = 0; j < 286; ++j)
            lf[j] = 0;
          for (var j = 0; j < 30; ++j)
            df[j] = 0;
        }
        var l = 2, d = 0, ch_1 = c3, dif = imod - pimod & 32767;
        if (rem > 2 && hv == hsh(i3 - dif)) {
          var maxn = Math.min(n, rem) - 1;
          var maxd = Math.min(32767, i3);
          var ml = Math.min(258, rem);
          while (dif <= maxd && --ch_1 && imod != pimod) {
            if (dat[i3 + l] == dat[i3 + l - dif]) {
              var nl = 0;
              for (; nl < ml && dat[i3 + nl] == dat[i3 + nl - dif]; ++nl)
                ;
              if (nl > l) {
                l = nl, d = dif;
                if (nl > maxn)
                  break;
                var mmd = Math.min(dif, nl - 2);
                var md = 0;
                for (var j = 0; j < mmd; ++j) {
                  var ti = i3 - dif + j + 32768 & 32767;
                  var pti = prev[ti];
                  var cd = ti - pti + 32768 & 32767;
                  if (cd > md)
                    md = cd, pimod = ti;
                }
              }
            }
            imod = pimod, pimod = prev[imod];
            dif += imod - pimod + 32768 & 32767;
          }
        }
        if (d) {
          syms[li++] = 268435456 | revfl2[l] << 18 | revfd2[d];
          var lin = revfl2[l] & 31, din = revfd2[d] & 31;
          eb += fleb2[lin] + fdeb2[din];
          ++lf[257 + lin];
          ++df[din];
          wi = i3 + l;
          ++lc_1;
        } else {
          syms[li++] = dat[i3];
          ++lf[dat[i3]];
        }
      }
    }
    pos = wblk2(dat, w, lst, syms, lf, df, eb, li, bs, i3 - bs, pos);
    if (!lst && pos & 7)
      pos = wfblk2(w, pos + 1, et2);
  }
  return slc2(o, 0, pre + shft2(pos) + post2);
};
var crct2 = function() {
  var t2 = new u322(256);
  for (var i3 = 0; i3 < 256; ++i3) {
    var c3 = i3, k = 9;
    while (--k)
      c3 = (c3 & 1 && 3988292384) ^ c3 >>> 1;
    t2[i3] = c3;
  }
  return t2;
}();
var crc2 = function() {
  var c3 = -1;
  return {
    p: function(d) {
      var cr = c3;
      for (var i3 = 0; i3 < d.length; ++i3)
        cr = crct2[cr & 255 ^ d[i3]] ^ cr >>> 8;
      c3 = cr;
    },
    d: function() {
      return ~c3;
    }
  };
};
var adler2 = function() {
  var a4 = 1, b5 = 0;
  return {
    p: function(d) {
      var n = a4, m = b5;
      var l = d.length;
      for (var i3 = 0; i3 != l; ) {
        var e = Math.min(i3 + 2655, l);
        for (; i3 < e; ++i3)
          m += n += d[i3];
        n = (n & 65535) + 15 * (n >> 16), m = (m & 65535) + 15 * (m >> 16);
      }
      a4 = n, b5 = m;
    },
    d: function() {
      a4 %= 65521, b5 %= 65521;
      return (a4 & 255) << 24 | a4 >>> 8 << 16 | (b5 & 255) << 8 | b5 >>> 8;
    }
  };
};
var dopt2 = function(dat, opt, pre, post2, st) {
  return dflt2(dat, opt.level == null ? 6 : opt.level, opt.mem == null ? Math.ceil(Math.max(8, Math.min(13, Math.log(dat.length))) * 1.5) : 12 + opt.mem, pre, post2, !st);
};
var mrg2 = function(a4, b5) {
  var o = {};
  for (var k in a4)
    o[k] = a4[k];
  for (var k in b5)
    o[k] = b5[k];
  return o;
};
var wcln2 = function(fn, fnStr, td3) {
  var dt = fn();
  var st = fn.toString();
  var ks = st.slice(st.indexOf("[") + 1, st.lastIndexOf("]")).replace(/ /g, "").split(",");
  for (var i3 = 0; i3 < dt.length; ++i3) {
    var v = dt[i3], k = ks[i3];
    if (typeof v == "function") {
      fnStr += ";" + k + "=";
      var st_1 = v.toString();
      if (v.prototype) {
        if (st_1.indexOf("[native code]") != -1) {
          var spInd = st_1.indexOf(" ", 8) + 1;
          fnStr += st_1.slice(spInd, st_1.indexOf("(", spInd));
        } else {
          fnStr += st_1;
          for (var t2 in v.prototype)
            fnStr += ";" + k + ".prototype." + t2 + "=" + v.prototype[t2].toString();
        }
      } else
        fnStr += st_1;
    } else
      td3[k] = v;
  }
  return [fnStr, td3];
};
var ch3 = [];
var cbfs2 = function(v) {
  var tl = [];
  for (var k in v) {
    if (v[k] instanceof u82 || v[k] instanceof u162 || v[k] instanceof u322)
      tl.push((v[k] = new v[k].constructor(v[k])).buffer);
  }
  return tl;
};
var wrkr2 = function(fns, init5, id, cb3) {
  var _a4;
  if (!ch3[id]) {
    var fnStr = "", td_1 = {}, m = fns.length - 1;
    for (var i3 = 0; i3 < m; ++i3)
      _a4 = wcln2(fns[i3], fnStr, td_1), fnStr = _a4[0], td_1 = _a4[1];
    ch3[id] = wcln2(fns[m], fnStr, td_1);
  }
  var td3 = mrg2({}, ch3[id][1]);
  return wk2(ch3[id][0] + ";onmessage=function(e){for(var k in e.data)self[k]=e.data[k];onmessage=" + init5.toString() + "}", id, td3, cbfs2(td3), cb3);
};
var bInflt2 = function() {
  return [
    u82,
    u162,
    u322,
    fleb2,
    fdeb2,
    clim2,
    fl2,
    fd2,
    flrm2,
    fdrm2,
    rev2,
    hMap2,
    max2,
    bits2,
    bits162,
    shft2,
    slc2,
    inflt2,
    inflateSync2,
    pbf2,
    gu82
  ];
};
var bDflt2 = function() {
  return [
    u82,
    u162,
    u322,
    fleb2,
    fdeb2,
    clim2,
    revfl2,
    revfd2,
    flm2,
    flt2,
    fdm2,
    fdt2,
    rev2,
    deo2,
    et2,
    hMap2,
    wbits2,
    wbits162,
    hTree2,
    ln2,
    lc2,
    clen2,
    wfblk2,
    wblk2,
    shft2,
    slc2,
    dflt2,
    dopt2,
    deflateSync2,
    pbf2
  ];
};
var gze2 = function() {
  return [gzh2, gzhl2, wbytes2, crc2, crct2];
};
var guze2 = function() {
  return [gzs2, gzl2];
};
var zle2 = function() {
  return [zlh2, wbytes2, adler2];
};
var zule2 = function() {
  return [zlv2];
};
var pbf2 = function(msg) {
  return postMessage(msg, [msg.buffer]);
};
var gu82 = function(o) {
  return o && o.size && new u82(o.size);
};
var astrm2 = function(strm) {
  strm.ondata = function(dat, final) {
    return postMessage([dat, final], [dat.buffer]);
  };
  return function(ev) {
    return strm.push(ev.data[0], ev.data[1]);
  };
};
var astrmify2 = function(fns, strm, opts, init5, id) {
  var t2;
  var w = wrkr2(fns, init5, id, function(err, dat) {
    if (err)
      w.terminate(), strm.ondata.call(strm, err);
    else {
      if (dat[1])
        w.terminate();
      strm.ondata.call(strm, err, dat[0], dat[1]);
    }
  });
  w.postMessage(opts);
  strm.push = function(d, f) {
    if (t2)
      throw "stream finished";
    if (!strm.ondata)
      throw "no stream handler";
    w.postMessage([d, t2 = f], [d.buffer]);
  };
  strm.terminate = function() {
    w.terminate();
  };
};
var b22 = function(d, b5) {
  return d[b5] | d[b5 + 1] << 8;
};
var b42 = function(d, b5) {
  return (d[b5] | d[b5 + 1] << 8 | d[b5 + 2] << 16 | d[b5 + 3] << 24) >>> 0;
};
var b82 = function(d, b5) {
  return b42(d, b5) + b42(d, b5 + 4) * 4294967296;
};
var wbytes2 = function(d, b5, v) {
  for (; v; ++b5)
    d[b5] = v, v >>>= 8;
};
var gzh2 = function(c3, o) {
  var fn = o.filename;
  c3[0] = 31, c3[1] = 139, c3[2] = 8, c3[8] = o.level < 2 ? 4 : o.level == 9 ? 2 : 0, c3[9] = 3;
  if (o.mtime != 0)
    wbytes2(c3, 4, Math.floor(new Date(o.mtime || Date.now()) / 1e3));
  if (fn) {
    c3[3] = 8;
    for (var i3 = 0; i3 <= fn.length; ++i3)
      c3[i3 + 10] = fn.charCodeAt(i3);
  }
};
var gzs2 = function(d) {
  if (d[0] != 31 || d[1] != 139 || d[2] != 8)
    throw "invalid gzip data";
  var flg = d[3];
  var st = 10;
  if (flg & 4)
    st += d[10] | (d[11] << 8) + 2;
  for (var zs = (flg >> 3 & 1) + (flg >> 4 & 1); zs > 0; zs -= !d[st++])
    ;
  return st + (flg & 2);
};
var gzl2 = function(d) {
  var l = d.length;
  return (d[l - 4] | d[l - 3] << 8 | d[l - 2] << 16 | d[l - 1] << 24) >>> 0;
};
var gzhl2 = function(o) {
  return 10 + (o.filename && o.filename.length + 1 || 0);
};
var zlh2 = function(c3, o) {
  var lv = o.level, fl3 = lv == 0 ? 0 : lv < 6 ? 1 : lv == 9 ? 3 : 2;
  c3[0] = 120, c3[1] = fl3 << 6 | (fl3 ? 32 - 2 * fl3 : 1);
};
var zlv2 = function(d) {
  if ((d[0] & 15) != 8 || d[0] >>> 4 > 7 || (d[0] << 8 | d[1]) % 31)
    throw "invalid zlib data";
  if (d[1] & 32)
    throw "invalid zlib data: preset dictionaries not supported";
};
function AsyncCmpStrm2(opts, cb3) {
  if (!cb3 && typeof opts == "function")
    cb3 = opts, opts = {};
  this.ondata = cb3;
  return opts;
}
var Deflate2 = function() {
  function Deflate3(opts, cb3) {
    if (!cb3 && typeof opts == "function")
      cb3 = opts, opts = {};
    this.ondata = cb3;
    this.o = opts || {};
  }
  Deflate3.prototype.p = function(c3, f) {
    this.ondata(dopt2(c3, this.o, 0, 0, !f), f);
  };
  Deflate3.prototype.push = function(chunk, final) {
    if (this.d)
      throw "stream finished";
    if (!this.ondata)
      throw "no stream handler";
    this.d = final;
    this.p(chunk, final || false);
  };
  return Deflate3;
}();
var AsyncDeflate2 = function() {
  function AsyncDeflate3(opts, cb3) {
    astrmify2([
      bDflt2,
      function() {
        return [astrm2, Deflate2];
      }
    ], this, AsyncCmpStrm2.call(this, opts, cb3), function(ev) {
      var strm = new Deflate2(ev.data);
      onmessage = astrm2(strm);
    }, 6);
  }
  return AsyncDeflate3;
}();
function deflateSync2(data, opts) {
  return dopt2(data, opts || {}, 0, 0);
}
var Inflate2 = function() {
  function Inflate3(cb3) {
    this.s = {};
    this.p = new u82(0);
    this.ondata = cb3;
  }
  Inflate3.prototype.e = function(c3) {
    if (this.d)
      throw "stream finished";
    if (!this.ondata)
      throw "no stream handler";
    var l = this.p.length;
    var n = new u82(l + c3.length);
    n.set(this.p), n.set(c3, l), this.p = n;
  };
  Inflate3.prototype.c = function(final) {
    this.d = this.s.i = final || false;
    var bts = this.s.b;
    var dt = inflt2(this.p, this.o, this.s);
    this.ondata(slc2(dt, bts, this.s.b), this.d);
    this.o = slc2(dt, this.s.b - 32768), this.s.b = this.o.length;
    this.p = slc2(this.p, this.s.p / 8 | 0), this.s.p &= 7;
  };
  Inflate3.prototype.push = function(chunk, final) {
    this.e(chunk), this.c(final);
  };
  return Inflate3;
}();
var AsyncInflate2 = function() {
  function AsyncInflate3(cb3) {
    this.ondata = cb3;
    astrmify2([
      bInflt2,
      function() {
        return [astrm2, Inflate2];
      }
    ], this, 0, function() {
      var strm = new Inflate2();
      onmessage = astrm2(strm);
    }, 7);
  }
  return AsyncInflate3;
}();
function inflateSync2(data, out) {
  return inflt2(data, out);
}
var Gzip2 = function() {
  function Gzip3(opts, cb3) {
    this.c = crc2();
    this.l = 0;
    this.v = 1;
    Deflate2.call(this, opts, cb3);
  }
  Gzip3.prototype.push = function(chunk, final) {
    Deflate2.prototype.push.call(this, chunk, final);
  };
  Gzip3.prototype.p = function(c3, f) {
    this.c.p(c3);
    this.l += c3.length;
    var raw = dopt2(c3, this.o, this.v && gzhl2(this.o), f && 8, !f);
    if (this.v)
      gzh2(raw, this.o), this.v = 0;
    if (f)
      wbytes2(raw, raw.length - 8, this.c.d()), wbytes2(raw, raw.length - 4, this.l);
    this.ondata(raw, f);
  };
  return Gzip3;
}();
var AsyncGzip2 = function() {
  function AsyncGzip3(opts, cb3) {
    astrmify2([
      bDflt2,
      gze2,
      function() {
        return [astrm2, Deflate2, Gzip2];
      }
    ], this, AsyncCmpStrm2.call(this, opts, cb3), function(ev) {
      var strm = new Gzip2(ev.data);
      onmessage = astrm2(strm);
    }, 8);
  }
  return AsyncGzip3;
}();
var Gunzip2 = function() {
  function Gunzip3(cb3) {
    this.v = 1;
    Inflate2.call(this, cb3);
  }
  Gunzip3.prototype.push = function(chunk, final) {
    Inflate2.prototype.e.call(this, chunk);
    if (this.v) {
      var s = this.p.length > 3 ? gzs2(this.p) : 4;
      if (s >= this.p.length && !final)
        return;
      this.p = this.p.subarray(s), this.v = 0;
    }
    if (final) {
      if (this.p.length < 8)
        throw "invalid gzip stream";
      this.p = this.p.subarray(0, -8);
    }
    Inflate2.prototype.c.call(this, final);
  };
  return Gunzip3;
}();
var AsyncGunzip2 = function() {
  function AsyncGunzip3(cb3) {
    this.ondata = cb3;
    astrmify2([
      bInflt2,
      guze2,
      function() {
        return [astrm2, Inflate2, Gunzip2];
      }
    ], this, 0, function() {
      var strm = new Gunzip2();
      onmessage = astrm2(strm);
    }, 9);
  }
  return AsyncGunzip3;
}();
var Zlib2 = function() {
  function Zlib3(opts, cb3) {
    this.c = adler2();
    this.v = 1;
    Deflate2.call(this, opts, cb3);
  }
  Zlib3.prototype.push = function(chunk, final) {
    Deflate2.prototype.push.call(this, chunk, final);
  };
  Zlib3.prototype.p = function(c3, f) {
    this.c.p(c3);
    var raw = dopt2(c3, this.o, this.v && 2, f && 4, !f);
    if (this.v)
      zlh2(raw, this.o), this.v = 0;
    if (f)
      wbytes2(raw, raw.length - 4, this.c.d());
    this.ondata(raw, f);
  };
  return Zlib3;
}();
var AsyncZlib2 = function() {
  function AsyncZlib3(opts, cb3) {
    astrmify2([
      bDflt2,
      zle2,
      function() {
        return [astrm2, Deflate2, Zlib2];
      }
    ], this, AsyncCmpStrm2.call(this, opts, cb3), function(ev) {
      var strm = new Zlib2(ev.data);
      onmessage = astrm2(strm);
    }, 10);
  }
  return AsyncZlib3;
}();
var Unzlib2 = function() {
  function Unzlib3(cb3) {
    this.v = 1;
    Inflate2.call(this, cb3);
  }
  Unzlib3.prototype.push = function(chunk, final) {
    Inflate2.prototype.e.call(this, chunk);
    if (this.v) {
      if (this.p.length < 2 && !final)
        return;
      this.p = this.p.subarray(2), this.v = 0;
    }
    if (final) {
      if (this.p.length < 4)
        throw "invalid zlib stream";
      this.p = this.p.subarray(0, -4);
    }
    Inflate2.prototype.c.call(this, final);
  };
  return Unzlib3;
}();
var AsyncUnzlib2 = function() {
  function AsyncUnzlib3(cb3) {
    this.ondata = cb3;
    astrmify2([
      bInflt2,
      zule2,
      function() {
        return [astrm2, Inflate2, Unzlib2];
      }
    ], this, 0, function() {
      var strm = new Unzlib2();
      onmessage = astrm2(strm);
    }, 11);
  }
  return AsyncUnzlib3;
}();
function unzlibSync2(data, out) {
  return inflt2((zlv2(data), data.subarray(2, -4)), out);
}
var Decompress2 = function() {
  function Decompress3(cb3) {
    this.G = Gunzip2;
    this.I = Inflate2;
    this.Z = Unzlib2;
    this.ondata = cb3;
  }
  Decompress3.prototype.push = function(chunk, final) {
    if (!this.ondata)
      throw "no stream handler";
    if (!this.s) {
      if (this.p && this.p.length) {
        var n = new u82(this.p.length + chunk.length);
        n.set(this.p), n.set(chunk, this.p.length);
      } else
        this.p = chunk;
      if (this.p.length > 2) {
        var _this_1 = this;
        var cb3 = function() {
          _this_1.ondata.apply(_this_1, arguments);
        };
        this.s = this.p[0] == 31 && this.p[1] == 139 && this.p[2] == 8 ? new this.G(cb3) : (this.p[0] & 15) != 8 || this.p[0] >> 4 > 7 || (this.p[0] << 8 | this.p[1]) % 31 ? new this.I(cb3) : new this.Z(cb3);
        this.s.push(this.p, final);
        this.p = null;
      }
    } else
      this.s.push(chunk, final);
  };
  return Decompress3;
}();
var AsyncDecompress2 = function() {
  function AsyncDecompress3(cb3) {
    this.G = AsyncGunzip2;
    this.I = AsyncInflate2;
    this.Z = AsyncUnzlib2;
    this.ondata = cb3;
  }
  AsyncDecompress3.prototype.push = function(chunk, final) {
    Decompress2.prototype.push.call(this, chunk, final);
  };
  return AsyncDecompress3;
}();
var te2 = typeof TextEncoder != "undefined" && new TextEncoder();
var td2 = typeof TextDecoder != "undefined" && new TextDecoder();
var tds2 = 0;
try {
  td2.decode(et2, { stream: true });
  tds2 = 1;
} catch (e) {
}
var dutf82 = function(d) {
  for (var r = "", i3 = 0; ; ) {
    var c3 = d[i3++];
    var eb = (c3 > 127) + (c3 > 223) + (c3 > 239);
    if (i3 + eb > d.length)
      return [r, slc2(d, i3 - 1)];
    if (!eb)
      r += String.fromCharCode(c3);
    else if (eb == 3) {
      c3 = ((c3 & 15) << 18 | (d[i3++] & 63) << 12 | (d[i3++] & 63) << 6 | d[i3++] & 63) - 65536, r += String.fromCharCode(55296 | c3 >> 10, 56320 | c3 & 1023);
    } else if (eb & 1)
      r += String.fromCharCode((c3 & 31) << 6 | d[i3++] & 63);
    else
      r += String.fromCharCode((c3 & 15) << 12 | (d[i3++] & 63) << 6 | d[i3++] & 63);
  }
};
var DecodeUTF82 = function() {
  function DecodeUTF83(cb3) {
    this.ondata = cb3;
    if (tds2)
      this.t = new TextDecoder();
    else
      this.p = et2;
  }
  DecodeUTF83.prototype.push = function(chunk, final) {
    if (!this.ondata)
      throw "no callback";
    final = !!final;
    if (this.t) {
      this.ondata(this.t.decode(chunk, { stream: true }), final);
      if (final) {
        if (this.t.decode().length)
          throw "invalid utf-8 data";
        this.t = null;
      }
      return;
    }
    if (!this.p)
      throw "stream finished";
    var dat = new u82(this.p.length + chunk.length);
    dat.set(this.p);
    dat.set(chunk, this.p.length);
    var _a4 = dutf82(dat), ch4 = _a4[0], np = _a4[1];
    if (final) {
      if (np.length)
        throw "invalid utf-8 data";
      this.p = null;
    } else
      this.p = np;
    this.ondata(ch4, final);
  };
  return DecodeUTF83;
}();
var EncodeUTF82 = function() {
  function EncodeUTF83(cb3) {
    this.ondata = cb3;
  }
  EncodeUTF83.prototype.push = function(chunk, final) {
    if (!this.ondata)
      throw "no callback";
    if (this.d)
      throw "stream finished";
    this.ondata(strToU82(chunk), this.d = final || false);
  };
  return EncodeUTF83;
}();
function strToU82(str, latin1) {
  if (latin1) {
    var ar_1 = new u82(str.length);
    for (var i3 = 0; i3 < str.length; ++i3)
      ar_1[i3] = str.charCodeAt(i3);
    return ar_1;
  }
  if (te2)
    return te2.encode(str);
  var l = str.length;
  var ar = new u82(str.length + (str.length >> 1));
  var ai = 0;
  var w = function(v) {
    ar[ai++] = v;
  };
  for (var i3 = 0; i3 < l; ++i3) {
    if (ai + 5 > ar.length) {
      var n = new u82(ai + 8 + (l - i3 << 1));
      n.set(ar);
      ar = n;
    }
    var c3 = str.charCodeAt(i3);
    if (c3 < 128 || latin1)
      w(c3);
    else if (c3 < 2048)
      w(192 | c3 >> 6), w(128 | c3 & 63);
    else if (c3 > 55295 && c3 < 57344)
      c3 = 65536 + (c3 & 1023 << 10) | str.charCodeAt(++i3) & 1023, w(240 | c3 >> 18), w(128 | c3 >> 12 & 63), w(128 | c3 >> 6 & 63), w(128 | c3 & 63);
    else
      w(224 | c3 >> 12), w(128 | c3 >> 6 & 63), w(128 | c3 & 63);
  }
  return slc2(ar, 0, ai);
}
function strFromU82(dat, latin1) {
  if (latin1) {
    var r = "";
    for (var i3 = 0; i3 < dat.length; i3 += 16384)
      r += String.fromCharCode.apply(null, dat.subarray(i3, i3 + 16384));
    return r;
  } else if (td2)
    return td2.decode(dat);
  else {
    var _a4 = dutf82(dat), out = _a4[0], ext = _a4[1];
    if (ext.length)
      throw "invalid utf-8 data";
    return out;
  }
}
var dbf2 = function(l) {
  return l == 1 ? 3 : l < 6 ? 2 : l == 9 ? 1 : 0;
};
var z64e2 = function(d, b5) {
  for (; b22(d, b5) != 1; b5 += 4 + b22(d, b5 + 2))
    ;
  return [b82(d, b5 + 12), b82(d, b5 + 4), b82(d, b5 + 20)];
};
var exfl2 = function(ex) {
  var le = 0;
  if (ex) {
    for (var k in ex) {
      var l = ex[k].length;
      if (l > 65535)
        throw "extra field too long";
      le += l + 4;
    }
  }
  return le;
};
var wzh2 = function(d, b5, f, fn, u, c3, ce, co) {
  var fl3 = fn.length, ex = f.extra, col = co && co.length;
  var exl = exfl2(ex);
  wbytes2(d, b5, ce != null ? 33639248 : 67324752), b5 += 4;
  if (ce != null)
    d[b5++] = 20, d[b5++] = f.os;
  d[b5] = 20, b5 += 2;
  d[b5++] = f.flag << 1 | (c3 == null && 8), d[b5++] = u && 8;
  d[b5++] = f.compression & 255, d[b5++] = f.compression >> 8;
  var dt = new Date(f.mtime == null ? Date.now() : f.mtime), y = dt.getFullYear() - 1980;
  if (y < 0 || y > 119)
    throw "date not in range 1980-2099";
  wbytes2(d, b5, y << 25 | dt.getMonth() + 1 << 21 | dt.getDate() << 16 | dt.getHours() << 11 | dt.getMinutes() << 5 | dt.getSeconds() >>> 1), b5 += 4;
  if (c3 != null) {
    wbytes2(d, b5, f.crc);
    wbytes2(d, b5 + 4, c3);
    wbytes2(d, b5 + 8, f.size);
  }
  wbytes2(d, b5 + 12, fl3);
  wbytes2(d, b5 + 14, exl), b5 += 16;
  if (ce != null) {
    wbytes2(d, b5, col);
    wbytes2(d, b5 + 6, f.attrs);
    wbytes2(d, b5 + 10, ce), b5 += 14;
  }
  d.set(fn, b5);
  b5 += fl3;
  if (exl) {
    for (var k in ex) {
      var exf = ex[k], l = exf.length;
      wbytes2(d, b5, +k);
      wbytes2(d, b5 + 2, l);
      d.set(exf, b5 + 4), b5 += 4 + l;
    }
  }
  if (col)
    d.set(co, b5), b5 += col;
  return b5;
};
var wzf2 = function(o, b5, c3, d, e) {
  wbytes2(o, b5, 101010256);
  wbytes2(o, b5 + 8, c3);
  wbytes2(o, b5 + 10, c3);
  wbytes2(o, b5 + 12, d);
  wbytes2(o, b5 + 16, e);
};
var ZipPassThrough2 = function() {
  function ZipPassThrough3(filename) {
    this.filename = filename;
    this.c = crc2();
    this.size = 0;
    this.compression = 0;
  }
  ZipPassThrough3.prototype.process = function(chunk, final) {
    this.ondata(null, chunk, final);
  };
  ZipPassThrough3.prototype.push = function(chunk, final) {
    if (!this.ondata)
      throw "no callback - add to ZIP archive before pushing";
    this.c.p(chunk);
    this.size += chunk.length;
    if (final)
      this.crc = this.c.d();
    this.process(chunk, final || false);
  };
  return ZipPassThrough3;
}();
var ZipDeflate2 = function() {
  function ZipDeflate3(filename, opts) {
    var _this_1 = this;
    if (!opts)
      opts = {};
    ZipPassThrough2.call(this, filename);
    this.d = new Deflate2(opts, function(dat, final) {
      _this_1.ondata(null, dat, final);
    });
    this.compression = 8;
    this.flag = dbf2(opts.level);
  }
  ZipDeflate3.prototype.process = function(chunk, final) {
    try {
      this.d.push(chunk, final);
    } catch (e) {
      this.ondata(e, null, final);
    }
  };
  ZipDeflate3.prototype.push = function(chunk, final) {
    ZipPassThrough2.prototype.push.call(this, chunk, final);
  };
  return ZipDeflate3;
}();
var AsyncZipDeflate2 = function() {
  function AsyncZipDeflate3(filename, opts) {
    var _this_1 = this;
    if (!opts)
      opts = {};
    ZipPassThrough2.call(this, filename);
    this.d = new AsyncDeflate2(opts, function(err, dat, final) {
      _this_1.ondata(err, dat, final);
    });
    this.compression = 8;
    this.flag = dbf2(opts.level);
    this.terminate = this.d.terminate;
  }
  AsyncZipDeflate3.prototype.process = function(chunk, final) {
    this.d.push(chunk, final);
  };
  AsyncZipDeflate3.prototype.push = function(chunk, final) {
    ZipPassThrough2.prototype.push.call(this, chunk, final);
  };
  return AsyncZipDeflate3;
}();
var Zip2 = function() {
  function Zip3(cb3) {
    this.ondata = cb3;
    this.u = [];
    this.d = 1;
  }
  Zip3.prototype.add = function(file) {
    var _this_1 = this;
    if (this.d & 2)
      throw "stream finished";
    var f = strToU82(file.filename), fl3 = f.length;
    var com = file.comment, o = com && strToU82(com);
    var u = fl3 != file.filename.length || o && com.length != o.length;
    var hl = fl3 + exfl2(file.extra) + 30;
    if (fl3 > 65535)
      throw "filename too long";
    var header = new u82(hl);
    wzh2(header, 0, file, f, u);
    var chks = [header];
    var pAll = function() {
      for (var _i = 0, chks_1 = chks; _i < chks_1.length; _i++) {
        var chk = chks_1[_i];
        _this_1.ondata(null, chk, false);
      }
      chks = [];
    };
    var tr = this.d;
    this.d = 0;
    var ind = this.u.length;
    var uf = mrg2(file, {
      f,
      u,
      o,
      t: function() {
        if (file.terminate)
          file.terminate();
      },
      r: function() {
        pAll();
        if (tr) {
          var nxt = _this_1.u[ind + 1];
          if (nxt)
            nxt.r();
          else
            _this_1.d = 1;
        }
        tr = 1;
      }
    });
    var cl = 0;
    file.ondata = function(err, dat, final) {
      if (err) {
        _this_1.ondata(err, dat, final);
        _this_1.terminate();
      } else {
        cl += dat.length;
        chks.push(dat);
        if (final) {
          var dd = new u82(16);
          wbytes2(dd, 0, 134695760);
          wbytes2(dd, 4, file.crc);
          wbytes2(dd, 8, cl);
          wbytes2(dd, 12, file.size);
          chks.push(dd);
          uf.c = cl, uf.b = hl + cl + 16, uf.crc = file.crc, uf.size = file.size;
          if (tr)
            uf.r();
          tr = 1;
        } else if (tr)
          pAll();
      }
    };
    this.u.push(uf);
  };
  Zip3.prototype.end = function() {
    var _this_1 = this;
    if (this.d & 2) {
      if (this.d & 1)
        throw "stream finishing";
      throw "stream finished";
    }
    if (this.d)
      this.e();
    else
      this.u.push({
        r: function() {
          if (!(_this_1.d & 1))
            return;
          _this_1.u.splice(-1, 1);
          _this_1.e();
        },
        t: function() {
        }
      });
    this.d = 3;
  };
  Zip3.prototype.e = function() {
    var bt = 0, l = 0, tl = 0;
    for (var _i = 0, _a4 = this.u; _i < _a4.length; _i++) {
      var f = _a4[_i];
      tl += 46 + f.f.length + exfl2(f.extra) + (f.o ? f.o.length : 0);
    }
    var out = new u82(tl + 22);
    for (var _b4 = 0, _c = this.u; _b4 < _c.length; _b4++) {
      var f = _c[_b4];
      wzh2(out, bt, f, f.f, f.u, f.c, l, f.o);
      bt += 46 + f.f.length + exfl2(f.extra) + (f.o ? f.o.length : 0), l += f.b;
    }
    wzf2(out, bt, this.u.length, tl, l);
    this.ondata(null, out, true);
    this.d = 2;
  };
  Zip3.prototype.terminate = function() {
    for (var _i = 0, _a4 = this.u; _i < _a4.length; _i++) {
      var f = _a4[_i];
      f.t();
    }
    this.d = 2;
  };
  return Zip3;
}();
var UnzipPassThrough2 = function() {
  function UnzipPassThrough3() {
  }
  UnzipPassThrough3.prototype.push = function(data, final) {
    this.ondata(null, data, final);
  };
  UnzipPassThrough3.compression = 0;
  return UnzipPassThrough3;
}();
var UnzipInflate2 = function() {
  function UnzipInflate3() {
    var _this_1 = this;
    this.i = new Inflate2(function(dat, final) {
      _this_1.ondata(null, dat, final);
    });
  }
  UnzipInflate3.prototype.push = function(data, final) {
    try {
      this.i.push(data, final);
    } catch (e) {
      this.ondata(e, data, final);
    }
  };
  UnzipInflate3.compression = 8;
  return UnzipInflate3;
}();
var AsyncUnzipInflate2 = function() {
  function AsyncUnzipInflate3(_, sz) {
    var _this_1 = this;
    if (sz < 32e4) {
      this.i = new Inflate2(function(dat, final) {
        _this_1.ondata(null, dat, final);
      });
    } else {
      this.i = new AsyncInflate2(function(err, dat, final) {
        _this_1.ondata(err, dat, final);
      });
      this.terminate = this.i.terminate;
    }
  }
  AsyncUnzipInflate3.prototype.push = function(data, final) {
    if (this.i.terminate)
      data = slc2(data, 0);
    this.i.push(data, final);
  };
  AsyncUnzipInflate3.compression = 8;
  return AsyncUnzipInflate3;
}();
var Unzip2 = function() {
  function Unzip3(cb3) {
    this.onfile = cb3;
    this.k = [];
    this.o = {
      0: UnzipPassThrough2
    };
    this.p = et2;
  }
  Unzip3.prototype.push = function(chunk, final) {
    var _this_1 = this;
    if (!this.onfile)
      throw "no callback";
    if (!this.p)
      throw "stream finished";
    if (this.c > 0) {
      var len = Math.min(this.c, chunk.length);
      var toAdd = chunk.subarray(0, len);
      this.c -= len;
      if (this.d)
        this.d.push(toAdd, !this.c);
      else
        this.k[0].push(toAdd);
      chunk = chunk.subarray(len);
      if (chunk.length)
        return this.push(chunk, final);
    } else {
      var f = 0, i3 = 0, is = void 0, buf = void 0;
      if (!this.p.length)
        buf = chunk;
      else if (!chunk.length)
        buf = this.p;
      else {
        buf = new u82(this.p.length + chunk.length);
        buf.set(this.p), buf.set(chunk, this.p.length);
      }
      var l = buf.length, oc = this.c, add = oc && this.d;
      var _loop_2 = function() {
        var _a4;
        var sig = b42(buf, i3);
        if (sig == 67324752) {
          f = 1, is = i3;
          this_1.d = null;
          this_1.c = 0;
          var bf = b22(buf, i3 + 6), cmp_1 = b22(buf, i3 + 8), u = bf & 2048, dd = bf & 8, fnl = b22(buf, i3 + 26), es = b22(buf, i3 + 28);
          if (l > i3 + 30 + fnl + es) {
            var chks_2 = [];
            this_1.k.unshift(chks_2);
            f = 2;
            var sc_1 = b42(buf, i3 + 18), su_1 = b42(buf, i3 + 22);
            var fn_1 = strFromU82(buf.subarray(i3 + 30, i3 += 30 + fnl), !u);
            if (sc_1 == 4294967295) {
              _a4 = dd ? [-2] : z64e2(buf, i3), sc_1 = _a4[0], su_1 = _a4[1];
            } else if (dd)
              sc_1 = -1;
            i3 += es;
            this_1.c = sc_1;
            var d_1;
            var file_1 = {
              name: fn_1,
              compression: cmp_1,
              start: function() {
                if (!file_1.ondata)
                  throw "no callback";
                if (!sc_1)
                  file_1.ondata(null, et2, true);
                else {
                  var ctr = _this_1.o[cmp_1];
                  if (!ctr)
                    throw "unknown compression type " + cmp_1;
                  d_1 = sc_1 < 0 ? new ctr(fn_1) : new ctr(fn_1, sc_1, su_1);
                  d_1.ondata = function(err, dat3, final2) {
                    file_1.ondata(err, dat3, final2);
                  };
                  for (var _i = 0, chks_3 = chks_2; _i < chks_3.length; _i++) {
                    var dat2 = chks_3[_i];
                    d_1.push(dat2, false);
                  }
                  if (_this_1.k[0] == chks_2 && _this_1.c)
                    _this_1.d = d_1;
                  else
                    d_1.push(et2, true);
                }
              },
              terminate: function() {
                if (d_1 && d_1.terminate)
                  d_1.terminate();
              }
            };
            if (sc_1 >= 0)
              file_1.size = sc_1, file_1.originalSize = su_1;
            this_1.onfile(file_1);
          }
          return "break";
        } else if (oc) {
          if (sig == 134695760) {
            is = i3 += 12 + (oc == -2 && 8), f = 3, this_1.c = 0;
            return "break";
          } else if (sig == 33639248) {
            is = i3 -= 4, f = 3, this_1.c = 0;
            return "break";
          }
        }
      };
      var this_1 = this;
      for (; i3 < l - 4; ++i3) {
        var state_1 = _loop_2();
        if (state_1 === "break")
          break;
      }
      this.p = et2;
      if (oc < 0) {
        var dat = f ? buf.subarray(0, is - 12 - (oc == -2 && 8) - (b42(buf, is - 16) == 134695760 && 4)) : buf.subarray(0, i3);
        if (add)
          add.push(dat, !!f);
        else
          this.k[+(f == 2)].push(dat);
      }
      if (f & 2)
        return this.push(buf.subarray(i3), final);
      this.p = buf.subarray(i3);
    }
    if (final) {
      if (this.c)
        throw "invalid zip file";
      this.p = null;
    }
  };
  Unzip3.prototype.register = function(decoder) {
    this.o[decoder.compression] = decoder;
  };
  return Unzip3;
}();

// node_modules/kokomi.js/dist/lib/three-stdlib/curves/NURBSUtils.js
function findSpan2(p, u, U) {
  const n = U.length - p - 1;
  if (u >= U[n]) {
    return n - 1;
  }
  if (u <= U[p]) {
    return p;
  }
  let low = p;
  let high = n;
  let mid = Math.floor((low + high) / 2);
  while (u < U[mid] || u >= U[mid + 1]) {
    if (u < U[mid]) {
      high = mid;
    } else {
      low = mid;
    }
    mid = Math.floor((low + high) / 2);
  }
  return mid;
}
function calcBasisFunctions2(span, u, p, U) {
  const N = [];
  const left = [];
  const right = [];
  N[0] = 1;
  for (let j = 1; j <= p; ++j) {
    left[j] = u - U[span + 1 - j];
    right[j] = U[span + j] - u;
    let saved = 0;
    for (let r = 0; r < j; ++r) {
      const rv = right[r + 1];
      const lv = left[j - r];
      const temp = N[r] / (rv + lv);
      N[r] = saved + rv * temp;
      saved = lv * temp;
    }
    N[j] = saved;
  }
  return N;
}
function calcBSplinePoint2(p, U, P, u) {
  const span = findSpan2(p, u, U);
  const N = calcBasisFunctions2(span, u, p, U);
  const C2 = new Vector4(0, 0, 0, 0);
  for (let j = 0; j <= p; ++j) {
    const point = P[span - p + j];
    const Nj = N[j];
    const wNj = point.w * Nj;
    C2.x += point.x * wNj;
    C2.y += point.y * wNj;
    C2.z += point.z * wNj;
    C2.w += point.w * Nj;
  }
  return C2;
}
function calcBasisFunctionDerivatives2(span, u, p, n, U) {
  const zeroArr = [];
  for (let i3 = 0; i3 <= p; ++i3)
    zeroArr[i3] = 0;
  const ders = [];
  for (let i3 = 0; i3 <= n; ++i3)
    ders[i3] = zeroArr.slice(0);
  const ndu = [];
  for (let i3 = 0; i3 <= p; ++i3)
    ndu[i3] = zeroArr.slice(0);
  ndu[0][0] = 1;
  const left = zeroArr.slice(0);
  const right = zeroArr.slice(0);
  for (let j = 1; j <= p; ++j) {
    left[j] = u - U[span + 1 - j];
    right[j] = U[span + j] - u;
    let saved = 0;
    for (let r2 = 0; r2 < j; ++r2) {
      const rv = right[r2 + 1];
      const lv = left[j - r2];
      ndu[j][r2] = rv + lv;
      const temp = ndu[r2][j - 1] / ndu[j][r2];
      ndu[r2][j] = saved + rv * temp;
      saved = lv * temp;
    }
    ndu[j][j] = saved;
  }
  for (let j = 0; j <= p; ++j) {
    ders[0][j] = ndu[j][p];
  }
  for (let r2 = 0; r2 <= p; ++r2) {
    let s1 = 0;
    let s2 = 1;
    const a4 = [];
    for (let i3 = 0; i3 <= p; ++i3) {
      a4[i3] = zeroArr.slice(0);
    }
    a4[0][0] = 1;
    for (let k = 1; k <= n; ++k) {
      let d = 0;
      const rk = r2 - k;
      const pk = p - k;
      if (r2 >= k) {
        a4[s2][0] = a4[s1][0] / ndu[pk + 1][rk];
        d = a4[s2][0] * ndu[rk][pk];
      }
      const j1 = rk >= -1 ? 1 : -rk;
      const j2 = r2 - 1 <= pk ? k - 1 : p - r2;
      for (let j3 = j1; j3 <= j2; ++j3) {
        a4[s2][j3] = (a4[s1][j3] - a4[s1][j3 - 1]) / ndu[pk + 1][rk + j3];
        d += a4[s2][j3] * ndu[rk + j3][pk];
      }
      if (r2 <= pk) {
        a4[s2][k] = -a4[s1][k - 1] / ndu[pk + 1][r2];
        d += a4[s2][k] * ndu[r2][pk];
      }
      ders[k][r2] = d;
      const j = s1;
      s1 = s2;
      s2 = j;
    }
  }
  let r = p;
  for (let k = 1; k <= n; ++k) {
    for (let j = 0; j <= p; ++j) {
      ders[k][j] *= r;
    }
    r *= p - k;
  }
  return ders;
}
function calcBSplineDerivatives2(p, U, P, u, nd) {
  const du = nd < p ? nd : p;
  const CK = [];
  const span = findSpan2(p, u, U);
  const nders = calcBasisFunctionDerivatives2(span, u, p, du, U);
  const Pw = [];
  for (let i3 = 0; i3 < P.length; ++i3) {
    const point = P[i3].clone();
    const w = point.w;
    point.x *= w;
    point.y *= w;
    point.z *= w;
    Pw[i3] = point;
  }
  for (let k = 0; k <= du; ++k) {
    const point = Pw[span - p].clone().multiplyScalar(nders[k][0]);
    for (let j = 1; j <= p; ++j) {
      point.add(Pw[span - p + j].clone().multiplyScalar(nders[k][j]));
    }
    CK[k] = point;
  }
  for (let k = du + 1; k <= nd + 1; ++k) {
    CK[k] = new Vector4(0, 0, 0);
  }
  return CK;
}
function calcKoverI2(k, i3) {
  let nom = 1;
  for (let j = 2; j <= k; ++j) {
    nom *= j;
  }
  let denom = 1;
  for (let j = 2; j <= i3; ++j) {
    denom *= j;
  }
  for (let j = 2; j <= k - i3; ++j) {
    denom *= j;
  }
  return nom / denom;
}
function calcRationalCurveDerivatives2(Pders) {
  const nd = Pders.length;
  const Aders = [];
  const wders = [];
  for (let i3 = 0; i3 < nd; ++i3) {
    const point = Pders[i3];
    Aders[i3] = new Vector3(point.x, point.y, point.z);
    wders[i3] = point.w;
  }
  const CK = [];
  for (let k = 0; k < nd; ++k) {
    const v = Aders[k].clone();
    for (let i3 = 1; i3 <= k; ++i3) {
      v.sub(CK[k - i3].clone().multiplyScalar(calcKoverI2(k, i3) * wders[i3]));
    }
    CK[k] = v.divideScalar(wders[0]);
  }
  return CK;
}
function calcNURBSDerivatives2(p, U, P, u, nd) {
  const Pders = calcBSplineDerivatives2(p, U, P, u, nd);
  return calcRationalCurveDerivatives2(Pders);
}

// node_modules/kokomi.js/dist/lib/three-stdlib/curves/NURBSCurve.js
var NURBSCurve2 = class extends Curve {
  constructor(degree, knots, controlPoints, startKnot, endKnot) {
    super();
    this.degree = degree;
    this.knots = knots;
    this.controlPoints = [];
    this.startKnot = startKnot || 0;
    this.endKnot = endKnot || this.knots.length - 1;
    for (let i3 = 0; i3 < controlPoints.length; ++i3) {
      const point = controlPoints[i3];
      this.controlPoints[i3] = new Vector4(point.x, point.y, point.z, point.w);
    }
  }
  getPoint(t2, optionalTarget = new Vector3()) {
    const point = optionalTarget;
    const u = this.knots[this.startKnot] + t2 * (this.knots[this.endKnot] - this.knots[this.startKnot]);
    const hpoint = calcBSplinePoint2(this.degree, this.knots, this.controlPoints, u);
    if (hpoint.w !== 1) {
      hpoint.divideScalar(hpoint.w);
    }
    return point.set(hpoint.x, hpoint.y, hpoint.z);
  }
  getTangent(t2, optionalTarget = new Vector3()) {
    const tangent = optionalTarget;
    const u = this.knots[0] + t2 * (this.knots[this.knots.length - 1] - this.knots[0]);
    const ders = calcNURBSDerivatives2(this.degree, this.knots, this.controlPoints, u, 1);
    tangent.copy(ders[1]).normalize();
    return tangent;
  }
};

// node_modules/kokomi.js/dist/lib/three-stdlib/loaders/FBXLoader.js
var fbxTree2;
var connections2;
var sceneGraph2;
var FBXLoader2 = class extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(url, onLoad, onProgress, onError) {
    const scope = this;
    const path = scope.path === "" ? LoaderUtils.extractUrlBase(url) : scope.path;
    const loader = new FileLoader(this.manager);
    loader.setPath(scope.path);
    loader.setResponseType("arraybuffer");
    loader.setRequestHeader(scope.requestHeader);
    loader.setWithCredentials(scope.withCredentials);
    loader.load(url, function(buffer) {
      try {
        onLoad(scope.parse(buffer, path));
      } catch (e) {
        if (onError) {
          onError(e);
        } else {
          console.error(e);
        }
        scope.manager.itemError(url);
      }
    }, onProgress, onError);
  }
  parse(FBXBuffer, path) {
    if (isFbxFormatBinary2(FBXBuffer)) {
      fbxTree2 = new BinaryParser2().parse(FBXBuffer);
    } else {
      const FBXText = convertArrayBufferToString2(FBXBuffer);
      if (!isFbxFormatASCII2(FBXText)) {
        throw new Error("THREE.FBXLoader: Unknown format.");
      }
      if (getFbxVersion2(FBXText) < 7e3) {
        throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: " + getFbxVersion2(FBXText));
      }
      fbxTree2 = new TextParser2().parse(FBXText);
    }
    const textureLoader = new TextureLoader(this.manager).setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin);
    return new FBXTreeParser2(textureLoader, this.manager).parse(fbxTree2);
  }
};
var FBXTreeParser2 = class {
  constructor(textureLoader, manager) {
    this.textureLoader = textureLoader;
    this.manager = manager;
  }
  parse() {
    connections2 = this.parseConnections();
    const images = this.parseImages();
    const textures = this.parseTextures(images);
    const materials = this.parseMaterials(textures);
    const deformers = this.parseDeformers();
    const geometryMap = new GeometryParser2().parse(deformers);
    this.parseScene(deformers, geometryMap, materials);
    return sceneGraph2;
  }
  // Parses FBXTree.Connections which holds parent-child connections between objects (e.g. material -> texture, model->geometry )
  // and details the connection type
  parseConnections() {
    const connectionMap = /* @__PURE__ */ new Map();
    if ("Connections" in fbxTree2) {
      const rawConnections = fbxTree2.Connections.connections;
      rawConnections.forEach(function(rawConnection) {
        const fromID = rawConnection[0];
        const toID = rawConnection[1];
        const relationship = rawConnection[2];
        if (!connectionMap.has(fromID)) {
          connectionMap.set(fromID, {
            parents: [],
            children: []
          });
        }
        const parentRelationship = { ID: toID, relationship };
        connectionMap.get(fromID).parents.push(parentRelationship);
        if (!connectionMap.has(toID)) {
          connectionMap.set(toID, {
            parents: [],
            children: []
          });
        }
        const childRelationship = { ID: fromID, relationship };
        connectionMap.get(toID).children.push(childRelationship);
      });
    }
    return connectionMap;
  }
  // Parse FBXTree.Objects.Video for embedded image data
  // These images are connected to textures in FBXTree.Objects.Textures
  // via FBXTree.Connections.
  parseImages() {
    const images = {};
    const blobs = {};
    if ("Video" in fbxTree2.Objects) {
      const videoNodes = fbxTree2.Objects.Video;
      for (const nodeID in videoNodes) {
        const videoNode = videoNodes[nodeID];
        const id = parseInt(nodeID);
        images[id] = videoNode.RelativeFilename || videoNode.Filename;
        if ("Content" in videoNode) {
          const arrayBufferContent = videoNode.Content instanceof ArrayBuffer && videoNode.Content.byteLength > 0;
          const base64Content = typeof videoNode.Content === "string" && videoNode.Content !== "";
          if (arrayBufferContent || base64Content) {
            const image = this.parseImage(videoNodes[nodeID]);
            blobs[videoNode.RelativeFilename || videoNode.Filename] = image;
          }
        }
      }
    }
    for (const id in images) {
      const filename = images[id];
      if (blobs[filename] !== void 0)
        images[id] = blobs[filename];
      else
        images[id] = images[id].split("\\").pop();
    }
    return images;
  }
  // Parse embedded image data in FBXTree.Video.Content
  parseImage(videoNode) {
    const content = videoNode.Content;
    const fileName = videoNode.RelativeFilename || videoNode.Filename;
    const extension = fileName.slice(fileName.lastIndexOf(".") + 1).toLowerCase();
    let type;
    switch (extension) {
      case "bmp":
        type = "image/bmp";
        break;
      case "jpg":
      case "jpeg":
        type = "image/jpeg";
        break;
      case "png":
        type = "image/png";
        break;
      case "tif":
        type = "image/tiff";
        break;
      case "tga":
        if (this.manager.getHandler(".tga") === null) {
          console.warn("FBXLoader: TGA loader not found, skipping ", fileName);
        }
        type = "image/tga";
        break;
      default:
        console.warn('FBXLoader: Image type "' + extension + '" is not supported.');
        return;
    }
    if (typeof content === "string") {
      return "data:" + type + ";base64," + content;
    } else {
      const array = new Uint8Array(content);
      return window.URL.createObjectURL(new Blob([array], { type }));
    }
  }
  // Parse nodes in FBXTree.Objects.Texture
  // These contain details such as UV scaling, cropping, rotation etc and are connected
  // to images in FBXTree.Objects.Video
  parseTextures(images) {
    const textureMap = /* @__PURE__ */ new Map();
    if ("Texture" in fbxTree2.Objects) {
      const textureNodes = fbxTree2.Objects.Texture;
      for (const nodeID in textureNodes) {
        const texture = this.parseTexture(textureNodes[nodeID], images);
        textureMap.set(parseInt(nodeID), texture);
      }
    }
    return textureMap;
  }
  // Parse individual node in FBXTree.Objects.Texture
  parseTexture(textureNode, images) {
    const texture = this.loadTexture(textureNode, images);
    texture.ID = textureNode.id;
    texture.name = textureNode.attrName;
    const wrapModeU = textureNode.WrapModeU;
    const wrapModeV = textureNode.WrapModeV;
    const valueU = wrapModeU !== void 0 ? wrapModeU.value : 0;
    const valueV = wrapModeV !== void 0 ? wrapModeV.value : 0;
    texture.wrapS = valueU === 0 ? RepeatWrapping : ClampToEdgeWrapping;
    texture.wrapT = valueV === 0 ? RepeatWrapping : ClampToEdgeWrapping;
    if ("Scaling" in textureNode) {
      const values = textureNode.Scaling.value;
      texture.repeat.x = values[0];
      texture.repeat.y = values[1];
    }
    if ("Translation" in textureNode) {
      const values = textureNode.Translation.value;
      texture.offset.x = values[0];
      texture.offset.y = values[1];
    }
    return texture;
  }
  // load a texture specified as a blob or data URI, or via an external URL using TextureLoader
  loadTexture(textureNode, images) {
    let fileName;
    const currentPath = this.textureLoader.path;
    const children = connections2.get(textureNode.id).children;
    if (children !== void 0 && children.length > 0 && images[children[0].ID] !== void 0) {
      fileName = images[children[0].ID];
      if (fileName.indexOf("blob:") === 0 || fileName.indexOf("data:") === 0) {
        this.textureLoader.setPath(void 0);
      }
    }
    let texture;
    const extension = textureNode.FileName.slice(-3).toLowerCase();
    if (extension === "tga") {
      const loader = this.manager.getHandler(".tga");
      if (loader === null) {
        console.warn("FBXLoader: TGA loader not found, creating placeholder texture for", textureNode.RelativeFilename);
        texture = new Texture();
      } else {
        loader.setPath(this.textureLoader.path);
        texture = loader.load(fileName);
      }
    } else if (extension === "psd") {
      console.warn("FBXLoader: PSD textures are not supported, creating placeholder texture for", textureNode.RelativeFilename);
      texture = new Texture();
    } else {
      texture = this.textureLoader.load(fileName);
    }
    this.textureLoader.setPath(currentPath);
    return texture;
  }
  // Parse nodes in FBXTree.Objects.Material
  parseMaterials(textureMap) {
    const materialMap = /* @__PURE__ */ new Map();
    if ("Material" in fbxTree2.Objects) {
      const materialNodes = fbxTree2.Objects.Material;
      for (const nodeID in materialNodes) {
        const material2 = this.parseMaterial(materialNodes[nodeID], textureMap);
        if (material2 !== null)
          materialMap.set(parseInt(nodeID), material2);
      }
    }
    return materialMap;
  }
  // Parse single node in FBXTree.Objects.Material
  // Materials are connected to texture maps in FBXTree.Objects.Textures
  // FBX format currently only supports Lambert and Phong shading models
  parseMaterial(materialNode, textureMap) {
    const ID = materialNode.id;
    const name = materialNode.attrName;
    let type = materialNode.ShadingModel;
    if (typeof type === "object") {
      type = type.value;
    }
    if (!connections2.has(ID))
      return null;
    const parameters = this.parseParameters(materialNode, textureMap, ID);
    let material2;
    switch (type.toLowerCase()) {
      case "phong":
        material2 = new MeshPhongMaterial();
        break;
      case "lambert":
        material2 = new MeshLambertMaterial();
        break;
      default:
        console.warn('THREE.FBXLoader: unknown material type "%s". Defaulting to MeshPhongMaterial.', type);
        material2 = new MeshPhongMaterial();
        break;
    }
    material2.setValues(parameters);
    material2.name = name;
    return material2;
  }
  // Parse FBX material and return parameters suitable for a three.js material
  // Also parse the texture map and return any textures associated with the material
  parseParameters(materialNode, textureMap, ID) {
    const parameters = {};
    if (materialNode.BumpFactor) {
      parameters.bumpScale = materialNode.BumpFactor.value;
    }
    if (materialNode.Diffuse) {
      parameters.color = new Color().fromArray(materialNode.Diffuse.value).convertSRGBToLinear();
    } else if (materialNode.DiffuseColor && (materialNode.DiffuseColor.type === "Color" || materialNode.DiffuseColor.type === "ColorRGB")) {
      parameters.color = new Color().fromArray(materialNode.DiffuseColor.value).convertSRGBToLinear();
    }
    if (materialNode.DisplacementFactor) {
      parameters.displacementScale = materialNode.DisplacementFactor.value;
    }
    if (materialNode.Emissive) {
      parameters.emissive = new Color().fromArray(materialNode.Emissive.value).convertSRGBToLinear();
    } else if (materialNode.EmissiveColor && (materialNode.EmissiveColor.type === "Color" || materialNode.EmissiveColor.type === "ColorRGB")) {
      parameters.emissive = new Color().fromArray(materialNode.EmissiveColor.value).convertSRGBToLinear();
    }
    if (materialNode.EmissiveFactor) {
      parameters.emissiveIntensity = parseFloat(materialNode.EmissiveFactor.value);
    }
    if (materialNode.Opacity) {
      parameters.opacity = parseFloat(materialNode.Opacity.value);
    }
    if (parameters.opacity < 1) {
      parameters.transparent = true;
    }
    if (materialNode.ReflectionFactor) {
      parameters.reflectivity = materialNode.ReflectionFactor.value;
    }
    if (materialNode.Shininess) {
      parameters.shininess = materialNode.Shininess.value;
    }
    if (materialNode.Specular) {
      parameters.specular = new Color().fromArray(materialNode.Specular.value).convertSRGBToLinear();
    } else if (materialNode.SpecularColor && materialNode.SpecularColor.type === "Color") {
      parameters.specular = new Color().fromArray(materialNode.SpecularColor.value).convertSRGBToLinear();
    }
    const scope = this;
    connections2.get(ID).children.forEach(function(child) {
      const type = child.relationship;
      switch (type) {
        case "Bump":
          parameters.bumpMap = scope.getTexture(textureMap, child.ID);
          break;
        case "Maya|TEX_ao_map":
          parameters.aoMap = scope.getTexture(textureMap, child.ID);
          break;
        case "DiffuseColor":
        case "Maya|TEX_color_map":
          parameters.map = scope.getTexture(textureMap, child.ID);
          if (parameters.map !== void 0) {
            parameters.map.encoding = sRGBEncoding;
          }
          break;
        case "DisplacementColor":
          parameters.displacementMap = scope.getTexture(textureMap, child.ID);
          break;
        case "EmissiveColor":
          parameters.emissiveMap = scope.getTexture(textureMap, child.ID);
          if (parameters.emissiveMap !== void 0) {
            parameters.emissiveMap.encoding = sRGBEncoding;
          }
          break;
        case "NormalMap":
        case "Maya|TEX_normal_map":
          parameters.normalMap = scope.getTexture(textureMap, child.ID);
          break;
        case "ReflectionColor":
          parameters.envMap = scope.getTexture(textureMap, child.ID);
          if (parameters.envMap !== void 0) {
            parameters.envMap.mapping = EquirectangularReflectionMapping;
            parameters.envMap.encoding = sRGBEncoding;
          }
          break;
        case "SpecularColor":
          parameters.specularMap = scope.getTexture(textureMap, child.ID);
          if (parameters.specularMap !== void 0) {
            parameters.specularMap.encoding = sRGBEncoding;
          }
          break;
        case "TransparentColor":
        case "TransparencyFactor":
          parameters.alphaMap = scope.getTexture(textureMap, child.ID);
          parameters.transparent = true;
          break;
        case "AmbientColor":
        case "ShininessExponent":
        case "SpecularFactor":
        case "VectorDisplacementColor":
        default:
          console.warn("THREE.FBXLoader: %s map is not supported in three.js, skipping texture.", type);
          break;
      }
    });
    return parameters;
  }
  // get a texture from the textureMap for use by a material.
  getTexture(textureMap, id) {
    if ("LayeredTexture" in fbxTree2.Objects && id in fbxTree2.Objects.LayeredTexture) {
      console.warn("THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer.");
      id = connections2.get(id).children[0].ID;
    }
    return textureMap.get(id);
  }
  // Parse nodes in FBXTree.Objects.Deformer
  // Deformer node can contain skinning or Vertex Cache animation data, however only skinning is supported here
  // Generates map of Skeleton-like objects for use later when generating and binding skeletons.
  parseDeformers() {
    const skeletons = {};
    const morphTargets = {};
    if ("Deformer" in fbxTree2.Objects) {
      const DeformerNodes = fbxTree2.Objects.Deformer;
      for (const nodeID in DeformerNodes) {
        const deformerNode = DeformerNodes[nodeID];
        const relationships = connections2.get(parseInt(nodeID));
        if (relationships) {
          if (deformerNode.attrType === "Skin") {
            const skeleton = this.parseSkeleton(relationships, DeformerNodes);
            skeleton.ID = nodeID;
            if (relationships.parents.length > 1)
              console.warn("THREE.FBXLoader: skeleton attached to more than one geometry is not supported.");
            skeleton.geometryID = relationships.parents[0].ID;
            skeletons[nodeID] = skeleton;
          } else if (deformerNode.attrType === "BlendShape") {
            const morphTarget = {
              id: nodeID
            };
            morphTarget.rawTargets = this.parseMorphTargets(relationships, DeformerNodes);
            morphTarget.id = nodeID;
            if (relationships.parents.length > 1)
              console.warn("THREE.FBXLoader: morph target attached to more than one geometry is not supported.");
            morphTargets[nodeID] = morphTarget;
          }
        }
      }
    }
    return {
      skeletons,
      morphTargets
    };
  }
  // Parse single nodes in FBXTree.Objects.Deformer
  // The top level skeleton node has type 'Skin' and sub nodes have type 'Cluster'
  // Each skin node represents a skeleton and each cluster node represents a bone
  parseSkeleton(relationships, deformerNodes) {
    const rawBones = [];
    relationships == null ? void 0 : relationships.children.forEach(function(child) {
      const boneNode = deformerNodes[child.ID];
      if (boneNode.attrType !== "Cluster")
        return;
      const rawBone = {
        ID: child.ID,
        indices: [],
        weights: [],
        transformLink: new Matrix4().fromArray(boneNode.TransformLink.a)
        // transform: new Matrix4().fromArray( boneNode.Transform.a ),
        // linkMode: boneNode.Mode,
      };
      if ("Indexes" in boneNode) {
        rawBone.indices = boneNode.Indexes.a;
        rawBone.weights = boneNode.Weights.a;
      }
      rawBones.push(rawBone);
    });
    return {
      rawBones,
      bones: []
    };
  }
  // The top level morph deformer node has type "BlendShape" and sub nodes have type "BlendShapeChannel"
  parseMorphTargets(relationships, deformerNodes) {
    const rawMorphTargets = [];
    for (let i3 = 0; i3 < relationships.children.length; i3++) {
      const child = relationships.children[i3];
      const morphTargetNode = deformerNodes[child.ID];
      const rawMorphTarget = {
        name: morphTargetNode.attrName,
        initialWeight: morphTargetNode.DeformPercent,
        id: morphTargetNode.id,
        fullWeights: morphTargetNode.FullWeights.a
      };
      if (morphTargetNode.attrType !== "BlendShapeChannel")
        return;
      rawMorphTarget.geoID = connections2.get(parseInt(child.ID)).children.filter(function(child2) {
        return child2.relationship === void 0;
      })[0].ID;
      rawMorphTargets.push(rawMorphTarget);
    }
    return rawMorphTargets;
  }
  // create the main Group() to be returned by the loader
  parseScene(deformers, geometryMap, materialMap) {
    sceneGraph2 = new Group();
    const modelMap = this.parseModels(deformers.skeletons, geometryMap, materialMap);
    const modelNodes = fbxTree2.Objects.Model;
    const scope = this;
    modelMap.forEach(function(model) {
      const modelNode = modelNodes[model.ID];
      scope.setLookAtProperties(model, modelNode);
      const parentConnections = connections2.get(model.ID).parents;
      parentConnections.forEach(function(connection) {
        const parent = modelMap.get(connection.ID);
        if (parent !== void 0)
          parent.add(model);
      });
      if (model.parent === null) {
        sceneGraph2.add(model);
      }
    });
    this.bindSkeleton(deformers.skeletons, geometryMap, modelMap);
    this.createAmbientLight();
    sceneGraph2.traverse(function(node) {
      if (node.userData.transformData) {
        if (node.parent) {
          node.userData.transformData.parentMatrix = node.parent.matrix;
          node.userData.transformData.parentMatrixWorld = node.parent.matrixWorld;
        }
        const transform = generateTransform2(node.userData.transformData);
        node.applyMatrix4(transform);
        node.updateWorldMatrix();
      }
    });
    const animations = new AnimationParser2().parse();
    if (sceneGraph2.children.length === 1 && sceneGraph2.children[0].isGroup) {
      sceneGraph2.children[0].animations = animations;
      sceneGraph2 = sceneGraph2.children[0];
    }
    sceneGraph2.animations = animations;
  }
  // parse nodes in FBXTree.Objects.Model
  parseModels(skeletons, geometryMap, materialMap) {
    const modelMap = /* @__PURE__ */ new Map();
    const modelNodes = fbxTree2.Objects.Model;
    for (const nodeID in modelNodes) {
      const id = parseInt(nodeID);
      const node = modelNodes[nodeID];
      const relationships = connections2.get(id);
      let model = this.buildSkeleton(relationships, skeletons, id, node.attrName);
      if (!model) {
        switch (node.attrType) {
          case "Camera":
            model = this.createCamera(relationships);
            break;
          case "Light":
            model = this.createLight(relationships);
            break;
          case "Mesh":
            model = this.createMesh(relationships, geometryMap, materialMap);
            break;
          case "NurbsCurve":
            model = this.createCurve(relationships, geometryMap);
            break;
          case "LimbNode":
          case "Root":
            model = new Bone();
            break;
          case "Null":
          default:
            model = new Group();
            break;
        }
        model.name = node.attrName ? PropertyBinding.sanitizeNodeName(node.attrName) : "";
        model.ID = id;
      }
      this.getTransformData(model, node);
      modelMap.set(id, model);
    }
    return modelMap;
  }
  buildSkeleton(relationships, skeletons, id, name) {
    let bone = null;
    relationships.parents.forEach(function(parent) {
      for (const ID in skeletons) {
        const skeleton = skeletons[ID];
        skeleton.rawBones.forEach(function(rawBone, i3) {
          if (rawBone.ID === parent.ID) {
            const subBone = bone;
            bone = new Bone();
            bone.matrixWorld.copy(rawBone.transformLink);
            bone.name = name ? PropertyBinding.sanitizeNodeName(name) : "";
            bone.ID = id;
            skeleton.bones[i3] = bone;
            if (subBone !== null) {
              bone.add(subBone);
            }
          }
        });
      }
    });
    return bone;
  }
  // create a PerspectiveCamera or OrthographicCamera
  createCamera(relationships) {
    let model;
    let cameraAttribute;
    relationships.children.forEach(function(child) {
      const attr = fbxTree2.Objects.NodeAttribute[child.ID];
      if (attr !== void 0) {
        cameraAttribute = attr;
      }
    });
    if (cameraAttribute === void 0) {
      model = new Object3D();
    } else {
      let type = 0;
      if (cameraAttribute.CameraProjectionType !== void 0 && cameraAttribute.CameraProjectionType.value === 1) {
        type = 1;
      }
      let nearClippingPlane = 1;
      if (cameraAttribute.NearPlane !== void 0) {
        nearClippingPlane = cameraAttribute.NearPlane.value / 1e3;
      }
      let farClippingPlane = 1e3;
      if (cameraAttribute.FarPlane !== void 0) {
        farClippingPlane = cameraAttribute.FarPlane.value / 1e3;
      }
      let width = window.innerWidth;
      let height = window.innerHeight;
      if (cameraAttribute.AspectWidth !== void 0 && cameraAttribute.AspectHeight !== void 0) {
        width = cameraAttribute.AspectWidth.value;
        height = cameraAttribute.AspectHeight.value;
      }
      const aspect = width / height;
      let fov = 45;
      if (cameraAttribute.FieldOfView !== void 0) {
        fov = cameraAttribute.FieldOfView.value;
      }
      const focalLength = cameraAttribute.FocalLength ? cameraAttribute.FocalLength.value : null;
      switch (type) {
        case 0:
          model = new PerspectiveCamera(fov, aspect, nearClippingPlane, farClippingPlane);
          if (focalLength !== null)
            model.setFocalLength(focalLength);
          break;
        case 1:
          model = new OrthographicCamera(-width / 2, width / 2, height / 2, -height / 2, nearClippingPlane, farClippingPlane);
          break;
        default:
          console.warn("THREE.FBXLoader: Unknown camera type " + type + ".");
          model = new Object3D();
          break;
      }
    }
    return model;
  }
  // Create a DirectionalLight, PointLight or SpotLight
  createLight(relationships) {
    let model;
    let lightAttribute;
    relationships.children.forEach(function(child) {
      const attr = fbxTree2.Objects.NodeAttribute[child.ID];
      if (attr !== void 0) {
        lightAttribute = attr;
      }
    });
    if (lightAttribute === void 0) {
      model = new Object3D();
    } else {
      let type;
      if (lightAttribute.LightType === void 0) {
        type = 0;
      } else {
        type = lightAttribute.LightType.value;
      }
      let color = 16777215;
      if (lightAttribute.Color !== void 0) {
        color = new Color().fromArray(lightAttribute.Color.value).convertSRGBToLinear();
      }
      let intensity = lightAttribute.Intensity === void 0 ? 1 : lightAttribute.Intensity.value / 100;
      if (lightAttribute.CastLightOnObject !== void 0 && lightAttribute.CastLightOnObject.value === 0) {
        intensity = 0;
      }
      let distance2 = 0;
      if (lightAttribute.FarAttenuationEnd !== void 0) {
        if (lightAttribute.EnableFarAttenuation !== void 0 && lightAttribute.EnableFarAttenuation.value === 0) {
          distance2 = 0;
        } else {
          distance2 = lightAttribute.FarAttenuationEnd.value;
        }
      }
      const decay = 1;
      switch (type) {
        case 0:
          model = new PointLight(color, intensity, distance2, decay);
          break;
        case 1:
          model = new DirectionalLight(color, intensity);
          break;
        case 2:
          let angle2 = Math.PI / 3;
          if (lightAttribute.InnerAngle !== void 0) {
            angle2 = MathUtils.degToRad(lightAttribute.InnerAngle.value);
          }
          let penumbra = 0;
          if (lightAttribute.OuterAngle !== void 0) {
            penumbra = MathUtils.degToRad(lightAttribute.OuterAngle.value);
            penumbra = Math.max(penumbra, 1);
          }
          model = new SpotLight(color, intensity, distance2, angle2, penumbra, decay);
          break;
        default:
          console.warn("THREE.FBXLoader: Unknown light type " + lightAttribute.LightType.value + ", defaulting to a PointLight.");
          model = new PointLight(color, intensity);
          break;
      }
      if (lightAttribute.CastShadows !== void 0 && lightAttribute.CastShadows.value === 1) {
        model.castShadow = true;
      }
    }
    return model;
  }
  createMesh(relationships, geometryMap, materialMap) {
    let model;
    let geometry2 = null;
    let material2 = null;
    const materials = [];
    relationships.children.forEach(function(child) {
      if (geometryMap.has(child.ID)) {
        geometry2 = geometryMap.get(child.ID);
      }
      if (materialMap.has(child.ID)) {
        materials.push(materialMap.get(child.ID));
      }
    });
    if (materials.length > 1) {
      material2 = materials;
    } else if (materials.length > 0) {
      material2 = materials[0];
    } else {
      material2 = new MeshPhongMaterial({ color: 13421772 });
      materials.push(material2);
    }
    if ("color" in geometry2.attributes) {
      materials.forEach(function(material3) {
        material3.vertexColors = true;
      });
    }
    if (geometry2.FBX_Deformer) {
      model = new SkinnedMesh(geometry2, material2);
      model.normalizeSkinWeights();
    } else {
      model = new Mesh(geometry2, material2);
    }
    return model;
  }
  createCurve(relationships, geometryMap) {
    const geometry2 = relationships.children.reduce(function(geo, child) {
      if (geometryMap.has(child.ID))
        geo = geometryMap.get(child.ID);
      return geo;
    }, null);
    const material2 = new LineBasicMaterial({ color: 3342591, linewidth: 1 });
    return new Line(geometry2, material2);
  }
  // parse the model node for transform data
  getTransformData(model, modelNode) {
    const transformData = {};
    if ("InheritType" in modelNode)
      transformData.inheritType = parseInt(modelNode.InheritType.value);
    if ("RotationOrder" in modelNode)
      transformData.eulerOrder = getEulerOrder2(modelNode.RotationOrder.value);
    else
      transformData.eulerOrder = "ZYX";
    if ("Lcl_Translation" in modelNode)
      transformData.translation = modelNode.Lcl_Translation.value;
    if ("PreRotation" in modelNode)
      transformData.preRotation = modelNode.PreRotation.value;
    if ("Lcl_Rotation" in modelNode)
      transformData.rotation = modelNode.Lcl_Rotation.value;
    if ("PostRotation" in modelNode)
      transformData.postRotation = modelNode.PostRotation.value;
    if ("Lcl_Scaling" in modelNode)
      transformData.scale = modelNode.Lcl_Scaling.value;
    if ("ScalingOffset" in modelNode)
      transformData.scalingOffset = modelNode.ScalingOffset.value;
    if ("ScalingPivot" in modelNode)
      transformData.scalingPivot = modelNode.ScalingPivot.value;
    if ("RotationOffset" in modelNode)
      transformData.rotationOffset = modelNode.RotationOffset.value;
    if ("RotationPivot" in modelNode)
      transformData.rotationPivot = modelNode.RotationPivot.value;
    model.userData.transformData = transformData;
  }
  setLookAtProperties(model, modelNode) {
    if ("LookAtProperty" in modelNode) {
      const children = connections2.get(model.ID).children;
      children.forEach(function(child) {
        if (child.relationship === "LookAtProperty") {
          const lookAtTarget = fbxTree2.Objects.Model[child.ID];
          if ("Lcl_Translation" in lookAtTarget) {
            const pos = lookAtTarget.Lcl_Translation.value;
            if (model.target !== void 0) {
              model.target.position.fromArray(pos);
              sceneGraph2.add(model.target);
            } else {
              model.lookAt(new Vector3().fromArray(pos));
            }
          }
        }
      });
    }
  }
  bindSkeleton(skeletons, geometryMap, modelMap) {
    const bindMatrices = this.parsePoseNodes();
    for (const ID in skeletons) {
      const skeleton = skeletons[ID];
      const parents = connections2.get(parseInt(skeleton.ID)).parents;
      parents.forEach(function(parent) {
        if (geometryMap.has(parent.ID)) {
          const geoID = parent.ID;
          const geoRelationships = connections2.get(geoID);
          geoRelationships.parents.forEach(function(geoConnParent) {
            if (modelMap.has(geoConnParent.ID)) {
              const model = modelMap.get(geoConnParent.ID);
              model.bind(new Skeleton(skeleton.bones), bindMatrices[geoConnParent.ID]);
            }
          });
        }
      });
    }
  }
  parsePoseNodes() {
    const bindMatrices = {};
    if ("Pose" in fbxTree2.Objects) {
      const BindPoseNode = fbxTree2.Objects.Pose;
      for (const nodeID in BindPoseNode) {
        if (BindPoseNode[nodeID].attrType === "BindPose" && BindPoseNode[nodeID].NbPoseNodes > 0) {
          const poseNodes = BindPoseNode[nodeID].PoseNode;
          if (Array.isArray(poseNodes)) {
            poseNodes.forEach(function(poseNode) {
              bindMatrices[poseNode.Node] = new Matrix4().fromArray(poseNode.Matrix.a);
            });
          } else {
            bindMatrices[poseNodes.Node] = new Matrix4().fromArray(poseNodes.Matrix.a);
          }
        }
      }
    }
    return bindMatrices;
  }
  // Parse ambient color in FBXTree.GlobalSettings - if it's not set to black (default), create an ambient light
  createAmbientLight() {
    if ("GlobalSettings" in fbxTree2 && "AmbientColor" in fbxTree2.GlobalSettings) {
      const ambientColor = fbxTree2.GlobalSettings.AmbientColor.value;
      const r = ambientColor[0];
      const g2 = ambientColor[1];
      const b5 = ambientColor[2];
      if (r !== 0 || g2 !== 0 || b5 !== 0) {
        const color = new Color(r, g2, b5).convertSRGBToLinear();
        sceneGraph2.add(new AmbientLight(color, 1));
      }
    }
  }
};
var GeometryParser2 = class {
  constructor() {
    this.negativeMaterialIndices = false;
  }
  // Parse nodes in FBXTree.Objects.Geometry
  parse(deformers) {
    const geometryMap = /* @__PURE__ */ new Map();
    if ("Geometry" in fbxTree2.Objects) {
      const geoNodes = fbxTree2.Objects.Geometry;
      for (const nodeID in geoNodes) {
        const relationships = connections2.get(parseInt(nodeID));
        const geo = this.parseGeometry(relationships, geoNodes[nodeID], deformers);
        geometryMap.set(parseInt(nodeID), geo);
      }
    }
    if (this.negativeMaterialIndices === true) {
      console.warn("THREE.FBXLoader: The FBX file contains invalid (negative) material indices. The asset might not render as expected.");
    }
    return geometryMap;
  }
  // Parse single node in FBXTree.Objects.Geometry
  parseGeometry(relationships, geoNode, deformers) {
    switch (geoNode.attrType) {
      case "Mesh":
        return this.parseMeshGeometry(relationships, geoNode, deformers);
        break;
      case "NurbsCurve":
        return this.parseNurbsGeometry(geoNode);
        break;
    }
  }
  // Parse single node mesh geometry in FBXTree.Objects.Geometry
  parseMeshGeometry(relationships, geoNode, deformers) {
    const skeletons = deformers.skeletons;
    const morphTargets = [];
    const modelNodes = relationships.parents.map(function(parent) {
      return fbxTree2.Objects.Model[parent.ID];
    });
    if (modelNodes.length === 0)
      return;
    const skeleton = relationships.children.reduce(function(skeleton2, child) {
      if (skeletons[child.ID] !== void 0)
        skeleton2 = skeletons[child.ID];
      return skeleton2;
    }, null);
    relationships.children.forEach(function(child) {
      if (deformers.morphTargets[child.ID] !== void 0) {
        morphTargets.push(deformers.morphTargets[child.ID]);
      }
    });
    const modelNode = modelNodes[0];
    const transformData = {};
    if ("RotationOrder" in modelNode)
      transformData.eulerOrder = getEulerOrder2(modelNode.RotationOrder.value);
    if ("InheritType" in modelNode)
      transformData.inheritType = parseInt(modelNode.InheritType.value);
    if ("GeometricTranslation" in modelNode)
      transformData.translation = modelNode.GeometricTranslation.value;
    if ("GeometricRotation" in modelNode)
      transformData.rotation = modelNode.GeometricRotation.value;
    if ("GeometricScaling" in modelNode)
      transformData.scale = modelNode.GeometricScaling.value;
    const transform = generateTransform2(transformData);
    return this.genGeometry(geoNode, skeleton, morphTargets, transform);
  }
  // Generate a BufferGeometry from a node in FBXTree.Objects.Geometry
  genGeometry(geoNode, skeleton, morphTargets, preTransform) {
    const geo = new BufferGeometry();
    if (geoNode.attrName)
      geo.name = geoNode.attrName;
    const geoInfo = this.parseGeoNode(geoNode, skeleton);
    const buffers = this.genBuffers(geoInfo);
    const positionAttribute = new Float32BufferAttribute(buffers.vertex, 3);
    positionAttribute.applyMatrix4(preTransform);
    geo.setAttribute("position", positionAttribute);
    if (buffers.colors.length > 0) {
      geo.setAttribute("color", new Float32BufferAttribute(buffers.colors, 3));
    }
    if (skeleton) {
      geo.setAttribute("skinIndex", new Uint16BufferAttribute(buffers.weightsIndices, 4));
      geo.setAttribute("skinWeight", new Float32BufferAttribute(buffers.vertexWeights, 4));
      geo.FBX_Deformer = skeleton;
    }
    if (buffers.normal.length > 0) {
      const normalMatrix = new Matrix3().getNormalMatrix(preTransform);
      const normalAttribute = new Float32BufferAttribute(buffers.normal, 3);
      normalAttribute.applyNormalMatrix(normalMatrix);
      geo.setAttribute("normal", normalAttribute);
    }
    buffers.uvs.forEach(function(uvBuffer, i3) {
      let name = "uv" + (i3 + 1).toString();
      if (i3 === 0) {
        name = "uv";
      }
      geo.setAttribute(name, new Float32BufferAttribute(buffers.uvs[i3], 2));
    });
    if (geoInfo.material && geoInfo.material.mappingType !== "AllSame") {
      let prevMaterialIndex = buffers.materialIndex[0];
      let startIndex = 0;
      buffers.materialIndex.forEach(function(currentIndex, i3) {
        if (currentIndex !== prevMaterialIndex) {
          geo.addGroup(startIndex, i3 - startIndex, prevMaterialIndex);
          prevMaterialIndex = currentIndex;
          startIndex = i3;
        }
      });
      if (geo.groups.length > 0) {
        const lastGroup = geo.groups[geo.groups.length - 1];
        const lastIndex = lastGroup.start + lastGroup.count;
        if (lastIndex !== buffers.materialIndex.length) {
          geo.addGroup(lastIndex, buffers.materialIndex.length - lastIndex, prevMaterialIndex);
        }
      }
      if (geo.groups.length === 0) {
        geo.addGroup(0, buffers.materialIndex.length, buffers.materialIndex[0]);
      }
    }
    this.addMorphTargets(geo, geoNode, morphTargets, preTransform);
    return geo;
  }
  parseGeoNode(geoNode, skeleton) {
    const geoInfo = {};
    geoInfo.vertexPositions = geoNode.Vertices !== void 0 ? geoNode.Vertices.a : [];
    geoInfo.vertexIndices = geoNode.PolygonVertexIndex !== void 0 ? geoNode.PolygonVertexIndex.a : [];
    if (geoNode.LayerElementColor) {
      geoInfo.color = this.parseVertexColors(geoNode.LayerElementColor[0]);
    }
    if (geoNode.LayerElementMaterial) {
      geoInfo.material = this.parseMaterialIndices(geoNode.LayerElementMaterial[0]);
    }
    if (geoNode.LayerElementNormal) {
      geoInfo.normal = this.parseNormals(geoNode.LayerElementNormal[0]);
    }
    if (geoNode.LayerElementUV) {
      geoInfo.uv = [];
      let i3 = 0;
      while (geoNode.LayerElementUV[i3]) {
        if (geoNode.LayerElementUV[i3].UV) {
          geoInfo.uv.push(this.parseUVs(geoNode.LayerElementUV[i3]));
        }
        i3++;
      }
    }
    geoInfo.weightTable = {};
    if (skeleton !== null) {
      geoInfo.skeleton = skeleton;
      skeleton.rawBones.forEach(function(rawBone, i3) {
        rawBone.indices.forEach(function(index, j) {
          if (geoInfo.weightTable[index] === void 0)
            geoInfo.weightTable[index] = [];
          geoInfo.weightTable[index].push({
            id: i3,
            weight: rawBone.weights[j]
          });
        });
      });
    }
    return geoInfo;
  }
  genBuffers(geoInfo) {
    const buffers = {
      vertex: [],
      normal: [],
      colors: [],
      uvs: [],
      materialIndex: [],
      vertexWeights: [],
      weightsIndices: []
    };
    let polygonIndex = 0;
    let faceLength = 0;
    let displayedWeightsWarning = false;
    let facePositionIndexes = [];
    let faceNormals = [];
    let faceColors = [];
    let faceUVs = [];
    let faceWeights = [];
    let faceWeightIndices = [];
    const scope = this;
    geoInfo.vertexIndices.forEach(function(vertexIndex, polygonVertexIndex) {
      let materialIndex;
      let endOfFace = false;
      if (vertexIndex < 0) {
        vertexIndex = vertexIndex ^ -1;
        endOfFace = true;
      }
      let weightIndices = [];
      let weights = [];
      facePositionIndexes.push(vertexIndex * 3, vertexIndex * 3 + 1, vertexIndex * 3 + 2);
      if (geoInfo.color) {
        const data = getData2(polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.color);
        faceColors.push(data[0], data[1], data[2]);
      }
      if (geoInfo.skeleton) {
        if (geoInfo.weightTable[vertexIndex] !== void 0) {
          geoInfo.weightTable[vertexIndex].forEach(function(wt) {
            weights.push(wt.weight);
            weightIndices.push(wt.id);
          });
        }
        if (weights.length > 4) {
          if (!displayedWeightsWarning) {
            console.warn("THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights.");
            displayedWeightsWarning = true;
          }
          const wIndex = [0, 0, 0, 0];
          const Weight = [0, 0, 0, 0];
          weights.forEach(function(weight, weightIndex) {
            let currentWeight = weight;
            let currentIndex = weightIndices[weightIndex];
            Weight.forEach(function(comparedWeight, comparedWeightIndex, comparedWeightArray) {
              if (currentWeight > comparedWeight) {
                comparedWeightArray[comparedWeightIndex] = currentWeight;
                currentWeight = comparedWeight;
                const tmp2 = wIndex[comparedWeightIndex];
                wIndex[comparedWeightIndex] = currentIndex;
                currentIndex = tmp2;
              }
            });
          });
          weightIndices = wIndex;
          weights = Weight;
        }
        while (weights.length < 4) {
          weights.push(0);
          weightIndices.push(0);
        }
        for (let i3 = 0; i3 < 4; ++i3) {
          faceWeights.push(weights[i3]);
          faceWeightIndices.push(weightIndices[i3]);
        }
      }
      if (geoInfo.normal) {
        const data = getData2(polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.normal);
        faceNormals.push(data[0], data[1], data[2]);
      }
      if (geoInfo.material && geoInfo.material.mappingType !== "AllSame") {
        materialIndex = getData2(polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.material)[0];
        if (materialIndex < 0) {
          scope.negativeMaterialIndices = true;
          materialIndex = 0;
        }
      }
      if (geoInfo.uv) {
        geoInfo.uv.forEach(function(uv, i3) {
          const data = getData2(polygonVertexIndex, polygonIndex, vertexIndex, uv);
          if (faceUVs[i3] === void 0) {
            faceUVs[i3] = [];
          }
          faceUVs[i3].push(data[0]);
          faceUVs[i3].push(data[1]);
        });
      }
      faceLength++;
      if (endOfFace) {
        if (faceLength > 4)
          console.warn("THREE.FBXLoader: Polygons with more than four sides are not supported. Make sure to triangulate the geometry during export.");
        scope.genFace(buffers, geoInfo, facePositionIndexes, materialIndex, faceNormals, faceColors, faceUVs, faceWeights, faceWeightIndices, faceLength);
        polygonIndex++;
        faceLength = 0;
        facePositionIndexes = [];
        faceNormals = [];
        faceColors = [];
        faceUVs = [];
        faceWeights = [];
        faceWeightIndices = [];
      }
    });
    return buffers;
  }
  // Generate data for a single face in a geometry. If the face is a quad then split it into 2 tris
  genFace(buffers, geoInfo, facePositionIndexes, materialIndex, faceNormals, faceColors, faceUVs, faceWeights, faceWeightIndices, faceLength) {
    for (let i3 = 2; i3 < faceLength; i3++) {
      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[0]]);
      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[1]]);
      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[2]]);
      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[(i3 - 1) * 3]]);
      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[(i3 - 1) * 3 + 1]]);
      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[(i3 - 1) * 3 + 2]]);
      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i3 * 3]]);
      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i3 * 3 + 1]]);
      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i3 * 3 + 2]]);
      if (geoInfo.skeleton) {
        buffers.vertexWeights.push(faceWeights[0]);
        buffers.vertexWeights.push(faceWeights[1]);
        buffers.vertexWeights.push(faceWeights[2]);
        buffers.vertexWeights.push(faceWeights[3]);
        buffers.vertexWeights.push(faceWeights[(i3 - 1) * 4]);
        buffers.vertexWeights.push(faceWeights[(i3 - 1) * 4 + 1]);
        buffers.vertexWeights.push(faceWeights[(i3 - 1) * 4 + 2]);
        buffers.vertexWeights.push(faceWeights[(i3 - 1) * 4 + 3]);
        buffers.vertexWeights.push(faceWeights[i3 * 4]);
        buffers.vertexWeights.push(faceWeights[i3 * 4 + 1]);
        buffers.vertexWeights.push(faceWeights[i3 * 4 + 2]);
        buffers.vertexWeights.push(faceWeights[i3 * 4 + 3]);
        buffers.weightsIndices.push(faceWeightIndices[0]);
        buffers.weightsIndices.push(faceWeightIndices[1]);
        buffers.weightsIndices.push(faceWeightIndices[2]);
        buffers.weightsIndices.push(faceWeightIndices[3]);
        buffers.weightsIndices.push(faceWeightIndices[(i3 - 1) * 4]);
        buffers.weightsIndices.push(faceWeightIndices[(i3 - 1) * 4 + 1]);
        buffers.weightsIndices.push(faceWeightIndices[(i3 - 1) * 4 + 2]);
        buffers.weightsIndices.push(faceWeightIndices[(i3 - 1) * 4 + 3]);
        buffers.weightsIndices.push(faceWeightIndices[i3 * 4]);
        buffers.weightsIndices.push(faceWeightIndices[i3 * 4 + 1]);
        buffers.weightsIndices.push(faceWeightIndices[i3 * 4 + 2]);
        buffers.weightsIndices.push(faceWeightIndices[i3 * 4 + 3]);
      }
      if (geoInfo.color) {
        buffers.colors.push(faceColors[0]);
        buffers.colors.push(faceColors[1]);
        buffers.colors.push(faceColors[2]);
        buffers.colors.push(faceColors[(i3 - 1) * 3]);
        buffers.colors.push(faceColors[(i3 - 1) * 3 + 1]);
        buffers.colors.push(faceColors[(i3 - 1) * 3 + 2]);
        buffers.colors.push(faceColors[i3 * 3]);
        buffers.colors.push(faceColors[i3 * 3 + 1]);
        buffers.colors.push(faceColors[i3 * 3 + 2]);
      }
      if (geoInfo.material && geoInfo.material.mappingType !== "AllSame") {
        buffers.materialIndex.push(materialIndex);
        buffers.materialIndex.push(materialIndex);
        buffers.materialIndex.push(materialIndex);
      }
      if (geoInfo.normal) {
        buffers.normal.push(faceNormals[0]);
        buffers.normal.push(faceNormals[1]);
        buffers.normal.push(faceNormals[2]);
        buffers.normal.push(faceNormals[(i3 - 1) * 3]);
        buffers.normal.push(faceNormals[(i3 - 1) * 3 + 1]);
        buffers.normal.push(faceNormals[(i3 - 1) * 3 + 2]);
        buffers.normal.push(faceNormals[i3 * 3]);
        buffers.normal.push(faceNormals[i3 * 3 + 1]);
        buffers.normal.push(faceNormals[i3 * 3 + 2]);
      }
      if (geoInfo.uv) {
        geoInfo.uv.forEach(function(uv, j) {
          if (buffers.uvs[j] === void 0)
            buffers.uvs[j] = [];
          buffers.uvs[j].push(faceUVs[j][0]);
          buffers.uvs[j].push(faceUVs[j][1]);
          buffers.uvs[j].push(faceUVs[j][(i3 - 1) * 2]);
          buffers.uvs[j].push(faceUVs[j][(i3 - 1) * 2 + 1]);
          buffers.uvs[j].push(faceUVs[j][i3 * 2]);
          buffers.uvs[j].push(faceUVs[j][i3 * 2 + 1]);
        });
      }
    }
  }
  addMorphTargets(parentGeo, parentGeoNode, morphTargets, preTransform) {
    if (morphTargets.length === 0)
      return;
    parentGeo.morphTargetsRelative = true;
    parentGeo.morphAttributes.position = [];
    const scope = this;
    morphTargets.forEach(function(morphTarget) {
      morphTarget.rawTargets.forEach(function(rawTarget) {
        const morphGeoNode = fbxTree2.Objects.Geometry[rawTarget.geoID];
        if (morphGeoNode !== void 0) {
          scope.genMorphGeometry(parentGeo, parentGeoNode, morphGeoNode, preTransform, rawTarget.name);
        }
      });
    });
  }
  // a morph geometry node is similar to a standard  node, and the node is also contained
  // in FBXTree.Objects.Geometry, however it can only have attributes for position, normal
  // and a special attribute Index defining which vertices of the original geometry are affected
  // Normal and position attributes only have data for the vertices that are affected by the morph
  genMorphGeometry(parentGeo, parentGeoNode, morphGeoNode, preTransform, name) {
    const vertexIndices = parentGeoNode.PolygonVertexIndex !== void 0 ? parentGeoNode.PolygonVertexIndex.a : [];
    const morphPositionsSparse = morphGeoNode.Vertices !== void 0 ? morphGeoNode.Vertices.a : [];
    const indices = morphGeoNode.Indexes !== void 0 ? morphGeoNode.Indexes.a : [];
    const length = parentGeo.attributes.position.count * 3;
    const morphPositions = new Float32Array(length);
    for (let i3 = 0; i3 < indices.length; i3++) {
      const morphIndex = indices[i3] * 3;
      morphPositions[morphIndex] = morphPositionsSparse[i3 * 3];
      morphPositions[morphIndex + 1] = morphPositionsSparse[i3 * 3 + 1];
      morphPositions[morphIndex + 2] = morphPositionsSparse[i3 * 3 + 2];
    }
    const morphGeoInfo = {
      vertexIndices,
      vertexPositions: morphPositions
    };
    const morphBuffers = this.genBuffers(morphGeoInfo);
    const positionAttribute = new Float32BufferAttribute(morphBuffers.vertex, 3);
    positionAttribute.name = name || morphGeoNode.attrName;
    positionAttribute.applyMatrix4(preTransform);
    parentGeo.morphAttributes.position.push(positionAttribute);
  }
  // Parse normal from FBXTree.Objects.Geometry.LayerElementNormal if it exists
  parseNormals(NormalNode) {
    const mappingType = NormalNode.MappingInformationType;
    const referenceType = NormalNode.ReferenceInformationType;
    const buffer = NormalNode.Normals.a;
    let indexBuffer = [];
    if (referenceType === "IndexToDirect") {
      if ("NormalIndex" in NormalNode) {
        indexBuffer = NormalNode.NormalIndex.a;
      } else if ("NormalsIndex" in NormalNode) {
        indexBuffer = NormalNode.NormalsIndex.a;
      }
    }
    return {
      dataSize: 3,
      buffer,
      indices: indexBuffer,
      mappingType,
      referenceType
    };
  }
  // Parse UVs from FBXTree.Objects.Geometry.LayerElementUV if it exists
  parseUVs(UVNode) {
    const mappingType = UVNode.MappingInformationType;
    const referenceType = UVNode.ReferenceInformationType;
    const buffer = UVNode.UV.a;
    let indexBuffer = [];
    if (referenceType === "IndexToDirect") {
      indexBuffer = UVNode.UVIndex.a;
    }
    return {
      dataSize: 2,
      buffer,
      indices: indexBuffer,
      mappingType,
      referenceType
    };
  }
  // Parse Vertex Colors from FBXTree.Objects.Geometry.LayerElementColor if it exists
  parseVertexColors(ColorNode) {
    const mappingType = ColorNode.MappingInformationType;
    const referenceType = ColorNode.ReferenceInformationType;
    const buffer = ColorNode.Colors.a;
    let indexBuffer = [];
    if (referenceType === "IndexToDirect") {
      indexBuffer = ColorNode.ColorIndex.a;
    }
    for (let i3 = 0, c3 = new Color(); i3 < buffer.length; i3 += 4) {
      c3.fromArray(buffer, i3).convertSRGBToLinear().toArray(buffer, i3);
    }
    return {
      dataSize: 4,
      buffer,
      indices: indexBuffer,
      mappingType,
      referenceType
    };
  }
  // Parse mapping and material data in FBXTree.Objects.Geometry.LayerElementMaterial if it exists
  parseMaterialIndices(MaterialNode) {
    const mappingType = MaterialNode.MappingInformationType;
    const referenceType = MaterialNode.ReferenceInformationType;
    if (mappingType === "NoMappingInformation") {
      return {
        dataSize: 1,
        buffer: [0],
        indices: [0],
        mappingType: "AllSame",
        referenceType
      };
    }
    const materialIndexBuffer = MaterialNode.Materials.a;
    const materialIndices = [];
    for (let i3 = 0; i3 < materialIndexBuffer.length; ++i3) {
      materialIndices.push(i3);
    }
    return {
      dataSize: 1,
      buffer: materialIndexBuffer,
      indices: materialIndices,
      mappingType,
      referenceType
    };
  }
  // Generate a NurbGeometry from a node in FBXTree.Objects.Geometry
  parseNurbsGeometry(geoNode) {
    const order = parseInt(geoNode.Order);
    if (isNaN(order)) {
      console.error("THREE.FBXLoader: Invalid Order %s given for geometry ID: %s", geoNode.Order, geoNode.id);
      return new BufferGeometry();
    }
    const degree = order - 1;
    const knots = geoNode.KnotVector.a;
    const controlPoints = [];
    const pointsValues = geoNode.Points.a;
    for (let i3 = 0, l = pointsValues.length; i3 < l; i3 += 4) {
      controlPoints.push(new Vector4().fromArray(pointsValues, i3));
    }
    let startKnot, endKnot;
    if (geoNode.Form === "Closed") {
      controlPoints.push(controlPoints[0]);
    } else if (geoNode.Form === "Periodic") {
      startKnot = degree;
      endKnot = knots.length - 1 - startKnot;
      for (let i3 = 0; i3 < degree; ++i3) {
        controlPoints.push(controlPoints[i3]);
      }
    }
    const curve = new NURBSCurve2(degree, knots, controlPoints, startKnot, endKnot);
    const points = curve.getPoints(controlPoints.length * 12);
    return new BufferGeometry().setFromPoints(points);
  }
};
var AnimationParser2 = class {
  // take raw animation clips and turn them into three.js animation clips
  parse() {
    const animationClips = [];
    const rawClips = this.parseClips();
    if (rawClips !== void 0) {
      for (const key in rawClips) {
        const rawClip = rawClips[key];
        const clip = this.addClip(rawClip);
        animationClips.push(clip);
      }
    }
    return animationClips;
  }
  parseClips() {
    if (fbxTree2.Objects.AnimationCurve === void 0)
      return void 0;
    const curveNodesMap = this.parseAnimationCurveNodes();
    this.parseAnimationCurves(curveNodesMap);
    const layersMap = this.parseAnimationLayers(curveNodesMap);
    const rawClips = this.parseAnimStacks(layersMap);
    return rawClips;
  }
  // parse nodes in FBXTree.Objects.AnimationCurveNode
  // each AnimationCurveNode holds data for an animation transform for a model (e.g. left arm rotation )
  // and is referenced by an AnimationLayer
  parseAnimationCurveNodes() {
    const rawCurveNodes = fbxTree2.Objects.AnimationCurveNode;
    const curveNodesMap = /* @__PURE__ */ new Map();
    for (const nodeID in rawCurveNodes) {
      const rawCurveNode = rawCurveNodes[nodeID];
      if (rawCurveNode.attrName.match(/S|R|T|DeformPercent/) !== null) {
        const curveNode = {
          id: rawCurveNode.id,
          attr: rawCurveNode.attrName,
          curves: {}
        };
        curveNodesMap.set(curveNode.id, curveNode);
      }
    }
    return curveNodesMap;
  }
  // parse nodes in FBXTree.Objects.AnimationCurve and connect them up to
  // previously parsed AnimationCurveNodes. Each AnimationCurve holds data for a single animated
  // axis ( e.g. times and values of x rotation)
  parseAnimationCurves(curveNodesMap) {
    const rawCurves = fbxTree2.Objects.AnimationCurve;
    for (const nodeID in rawCurves) {
      const animationCurve = {
        id: rawCurves[nodeID].id,
        times: rawCurves[nodeID].KeyTime.a.map(convertFBXTimeToSeconds2),
        values: rawCurves[nodeID].KeyValueFloat.a
      };
      const relationships = connections2.get(animationCurve.id);
      if (relationships !== void 0) {
        const animationCurveID = relationships.parents[0].ID;
        const animationCurveRelationship = relationships.parents[0].relationship;
        if (animationCurveRelationship.match(/X/)) {
          curveNodesMap.get(animationCurveID).curves["x"] = animationCurve;
        } else if (animationCurveRelationship.match(/Y/)) {
          curveNodesMap.get(animationCurveID).curves["y"] = animationCurve;
        } else if (animationCurveRelationship.match(/Z/)) {
          curveNodesMap.get(animationCurveID).curves["z"] = animationCurve;
        } else if (animationCurveRelationship.match(/d|DeformPercent/) && curveNodesMap.has(animationCurveID)) {
          curveNodesMap.get(animationCurveID).curves["morph"] = animationCurve;
        }
      }
    }
  }
  // parse nodes in FBXTree.Objects.AnimationLayer. Each layers holds references
  // to various AnimationCurveNodes and is referenced by an AnimationStack node
  // note: theoretically a stack can have multiple layers, however in practice there always seems to be one per stack
  parseAnimationLayers(curveNodesMap) {
    const rawLayers = fbxTree2.Objects.AnimationLayer;
    const layersMap = /* @__PURE__ */ new Map();
    for (const nodeID in rawLayers) {
      const layerCurveNodes = [];
      const connection = connections2.get(parseInt(nodeID));
      if (connection !== void 0) {
        const children = connection.children;
        children.forEach(function(child, i3) {
          if (curveNodesMap.has(child.ID)) {
            const curveNode = curveNodesMap.get(child.ID);
            if (curveNode.curves.x !== void 0 || curveNode.curves.y !== void 0 || curveNode.curves.z !== void 0) {
              if (layerCurveNodes[i3] === void 0) {
                const modelID = connections2.get(child.ID).parents.filter(function(parent) {
                  return parent.relationship !== void 0;
                })[0].ID;
                if (modelID !== void 0) {
                  const rawModel = fbxTree2.Objects.Model[modelID.toString()];
                  if (rawModel === void 0) {
                    console.warn("THREE.FBXLoader: Encountered a unused curve.", child);
                    return;
                  }
                  const node = {
                    modelName: rawModel.attrName ? PropertyBinding.sanitizeNodeName(rawModel.attrName) : "",
                    ID: rawModel.id,
                    initialPosition: [0, 0, 0],
                    initialRotation: [0, 0, 0],
                    initialScale: [1, 1, 1]
                  };
                  sceneGraph2.traverse(function(child2) {
                    if (child2.ID === rawModel.id) {
                      node.transform = child2.matrix;
                      if (child2.userData.transformData)
                        node.eulerOrder = child2.userData.transformData.eulerOrder;
                    }
                  });
                  if (!node.transform)
                    node.transform = new Matrix4();
                  if ("PreRotation" in rawModel)
                    node.preRotation = rawModel.PreRotation.value;
                  if ("PostRotation" in rawModel)
                    node.postRotation = rawModel.PostRotation.value;
                  layerCurveNodes[i3] = node;
                }
              }
              if (layerCurveNodes[i3])
                layerCurveNodes[i3][curveNode.attr] = curveNode;
            } else if (curveNode.curves.morph !== void 0) {
              if (layerCurveNodes[i3] === void 0) {
                const deformerID = connections2.get(child.ID).parents.filter(function(parent) {
                  return parent.relationship !== void 0;
                })[0].ID;
                const morpherID = connections2.get(deformerID).parents[0].ID;
                const geoID = connections2.get(morpherID).parents[0].ID;
                const modelID = connections2.get(geoID).parents[0].ID;
                const rawModel = fbxTree2.Objects.Model[modelID];
                const node = {
                  modelName: rawModel.attrName ? PropertyBinding.sanitizeNodeName(rawModel.attrName) : "",
                  morphName: fbxTree2.Objects.Deformer[deformerID].attrName
                };
                layerCurveNodes[i3] = node;
              }
              layerCurveNodes[i3][curveNode.attr] = curveNode;
            }
          }
        });
        layersMap.set(parseInt(nodeID), layerCurveNodes);
      }
    }
    return layersMap;
  }
  // parse nodes in FBXTree.Objects.AnimationStack. These are the top level node in the animation
  // hierarchy. Each Stack node will be used to create a AnimationClip
  parseAnimStacks(layersMap) {
    const rawStacks = fbxTree2.Objects.AnimationStack;
    const rawClips = {};
    for (const nodeID in rawStacks) {
      const children = connections2.get(parseInt(nodeID)).children;
      if (children.length > 1) {
        console.warn("THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers.");
      }
      const layer = layersMap.get(children[0].ID);
      rawClips[nodeID] = {
        name: rawStacks[nodeID].attrName,
        layer
      };
    }
    return rawClips;
  }
  addClip(rawClip) {
    let tracks = [];
    const scope = this;
    rawClip.layer.forEach(function(rawTracks) {
      tracks = tracks.concat(scope.generateTracks(rawTracks));
    });
    return new AnimationClip(rawClip.name, -1, tracks);
  }
  generateTracks(rawTracks) {
    const tracks = [];
    let initialPosition = new Vector3();
    let initialRotation = new Quaternion();
    let initialScale = new Vector3();
    if (rawTracks.transform)
      rawTracks.transform.decompose(initialPosition, initialRotation, initialScale);
    initialPosition = initialPosition.toArray();
    initialRotation = new Euler().setFromQuaternion(initialRotation, rawTracks.eulerOrder).toArray();
    initialScale = initialScale.toArray();
    if (rawTracks.T !== void 0 && Object.keys(rawTracks.T.curves).length > 0) {
      const positionTrack = this.generateVectorTrack(rawTracks.modelName, rawTracks.T.curves, initialPosition, "position");
      if (positionTrack !== void 0)
        tracks.push(positionTrack);
    }
    if (rawTracks.R !== void 0 && Object.keys(rawTracks.R.curves).length > 0) {
      const rotationTrack = this.generateRotationTrack(rawTracks.modelName, rawTracks.R.curves, initialRotation, rawTracks.preRotation, rawTracks.postRotation, rawTracks.eulerOrder);
      if (rotationTrack !== void 0)
        tracks.push(rotationTrack);
    }
    if (rawTracks.S !== void 0 && Object.keys(rawTracks.S.curves).length > 0) {
      const scaleTrack = this.generateVectorTrack(rawTracks.modelName, rawTracks.S.curves, initialScale, "scale");
      if (scaleTrack !== void 0)
        tracks.push(scaleTrack);
    }
    if (rawTracks.DeformPercent !== void 0) {
      const morphTrack = this.generateMorphTrack(rawTracks);
      if (morphTrack !== void 0)
        tracks.push(morphTrack);
    }
    return tracks;
  }
  generateVectorTrack(modelName, curves, initialValue, type) {
    const times = this.getTimesForAllAxes(curves);
    const values = this.getKeyframeTrackValues(times, curves, initialValue);
    return new VectorKeyframeTrack(modelName + "." + type, times, values);
  }
  generateRotationTrack(modelName, curves, initialValue, preRotation, postRotation, eulerOrder) {
    if (curves.x !== void 0) {
      this.interpolateRotations(curves.x);
      curves.x.values = curves.x.values.map(MathUtils.degToRad);
    }
    if (curves.y !== void 0) {
      this.interpolateRotations(curves.y);
      curves.y.values = curves.y.values.map(MathUtils.degToRad);
    }
    if (curves.z !== void 0) {
      this.interpolateRotations(curves.z);
      curves.z.values = curves.z.values.map(MathUtils.degToRad);
    }
    const times = this.getTimesForAllAxes(curves);
    const values = this.getKeyframeTrackValues(times, curves, initialValue);
    if (preRotation !== void 0) {
      preRotation = preRotation.map(MathUtils.degToRad);
      preRotation.push(eulerOrder);
      preRotation = new Euler().fromArray(preRotation);
      preRotation = new Quaternion().setFromEuler(preRotation);
    }
    if (postRotation !== void 0) {
      postRotation = postRotation.map(MathUtils.degToRad);
      postRotation.push(eulerOrder);
      postRotation = new Euler().fromArray(postRotation);
      postRotation = new Quaternion().setFromEuler(postRotation).invert();
    }
    const quaternion = new Quaternion();
    const euler = new Euler();
    const quaternionValues = [];
    for (let i3 = 0; i3 < values.length; i3 += 3) {
      euler.set(values[i3], values[i3 + 1], values[i3 + 2], eulerOrder);
      quaternion.setFromEuler(euler);
      if (preRotation !== void 0)
        quaternion.premultiply(preRotation);
      if (postRotation !== void 0)
        quaternion.multiply(postRotation);
      quaternion.toArray(quaternionValues, i3 / 3 * 4);
    }
    return new QuaternionKeyframeTrack(modelName + ".quaternion", times, quaternionValues);
  }
  generateMorphTrack(rawTracks) {
    const curves = rawTracks.DeformPercent.curves.morph;
    const values = curves.values.map(function(val) {
      return val / 100;
    });
    const morphNum = sceneGraph2.getObjectByName(rawTracks.modelName).morphTargetDictionary[rawTracks.morphName];
    return new NumberKeyframeTrack(rawTracks.modelName + ".morphTargetInfluences[" + morphNum + "]", curves.times, values);
  }
  // For all animated objects, times are defined separately for each axis
  // Here we'll combine the times into one sorted array without duplicates
  getTimesForAllAxes(curves) {
    let times = [];
    if (curves.x !== void 0)
      times = times.concat(curves.x.times);
    if (curves.y !== void 0)
      times = times.concat(curves.y.times);
    if (curves.z !== void 0)
      times = times.concat(curves.z.times);
    times = times.sort(function(a4, b5) {
      return a4 - b5;
    });
    if (times.length > 1) {
      let targetIndex = 1;
      let lastValue = times[0];
      for (let i3 = 1; i3 < times.length; i3++) {
        const currentValue = times[i3];
        if (currentValue !== lastValue) {
          times[targetIndex] = currentValue;
          lastValue = currentValue;
          targetIndex++;
        }
      }
      times = times.slice(0, targetIndex);
    }
    return times;
  }
  getKeyframeTrackValues(times, curves, initialValue) {
    const prevValue = initialValue;
    const values = [];
    let xIndex = -1;
    let yIndex = -1;
    let zIndex = -1;
    times.forEach(function(time) {
      if (curves.x)
        xIndex = curves.x.times.indexOf(time);
      if (curves.y)
        yIndex = curves.y.times.indexOf(time);
      if (curves.z)
        zIndex = curves.z.times.indexOf(time);
      if (xIndex !== -1) {
        const xValue = curves.x.values[xIndex];
        values.push(xValue);
        prevValue[0] = xValue;
      } else {
        values.push(prevValue[0]);
      }
      if (yIndex !== -1) {
        const yValue = curves.y.values[yIndex];
        values.push(yValue);
        prevValue[1] = yValue;
      } else {
        values.push(prevValue[1]);
      }
      if (zIndex !== -1) {
        const zValue = curves.z.values[zIndex];
        values.push(zValue);
        prevValue[2] = zValue;
      } else {
        values.push(prevValue[2]);
      }
    });
    return values;
  }
  // Rotations are defined as Euler angles which can have values  of any size
  // These will be converted to quaternions which don't support values greater than
  // PI, so we'll interpolate large rotations
  interpolateRotations(curve) {
    for (let i3 = 1; i3 < curve.values.length; i3++) {
      const initialValue = curve.values[i3 - 1];
      const valuesSpan = curve.values[i3] - initialValue;
      const absoluteSpan = Math.abs(valuesSpan);
      if (absoluteSpan >= 180) {
        const numSubIntervals = absoluteSpan / 180;
        const step = valuesSpan / numSubIntervals;
        let nextValue = initialValue + step;
        const initialTime = curve.times[i3 - 1];
        const timeSpan = curve.times[i3] - initialTime;
        const interval = timeSpan / numSubIntervals;
        let nextTime = initialTime + interval;
        const interpolatedTimes = [];
        const interpolatedValues = [];
        while (nextTime < curve.times[i3]) {
          interpolatedTimes.push(nextTime);
          nextTime += interval;
          interpolatedValues.push(nextValue);
          nextValue += step;
        }
        curve.times = inject2(curve.times, i3, interpolatedTimes);
        curve.values = inject2(curve.values, i3, interpolatedValues);
      }
    }
  }
};
var TextParser2 = class {
  getPrevNode() {
    return this.nodeStack[this.currentIndent - 2];
  }
  getCurrentNode() {
    return this.nodeStack[this.currentIndent - 1];
  }
  getCurrentProp() {
    return this.currentProp;
  }
  pushStack(node) {
    this.nodeStack.push(node);
    this.currentIndent += 1;
  }
  popStack() {
    this.nodeStack.pop();
    this.currentIndent -= 1;
  }
  setCurrentProp(val, name) {
    this.currentProp = val;
    this.currentPropName = name;
  }
  parse(text) {
    this.currentIndent = 0;
    this.allNodes = new FBXTree2();
    this.nodeStack = [];
    this.currentProp = [];
    this.currentPropName = "";
    const scope = this;
    const split = text.split(/[\r\n]+/);
    split.forEach(function(line2, i3) {
      const matchComment = line2.match(/^[\s\t]*;/);
      const matchEmpty = line2.match(/^[\s\t]*$/);
      if (matchComment || matchEmpty)
        return;
      const matchBeginning = line2.match("^\\t{" + scope.currentIndent + "}(\\w+):(.*){", "");
      const matchProperty = line2.match("^\\t{" + scope.currentIndent + "}(\\w+):[\\s\\t\\r\\n](.*)");
      const matchEnd = line2.match("^\\t{" + (scope.currentIndent - 1) + "}}");
      if (matchBeginning) {
        scope.parseNodeBegin(line2, matchBeginning);
      } else if (matchProperty) {
        scope.parseNodeProperty(line2, matchProperty, split[++i3]);
      } else if (matchEnd) {
        scope.popStack();
      } else if (line2.match(/^[^\s\t}]/)) {
        scope.parseNodePropertyContinued(line2);
      }
    });
    return this.allNodes;
  }
  parseNodeBegin(line2, property) {
    const nodeName = property[1].trim().replace(/^"/, "").replace(/"$/, "");
    const nodeAttrs = property[2].split(",").map(function(attr) {
      return attr.trim().replace(/^"/, "").replace(/"$/, "");
    });
    const node = { name: nodeName };
    const attrs = this.parseNodeAttr(nodeAttrs);
    const currentNode = this.getCurrentNode();
    if (this.currentIndent === 0) {
      this.allNodes.add(nodeName, node);
    } else {
      if (nodeName in currentNode) {
        if (nodeName === "PoseNode") {
          currentNode.PoseNode.push(node);
        } else if (currentNode[nodeName].id !== void 0) {
          currentNode[nodeName] = {};
          currentNode[nodeName][currentNode[nodeName].id] = currentNode[nodeName];
        }
        if (attrs.id !== "")
          currentNode[nodeName][attrs.id] = node;
      } else if (typeof attrs.id === "number") {
        currentNode[nodeName] = {};
        currentNode[nodeName][attrs.id] = node;
      } else if (nodeName !== "Properties70") {
        if (nodeName === "PoseNode")
          currentNode[nodeName] = [node];
        else
          currentNode[nodeName] = node;
      }
    }
    if (typeof attrs.id === "number")
      node.id = attrs.id;
    if (attrs.name !== "")
      node.attrName = attrs.name;
    if (attrs.type !== "")
      node.attrType = attrs.type;
    this.pushStack(node);
  }
  parseNodeAttr(attrs) {
    let id = attrs[0];
    if (attrs[0] !== "") {
      id = parseInt(attrs[0]);
      if (isNaN(id)) {
        id = attrs[0];
      }
    }
    let name = "", type = "";
    if (attrs.length > 1) {
      name = attrs[1].replace(/^(\w+)::/, "");
      type = attrs[2];
    }
    return { id, name, type };
  }
  parseNodeProperty(line2, property, contentLine) {
    let propName = property[1].replace(/^"/, "").replace(/"$/, "").trim();
    let propValue = property[2].replace(/^"/, "").replace(/"$/, "").trim();
    if (propName === "Content" && propValue === ",") {
      propValue = contentLine.replace(/"/g, "").replace(/,$/, "").trim();
    }
    const currentNode = this.getCurrentNode();
    const parentName = currentNode.name;
    if (parentName === "Properties70") {
      this.parseNodeSpecialProperty(line2, propName, propValue);
      return;
    }
    if (propName === "C") {
      const connProps = propValue.split(",").slice(1);
      const from = parseInt(connProps[0]);
      const to = parseInt(connProps[1]);
      let rest = propValue.split(",").slice(3);
      rest = rest.map(function(elem) {
        return elem.trim().replace(/^"/, "");
      });
      propName = "connections";
      propValue = [from, to];
      append2(propValue, rest);
      if (currentNode[propName] === void 0) {
        currentNode[propName] = [];
      }
    }
    if (propName === "Node")
      currentNode.id = propValue;
    if (propName in currentNode && Array.isArray(currentNode[propName])) {
      currentNode[propName].push(propValue);
    } else {
      if (propName !== "a")
        currentNode[propName] = propValue;
      else
        currentNode.a = propValue;
    }
    this.setCurrentProp(currentNode, propName);
    if (propName === "a" && propValue.slice(-1) !== ",") {
      currentNode.a = parseNumberArray2(propValue);
    }
  }
  parseNodePropertyContinued(line2) {
    const currentNode = this.getCurrentNode();
    currentNode.a += line2;
    if (line2.slice(-1) !== ",") {
      currentNode.a = parseNumberArray2(currentNode.a);
    }
  }
  // parse "Property70"
  parseNodeSpecialProperty(line2, propName, propValue) {
    const props = propValue.split('",').map(function(prop) {
      return prop.trim().replace(/^\"/, "").replace(/\s/, "_");
    });
    const innerPropName = props[0];
    const innerPropType1 = props[1];
    const innerPropType2 = props[2];
    const innerPropFlag = props[3];
    let innerPropValue = props[4];
    switch (innerPropType1) {
      case "int":
      case "enum":
      case "bool":
      case "ULongLong":
      case "double":
      case "Number":
      case "FieldOfView":
        innerPropValue = parseFloat(innerPropValue);
        break;
      case "Color":
      case "ColorRGB":
      case "Vector3D":
      case "Lcl_Translation":
      case "Lcl_Rotation":
      case "Lcl_Scaling":
        innerPropValue = parseNumberArray2(innerPropValue);
        break;
    }
    this.getPrevNode()[innerPropName] = {
      type: innerPropType1,
      type2: innerPropType2,
      flag: innerPropFlag,
      value: innerPropValue
    };
    this.setCurrentProp(this.getPrevNode(), innerPropName);
  }
};
var BinaryParser2 = class {
  parse(buffer) {
    const reader = new BinaryReader2(buffer);
    reader.skip(23);
    const version = reader.getUint32();
    if (version < 6400) {
      throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: " + version);
    }
    const allNodes = new FBXTree2();
    while (!this.endOfContent(reader)) {
      const node = this.parseNode(reader, version);
      if (node !== null)
        allNodes.add(node.name, node);
    }
    return allNodes;
  }
  // Check if reader has reached the end of content.
  endOfContent(reader) {
    if (reader.size() % 16 === 0) {
      return (reader.getOffset() + 160 + 16 & ~15) >= reader.size();
    } else {
      return reader.getOffset() + 160 + 16 >= reader.size();
    }
  }
  // recursively parse nodes until the end of the file is reached
  parseNode(reader, version) {
    const node = {};
    const endOffset = version >= 7500 ? reader.getUint64() : reader.getUint32();
    const numProperties = version >= 7500 ? reader.getUint64() : reader.getUint32();
    version >= 7500 ? reader.getUint64() : reader.getUint32();
    const nameLen = reader.getUint8();
    const name = reader.getString(nameLen);
    if (endOffset === 0)
      return null;
    const propertyList = [];
    for (let i3 = 0; i3 < numProperties; i3++) {
      propertyList.push(this.parseProperty(reader));
    }
    const id = propertyList.length > 0 ? propertyList[0] : "";
    const attrName = propertyList.length > 1 ? propertyList[1] : "";
    const attrType = propertyList.length > 2 ? propertyList[2] : "";
    node.singleProperty = numProperties === 1 && reader.getOffset() === endOffset ? true : false;
    while (endOffset > reader.getOffset()) {
      const subNode = this.parseNode(reader, version);
      if (subNode !== null)
        this.parseSubNode(name, node, subNode);
    }
    node.propertyList = propertyList;
    if (typeof id === "number")
      node.id = id;
    if (attrName !== "")
      node.attrName = attrName;
    if (attrType !== "")
      node.attrType = attrType;
    if (name !== "")
      node.name = name;
    return node;
  }
  parseSubNode(name, node, subNode) {
    if (subNode.singleProperty === true) {
      const value = subNode.propertyList[0];
      if (Array.isArray(value)) {
        node[subNode.name] = subNode;
        subNode.a = value;
      } else {
        node[subNode.name] = value;
      }
    } else if (name === "Connections" && subNode.name === "C") {
      const array = [];
      subNode.propertyList.forEach(function(property, i3) {
        if (i3 !== 0)
          array.push(property);
      });
      if (node.connections === void 0) {
        node.connections = [];
      }
      node.connections.push(array);
    } else if (subNode.name === "Properties70") {
      const keys = Object.keys(subNode);
      keys.forEach(function(key) {
        node[key] = subNode[key];
      });
    } else if (name === "Properties70" && subNode.name === "P") {
      let innerPropName = subNode.propertyList[0];
      let innerPropType1 = subNode.propertyList[1];
      const innerPropType2 = subNode.propertyList[2];
      const innerPropFlag = subNode.propertyList[3];
      let innerPropValue;
      if (innerPropName.indexOf("Lcl ") === 0)
        innerPropName = innerPropName.replace("Lcl ", "Lcl_");
      if (innerPropType1.indexOf("Lcl ") === 0)
        innerPropType1 = innerPropType1.replace("Lcl ", "Lcl_");
      if (innerPropType1 === "Color" || innerPropType1 === "ColorRGB" || innerPropType1 === "Vector" || innerPropType1 === "Vector3D" || innerPropType1.indexOf("Lcl_") === 0) {
        innerPropValue = [
          subNode.propertyList[4],
          subNode.propertyList[5],
          subNode.propertyList[6]
        ];
      } else {
        innerPropValue = subNode.propertyList[4];
      }
      node[innerPropName] = {
        type: innerPropType1,
        type2: innerPropType2,
        flag: innerPropFlag,
        value: innerPropValue
      };
    } else if (node[subNode.name] === void 0) {
      if (typeof subNode.id === "number") {
        node[subNode.name] = {};
        node[subNode.name][subNode.id] = subNode;
      } else {
        node[subNode.name] = subNode;
      }
    } else {
      if (subNode.name === "PoseNode") {
        if (!Array.isArray(node[subNode.name])) {
          node[subNode.name] = [node[subNode.name]];
        }
        node[subNode.name].push(subNode);
      } else if (node[subNode.name][subNode.id] === void 0) {
        node[subNode.name][subNode.id] = subNode;
      }
    }
  }
  parseProperty(reader) {
    const type = reader.getString(1);
    let length;
    switch (type) {
      case "C":
        return reader.getBoolean();
      case "D":
        return reader.getFloat64();
      case "F":
        return reader.getFloat32();
      case "I":
        return reader.getInt32();
      case "L":
        return reader.getInt64();
      case "R":
        length = reader.getUint32();
        return reader.getArrayBuffer(length);
      case "S":
        length = reader.getUint32();
        return reader.getString(length);
      case "Y":
        return reader.getInt16();
      case "b":
      case "c":
      case "d":
      case "f":
      case "i":
      case "l":
        const arrayLength = reader.getUint32();
        const encoding = reader.getUint32();
        const compressedLength = reader.getUint32();
        if (encoding === 0) {
          switch (type) {
            case "b":
            case "c":
              return reader.getBooleanArray(arrayLength);
            case "d":
              return reader.getFloat64Array(arrayLength);
            case "f":
              return reader.getFloat32Array(arrayLength);
            case "i":
              return reader.getInt32Array(arrayLength);
            case "l":
              return reader.getInt64Array(arrayLength);
          }
        }
        const data = unzlibSync2(new Uint8Array(reader.getArrayBuffer(compressedLength)));
        const reader2 = new BinaryReader2(data.buffer);
        switch (type) {
          case "b":
          case "c":
            return reader2.getBooleanArray(arrayLength);
          case "d":
            return reader2.getFloat64Array(arrayLength);
          case "f":
            return reader2.getFloat32Array(arrayLength);
          case "i":
            return reader2.getInt32Array(arrayLength);
          case "l":
            return reader2.getInt64Array(arrayLength);
        }
        break;
      default:
        throw new Error("THREE.FBXLoader: Unknown property type " + type);
    }
  }
};
var BinaryReader2 = class {
  constructor(buffer, littleEndian) {
    this.dv = new DataView(buffer);
    this.offset = 0;
    this.littleEndian = littleEndian !== void 0 ? littleEndian : true;
    this._textDecoder = new TextDecoder();
  }
  getOffset() {
    return this.offset;
  }
  size() {
    return this.dv.buffer.byteLength;
  }
  skip(length) {
    this.offset += length;
  }
  // seems like true/false representation depends on exporter.
  // true: 1 or 'Y'(=0x59), false: 0 or 'T'(=0x54)
  // then sees LSB.
  getBoolean() {
    return (this.getUint8() & 1) === 1;
  }
  getBooleanArray(size2) {
    const a4 = [];
    for (let i3 = 0; i3 < size2; i3++) {
      a4.push(this.getBoolean());
    }
    return a4;
  }
  getUint8() {
    const value = this.dv.getUint8(this.offset);
    this.offset += 1;
    return value;
  }
  getInt16() {
    const value = this.dv.getInt16(this.offset, this.littleEndian);
    this.offset += 2;
    return value;
  }
  getInt32() {
    const value = this.dv.getInt32(this.offset, this.littleEndian);
    this.offset += 4;
    return value;
  }
  getInt32Array(size2) {
    const a4 = [];
    for (let i3 = 0; i3 < size2; i3++) {
      a4.push(this.getInt32());
    }
    return a4;
  }
  getUint32() {
    const value = this.dv.getUint32(this.offset, this.littleEndian);
    this.offset += 4;
    return value;
  }
  // JavaScript doesn't support 64-bit integer so calculate this here
  // 1 << 32 will return 1 so using multiply operation instead here.
  // There's a possibility that this method returns wrong value if the value
  // is out of the range between Number.MAX_SAFE_INTEGER and Number.MIN_SAFE_INTEGER.
  // TODO: safely handle 64-bit integer
  getInt64() {
    let low, high;
    if (this.littleEndian) {
      low = this.getUint32();
      high = this.getUint32();
    } else {
      high = this.getUint32();
      low = this.getUint32();
    }
    if (high & 2147483648) {
      high = ~high & 4294967295;
      low = ~low & 4294967295;
      if (low === 4294967295)
        high = high + 1 & 4294967295;
      low = low + 1 & 4294967295;
      return -(high * 4294967296 + low);
    }
    return high * 4294967296 + low;
  }
  getInt64Array(size2) {
    const a4 = [];
    for (let i3 = 0; i3 < size2; i3++) {
      a4.push(this.getInt64());
    }
    return a4;
  }
  // Note: see getInt64() comment
  getUint64() {
    let low, high;
    if (this.littleEndian) {
      low = this.getUint32();
      high = this.getUint32();
    } else {
      high = this.getUint32();
      low = this.getUint32();
    }
    return high * 4294967296 + low;
  }
  getFloat32() {
    const value = this.dv.getFloat32(this.offset, this.littleEndian);
    this.offset += 4;
    return value;
  }
  getFloat32Array(size2) {
    const a4 = [];
    for (let i3 = 0; i3 < size2; i3++) {
      a4.push(this.getFloat32());
    }
    return a4;
  }
  getFloat64() {
    const value = this.dv.getFloat64(this.offset, this.littleEndian);
    this.offset += 8;
    return value;
  }
  getFloat64Array(size2) {
    const a4 = [];
    for (let i3 = 0; i3 < size2; i3++) {
      a4.push(this.getFloat64());
    }
    return a4;
  }
  getArrayBuffer(size2) {
    const value = this.dv.buffer.slice(this.offset, this.offset + size2);
    this.offset += size2;
    return value;
  }
  getString(size2) {
    const start = this.offset;
    let a4 = new Uint8Array(this.dv.buffer, start, size2);
    this.skip(size2);
    const nullByte = a4.indexOf(0);
    if (nullByte >= 0)
      a4 = new Uint8Array(this.dv.buffer, start, nullByte);
    return this._textDecoder.decode(a4);
  }
};
var FBXTree2 = class {
  add(key, val) {
    this[key] = val;
  }
};
function isFbxFormatBinary2(buffer) {
  const CORRECT = "Kaydara FBX Binary  \0";
  return buffer.byteLength >= CORRECT.length && CORRECT === convertArrayBufferToString2(buffer, 0, CORRECT.length);
}
function isFbxFormatASCII2(text) {
  const CORRECT = [
    "K",
    "a",
    "y",
    "d",
    "a",
    "r",
    "a",
    "\\",
    "F",
    "B",
    "X",
    "\\",
    "B",
    "i",
    "n",
    "a",
    "r",
    "y",
    "\\",
    "\\"
  ];
  let cursor = 0;
  function read2(offset) {
    const result = text[offset - 1];
    text = text.slice(cursor + offset);
    cursor++;
    return result;
  }
  for (let i3 = 0; i3 < CORRECT.length; ++i3) {
    const num = read2(1);
    if (num === CORRECT[i3]) {
      return false;
    }
  }
  return true;
}
function getFbxVersion2(text) {
  const versionRegExp = /FBXVersion: (\d+)/;
  const match = text.match(versionRegExp);
  if (match) {
    const version = parseInt(match[1]);
    return version;
  }
  throw new Error("THREE.FBXLoader: Cannot find the version number for the file given.");
}
function convertFBXTimeToSeconds2(time) {
  return time / 46186158e3;
}
var dataArray2 = [];
function getData2(polygonVertexIndex, polygonIndex, vertexIndex, infoObject) {
  let index;
  switch (infoObject.mappingType) {
    case "ByPolygonVertex":
      index = polygonVertexIndex;
      break;
    case "ByPolygon":
      index = polygonIndex;
      break;
    case "ByVertice":
      index = vertexIndex;
      break;
    case "AllSame":
      index = infoObject.indices[0];
      break;
    default:
      console.warn("THREE.FBXLoader: unknown attribute mapping type " + infoObject.mappingType);
  }
  if (infoObject.referenceType === "IndexToDirect")
    index = infoObject.indices[index];
  const from = index * infoObject.dataSize;
  const to = from + infoObject.dataSize;
  return slice2(dataArray2, infoObject.buffer, from, to);
}
var tempEuler2 = new Euler();
var tempVec2 = new Vector3();
function generateTransform2(transformData) {
  const lTranslationM = new Matrix4();
  const lPreRotationM = new Matrix4();
  const lRotationM = new Matrix4();
  const lPostRotationM = new Matrix4();
  const lScalingM = new Matrix4();
  const lScalingPivotM = new Matrix4();
  const lScalingOffsetM = new Matrix4();
  const lRotationOffsetM = new Matrix4();
  const lRotationPivotM = new Matrix4();
  const lParentGX = new Matrix4();
  const lParentLX = new Matrix4();
  const lGlobalT = new Matrix4();
  const inheritType = transformData.inheritType ? transformData.inheritType : 0;
  if (transformData.translation)
    lTranslationM.setPosition(tempVec2.fromArray(transformData.translation));
  if (transformData.preRotation) {
    const array = transformData.preRotation.map(MathUtils.degToRad);
    array.push(transformData.eulerOrder || Euler.DEFAULT_ORDER);
    lPreRotationM.makeRotationFromEuler(tempEuler2.fromArray(array));
  }
  if (transformData.rotation) {
    const array = transformData.rotation.map(MathUtils.degToRad);
    array.push(transformData.eulerOrder || Euler.DEFAULT_ORDER);
    lRotationM.makeRotationFromEuler(tempEuler2.fromArray(array));
  }
  if (transformData.postRotation) {
    const array = transformData.postRotation.map(MathUtils.degToRad);
    array.push(transformData.eulerOrder || Euler.DEFAULT_ORDER);
    lPostRotationM.makeRotationFromEuler(tempEuler2.fromArray(array));
    lPostRotationM.invert();
  }
  if (transformData.scale)
    lScalingM.scale(tempVec2.fromArray(transformData.scale));
  if (transformData.scalingOffset)
    lScalingOffsetM.setPosition(tempVec2.fromArray(transformData.scalingOffset));
  if (transformData.scalingPivot)
    lScalingPivotM.setPosition(tempVec2.fromArray(transformData.scalingPivot));
  if (transformData.rotationOffset)
    lRotationOffsetM.setPosition(tempVec2.fromArray(transformData.rotationOffset));
  if (transformData.rotationPivot)
    lRotationPivotM.setPosition(tempVec2.fromArray(transformData.rotationPivot));
  if (transformData.parentMatrixWorld) {
    lParentLX.copy(transformData.parentMatrix);
    lParentGX.copy(transformData.parentMatrixWorld);
  }
  const lLRM = lPreRotationM.clone().multiply(lRotationM).multiply(lPostRotationM);
  const lParentGRM = new Matrix4();
  lParentGRM.extractRotation(lParentGX);
  const lParentTM = new Matrix4();
  lParentTM.copyPosition(lParentGX);
  const lParentGRSM = lParentTM.clone().invert().multiply(lParentGX);
  const lParentGSM = lParentGRM.clone().invert().multiply(lParentGRSM);
  const lLSM = lScalingM;
  const lGlobalRS = new Matrix4();
  if (inheritType === 0) {
    lGlobalRS.copy(lParentGRM).multiply(lLRM).multiply(lParentGSM).multiply(lLSM);
  } else if (inheritType === 1) {
    lGlobalRS.copy(lParentGRM).multiply(lParentGSM).multiply(lLRM).multiply(lLSM);
  } else {
    const lParentLSM = new Matrix4().scale(new Vector3().setFromMatrixScale(lParentLX));
    const lParentLSM_inv = lParentLSM.clone().invert();
    const lParentGSM_noLocal = lParentGSM.clone().multiply(lParentLSM_inv);
    lGlobalRS.copy(lParentGRM).multiply(lLRM).multiply(lParentGSM_noLocal).multiply(lLSM);
  }
  const lRotationPivotM_inv = lRotationPivotM.clone().invert();
  const lScalingPivotM_inv = lScalingPivotM.clone().invert();
  let lTransform = lTranslationM.clone().multiply(lRotationOffsetM).multiply(lRotationPivotM).multiply(lPreRotationM).multiply(lRotationM).multiply(lPostRotationM).multiply(lRotationPivotM_inv).multiply(lScalingOffsetM).multiply(lScalingPivotM).multiply(lScalingM).multiply(lScalingPivotM_inv);
  const lLocalTWithAllPivotAndOffsetInfo = new Matrix4().copyPosition(lTransform);
  const lGlobalTranslation = lParentGX.clone().multiply(lLocalTWithAllPivotAndOffsetInfo);
  lGlobalT.copyPosition(lGlobalTranslation);
  lTransform = lGlobalT.clone().multiply(lGlobalRS);
  lTransform.premultiply(lParentGX.invert());
  return lTransform;
}
function getEulerOrder2(order) {
  order = order || 0;
  const enums = [
    "ZYX",
    "YZX",
    "XZY",
    "ZXY",
    "YXZ",
    "XYZ"
    // -> ZYX extrinsic
    //'SphericXYZ', // not possible to support
  ];
  if (order === 6) {
    console.warn("THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect.");
    return enums[0];
  }
  return enums[order];
}
function parseNumberArray2(value) {
  const array = value.split(",").map(function(val) {
    return parseFloat(val);
  });
  return array;
}
function convertArrayBufferToString2(buffer, from, to) {
  if (from === void 0)
    from = 0;
  if (to === void 0)
    to = buffer.byteLength;
  return new TextDecoder().decode(new Uint8Array(buffer, from, to));
}
function append2(a4, b5) {
  for (let i3 = 0, j = a4.length, l = b5.length; i3 < l; i3++, j++) {
    a4[j] = b5[i3];
  }
}
function slice2(a4, b5, from, to) {
  for (let i3 = from, j = 0; i3 < to; i3++, j++) {
    a4[j] = b5[i3];
  }
  return a4;
}
function inject2(a1, index, a22) {
  return a1.slice(0, index).concat(a22).concat(a1.slice(index));
}

// node_modules/kokomi.js/dist/lib/threejs-thin-film-iridescence/ThinFilmFresnelMap.js
var ThinFilmFresnelMap = class extends DataTexture {
  constructor(filmThickness = 380, refractiveIndexFilm = 2, refractiveIndexBase = 3, size2 = 64) {
    const data = new Uint8Array(size2 * 4);
    super(data, size2, 1, RGBAFormat, UnsignedByteType, UVMapping, RepeatWrapping, RepeatWrapping, LinearFilter, LinearMipMapLinearFilter);
    __publicField(this, "_filmThickness");
    __publicField(this, "_refractiveIndexFilm");
    __publicField(this, "_refractiveIndexBase");
    __publicField(this, "_size");
    __publicField(this, "_data");
    this._filmThickness = filmThickness;
    this._refractiveIndexFilm = refractiveIndexFilm;
    this._refractiveIndexBase = refractiveIndexBase;
    this._size = size2;
    this._data = data;
    this._updateData();
    this.generateMipmaps = true;
    this.needsUpdate = true;
  }
  get filmThickness() {
    return this._filmThickness;
  }
  set filmThickness(value) {
    this._filmThickness = value;
    this.updateSettings(this._filmThickness, this._refractiveIndexFilm, this._refractiveIndexBase);
  }
  get refractiveIndexFilm() {
    return this._refractiveIndexFilm;
  }
  set refractiveIndexFilm(value) {
    this._refractiveIndexFilm = value;
    this.updateSettings(this._filmThickness, this._refractiveIndexFilm, this._refractiveIndexBase);
  }
  get refractiveIndexBase() {
    return this._refractiveIndexBase;
  }
  set refractiveIndexBase(value) {
    this._refractiveIndexBase = value;
    this.updateSettings(this._filmThickness, this._refractiveIndexFilm, this._refractiveIndexBase);
  }
  /**
   * Regenerates the lookup texture given new data.
   * @param filmThickness The thickness of the thin film layer in nanometers. Defaults to 380.
   * @param refractiveIndexFilm The refractive index of the thin film. Defaults to 2.
   * @param refractiveIndexBase The refractive index of the material under the film. Defaults to 3.
   */
  updateSettings(filmThickness, refractiveIndexFilm, refractiveIndexBase) {
    this._filmThickness = filmThickness || 380;
    this._refractiveIndexFilm = refractiveIndexFilm || 2;
    this._refractiveIndexBase = refractiveIndexBase || 3;
    this._updateData();
  }
  /**
   * @private
   */
  _fresnelRefl(refractiveIndex1, refractiveIndex2, cos1, cos2, R2, phi) {
    var sin1Sqr = 1 - cos1 * cos1;
    var refrRatio = refractiveIndex1 / refractiveIndex2;
    if (refrRatio * refrRatio * sin1Sqr > 1) {
      R2.x = 1;
      R2.y = 1;
      var sqrRefrRatio = refrRatio * refrRatio;
      phi.x = 2 * Math.atan(-sqrRefrRatio * Math.sqrt(sin1Sqr - 1 / sqrRefrRatio) / cos1);
      phi.y = 2 * Math.atan(-Math.sqrt(sin1Sqr - 1 / sqrRefrRatio) / cos1);
    } else {
      var r_p = (refractiveIndex2 * cos1 - refractiveIndex1 * cos2) / (refractiveIndex2 * cos1 + refractiveIndex1 * cos2);
      var r_s = (refractiveIndex1 * cos1 - refractiveIndex2 * cos2) / (refractiveIndex1 * cos1 + refractiveIndex2 * cos2);
      phi.x = r_p < 0 ? Math.PI : 0;
      phi.y = r_s < 0 ? Math.PI : 0;
      R2.x = r_p * r_p;
      R2.y = r_s * r_s;
    }
  }
  /**
   * @private
   */
  _updateData() {
    var filmThickness = this._filmThickness;
    var refractiveIndexFilm = this._refractiveIndexFilm;
    var refractiveIndexBase = this._refractiveIndexBase;
    var size2 = this._size;
    function xFit_1931(lambda) {
      var t1 = (lambda - 442) * (lambda < 442 ? 0.0624 : 0.0374);
      var t2 = (lambda - 599.8) * (lambda < 599.8 ? 0.0264 : 0.0323);
      var t3 = (lambda - 501.1) * (lambda < 501.1 ? 0.049 : 0.0382);
      return 0.362 * Math.exp(-0.5 * t1 * t1) + 1.056 * Math.exp(-0.5 * t2 * t2) - 0.065 * Math.exp(-0.5 * t3 * t3);
    }
    function yFit_1931(lambda) {
      var t1 = (lambda - 568.8) * (lambda < 568.8 ? 0.0213 : 0.0247);
      var t2 = (lambda - 530.9) * (lambda < 530.9 ? 0.0613 : 0.0322);
      return 0.821 * Math.exp(-0.5 * t1 * t1) + 0.286 * Math.exp(-0.5 * t2 * t2);
    }
    function zFit_1931(lambda) {
      var t1 = (lambda - 437) * (lambda < 437 ? 0.0845 : 0.0278);
      var t2 = (lambda - 459) * (lambda < 459 ? 0.0385 : 0.0725);
      return 1.217 * Math.exp(-0.5 * t1 * t1) + 0.681 * Math.exp(-0.5 * t2 * t2);
    }
    var data = this._data;
    var phi12 = new Vector2();
    var phi21 = new Vector2();
    var phi23 = new Vector2();
    var R12 = new Vector2();
    var T12 = new Vector2();
    var R23 = new Vector2();
    var R_bi = new Vector2();
    var T_tot = new Vector2();
    var R_star = new Vector2();
    var R_bi_sqr = new Vector2();
    var R_12_star = new Vector2();
    var R_star_t_tot = new Vector2();
    var refrRatioSqr = 1 / (refractiveIndexFilm * refractiveIndexFilm);
    var refrRatioSqrBase = refractiveIndexFilm * refractiveIndexFilm / (refractiveIndexBase * refractiveIndexBase);
    var numBands = 64;
    var waveLenRange = 780 - 380;
    for (var i3 = 0; i3 < size2; ++i3) {
      var cosThetaI = i3 / size2;
      var cosThetaT = Math.sqrt(1 - refrRatioSqr * (1 - cosThetaI * cosThetaI));
      var cosThetaT2 = Math.sqrt(1 - refrRatioSqrBase * (1 - cosThetaT * cosThetaT));
      var pathDiff = 2 * refractiveIndexFilm * filmThickness * cosThetaT;
      var pathDiff2PI = 2 * Math.PI * pathDiff;
      this._fresnelRefl(1, refractiveIndexFilm, cosThetaI, cosThetaT, R12, phi12);
      T12.x = 1 - R12.x;
      T12.y = 1 - R12.y;
      phi21.x = Math.PI - phi12.x;
      phi21.y = Math.PI - phi12.y;
      this._fresnelRefl(refractiveIndexFilm, refractiveIndexBase, cosThetaT, cosThetaT2, R23, phi23);
      R_bi.x = Math.sqrt(R23.x * R12.x);
      R_bi.y = Math.sqrt(R23.y * R12.y);
      T_tot.x = Math.sqrt(T12.x * T12.x);
      T_tot.y = Math.sqrt(T12.y * T12.y);
      R_star.x = T12.x * T12.x * R23.x / (1 - R23.x * R12.x);
      R_star.y = T12.y * T12.y * R23.y / (1 - R23.y * R12.y);
      R_bi_sqr.x = R_bi.x * R_bi.x;
      R_bi_sqr.y = R_bi.y * R_bi.y;
      R_12_star.x = R12.x + R_star.x;
      R_12_star.y = R12.y + R_star.y;
      R_star_t_tot.x = R_star.x - T_tot.x;
      R_star_t_tot.y = R_star.y - T_tot.y;
      var x = 0, y = 0, z = 0;
      var totX = 0, totY = 0, totZ = 0;
      for (var j = 0; j < numBands; ++j) {
        var waveLen = 380 + j / (numBands - 1) * waveLenRange;
        var deltaPhase = pathDiff2PI / waveLen;
        var cosPhiX = Math.cos(deltaPhase + phi23.x + phi21.x);
        var cosPhiY = Math.cos(deltaPhase + phi23.y + phi21.y);
        var valX = R_12_star.x + 2 * (R_bi.x * cosPhiX - R_bi_sqr.x) / (1 - 2 * R_bi.x * cosPhiX + R_bi_sqr.x) * R_star_t_tot.x;
        var valY = R_12_star.y + 2 * (R_bi.y * cosPhiY - R_bi_sqr.y) / (1 - 2 * R_bi.y * cosPhiY + R_bi_sqr.y) * R_star_t_tot.y;
        var v = 0.5 * (valX + valY);
        var wx = xFit_1931(waveLen);
        var wy = yFit_1931(waveLen);
        var wz = zFit_1931(waveLen);
        totX += wx;
        totY += wy;
        totZ += wz;
        x += wx * v;
        y += wy * v;
        z += wz * v;
      }
      x /= totX;
      y /= totY;
      z /= totZ;
      var r = 3.2406 * x - 1.5372 * y - 0.4986 * z;
      var g2 = -0.9689 * x + 1.8758 * y + 0.0415 * z;
      var b5 = 0.0557 * x - 0.204 * y + 1.057 * z;
      r = MathUtils.clamp(r, 0, 1);
      g2 = MathUtils.clamp(g2, 0, 1);
      b5 = MathUtils.clamp(b5, 0, 1);
      r = Math.sqrt(r);
      g2 = Math.sqrt(g2);
      b5 = Math.sqrt(b5);
      var k = i3 << 2;
      data[k] = Math.floor(r * 255);
      data[k + 1] = Math.floor(g2 * 255);
      data[k + 2] = Math.floor(b5 * 255);
      data[k + 3] = 255;
    }
    this.needsUpdate = true;
  }
};

// node_modules/cannon-es/dist/cannon-es.js
var Mat3 = class {
  /**
   * A vector of length 9, containing all matrix elements.
   */
  /**
   * @param elements A vector of length 9, containing all matrix elements.
   */
  constructor(elements) {
    if (elements === void 0) {
      elements = [0, 0, 0, 0, 0, 0, 0, 0, 0];
    }
    this.elements = elements;
  }
  /**
   * Sets the matrix to identity
   * @todo Should perhaps be renamed to `setIdentity()` to be more clear.
   * @todo Create another function that immediately creates an identity matrix eg. `eye()`
   */
  identity() {
    const e = this.elements;
    e[0] = 1;
    e[1] = 0;
    e[2] = 0;
    e[3] = 0;
    e[4] = 1;
    e[5] = 0;
    e[6] = 0;
    e[7] = 0;
    e[8] = 1;
  }
  /**
   * Set all elements to zero
   */
  setZero() {
    const e = this.elements;
    e[0] = 0;
    e[1] = 0;
    e[2] = 0;
    e[3] = 0;
    e[4] = 0;
    e[5] = 0;
    e[6] = 0;
    e[7] = 0;
    e[8] = 0;
  }
  /**
   * Sets the matrix diagonal elements from a Vec3
   */
  setTrace(vector) {
    const e = this.elements;
    e[0] = vector.x;
    e[4] = vector.y;
    e[8] = vector.z;
  }
  /**
   * Gets the matrix diagonal elements
   */
  getTrace(target) {
    if (target === void 0) {
      target = new Vec3();
    }
    const e = this.elements;
    target.x = e[0];
    target.y = e[4];
    target.z = e[8];
    return target;
  }
  /**
   * Matrix-Vector multiplication
   * @param v The vector to multiply with
   * @param target Optional, target to save the result in.
   */
  vmult(v, target) {
    if (target === void 0) {
      target = new Vec3();
    }
    const e = this.elements;
    const x = v.x;
    const y = v.y;
    const z = v.z;
    target.x = e[0] * x + e[1] * y + e[2] * z;
    target.y = e[3] * x + e[4] * y + e[5] * z;
    target.z = e[6] * x + e[7] * y + e[8] * z;
    return target;
  }
  /**
   * Matrix-scalar multiplication
   */
  smult(s) {
    for (let i3 = 0; i3 < this.elements.length; i3++) {
      this.elements[i3] *= s;
    }
  }
  /**
   * Matrix multiplication
   * @param matrix Matrix to multiply with from left side.
   */
  mmult(matrix3, target) {
    if (target === void 0) {
      target = new Mat3();
    }
    const A2 = this.elements;
    const B2 = matrix3.elements;
    const T = target.elements;
    const a11 = A2[0], a12 = A2[1], a13 = A2[2], a21 = A2[3], a22 = A2[4], a23 = A2[5], a31 = A2[6], a32 = A2[7], a33 = A2[8];
    const b11 = B2[0], b12 = B2[1], b13 = B2[2], b21 = B2[3], b222 = B2[4], b23 = B2[5], b31 = B2[6], b32 = B2[7], b33 = B2[8];
    T[0] = a11 * b11 + a12 * b21 + a13 * b31;
    T[1] = a11 * b12 + a12 * b222 + a13 * b32;
    T[2] = a11 * b13 + a12 * b23 + a13 * b33;
    T[3] = a21 * b11 + a22 * b21 + a23 * b31;
    T[4] = a21 * b12 + a22 * b222 + a23 * b32;
    T[5] = a21 * b13 + a22 * b23 + a23 * b33;
    T[6] = a31 * b11 + a32 * b21 + a33 * b31;
    T[7] = a31 * b12 + a32 * b222 + a33 * b32;
    T[8] = a31 * b13 + a32 * b23 + a33 * b33;
    return target;
  }
  /**
   * Scale each column of the matrix
   */
  scale(vector, target) {
    if (target === void 0) {
      target = new Mat3();
    }
    const e = this.elements;
    const t2 = target.elements;
    for (let i3 = 0; i3 !== 3; i3++) {
      t2[3 * i3 + 0] = vector.x * e[3 * i3 + 0];
      t2[3 * i3 + 1] = vector.y * e[3 * i3 + 1];
      t2[3 * i3 + 2] = vector.z * e[3 * i3 + 2];
    }
    return target;
  }
  /**
   * Solve Ax=b
   * @param b The right hand side
   * @param target Optional. Target vector to save in.
   * @return The solution x
   * @todo should reuse arrays
   */
  solve(b5, target) {
    if (target === void 0) {
      target = new Vec3();
    }
    const nr = 3;
    const nc = 4;
    const eqns = [];
    let i3;
    let j;
    for (i3 = 0; i3 < nr * nc; i3++) {
      eqns.push(0);
    }
    for (i3 = 0; i3 < 3; i3++) {
      for (j = 0; j < 3; j++) {
        eqns[i3 + nc * j] = this.elements[i3 + 3 * j];
      }
    }
    eqns[3 + 4 * 0] = b5.x;
    eqns[3 + 4 * 1] = b5.y;
    eqns[3 + 4 * 2] = b5.z;
    let n = 3;
    const k = n;
    let np;
    const kp = 4;
    let p;
    do {
      i3 = k - n;
      if (eqns[i3 + nc * i3] === 0) {
        for (j = i3 + 1; j < k; j++) {
          if (eqns[i3 + nc * j] !== 0) {
            np = kp;
            do {
              p = kp - np;
              eqns[p + nc * i3] += eqns[p + nc * j];
            } while (--np);
            break;
          }
        }
      }
      if (eqns[i3 + nc * i3] !== 0) {
        for (j = i3 + 1; j < k; j++) {
          const multiplier = eqns[i3 + nc * j] / eqns[i3 + nc * i3];
          np = kp;
          do {
            p = kp - np;
            eqns[p + nc * j] = p <= i3 ? 0 : eqns[p + nc * j] - eqns[p + nc * i3] * multiplier;
          } while (--np);
        }
      }
    } while (--n);
    target.z = eqns[2 * nc + 3] / eqns[2 * nc + 2];
    target.y = (eqns[1 * nc + 3] - eqns[1 * nc + 2] * target.z) / eqns[1 * nc + 1];
    target.x = (eqns[0 * nc + 3] - eqns[0 * nc + 2] * target.z - eqns[0 * nc + 1] * target.y) / eqns[0 * nc + 0];
    if (isNaN(target.x) || isNaN(target.y) || isNaN(target.z) || target.x === Infinity || target.y === Infinity || target.z === Infinity) {
      throw `Could not solve equation! Got x=[${target.toString()}], b=[${b5.toString()}], A=[${this.toString()}]`;
    }
    return target;
  }
  /**
   * Get an element in the matrix by index. Index starts at 0, not 1!!!
   * @param value If provided, the matrix element will be set to this value.
   */
  e(row, column, value) {
    if (value === void 0) {
      return this.elements[column + 3 * row];
    } else {
      this.elements[column + 3 * row] = value;
    }
  }
  /**
   * Copy another matrix into this matrix object.
   */
  copy(matrix3) {
    for (let i3 = 0; i3 < matrix3.elements.length; i3++) {
      this.elements[i3] = matrix3.elements[i3];
    }
    return this;
  }
  /**
   * Returns a string representation of the matrix.
   */
  toString() {
    let r = "";
    const sep = ",";
    for (let i3 = 0; i3 < 9; i3++) {
      r += this.elements[i3] + sep;
    }
    return r;
  }
  /**
   * reverse the matrix
   * @param target Target matrix to save in.
   * @return The solution x
   */
  reverse(target) {
    if (target === void 0) {
      target = new Mat3();
    }
    const nr = 3;
    const nc = 6;
    const eqns = reverse_eqns;
    let i3;
    let j;
    for (i3 = 0; i3 < 3; i3++) {
      for (j = 0; j < 3; j++) {
        eqns[i3 + nc * j] = this.elements[i3 + 3 * j];
      }
    }
    eqns[3 + 6 * 0] = 1;
    eqns[3 + 6 * 1] = 0;
    eqns[3 + 6 * 2] = 0;
    eqns[4 + 6 * 0] = 0;
    eqns[4 + 6 * 1] = 1;
    eqns[4 + 6 * 2] = 0;
    eqns[5 + 6 * 0] = 0;
    eqns[5 + 6 * 1] = 0;
    eqns[5 + 6 * 2] = 1;
    let n = 3;
    const k = n;
    let np;
    const kp = nc;
    let p;
    do {
      i3 = k - n;
      if (eqns[i3 + nc * i3] === 0) {
        for (j = i3 + 1; j < k; j++) {
          if (eqns[i3 + nc * j] !== 0) {
            np = kp;
            do {
              p = kp - np;
              eqns[p + nc * i3] += eqns[p + nc * j];
            } while (--np);
            break;
          }
        }
      }
      if (eqns[i3 + nc * i3] !== 0) {
        for (j = i3 + 1; j < k; j++) {
          const multiplier = eqns[i3 + nc * j] / eqns[i3 + nc * i3];
          np = kp;
          do {
            p = kp - np;
            eqns[p + nc * j] = p <= i3 ? 0 : eqns[p + nc * j] - eqns[p + nc * i3] * multiplier;
          } while (--np);
        }
      }
    } while (--n);
    i3 = 2;
    do {
      j = i3 - 1;
      do {
        const multiplier = eqns[i3 + nc * j] / eqns[i3 + nc * i3];
        np = nc;
        do {
          p = nc - np;
          eqns[p + nc * j] = eqns[p + nc * j] - eqns[p + nc * i3] * multiplier;
        } while (--np);
      } while (j--);
    } while (--i3);
    i3 = 2;
    do {
      const multiplier = 1 / eqns[i3 + nc * i3];
      np = nc;
      do {
        p = nc - np;
        eqns[p + nc * i3] = eqns[p + nc * i3] * multiplier;
      } while (--np);
    } while (i3--);
    i3 = 2;
    do {
      j = 2;
      do {
        p = eqns[nr + j + nc * i3];
        if (isNaN(p) || p === Infinity) {
          throw `Could not reverse! A=[${this.toString()}]`;
        }
        target.e(i3, j, p);
      } while (j--);
    } while (i3--);
    return target;
  }
  /**
   * Set the matrix from a quaterion
   */
  setRotationFromQuaternion(q) {
    const x = q.x;
    const y = q.y;
    const z = q.z;
    const w = q.w;
    const x2 = x + x;
    const y2 = y + y;
    const z2 = z + z;
    const xx = x * x2;
    const xy = x * y2;
    const xz = x * z2;
    const yy = y * y2;
    const yz = y * z2;
    const zz = z * z2;
    const wx = w * x2;
    const wy = w * y2;
    const wz = w * z2;
    const e = this.elements;
    e[3 * 0 + 0] = 1 - (yy + zz);
    e[3 * 0 + 1] = xy - wz;
    e[3 * 0 + 2] = xz + wy;
    e[3 * 1 + 0] = xy + wz;
    e[3 * 1 + 1] = 1 - (xx + zz);
    e[3 * 1 + 2] = yz - wx;
    e[3 * 2 + 0] = xz - wy;
    e[3 * 2 + 1] = yz + wx;
    e[3 * 2 + 2] = 1 - (xx + yy);
    return this;
  }
  /**
   * Transpose the matrix
   * @param target Optional. Where to store the result.
   * @return The target Mat3, or a new Mat3 if target was omitted.
   */
  transpose(target) {
    if (target === void 0) {
      target = new Mat3();
    }
    const M = this.elements;
    const T = target.elements;
    let tmp2;
    T[0] = M[0];
    T[4] = M[4];
    T[8] = M[8];
    tmp2 = M[1];
    T[1] = M[3];
    T[3] = tmp2;
    tmp2 = M[2];
    T[2] = M[6];
    T[6] = tmp2;
    tmp2 = M[5];
    T[5] = M[7];
    T[7] = tmp2;
    return target;
  }
};
var reverse_eqns = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
var Vec3 = class {
  constructor(x, y, z) {
    if (x === void 0) {
      x = 0;
    }
    if (y === void 0) {
      y = 0;
    }
    if (z === void 0) {
      z = 0;
    }
    this.x = x;
    this.y = y;
    this.z = z;
  }
  /**
   * Vector cross product
   * @param target Optional target to save in.
   */
  cross(vector, target) {
    if (target === void 0) {
      target = new Vec3();
    }
    const vx = vector.x;
    const vy = vector.y;
    const vz = vector.z;
    const x = this.x;
    const y = this.y;
    const z = this.z;
    target.x = y * vz - z * vy;
    target.y = z * vx - x * vz;
    target.z = x * vy - y * vx;
    return target;
  }
  /**
   * Set the vectors' 3 elements
   */
  set(x, y, z) {
    this.x = x;
    this.y = y;
    this.z = z;
    return this;
  }
  /**
   * Set all components of the vector to zero.
   */
  setZero() {
    this.x = this.y = this.z = 0;
  }
  /**
   * Vector addition
   */
  vadd(vector, target) {
    if (target) {
      target.x = vector.x + this.x;
      target.y = vector.y + this.y;
      target.z = vector.z + this.z;
    } else {
      return new Vec3(this.x + vector.x, this.y + vector.y, this.z + vector.z);
    }
  }
  /**
   * Vector subtraction
   * @param target Optional target to save in.
   */
  vsub(vector, target) {
    if (target) {
      target.x = this.x - vector.x;
      target.y = this.y - vector.y;
      target.z = this.z - vector.z;
    } else {
      return new Vec3(this.x - vector.x, this.y - vector.y, this.z - vector.z);
    }
  }
  /**
   * Get the cross product matrix a_cross from a vector, such that a x b = a_cross * b = c
   *
   * See {@link https://www8.cs.umu.se/kurser/TDBD24/VT06/lectures/Lecture6.pdf Umeå University Lecture}
   */
  crossmat() {
    return new Mat3([0, -this.z, this.y, this.z, 0, -this.x, -this.y, this.x, 0]);
  }
  /**
   * Normalize the vector. Note that this changes the values in the vector.
    * @return Returns the norm of the vector
   */
  normalize() {
    const x = this.x;
    const y = this.y;
    const z = this.z;
    const n = Math.sqrt(x * x + y * y + z * z);
    if (n > 0) {
      const invN = 1 / n;
      this.x *= invN;
      this.y *= invN;
      this.z *= invN;
    } else {
      this.x = 0;
      this.y = 0;
      this.z = 0;
    }
    return n;
  }
  /**
   * Get the version of this vector that is of length 1.
   * @param target Optional target to save in
   * @return Returns the unit vector
   */
  unit(target) {
    if (target === void 0) {
      target = new Vec3();
    }
    const x = this.x;
    const y = this.y;
    const z = this.z;
    let ninv = Math.sqrt(x * x + y * y + z * z);
    if (ninv > 0) {
      ninv = 1 / ninv;
      target.x = x * ninv;
      target.y = y * ninv;
      target.z = z * ninv;
    } else {
      target.x = 1;
      target.y = 0;
      target.z = 0;
    }
    return target;
  }
  /**
   * Get the length of the vector
   */
  length() {
    const x = this.x;
    const y = this.y;
    const z = this.z;
    return Math.sqrt(x * x + y * y + z * z);
  }
  /**
   * Get the squared length of the vector.
   */
  lengthSquared() {
    return this.dot(this);
  }
  /**
   * Get distance from this point to another point
   */
  distanceTo(p) {
    const x = this.x;
    const y = this.y;
    const z = this.z;
    const px = p.x;
    const py = p.y;
    const pz = p.z;
    return Math.sqrt((px - x) * (px - x) + (py - y) * (py - y) + (pz - z) * (pz - z));
  }
  /**
   * Get squared distance from this point to another point
   */
  distanceSquared(p) {
    const x = this.x;
    const y = this.y;
    const z = this.z;
    const px = p.x;
    const py = p.y;
    const pz = p.z;
    return (px - x) * (px - x) + (py - y) * (py - y) + (pz - z) * (pz - z);
  }
  /**
   * Multiply all the components of the vector with a scalar.
   * @param target The vector to save the result in.
   */
  scale(scalar, target) {
    if (target === void 0) {
      target = new Vec3();
    }
    const x = this.x;
    const y = this.y;
    const z = this.z;
    target.x = scalar * x;
    target.y = scalar * y;
    target.z = scalar * z;
    return target;
  }
  /**
   * Multiply the vector with an other vector, component-wise.
   * @param target The vector to save the result in.
   */
  vmul(vector, target) {
    if (target === void 0) {
      target = new Vec3();
    }
    target.x = vector.x * this.x;
    target.y = vector.y * this.y;
    target.z = vector.z * this.z;
    return target;
  }
  /**
   * Scale a vector and add it to this vector. Save the result in "target". (target = this + vector * scalar)
   * @param target The vector to save the result in.
   */
  addScaledVector(scalar, vector, target) {
    if (target === void 0) {
      target = new Vec3();
    }
    target.x = this.x + scalar * vector.x;
    target.y = this.y + scalar * vector.y;
    target.z = this.z + scalar * vector.z;
    return target;
  }
  /**
   * Calculate dot product
   * @param vector
   */
  dot(vector) {
    return this.x * vector.x + this.y * vector.y + this.z * vector.z;
  }
  isZero() {
    return this.x === 0 && this.y === 0 && this.z === 0;
  }
  /**
   * Make the vector point in the opposite direction.
   * @param target Optional target to save in
   */
  negate(target) {
    if (target === void 0) {
      target = new Vec3();
    }
    target.x = -this.x;
    target.y = -this.y;
    target.z = -this.z;
    return target;
  }
  /**
   * Compute two artificial tangents to the vector
   * @param t1 Vector object to save the first tangent in
   * @param t2 Vector object to save the second tangent in
   */
  tangents(t1, t2) {
    const norm = this.length();
    if (norm > 0) {
      const n = Vec3_tangents_n;
      const inorm = 1 / norm;
      n.set(this.x * inorm, this.y * inorm, this.z * inorm);
      const randVec = Vec3_tangents_randVec;
      if (Math.abs(n.x) < 0.9) {
        randVec.set(1, 0, 0);
        n.cross(randVec, t1);
      } else {
        randVec.set(0, 1, 0);
        n.cross(randVec, t1);
      }
      n.cross(t1, t2);
    } else {
      t1.set(1, 0, 0);
      t2.set(0, 1, 0);
    }
  }
  /**
   * Converts to a more readable format
   */
  toString() {
    return `${this.x},${this.y},${this.z}`;
  }
  /**
   * Converts to an array
   */
  toArray() {
    return [this.x, this.y, this.z];
  }
  /**
   * Copies value of source to this vector.
   */
  copy(vector) {
    this.x = vector.x;
    this.y = vector.y;
    this.z = vector.z;
    return this;
  }
  /**
   * Do a linear interpolation between two vectors
   * @param t A number between 0 and 1. 0 will make this function return u, and 1 will make it return v. Numbers in between will generate a vector in between them.
   */
  lerp(vector, t2, target) {
    const x = this.x;
    const y = this.y;
    const z = this.z;
    target.x = x + (vector.x - x) * t2;
    target.y = y + (vector.y - y) * t2;
    target.z = z + (vector.z - z) * t2;
  }
  /**
   * Check if a vector equals is almost equal to another one.
   */
  almostEquals(vector, precision) {
    if (precision === void 0) {
      precision = 1e-6;
    }
    if (Math.abs(this.x - vector.x) > precision || Math.abs(this.y - vector.y) > precision || Math.abs(this.z - vector.z) > precision) {
      return false;
    }
    return true;
  }
  /**
   * Check if a vector is almost zero
   */
  almostZero(precision) {
    if (precision === void 0) {
      precision = 1e-6;
    }
    if (Math.abs(this.x) > precision || Math.abs(this.y) > precision || Math.abs(this.z) > precision) {
      return false;
    }
    return true;
  }
  /**
   * Check if the vector is anti-parallel to another vector.
   * @param precision Set to zero for exact comparisons
   */
  isAntiparallelTo(vector, precision) {
    this.negate(antip_neg);
    return antip_neg.almostEquals(vector, precision);
  }
  /**
   * Clone the vector
   */
  clone() {
    return new Vec3(this.x, this.y, this.z);
  }
};
Vec3.ZERO = new Vec3(0, 0, 0);
Vec3.UNIT_X = new Vec3(1, 0, 0);
Vec3.UNIT_Y = new Vec3(0, 1, 0);
Vec3.UNIT_Z = new Vec3(0, 0, 1);
var Vec3_tangents_n = new Vec3();
var Vec3_tangents_randVec = new Vec3();
var antip_neg = new Vec3();
var AABB = class {
  /**
   * The lower bound of the bounding box
   */
  /**
   * The upper bound of the bounding box
   */
  constructor(options) {
    if (options === void 0) {
      options = {};
    }
    this.lowerBound = new Vec3();
    this.upperBound = new Vec3();
    if (options.lowerBound) {
      this.lowerBound.copy(options.lowerBound);
    }
    if (options.upperBound) {
      this.upperBound.copy(options.upperBound);
    }
  }
  /**
   * Set the AABB bounds from a set of points.
   * @param points An array of Vec3's.
   * @return The self object
   */
  setFromPoints(points, position, quaternion, skinSize) {
    const l = this.lowerBound;
    const u = this.upperBound;
    const q = quaternion;
    l.copy(points[0]);
    if (q) {
      q.vmult(l, l);
    }
    u.copy(l);
    for (let i3 = 1; i3 < points.length; i3++) {
      let p = points[i3];
      if (q) {
        q.vmult(p, tmp$1);
        p = tmp$1;
      }
      if (p.x > u.x) {
        u.x = p.x;
      }
      if (p.x < l.x) {
        l.x = p.x;
      }
      if (p.y > u.y) {
        u.y = p.y;
      }
      if (p.y < l.y) {
        l.y = p.y;
      }
      if (p.z > u.z) {
        u.z = p.z;
      }
      if (p.z < l.z) {
        l.z = p.z;
      }
    }
    if (position) {
      position.vadd(l, l);
      position.vadd(u, u);
    }
    if (skinSize) {
      l.x -= skinSize;
      l.y -= skinSize;
      l.z -= skinSize;
      u.x += skinSize;
      u.y += skinSize;
      u.z += skinSize;
    }
    return this;
  }
  /**
   * Copy bounds from an AABB to this AABB
   * @param aabb Source to copy from
   * @return The this object, for chainability
   */
  copy(aabb2) {
    this.lowerBound.copy(aabb2.lowerBound);
    this.upperBound.copy(aabb2.upperBound);
    return this;
  }
  /**
   * Clone an AABB
   */
  clone() {
    return new AABB().copy(this);
  }
  /**
   * Extend this AABB so that it covers the given AABB too.
   */
  extend(aabb2) {
    this.lowerBound.x = Math.min(this.lowerBound.x, aabb2.lowerBound.x);
    this.upperBound.x = Math.max(this.upperBound.x, aabb2.upperBound.x);
    this.lowerBound.y = Math.min(this.lowerBound.y, aabb2.lowerBound.y);
    this.upperBound.y = Math.max(this.upperBound.y, aabb2.upperBound.y);
    this.lowerBound.z = Math.min(this.lowerBound.z, aabb2.lowerBound.z);
    this.upperBound.z = Math.max(this.upperBound.z, aabb2.upperBound.z);
  }
  /**
   * Returns true if the given AABB overlaps this AABB.
   */
  overlaps(aabb2) {
    const l1 = this.lowerBound;
    const u1 = this.upperBound;
    const l2 = aabb2.lowerBound;
    const u2 = aabb2.upperBound;
    const overlapsX = l2.x <= u1.x && u1.x <= u2.x || l1.x <= u2.x && u2.x <= u1.x;
    const overlapsY = l2.y <= u1.y && u1.y <= u2.y || l1.y <= u2.y && u2.y <= u1.y;
    const overlapsZ = l2.z <= u1.z && u1.z <= u2.z || l1.z <= u2.z && u2.z <= u1.z;
    return overlapsX && overlapsY && overlapsZ;
  }
  // Mostly for debugging
  volume() {
    const l = this.lowerBound;
    const u = this.upperBound;
    return (u.x - l.x) * (u.y - l.y) * (u.z - l.z);
  }
  /**
   * Returns true if the given AABB is fully contained in this AABB.
   */
  contains(aabb2) {
    const l1 = this.lowerBound;
    const u1 = this.upperBound;
    const l2 = aabb2.lowerBound;
    const u2 = aabb2.upperBound;
    return l1.x <= l2.x && u1.x >= u2.x && l1.y <= l2.y && u1.y >= u2.y && l1.z <= l2.z && u1.z >= u2.z;
  }
  getCorners(a4, b5, c3, d, e, f, g2, h) {
    const l = this.lowerBound;
    const u = this.upperBound;
    a4.copy(l);
    b5.set(u.x, l.y, l.z);
    c3.set(u.x, u.y, l.z);
    d.set(l.x, u.y, u.z);
    e.set(u.x, l.y, u.z);
    f.set(l.x, u.y, l.z);
    g2.set(l.x, l.y, u.z);
    h.copy(u);
  }
  /**
   * Get the representation of an AABB in another frame.
   * @return The "target" AABB object.
   */
  toLocalFrame(frame, target) {
    const corners = transformIntoFrame_corners;
    const a4 = corners[0];
    const b5 = corners[1];
    const c3 = corners[2];
    const d = corners[3];
    const e = corners[4];
    const f = corners[5];
    const g2 = corners[6];
    const h = corners[7];
    this.getCorners(a4, b5, c3, d, e, f, g2, h);
    for (let i3 = 0; i3 !== 8; i3++) {
      const corner = corners[i3];
      frame.pointToLocal(corner, corner);
    }
    return target.setFromPoints(corners);
  }
  /**
   * Get the representation of an AABB in the global frame.
   * @return The "target" AABB object.
   */
  toWorldFrame(frame, target) {
    const corners = transformIntoFrame_corners;
    const a4 = corners[0];
    const b5 = corners[1];
    const c3 = corners[2];
    const d = corners[3];
    const e = corners[4];
    const f = corners[5];
    const g2 = corners[6];
    const h = corners[7];
    this.getCorners(a4, b5, c3, d, e, f, g2, h);
    for (let i3 = 0; i3 !== 8; i3++) {
      const corner = corners[i3];
      frame.pointToWorld(corner, corner);
    }
    return target.setFromPoints(corners);
  }
  /**
   * Check if the AABB is hit by a ray.
   */
  overlapsRay(ray) {
    const {
      direction,
      from
    } = ray;
    const dirFracX = 1 / direction.x;
    const dirFracY = 1 / direction.y;
    const dirFracZ = 1 / direction.z;
    const t1 = (this.lowerBound.x - from.x) * dirFracX;
    const t2 = (this.upperBound.x - from.x) * dirFracX;
    const t3 = (this.lowerBound.y - from.y) * dirFracY;
    const t4 = (this.upperBound.y - from.y) * dirFracY;
    const t5 = (this.lowerBound.z - from.z) * dirFracZ;
    const t6 = (this.upperBound.z - from.z) * dirFracZ;
    const tmin = Math.max(Math.max(Math.min(t1, t2), Math.min(t3, t4)), Math.min(t5, t6));
    const tmax = Math.min(Math.min(Math.max(t1, t2), Math.max(t3, t4)), Math.max(t5, t6));
    if (tmax < 0) {
      return false;
    }
    if (tmin > tmax) {
      return false;
    }
    return true;
  }
};
var tmp$1 = new Vec3();
var transformIntoFrame_corners = [new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3()];
var ArrayCollisionMatrix = class {
  /**
   * The matrix storage.
   */
  constructor() {
    this.matrix = [];
  }
  /**
   * Get an element
   */
  get(bi, bj) {
    let {
      index: i3
    } = bi;
    let {
      index: j
    } = bj;
    if (j > i3) {
      const temp = j;
      j = i3;
      i3 = temp;
    }
    return this.matrix[(i3 * (i3 + 1) >> 1) + j - 1];
  }
  /**
   * Set an element
   */
  set(bi, bj, value) {
    let {
      index: i3
    } = bi;
    let {
      index: j
    } = bj;
    if (j > i3) {
      const temp = j;
      j = i3;
      i3 = temp;
    }
    this.matrix[(i3 * (i3 + 1) >> 1) + j - 1] = value ? 1 : 0;
  }
  /**
   * Sets all elements to zero
   */
  reset() {
    for (let i3 = 0, l = this.matrix.length; i3 !== l; i3++) {
      this.matrix[i3] = 0;
    }
  }
  /**
   * Sets the max number of objects
   */
  setNumObjects(n) {
    this.matrix.length = n * (n - 1) >> 1;
  }
};
var EventTarget = class {
  /**
   * Add an event listener
   * @return The self object, for chainability.
   */
  addEventListener(type, listener) {
    if (this._listeners === void 0) {
      this._listeners = {};
    }
    const listeners = this._listeners;
    if (listeners[type] === void 0) {
      listeners[type] = [];
    }
    if (!listeners[type].includes(listener)) {
      listeners[type].push(listener);
    }
    return this;
  }
  /**
   * Check if an event listener is added
   */
  hasEventListener(type, listener) {
    if (this._listeners === void 0) {
      return false;
    }
    const listeners = this._listeners;
    if (listeners[type] !== void 0 && listeners[type].includes(listener)) {
      return true;
    }
    return false;
  }
  /**
   * Check if any event listener of the given type is added
   */
  hasAnyEventListener(type) {
    if (this._listeners === void 0) {
      return false;
    }
    const listeners = this._listeners;
    return listeners[type] !== void 0;
  }
  /**
   * Remove an event listener
   * @return The self object, for chainability.
   */
  removeEventListener(type, listener) {
    if (this._listeners === void 0) {
      return this;
    }
    const listeners = this._listeners;
    if (listeners[type] === void 0) {
      return this;
    }
    const index = listeners[type].indexOf(listener);
    if (index !== -1) {
      listeners[type].splice(index, 1);
    }
    return this;
  }
  /**
   * Emit an event.
   * @return The self object, for chainability.
   */
  dispatchEvent(event) {
    if (this._listeners === void 0) {
      return this;
    }
    const listeners = this._listeners;
    const listenerArray = listeners[event.type];
    if (listenerArray !== void 0) {
      event.target = this;
      for (let i3 = 0, l = listenerArray.length; i3 < l; i3++) {
        listenerArray[i3].call(this, event);
      }
    }
    return this;
  }
};
var Quaternion2 = class {
  constructor(x, y, z, w) {
    if (x === void 0) {
      x = 0;
    }
    if (y === void 0) {
      y = 0;
    }
    if (z === void 0) {
      z = 0;
    }
    if (w === void 0) {
      w = 1;
    }
    this.x = x;
    this.y = y;
    this.z = z;
    this.w = w;
  }
  /**
   * Set the value of the quaternion.
   */
  set(x, y, z, w) {
    this.x = x;
    this.y = y;
    this.z = z;
    this.w = w;
    return this;
  }
  /**
   * Convert to a readable format
   * @return "x,y,z,w"
   */
  toString() {
    return `${this.x},${this.y},${this.z},${this.w}`;
  }
  /**
   * Convert to an Array
   * @return [x, y, z, w]
   */
  toArray() {
    return [this.x, this.y, this.z, this.w];
  }
  /**
   * Set the quaternion components given an axis and an angle in radians.
   */
  setFromAxisAngle(vector, angle2) {
    const s = Math.sin(angle2 * 0.5);
    this.x = vector.x * s;
    this.y = vector.y * s;
    this.z = vector.z * s;
    this.w = Math.cos(angle2 * 0.5);
    return this;
  }
  /**
   * Converts the quaternion to [ axis, angle ] representation.
   * @param targetAxis A vector object to reuse for storing the axis.
   * @return An array, first element is the axis and the second is the angle in radians.
   */
  toAxisAngle(targetAxis) {
    if (targetAxis === void 0) {
      targetAxis = new Vec3();
    }
    this.normalize();
    const angle2 = 2 * Math.acos(this.w);
    const s = Math.sqrt(1 - this.w * this.w);
    if (s < 1e-3) {
      targetAxis.x = this.x;
      targetAxis.y = this.y;
      targetAxis.z = this.z;
    } else {
      targetAxis.x = this.x / s;
      targetAxis.y = this.y / s;
      targetAxis.z = this.z / s;
    }
    return [targetAxis, angle2];
  }
  /**
   * Set the quaternion value given two vectors. The resulting rotation will be the needed rotation to rotate u to v.
   */
  setFromVectors(u, v) {
    if (u.isAntiparallelTo(v)) {
      const t1 = sfv_t1;
      const t2 = sfv_t2;
      u.tangents(t1, t2);
      this.setFromAxisAngle(t1, Math.PI);
    } else {
      const a4 = u.cross(v);
      this.x = a4.x;
      this.y = a4.y;
      this.z = a4.z;
      this.w = Math.sqrt(u.length() ** 2 * v.length() ** 2) + u.dot(v);
      this.normalize();
    }
    return this;
  }
  /**
   * Multiply the quaternion with an other quaternion.
   */
  mult(quat, target) {
    if (target === void 0) {
      target = new Quaternion2();
    }
    const ax = this.x;
    const ay = this.y;
    const az = this.z;
    const aw = this.w;
    const bx = quat.x;
    const by = quat.y;
    const bz = quat.z;
    const bw = quat.w;
    target.x = ax * bw + aw * bx + ay * bz - az * by;
    target.y = ay * bw + aw * by + az * bx - ax * bz;
    target.z = az * bw + aw * bz + ax * by - ay * bx;
    target.w = aw * bw - ax * bx - ay * by - az * bz;
    return target;
  }
  /**
   * Get the inverse quaternion rotation.
   */
  inverse(target) {
    if (target === void 0) {
      target = new Quaternion2();
    }
    const x = this.x;
    const y = this.y;
    const z = this.z;
    const w = this.w;
    this.conjugate(target);
    const inorm2 = 1 / (x * x + y * y + z * z + w * w);
    target.x *= inorm2;
    target.y *= inorm2;
    target.z *= inorm2;
    target.w *= inorm2;
    return target;
  }
  /**
   * Get the quaternion conjugate
   */
  conjugate(target) {
    if (target === void 0) {
      target = new Quaternion2();
    }
    target.x = -this.x;
    target.y = -this.y;
    target.z = -this.z;
    target.w = this.w;
    return target;
  }
  /**
   * Normalize the quaternion. Note that this changes the values of the quaternion.
   */
  normalize() {
    let l = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
    if (l === 0) {
      this.x = 0;
      this.y = 0;
      this.z = 0;
      this.w = 0;
    } else {
      l = 1 / l;
      this.x *= l;
      this.y *= l;
      this.z *= l;
      this.w *= l;
    }
    return this;
  }
  /**
   * Approximation of quaternion normalization. Works best when quat is already almost-normalized.
   * @author unphased, https://github.com/unphased
   */
  normalizeFast() {
    const f = (3 - (this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)) / 2;
    if (f === 0) {
      this.x = 0;
      this.y = 0;
      this.z = 0;
      this.w = 0;
    } else {
      this.x *= f;
      this.y *= f;
      this.z *= f;
      this.w *= f;
    }
    return this;
  }
  /**
   * Multiply the quaternion by a vector
   */
  vmult(v, target) {
    if (target === void 0) {
      target = new Vec3();
    }
    const x = v.x;
    const y = v.y;
    const z = v.z;
    const qx = this.x;
    const qy = this.y;
    const qz = this.z;
    const qw = this.w;
    const ix = qw * x + qy * z - qz * y;
    const iy = qw * y + qz * x - qx * z;
    const iz = qw * z + qx * y - qy * x;
    const iw = -qx * x - qy * y - qz * z;
    target.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    target.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    target.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    return target;
  }
  /**
   * Copies value of source to this quaternion.
   * @return this
   */
  copy(quat) {
    this.x = quat.x;
    this.y = quat.y;
    this.z = quat.z;
    this.w = quat.w;
    return this;
  }
  /**
   * Convert the quaternion to euler angle representation. Order: YZX, as this page describes: https://www.euclideanspace.com/maths/standards/index.htm
   * @param order Three-character string, defaults to "YZX"
   */
  toEuler(target, order) {
    if (order === void 0) {
      order = "YZX";
    }
    let heading;
    let attitude;
    let bank;
    const x = this.x;
    const y = this.y;
    const z = this.z;
    const w = this.w;
    switch (order) {
      case "YZX":
        const test = x * y + z * w;
        if (test > 0.499) {
          heading = 2 * Math.atan2(x, w);
          attitude = Math.PI / 2;
          bank = 0;
        }
        if (test < -0.499) {
          heading = -2 * Math.atan2(x, w);
          attitude = -Math.PI / 2;
          bank = 0;
        }
        if (heading === void 0) {
          const sqx = x * x;
          const sqy = y * y;
          const sqz = z * z;
          heading = Math.atan2(2 * y * w - 2 * x * z, 1 - 2 * sqy - 2 * sqz);
          attitude = Math.asin(2 * test);
          bank = Math.atan2(2 * x * w - 2 * y * z, 1 - 2 * sqx - 2 * sqz);
        }
        break;
      default:
        throw new Error(`Euler order ${order} not supported yet.`);
    }
    target.y = heading;
    target.z = attitude;
    target.x = bank;
  }
  /**
   * Set the quaternion components given Euler angle representation.
   *
   * @param order The order to apply angles: 'XYZ' or 'YXZ' or any other combination.
   *
   * See {@link https://www.mathworks.com/matlabcentral/fileexchange/20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors MathWorks} reference
   */
  setFromEuler(x, y, z, order) {
    if (order === void 0) {
      order = "XYZ";
    }
    const c1 = Math.cos(x / 2);
    const c22 = Math.cos(y / 2);
    const c3 = Math.cos(z / 2);
    const s1 = Math.sin(x / 2);
    const s2 = Math.sin(y / 2);
    const s3 = Math.sin(z / 2);
    if (order === "XYZ") {
      this.x = s1 * c22 * c3 + c1 * s2 * s3;
      this.y = c1 * s2 * c3 - s1 * c22 * s3;
      this.z = c1 * c22 * s3 + s1 * s2 * c3;
      this.w = c1 * c22 * c3 - s1 * s2 * s3;
    } else if (order === "YXZ") {
      this.x = s1 * c22 * c3 + c1 * s2 * s3;
      this.y = c1 * s2 * c3 - s1 * c22 * s3;
      this.z = c1 * c22 * s3 - s1 * s2 * c3;
      this.w = c1 * c22 * c3 + s1 * s2 * s3;
    } else if (order === "ZXY") {
      this.x = s1 * c22 * c3 - c1 * s2 * s3;
      this.y = c1 * s2 * c3 + s1 * c22 * s3;
      this.z = c1 * c22 * s3 + s1 * s2 * c3;
      this.w = c1 * c22 * c3 - s1 * s2 * s3;
    } else if (order === "ZYX") {
      this.x = s1 * c22 * c3 - c1 * s2 * s3;
      this.y = c1 * s2 * c3 + s1 * c22 * s3;
      this.z = c1 * c22 * s3 - s1 * s2 * c3;
      this.w = c1 * c22 * c3 + s1 * s2 * s3;
    } else if (order === "YZX") {
      this.x = s1 * c22 * c3 + c1 * s2 * s3;
      this.y = c1 * s2 * c3 + s1 * c22 * s3;
      this.z = c1 * c22 * s3 - s1 * s2 * c3;
      this.w = c1 * c22 * c3 - s1 * s2 * s3;
    } else if (order === "XZY") {
      this.x = s1 * c22 * c3 - c1 * s2 * s3;
      this.y = c1 * s2 * c3 - s1 * c22 * s3;
      this.z = c1 * c22 * s3 + s1 * s2 * c3;
      this.w = c1 * c22 * c3 + s1 * s2 * s3;
    }
    return this;
  }
  clone() {
    return new Quaternion2(this.x, this.y, this.z, this.w);
  }
  /**
   * Performs a spherical linear interpolation between two quat
   *
   * @param toQuat second operand
   * @param t interpolation amount between the self quaternion and toQuat
   * @param target A quaternion to store the result in. If not provided, a new one will be created.
   * @returns {Quaternion} The "target" object
   */
  slerp(toQuat, t2, target) {
    if (target === void 0) {
      target = new Quaternion2();
    }
    const ax = this.x;
    const ay = this.y;
    const az = this.z;
    const aw = this.w;
    let bx = toQuat.x;
    let by = toQuat.y;
    let bz = toQuat.z;
    let bw = toQuat.w;
    let omega;
    let cosom;
    let sinom;
    let scale0;
    let scale1;
    cosom = ax * bx + ay * by + az * bz + aw * bw;
    if (cosom < 0) {
      cosom = -cosom;
      bx = -bx;
      by = -by;
      bz = -bz;
      bw = -bw;
    }
    if (1 - cosom > 1e-6) {
      omega = Math.acos(cosom);
      sinom = Math.sin(omega);
      scale0 = Math.sin((1 - t2) * omega) / sinom;
      scale1 = Math.sin(t2 * omega) / sinom;
    } else {
      scale0 = 1 - t2;
      scale1 = t2;
    }
    target.x = scale0 * ax + scale1 * bx;
    target.y = scale0 * ay + scale1 * by;
    target.z = scale0 * az + scale1 * bz;
    target.w = scale0 * aw + scale1 * bw;
    return target;
  }
  /**
   * Rotate an absolute orientation quaternion given an angular velocity and a time step.
   */
  integrate(angularVelocity, dt, angularFactor, target) {
    if (target === void 0) {
      target = new Quaternion2();
    }
    const ax = angularVelocity.x * angularFactor.x, ay = angularVelocity.y * angularFactor.y, az = angularVelocity.z * angularFactor.z, bx = this.x, by = this.y, bz = this.z, bw = this.w;
    const half_dt = dt * 0.5;
    target.x += half_dt * (ax * bw + ay * bz - az * by);
    target.y += half_dt * (ay * bw + az * bx - ax * bz);
    target.z += half_dt * (az * bw + ax * by - ay * bx);
    target.w += half_dt * (-ax * bx - ay * by - az * bz);
    return target;
  }
};
var sfv_t1 = new Vec3();
var sfv_t2 = new Vec3();
var SHAPE_TYPES = {
  /** SPHERE */
  SPHERE: 1,
  /** PLANE */
  PLANE: 2,
  /** BOX */
  BOX: 4,
  /** COMPOUND */
  COMPOUND: 8,
  /** CONVEXPOLYHEDRON */
  CONVEXPOLYHEDRON: 16,
  /** HEIGHTFIELD */
  HEIGHTFIELD: 32,
  /** PARTICLE */
  PARTICLE: 64,
  /** CYLINDER */
  CYLINDER: 128,
  /** TRIMESH */
  TRIMESH: 256
};
var Shape2 = class {
  /**
   * Identifier of the Shape.
   */
  /**
   * The type of this shape. Must be set to an int > 0 by subclasses.
   */
  /**
   * The local bounding sphere radius of this shape.
   */
  /**
   * Whether to produce contact forces when in contact with other bodies. Note that contacts will be generated, but they will be disabled.
   * @default true
   */
  /**
   * @default 1
   */
  /**
   * @default -1
   */
  /**
   * Optional material of the shape that regulates contact properties.
   */
  /**
   * The body to which the shape is added to.
   */
  /**
   * All the Shape types.
   */
  constructor(options) {
    if (options === void 0) {
      options = {};
    }
    this.id = Shape2.idCounter++;
    this.type = options.type || 0;
    this.boundingSphereRadius = 0;
    this.collisionResponse = options.collisionResponse ? options.collisionResponse : true;
    this.collisionFilterGroup = options.collisionFilterGroup !== void 0 ? options.collisionFilterGroup : 1;
    this.collisionFilterMask = options.collisionFilterMask !== void 0 ? options.collisionFilterMask : -1;
    this.material = options.material ? options.material : null;
    this.body = null;
  }
  /**
   * Computes the bounding sphere radius.
   * The result is stored in the property `.boundingSphereRadius`
   */
  updateBoundingSphereRadius() {
    throw `computeBoundingSphereRadius() not implemented for shape type ${this.type}`;
  }
  /**
   * Get the volume of this shape
   */
  volume() {
    throw `volume() not implemented for shape type ${this.type}`;
  }
  /**
   * Calculates the inertia in the local frame for this shape.
   * @see http://en.wikipedia.org/wiki/List_of_moments_of_inertia
   */
  calculateLocalInertia(mass, target) {
    throw `calculateLocalInertia() not implemented for shape type ${this.type}`;
  }
  /**
   * @todo use abstract for these kind of methods
   */
  calculateWorldAABB(pos, quat, min, max3) {
    throw `calculateWorldAABB() not implemented for shape type ${this.type}`;
  }
};
Shape2.idCounter = 0;
Shape2.types = SHAPE_TYPES;
var Transform = class {
  /**
   * position
   */
  /**
   * quaternion
   */
  constructor(options) {
    if (options === void 0) {
      options = {};
    }
    this.position = new Vec3();
    this.quaternion = new Quaternion2();
    if (options.position) {
      this.position.copy(options.position);
    }
    if (options.quaternion) {
      this.quaternion.copy(options.quaternion);
    }
  }
  /**
   * Get a global point in local transform coordinates.
   */
  pointToLocal(worldPoint, result) {
    return Transform.pointToLocalFrame(this.position, this.quaternion, worldPoint, result);
  }
  /**
   * Get a local point in global transform coordinates.
   */
  pointToWorld(localPoint, result) {
    return Transform.pointToWorldFrame(this.position, this.quaternion, localPoint, result);
  }
  /**
   * vectorToWorldFrame
   */
  vectorToWorldFrame(localVector, result) {
    if (result === void 0) {
      result = new Vec3();
    }
    this.quaternion.vmult(localVector, result);
    return result;
  }
  /**
   * pointToLocalFrame
   */
  static pointToLocalFrame(position, quaternion, worldPoint, result) {
    if (result === void 0) {
      result = new Vec3();
    }
    worldPoint.vsub(position, result);
    quaternion.conjugate(tmpQuat$1);
    tmpQuat$1.vmult(result, result);
    return result;
  }
  /**
   * pointToWorldFrame
   */
  static pointToWorldFrame(position, quaternion, localPoint, result) {
    if (result === void 0) {
      result = new Vec3();
    }
    quaternion.vmult(localPoint, result);
    result.vadd(position, result);
    return result;
  }
  /**
   * vectorToWorldFrame
   */
  static vectorToWorldFrame(quaternion, localVector, result) {
    if (result === void 0) {
      result = new Vec3();
    }
    quaternion.vmult(localVector, result);
    return result;
  }
  /**
   * vectorToLocalFrame
   */
  static vectorToLocalFrame(position, quaternion, worldVector, result) {
    if (result === void 0) {
      result = new Vec3();
    }
    quaternion.w *= -1;
    quaternion.vmult(worldVector, result);
    quaternion.w *= -1;
    return result;
  }
};
var tmpQuat$1 = new Quaternion2();
var ConvexPolyhedron = class extends Shape2 {
  /** vertices */
  /**
   * Array of integer arrays, indicating which vertices each face consists of
   */
  /** faceNormals */
  /** worldVertices */
  /** worldVerticesNeedsUpdate */
  /** worldFaceNormals */
  /** worldFaceNormalsNeedsUpdate */
  /**
   * If given, these locally defined, normalized axes are the only ones being checked when doing separating axis check.
   */
  /** uniqueEdges */
  /**
   * @param vertices An array of Vec3's
   * @param faces Array of integer arrays, describing which vertices that is included in each face.
   */
  constructor(props) {
    if (props === void 0) {
      props = {};
    }
    const {
      vertices = [],
      faces = [],
      normals = [],
      axes,
      boundingSphereRadius
    } = props;
    super({
      type: Shape2.types.CONVEXPOLYHEDRON
    });
    this.vertices = vertices;
    this.faces = faces;
    this.faceNormals = normals;
    if (this.faceNormals.length === 0) {
      this.computeNormals();
    }
    if (!boundingSphereRadius) {
      this.updateBoundingSphereRadius();
    } else {
      this.boundingSphereRadius = boundingSphereRadius;
    }
    this.worldVertices = [];
    this.worldVerticesNeedsUpdate = true;
    this.worldFaceNormals = [];
    this.worldFaceNormalsNeedsUpdate = true;
    this.uniqueAxes = axes ? axes.slice() : null;
    this.uniqueEdges = [];
    this.computeEdges();
  }
  /**
   * Computes uniqueEdges
   */
  computeEdges() {
    const faces = this.faces;
    const vertices = this.vertices;
    const edges = this.uniqueEdges;
    edges.length = 0;
    const edge = new Vec3();
    for (let i3 = 0; i3 !== faces.length; i3++) {
      const face = faces[i3];
      const numVertices = face.length;
      for (let j = 0; j !== numVertices; j++) {
        const k = (j + 1) % numVertices;
        vertices[face[j]].vsub(vertices[face[k]], edge);
        edge.normalize();
        let found = false;
        for (let p = 0; p !== edges.length; p++) {
          if (edges[p].almostEquals(edge) || edges[p].almostEquals(edge)) {
            found = true;
            break;
          }
        }
        if (!found) {
          edges.push(edge.clone());
        }
      }
    }
  }
  /**
   * Compute the normals of the faces.
   * Will reuse existing Vec3 objects in the `faceNormals` array if they exist.
   */
  computeNormals() {
    this.faceNormals.length = this.faces.length;
    for (let i3 = 0; i3 < this.faces.length; i3++) {
      for (let j = 0; j < this.faces[i3].length; j++) {
        if (!this.vertices[this.faces[i3][j]]) {
          throw new Error(`Vertex ${this.faces[i3][j]} not found!`);
        }
      }
      const n = this.faceNormals[i3] || new Vec3();
      this.getFaceNormal(i3, n);
      n.negate(n);
      this.faceNormals[i3] = n;
      const vertex = this.vertices[this.faces[i3][0]];
      if (n.dot(vertex) < 0) {
        console.error(`.faceNormals[${i3}] = Vec3(${n.toString()}) looks like it points into the shape? The vertices follow. Make sure they are ordered CCW around the normal, using the right hand rule.`);
        for (let j = 0; j < this.faces[i3].length; j++) {
          console.warn(`.vertices[${this.faces[i3][j]}] = Vec3(${this.vertices[this.faces[i3][j]].toString()})`);
        }
      }
    }
  }
  /**
   * Compute the normal of a face from its vertices
   */
  getFaceNormal(i3, target) {
    const f = this.faces[i3];
    const va2 = this.vertices[f[0]];
    const vb2 = this.vertices[f[1]];
    const vc2 = this.vertices[f[2]];
    ConvexPolyhedron.computeNormal(va2, vb2, vc2, target);
  }
  /**
   * Get face normal given 3 vertices
   */
  static computeNormal(va2, vb2, vc2, target) {
    const cb3 = new Vec3();
    const ab3 = new Vec3();
    vb2.vsub(va2, ab3);
    vc2.vsub(vb2, cb3);
    cb3.cross(ab3, target);
    if (!target.isZero()) {
      target.normalize();
    }
  }
  /**
   * @param minDist Clamp distance
   * @param result The an array of contact point objects, see clipFaceAgainstHull
   */
  clipAgainstHull(posA, quatA, hullB, posB, quatB, separatingNormal, minDist, maxDist, result) {
    const WorldNormal = new Vec3();
    let closestFaceB = -1;
    let dmax = -Number.MAX_VALUE;
    for (let face = 0; face < hullB.faces.length; face++) {
      WorldNormal.copy(hullB.faceNormals[face]);
      quatB.vmult(WorldNormal, WorldNormal);
      const d = WorldNormal.dot(separatingNormal);
      if (d > dmax) {
        dmax = d;
        closestFaceB = face;
      }
    }
    const worldVertsB1 = [];
    for (let i3 = 0; i3 < hullB.faces[closestFaceB].length; i3++) {
      const b5 = hullB.vertices[hullB.faces[closestFaceB][i3]];
      const worldb = new Vec3();
      worldb.copy(b5);
      quatB.vmult(worldb, worldb);
      posB.vadd(worldb, worldb);
      worldVertsB1.push(worldb);
    }
    if (closestFaceB >= 0) {
      this.clipFaceAgainstHull(separatingNormal, posA, quatA, worldVertsB1, minDist, maxDist, result);
    }
  }
  /**
   * Find the separating axis between this hull and another
   * @param target The target vector to save the axis in
   * @return Returns false if a separation is found, else true
   */
  findSeparatingAxis(hullB, posA, quatA, posB, quatB, target, faceListA, faceListB) {
    const faceANormalWS3 = new Vec3();
    const Worldnormal1 = new Vec3();
    const deltaC = new Vec3();
    const worldEdge0 = new Vec3();
    const worldEdge1 = new Vec3();
    const Cross = new Vec3();
    let dmin = Number.MAX_VALUE;
    const hullA = this;
    if (!hullA.uniqueAxes) {
      const numFacesA = faceListA ? faceListA.length : hullA.faces.length;
      for (let i3 = 0; i3 < numFacesA; i3++) {
        const fi = faceListA ? faceListA[i3] : i3;
        faceANormalWS3.copy(hullA.faceNormals[fi]);
        quatA.vmult(faceANormalWS3, faceANormalWS3);
        const d = hullA.testSepAxis(faceANormalWS3, hullB, posA, quatA, posB, quatB);
        if (d === false) {
          return false;
        }
        if (d < dmin) {
          dmin = d;
          target.copy(faceANormalWS3);
        }
      }
    } else {
      for (let i3 = 0; i3 !== hullA.uniqueAxes.length; i3++) {
        quatA.vmult(hullA.uniqueAxes[i3], faceANormalWS3);
        const d = hullA.testSepAxis(faceANormalWS3, hullB, posA, quatA, posB, quatB);
        if (d === false) {
          return false;
        }
        if (d < dmin) {
          dmin = d;
          target.copy(faceANormalWS3);
        }
      }
    }
    if (!hullB.uniqueAxes) {
      const numFacesB = faceListB ? faceListB.length : hullB.faces.length;
      for (let i3 = 0; i3 < numFacesB; i3++) {
        const fi = faceListB ? faceListB[i3] : i3;
        Worldnormal1.copy(hullB.faceNormals[fi]);
        quatB.vmult(Worldnormal1, Worldnormal1);
        const d = hullA.testSepAxis(Worldnormal1, hullB, posA, quatA, posB, quatB);
        if (d === false) {
          return false;
        }
        if (d < dmin) {
          dmin = d;
          target.copy(Worldnormal1);
        }
      }
    } else {
      for (let i3 = 0; i3 !== hullB.uniqueAxes.length; i3++) {
        quatB.vmult(hullB.uniqueAxes[i3], Worldnormal1);
        const d = hullA.testSepAxis(Worldnormal1, hullB, posA, quatA, posB, quatB);
        if (d === false) {
          return false;
        }
        if (d < dmin) {
          dmin = d;
          target.copy(Worldnormal1);
        }
      }
    }
    for (let e0 = 0; e0 !== hullA.uniqueEdges.length; e0++) {
      quatA.vmult(hullA.uniqueEdges[e0], worldEdge0);
      for (let e1 = 0; e1 !== hullB.uniqueEdges.length; e1++) {
        quatB.vmult(hullB.uniqueEdges[e1], worldEdge1);
        worldEdge0.cross(worldEdge1, Cross);
        if (!Cross.almostZero()) {
          Cross.normalize();
          const dist = hullA.testSepAxis(Cross, hullB, posA, quatA, posB, quatB);
          if (dist === false) {
            return false;
          }
          if (dist < dmin) {
            dmin = dist;
            target.copy(Cross);
          }
        }
      }
    }
    posB.vsub(posA, deltaC);
    if (deltaC.dot(target) > 0) {
      target.negate(target);
    }
    return true;
  }
  /**
   * Test separating axis against two hulls. Both hulls are projected onto the axis and the overlap size is returned if there is one.
   * @return The overlap depth, or FALSE if no penetration.
   */
  testSepAxis(axis, hullB, posA, quatA, posB, quatB) {
    const hullA = this;
    ConvexPolyhedron.project(hullA, axis, posA, quatA, maxminA);
    ConvexPolyhedron.project(hullB, axis, posB, quatB, maxminB);
    const maxA = maxminA[0];
    const minA = maxminA[1];
    const maxB = maxminB[0];
    const minB = maxminB[1];
    if (maxA < minB || maxB < minA) {
      return false;
    }
    const d0 = maxA - minB;
    const d1 = maxB - minA;
    const depth = d0 < d1 ? d0 : d1;
    return depth;
  }
  /**
   * calculateLocalInertia
   */
  calculateLocalInertia(mass, target) {
    const aabbmax = new Vec3();
    const aabbmin = new Vec3();
    this.computeLocalAABB(aabbmin, aabbmax);
    const x = aabbmax.x - aabbmin.x;
    const y = aabbmax.y - aabbmin.y;
    const z = aabbmax.z - aabbmin.z;
    target.x = 1 / 12 * mass * (2 * y * 2 * y + 2 * z * 2 * z);
    target.y = 1 / 12 * mass * (2 * x * 2 * x + 2 * z * 2 * z);
    target.z = 1 / 12 * mass * (2 * y * 2 * y + 2 * x * 2 * x);
  }
  /**
   * @param face_i Index of the face
   */
  getPlaneConstantOfFace(face_i) {
    const f = this.faces[face_i];
    const n = this.faceNormals[face_i];
    const v = this.vertices[f[0]];
    const c3 = -n.dot(v);
    return c3;
  }
  /**
   * Clip a face against a hull.
   * @param worldVertsB1 An array of Vec3 with vertices in the world frame.
   * @param minDist Distance clamping
   * @param Array result Array to store resulting contact points in. Will be objects with properties: point, depth, normal. These are represented in world coordinates.
   */
  clipFaceAgainstHull(separatingNormal, posA, quatA, worldVertsB1, minDist, maxDist, result) {
    const faceANormalWS = new Vec3();
    const edge0 = new Vec3();
    const WorldEdge0 = new Vec3();
    const worldPlaneAnormal1 = new Vec3();
    const planeNormalWS1 = new Vec3();
    const worldA1 = new Vec3();
    const localPlaneNormal = new Vec3();
    const planeNormalWS = new Vec3();
    const hullA = this;
    const worldVertsB2 = [];
    const pVtxIn = worldVertsB1;
    const pVtxOut = worldVertsB2;
    let closestFaceA = -1;
    let dmin = Number.MAX_VALUE;
    for (let face = 0; face < hullA.faces.length; face++) {
      faceANormalWS.copy(hullA.faceNormals[face]);
      quatA.vmult(faceANormalWS, faceANormalWS);
      const d = faceANormalWS.dot(separatingNormal);
      if (d < dmin) {
        dmin = d;
        closestFaceA = face;
      }
    }
    if (closestFaceA < 0) {
      return;
    }
    const polyA = hullA.faces[closestFaceA];
    polyA.connectedFaces = [];
    for (let i3 = 0; i3 < hullA.faces.length; i3++) {
      for (let j = 0; j < hullA.faces[i3].length; j++) {
        if (
          /* Sharing a vertex*/
          polyA.indexOf(hullA.faces[i3][j]) !== -1 && /* Not the one we are looking for connections from */
          i3 !== closestFaceA && /* Not already added */
          polyA.connectedFaces.indexOf(i3) === -1
        ) {
          polyA.connectedFaces.push(i3);
        }
      }
    }
    const numVerticesA = polyA.length;
    for (let i3 = 0; i3 < numVerticesA; i3++) {
      const a4 = hullA.vertices[polyA[i3]];
      const b5 = hullA.vertices[polyA[(i3 + 1) % numVerticesA]];
      a4.vsub(b5, edge0);
      WorldEdge0.copy(edge0);
      quatA.vmult(WorldEdge0, WorldEdge0);
      posA.vadd(WorldEdge0, WorldEdge0);
      worldPlaneAnormal1.copy(this.faceNormals[closestFaceA]);
      quatA.vmult(worldPlaneAnormal1, worldPlaneAnormal1);
      posA.vadd(worldPlaneAnormal1, worldPlaneAnormal1);
      WorldEdge0.cross(worldPlaneAnormal1, planeNormalWS1);
      planeNormalWS1.negate(planeNormalWS1);
      worldA1.copy(a4);
      quatA.vmult(worldA1, worldA1);
      posA.vadd(worldA1, worldA1);
      const otherFace = polyA.connectedFaces[i3];
      localPlaneNormal.copy(this.faceNormals[otherFace]);
      const localPlaneEq2 = this.getPlaneConstantOfFace(otherFace);
      planeNormalWS.copy(localPlaneNormal);
      quatA.vmult(planeNormalWS, planeNormalWS);
      const planeEqWS2 = localPlaneEq2 - planeNormalWS.dot(posA);
      this.clipFaceAgainstPlane(pVtxIn, pVtxOut, planeNormalWS, planeEqWS2);
      while (pVtxIn.length) {
        pVtxIn.shift();
      }
      while (pVtxOut.length) {
        pVtxIn.push(pVtxOut.shift());
      }
    }
    localPlaneNormal.copy(this.faceNormals[closestFaceA]);
    const localPlaneEq = this.getPlaneConstantOfFace(closestFaceA);
    planeNormalWS.copy(localPlaneNormal);
    quatA.vmult(planeNormalWS, planeNormalWS);
    const planeEqWS = localPlaneEq - planeNormalWS.dot(posA);
    for (let i3 = 0; i3 < pVtxIn.length; i3++) {
      let depth = planeNormalWS.dot(pVtxIn[i3]) + planeEqWS;
      if (depth <= minDist) {
        console.log(`clamped: depth=${depth} to minDist=${minDist}`);
        depth = minDist;
      }
      if (depth <= maxDist) {
        const point = pVtxIn[i3];
        if (depth <= 1e-6) {
          const p = {
            point,
            normal: planeNormalWS,
            depth
          };
          result.push(p);
        }
      }
    }
  }
  /**
   * Clip a face in a hull against the back of a plane.
   * @param planeConstant The constant in the mathematical plane equation
   */
  clipFaceAgainstPlane(inVertices, outVertices, planeNormal, planeConstant) {
    let n_dot_first;
    let n_dot_last;
    const numVerts = inVertices.length;
    if (numVerts < 2) {
      return outVertices;
    }
    let firstVertex = inVertices[inVertices.length - 1];
    let lastVertex = inVertices[0];
    n_dot_first = planeNormal.dot(firstVertex) + planeConstant;
    for (let vi = 0; vi < numVerts; vi++) {
      lastVertex = inVertices[vi];
      n_dot_last = planeNormal.dot(lastVertex) + planeConstant;
      if (n_dot_first < 0) {
        if (n_dot_last < 0) {
          const newv = new Vec3();
          newv.copy(lastVertex);
          outVertices.push(newv);
        } else {
          const newv = new Vec3();
          firstVertex.lerp(lastVertex, n_dot_first / (n_dot_first - n_dot_last), newv);
          outVertices.push(newv);
        }
      } else {
        if (n_dot_last < 0) {
          const newv = new Vec3();
          firstVertex.lerp(lastVertex, n_dot_first / (n_dot_first - n_dot_last), newv);
          outVertices.push(newv);
          outVertices.push(lastVertex);
        }
      }
      firstVertex = lastVertex;
      n_dot_first = n_dot_last;
    }
    return outVertices;
  }
  /**
   * Updates `.worldVertices` and sets `.worldVerticesNeedsUpdate` to false.
   */
  computeWorldVertices(position, quat) {
    while (this.worldVertices.length < this.vertices.length) {
      this.worldVertices.push(new Vec3());
    }
    const verts = this.vertices;
    const worldVerts = this.worldVertices;
    for (let i3 = 0; i3 !== this.vertices.length; i3++) {
      quat.vmult(verts[i3], worldVerts[i3]);
      position.vadd(worldVerts[i3], worldVerts[i3]);
    }
    this.worldVerticesNeedsUpdate = false;
  }
  computeLocalAABB(aabbmin, aabbmax) {
    const vertices = this.vertices;
    aabbmin.set(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
    aabbmax.set(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
    for (let i3 = 0; i3 < this.vertices.length; i3++) {
      const v = vertices[i3];
      if (v.x < aabbmin.x) {
        aabbmin.x = v.x;
      } else if (v.x > aabbmax.x) {
        aabbmax.x = v.x;
      }
      if (v.y < aabbmin.y) {
        aabbmin.y = v.y;
      } else if (v.y > aabbmax.y) {
        aabbmax.y = v.y;
      }
      if (v.z < aabbmin.z) {
        aabbmin.z = v.z;
      } else if (v.z > aabbmax.z) {
        aabbmax.z = v.z;
      }
    }
  }
  /**
   * Updates `worldVertices` and sets `worldVerticesNeedsUpdate` to false.
   */
  computeWorldFaceNormals(quat) {
    const N = this.faceNormals.length;
    while (this.worldFaceNormals.length < N) {
      this.worldFaceNormals.push(new Vec3());
    }
    const normals = this.faceNormals;
    const worldNormals = this.worldFaceNormals;
    for (let i3 = 0; i3 !== N; i3++) {
      quat.vmult(normals[i3], worldNormals[i3]);
    }
    this.worldFaceNormalsNeedsUpdate = false;
  }
  /**
   * updateBoundingSphereRadius
   */
  updateBoundingSphereRadius() {
    let max22 = 0;
    const verts = this.vertices;
    for (let i3 = 0; i3 !== verts.length; i3++) {
      const norm2 = verts[i3].lengthSquared();
      if (norm2 > max22) {
        max22 = norm2;
      }
    }
    this.boundingSphereRadius = Math.sqrt(max22);
  }
  /**
   * calculateWorldAABB
   */
  calculateWorldAABB(pos, quat, min, max3) {
    const verts = this.vertices;
    let minx;
    let miny;
    let minz;
    let maxx;
    let maxy;
    let maxz;
    let tempWorldVertex = new Vec3();
    for (let i3 = 0; i3 < verts.length; i3++) {
      tempWorldVertex.copy(verts[i3]);
      quat.vmult(tempWorldVertex, tempWorldVertex);
      pos.vadd(tempWorldVertex, tempWorldVertex);
      const v = tempWorldVertex;
      if (minx === void 0 || v.x < minx) {
        minx = v.x;
      }
      if (maxx === void 0 || v.x > maxx) {
        maxx = v.x;
      }
      if (miny === void 0 || v.y < miny) {
        miny = v.y;
      }
      if (maxy === void 0 || v.y > maxy) {
        maxy = v.y;
      }
      if (minz === void 0 || v.z < minz) {
        minz = v.z;
      }
      if (maxz === void 0 || v.z > maxz) {
        maxz = v.z;
      }
    }
    min.set(minx, miny, minz);
    max3.set(maxx, maxy, maxz);
  }
  /**
   * Get approximate convex volume
   */
  volume() {
    return 4 * Math.PI * this.boundingSphereRadius / 3;
  }
  /**
   * Get an average of all the vertices positions
   */
  getAveragePointLocal(target) {
    if (target === void 0) {
      target = new Vec3();
    }
    const verts = this.vertices;
    for (let i3 = 0; i3 < verts.length; i3++) {
      target.vadd(verts[i3], target);
    }
    target.scale(1 / verts.length, target);
    return target;
  }
  /**
   * Transform all local points. Will change the .vertices
   */
  transformAllPoints(offset, quat) {
    const n = this.vertices.length;
    const verts = this.vertices;
    if (quat) {
      for (let i3 = 0; i3 < n; i3++) {
        const v = verts[i3];
        quat.vmult(v, v);
      }
      for (let i3 = 0; i3 < this.faceNormals.length; i3++) {
        const v = this.faceNormals[i3];
        quat.vmult(v, v);
      }
    }
    if (offset) {
      for (let i3 = 0; i3 < n; i3++) {
        const v = verts[i3];
        v.vadd(offset, v);
      }
    }
  }
  /**
   * Checks whether p is inside the polyhedra. Must be in local coords.
   * The point lies outside of the convex hull of the other points if and only if the direction
   * of all the vectors from it to those other points are on less than one half of a sphere around it.
   * @param p A point given in local coordinates
   */
  pointIsInside(p) {
    const verts = this.vertices;
    const faces = this.faces;
    const normals = this.faceNormals;
    const positiveResult = null;
    const pointInside = new Vec3();
    this.getAveragePointLocal(pointInside);
    for (let i3 = 0; i3 < this.faces.length; i3++) {
      let n = normals[i3];
      const v = verts[faces[i3][0]];
      const vToP = new Vec3();
      p.vsub(v, vToP);
      const r1 = n.dot(vToP);
      const vToPointInside = new Vec3();
      pointInside.vsub(v, vToPointInside);
      const r2 = n.dot(vToPointInside);
      if (r1 < 0 && r2 > 0 || r1 > 0 && r2 < 0) {
        return false;
      }
    }
    return positiveResult ? 1 : -1;
  }
  /**
   * Get max and min dot product of a convex hull at position (pos,quat) projected onto an axis.
   * Results are saved in the array maxmin.
   * @param result result[0] and result[1] will be set to maximum and minimum, respectively.
   */
  static project(shape, axis, pos, quat, result) {
    const n = shape.vertices.length;
    project_worldVertex;
    const localAxis = project_localAxis;
    let max3 = 0;
    let min = 0;
    const localOrigin = project_localOrigin;
    const vs = shape.vertices;
    localOrigin.setZero();
    Transform.vectorToLocalFrame(pos, quat, axis, localAxis);
    Transform.pointToLocalFrame(pos, quat, localOrigin, localOrigin);
    const add = localOrigin.dot(localAxis);
    min = max3 = vs[0].dot(localAxis);
    for (let i3 = 1; i3 < n; i3++) {
      const val = vs[i3].dot(localAxis);
      if (val > max3) {
        max3 = val;
      }
      if (val < min) {
        min = val;
      }
    }
    min -= add;
    max3 -= add;
    if (min > max3) {
      const temp = min;
      min = max3;
      max3 = temp;
    }
    result[0] = max3;
    result[1] = min;
  }
};
var maxminA = [];
var maxminB = [];
var project_worldVertex = new Vec3();
var project_localAxis = new Vec3();
var project_localOrigin = new Vec3();
var Box = class extends Shape2 {
  /**
   * The half extents of the box.
   */
  /**
   * Used by the contact generator to make contacts with other convex polyhedra for example.
   */
  constructor(halfExtents) {
    super({
      type: Shape2.types.BOX
    });
    this.halfExtents = halfExtents;
    this.convexPolyhedronRepresentation = null;
    this.updateConvexPolyhedronRepresentation();
    this.updateBoundingSphereRadius();
  }
  /**
   * Updates the local convex polyhedron representation used for some collisions.
   */
  updateConvexPolyhedronRepresentation() {
    const sx = this.halfExtents.x;
    const sy = this.halfExtents.y;
    const sz = this.halfExtents.z;
    const V = Vec3;
    const vertices = [new V(-sx, -sy, -sz), new V(sx, -sy, -sz), new V(sx, sy, -sz), new V(-sx, sy, -sz), new V(-sx, -sy, sz), new V(sx, -sy, sz), new V(sx, sy, sz), new V(-sx, sy, sz)];
    const faces = [
      [3, 2, 1, 0],
      // -z
      [4, 5, 6, 7],
      // +z
      [5, 4, 0, 1],
      // -y
      [2, 3, 7, 6],
      // +y
      [0, 4, 7, 3],
      // -x
      [1, 2, 6, 5]
      // +x
    ];
    const axes = [new V(0, 0, 1), new V(0, 1, 0), new V(1, 0, 0)];
    const h = new ConvexPolyhedron({
      vertices,
      faces,
      axes
    });
    this.convexPolyhedronRepresentation = h;
    h.material = this.material;
  }
  /**
   * Calculate the inertia of the box.
   */
  calculateLocalInertia(mass, target) {
    if (target === void 0) {
      target = new Vec3();
    }
    Box.calculateInertia(this.halfExtents, mass, target);
    return target;
  }
  static calculateInertia(halfExtents, mass, target) {
    const e = halfExtents;
    target.x = 1 / 12 * mass * (2 * e.y * 2 * e.y + 2 * e.z * 2 * e.z);
    target.y = 1 / 12 * mass * (2 * e.x * 2 * e.x + 2 * e.z * 2 * e.z);
    target.z = 1 / 12 * mass * (2 * e.y * 2 * e.y + 2 * e.x * 2 * e.x);
  }
  /**
   * Get the box 6 side normals
   * @param sixTargetVectors An array of 6 vectors, to store the resulting side normals in.
   * @param quat Orientation to apply to the normal vectors. If not provided, the vectors will be in respect to the local frame.
   */
  getSideNormals(sixTargetVectors, quat) {
    const sides = sixTargetVectors;
    const ex = this.halfExtents;
    sides[0].set(ex.x, 0, 0);
    sides[1].set(0, ex.y, 0);
    sides[2].set(0, 0, ex.z);
    sides[3].set(-ex.x, 0, 0);
    sides[4].set(0, -ex.y, 0);
    sides[5].set(0, 0, -ex.z);
    if (quat !== void 0) {
      for (let i3 = 0; i3 !== sides.length; i3++) {
        quat.vmult(sides[i3], sides[i3]);
      }
    }
    return sides;
  }
  /**
   * Returns the volume of the box.
   */
  volume() {
    return 8 * this.halfExtents.x * this.halfExtents.y * this.halfExtents.z;
  }
  /**
   * updateBoundingSphereRadius
   */
  updateBoundingSphereRadius() {
    this.boundingSphereRadius = this.halfExtents.length();
  }
  /**
   * forEachWorldCorner
   */
  forEachWorldCorner(pos, quat, callback) {
    const e = this.halfExtents;
    const corners = [[e.x, e.y, e.z], [-e.x, e.y, e.z], [-e.x, -e.y, e.z], [-e.x, -e.y, -e.z], [e.x, -e.y, -e.z], [e.x, e.y, -e.z], [-e.x, e.y, -e.z], [e.x, -e.y, e.z]];
    for (let i3 = 0; i3 < corners.length; i3++) {
      worldCornerTempPos.set(corners[i3][0], corners[i3][1], corners[i3][2]);
      quat.vmult(worldCornerTempPos, worldCornerTempPos);
      pos.vadd(worldCornerTempPos, worldCornerTempPos);
      callback(worldCornerTempPos.x, worldCornerTempPos.y, worldCornerTempPos.z);
    }
  }
  /**
   * calculateWorldAABB
   */
  calculateWorldAABB(pos, quat, min, max3) {
    const e = this.halfExtents;
    worldCornersTemp[0].set(e.x, e.y, e.z);
    worldCornersTemp[1].set(-e.x, e.y, e.z);
    worldCornersTemp[2].set(-e.x, -e.y, e.z);
    worldCornersTemp[3].set(-e.x, -e.y, -e.z);
    worldCornersTemp[4].set(e.x, -e.y, -e.z);
    worldCornersTemp[5].set(e.x, e.y, -e.z);
    worldCornersTemp[6].set(-e.x, e.y, -e.z);
    worldCornersTemp[7].set(e.x, -e.y, e.z);
    const wc = worldCornersTemp[0];
    quat.vmult(wc, wc);
    pos.vadd(wc, wc);
    max3.copy(wc);
    min.copy(wc);
    for (let i3 = 1; i3 < 8; i3++) {
      const wc2 = worldCornersTemp[i3];
      quat.vmult(wc2, wc2);
      pos.vadd(wc2, wc2);
      const x = wc2.x;
      const y = wc2.y;
      const z = wc2.z;
      if (x > max3.x) {
        max3.x = x;
      }
      if (y > max3.y) {
        max3.y = y;
      }
      if (z > max3.z) {
        max3.z = z;
      }
      if (x < min.x) {
        min.x = x;
      }
      if (y < min.y) {
        min.y = y;
      }
      if (z < min.z) {
        min.z = z;
      }
    }
  }
};
var worldCornerTempPos = new Vec3();
var worldCornersTemp = [new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3()];
var BODY_TYPES = {
  /** DYNAMIC */
  DYNAMIC: 1,
  /** STATIC */
  STATIC: 2,
  /** KINEMATIC */
  KINEMATIC: 4
};
var BODY_SLEEP_STATES = {
  /** AWAKE */
  AWAKE: 0,
  /** SLEEPY */
  SLEEPY: 1,
  /** SLEEPING */
  SLEEPING: 2
};
var Body = class extends EventTarget {
  /**
   * Dispatched after two bodies collide. This event is dispatched on each
   * of the two bodies involved in the collision.
   * @event collide
   * @param body The body that was involved in the collision.
   * @param contact The details of the collision.
   */
  /**
   * A dynamic body is fully simulated. Can be moved manually by the user, but normally they move according to forces. A dynamic body can collide with all body types. A dynamic body always has finite, non-zero mass.
   */
  /**
   * A static body does not move during simulation and behaves as if it has infinite mass. Static bodies can be moved manually by setting the position of the body. The velocity of a static body is always zero. Static bodies do not collide with other static or kinematic bodies.
   */
  /**
   * A kinematic body moves under simulation according to its velocity. They do not respond to forces. They can be moved manually, but normally a kinematic body is moved by setting its velocity. A kinematic body behaves as if it has infinite mass. Kinematic bodies do not collide with other static or kinematic bodies.
   */
  /**
   * AWAKE
   */
  /**
   * SLEEPY
   */
  /**
   * SLEEPING
   */
  /**
   * Dispatched after a sleeping body has woken up.
   * @event wakeup
   */
  /**
   * Dispatched after a body has gone in to the sleepy state.
   * @event sleepy
   */
  /**
   * Dispatched after a body has fallen asleep.
   * @event sleep
   */
  constructor(options) {
    if (options === void 0) {
      options = {};
    }
    super();
    this.id = Body.idCounter++;
    this.index = -1;
    this.world = null;
    this.vlambda = new Vec3();
    this.collisionFilterGroup = typeof options.collisionFilterGroup === "number" ? options.collisionFilterGroup : 1;
    this.collisionFilterMask = typeof options.collisionFilterMask === "number" ? options.collisionFilterMask : -1;
    this.collisionResponse = typeof options.collisionResponse === "boolean" ? options.collisionResponse : true;
    this.position = new Vec3();
    this.previousPosition = new Vec3();
    this.interpolatedPosition = new Vec3();
    this.initPosition = new Vec3();
    if (options.position) {
      this.position.copy(options.position);
      this.previousPosition.copy(options.position);
      this.interpolatedPosition.copy(options.position);
      this.initPosition.copy(options.position);
    }
    this.velocity = new Vec3();
    if (options.velocity) {
      this.velocity.copy(options.velocity);
    }
    this.initVelocity = new Vec3();
    this.force = new Vec3();
    const mass = typeof options.mass === "number" ? options.mass : 0;
    this.mass = mass;
    this.invMass = mass > 0 ? 1 / mass : 0;
    this.material = options.material || null;
    this.linearDamping = typeof options.linearDamping === "number" ? options.linearDamping : 0.01;
    this.type = mass <= 0 ? Body.STATIC : Body.DYNAMIC;
    if (typeof options.type === typeof Body.STATIC) {
      this.type = options.type;
    }
    this.allowSleep = typeof options.allowSleep !== "undefined" ? options.allowSleep : true;
    this.sleepState = Body.AWAKE;
    this.sleepSpeedLimit = typeof options.sleepSpeedLimit !== "undefined" ? options.sleepSpeedLimit : 0.1;
    this.sleepTimeLimit = typeof options.sleepTimeLimit !== "undefined" ? options.sleepTimeLimit : 1;
    this.timeLastSleepy = 0;
    this.wakeUpAfterNarrowphase = false;
    this.torque = new Vec3();
    this.quaternion = new Quaternion2();
    this.initQuaternion = new Quaternion2();
    this.previousQuaternion = new Quaternion2();
    this.interpolatedQuaternion = new Quaternion2();
    if (options.quaternion) {
      this.quaternion.copy(options.quaternion);
      this.initQuaternion.copy(options.quaternion);
      this.previousQuaternion.copy(options.quaternion);
      this.interpolatedQuaternion.copy(options.quaternion);
    }
    this.angularVelocity = new Vec3();
    if (options.angularVelocity) {
      this.angularVelocity.copy(options.angularVelocity);
    }
    this.initAngularVelocity = new Vec3();
    this.shapes = [];
    this.shapeOffsets = [];
    this.shapeOrientations = [];
    this.inertia = new Vec3();
    this.invInertia = new Vec3();
    this.invInertiaWorld = new Mat3();
    this.invMassSolve = 0;
    this.invInertiaSolve = new Vec3();
    this.invInertiaWorldSolve = new Mat3();
    this.fixedRotation = typeof options.fixedRotation !== "undefined" ? options.fixedRotation : false;
    this.angularDamping = typeof options.angularDamping !== "undefined" ? options.angularDamping : 0.01;
    this.linearFactor = new Vec3(1, 1, 1);
    if (options.linearFactor) {
      this.linearFactor.copy(options.linearFactor);
    }
    this.angularFactor = new Vec3(1, 1, 1);
    if (options.angularFactor) {
      this.angularFactor.copy(options.angularFactor);
    }
    this.aabb = new AABB();
    this.aabbNeedsUpdate = true;
    this.boundingRadius = 0;
    this.wlambda = new Vec3();
    this.isTrigger = Boolean(options.isTrigger);
    if (options.shape) {
      this.addShape(options.shape);
    }
    this.updateMassProperties();
  }
  /**
   * Wake the body up.
   */
  wakeUp() {
    const prevState = this.sleepState;
    this.sleepState = Body.AWAKE;
    this.wakeUpAfterNarrowphase = false;
    if (prevState === Body.SLEEPING) {
      this.dispatchEvent(Body.wakeupEvent);
    }
  }
  /**
   * Force body sleep
   */
  sleep() {
    this.sleepState = Body.SLEEPING;
    this.velocity.set(0, 0, 0);
    this.angularVelocity.set(0, 0, 0);
    this.wakeUpAfterNarrowphase = false;
  }
  /**
   * Called every timestep to update internal sleep timer and change sleep state if needed.
   * @param time The world time in seconds
   */
  sleepTick(time) {
    if (this.allowSleep) {
      const sleepState = this.sleepState;
      const speedSquared = this.velocity.lengthSquared() + this.angularVelocity.lengthSquared();
      const speedLimitSquared = this.sleepSpeedLimit ** 2;
      if (sleepState === Body.AWAKE && speedSquared < speedLimitSquared) {
        this.sleepState = Body.SLEEPY;
        this.timeLastSleepy = time;
        this.dispatchEvent(Body.sleepyEvent);
      } else if (sleepState === Body.SLEEPY && speedSquared > speedLimitSquared) {
        this.wakeUp();
      } else if (sleepState === Body.SLEEPY && time - this.timeLastSleepy > this.sleepTimeLimit) {
        this.sleep();
        this.dispatchEvent(Body.sleepEvent);
      }
    }
  }
  /**
   * If the body is sleeping, it should be immovable / have infinite mass during solve. We solve it by having a separate "solve mass".
   */
  updateSolveMassProperties() {
    if (this.sleepState === Body.SLEEPING || this.type === Body.KINEMATIC) {
      this.invMassSolve = 0;
      this.invInertiaSolve.setZero();
      this.invInertiaWorldSolve.setZero();
    } else {
      this.invMassSolve = this.invMass;
      this.invInertiaSolve.copy(this.invInertia);
      this.invInertiaWorldSolve.copy(this.invInertiaWorld);
    }
  }
  /**
   * Convert a world point to local body frame.
   */
  pointToLocalFrame(worldPoint, result) {
    if (result === void 0) {
      result = new Vec3();
    }
    worldPoint.vsub(this.position, result);
    this.quaternion.conjugate().vmult(result, result);
    return result;
  }
  /**
   * Convert a world vector to local body frame.
   */
  vectorToLocalFrame(worldVector, result) {
    if (result === void 0) {
      result = new Vec3();
    }
    this.quaternion.conjugate().vmult(worldVector, result);
    return result;
  }
  /**
   * Convert a local body point to world frame.
   */
  pointToWorldFrame(localPoint, result) {
    if (result === void 0) {
      result = new Vec3();
    }
    this.quaternion.vmult(localPoint, result);
    result.vadd(this.position, result);
    return result;
  }
  /**
   * Convert a local body point to world frame.
   */
  vectorToWorldFrame(localVector, result) {
    if (result === void 0) {
      result = new Vec3();
    }
    this.quaternion.vmult(localVector, result);
    return result;
  }
  /**
   * Add a shape to the body with a local offset and orientation.
   * @return The body object, for chainability.
   */
  addShape(shape, _offset2, _orientation) {
    const offset = new Vec3();
    const orientation = new Quaternion2();
    if (_offset2) {
      offset.copy(_offset2);
    }
    if (_orientation) {
      orientation.copy(_orientation);
    }
    this.shapes.push(shape);
    this.shapeOffsets.push(offset);
    this.shapeOrientations.push(orientation);
    this.updateMassProperties();
    this.updateBoundingRadius();
    this.aabbNeedsUpdate = true;
    shape.body = this;
    return this;
  }
  /**
   * Remove a shape from the body.
   * @return The body object, for chainability.
   */
  removeShape(shape) {
    const index = this.shapes.indexOf(shape);
    if (index === -1) {
      console.warn("Shape does not belong to the body");
      return this;
    }
    this.shapes.splice(index, 1);
    this.shapeOffsets.splice(index, 1);
    this.shapeOrientations.splice(index, 1);
    this.updateMassProperties();
    this.updateBoundingRadius();
    this.aabbNeedsUpdate = true;
    shape.body = null;
    return this;
  }
  /**
   * Update the bounding radius of the body. Should be done if any of the shapes are changed.
   */
  updateBoundingRadius() {
    const shapes = this.shapes;
    const shapeOffsets = this.shapeOffsets;
    const N = shapes.length;
    let radius = 0;
    for (let i3 = 0; i3 !== N; i3++) {
      const shape = shapes[i3];
      shape.updateBoundingSphereRadius();
      const offset = shapeOffsets[i3].length();
      const r = shape.boundingSphereRadius;
      if (offset + r > radius) {
        radius = offset + r;
      }
    }
    this.boundingRadius = radius;
  }
  /**
   * Updates the .aabb
   */
  updateAABB() {
    const shapes = this.shapes;
    const shapeOffsets = this.shapeOffsets;
    const shapeOrientations = this.shapeOrientations;
    const N = shapes.length;
    const offset = tmpVec;
    const orientation = tmpQuat;
    const bodyQuat = this.quaternion;
    const aabb2 = this.aabb;
    const shapeAABB = updateAABB_shapeAABB;
    for (let i3 = 0; i3 !== N; i3++) {
      const shape = shapes[i3];
      bodyQuat.vmult(shapeOffsets[i3], offset);
      offset.vadd(this.position, offset);
      bodyQuat.mult(shapeOrientations[i3], orientation);
      shape.calculateWorldAABB(offset, orientation, shapeAABB.lowerBound, shapeAABB.upperBound);
      if (i3 === 0) {
        aabb2.copy(shapeAABB);
      } else {
        aabb2.extend(shapeAABB);
      }
    }
    this.aabbNeedsUpdate = false;
  }
  /**
   * Update `.inertiaWorld` and `.invInertiaWorld`
   */
  updateInertiaWorld(force) {
    const I2 = this.invInertia;
    if (I2.x === I2.y && I2.y === I2.z && !force)
      ;
    else {
      const m1 = uiw_m1;
      const m2 = uiw_m2;
      uiw_m3;
      m1.setRotationFromQuaternion(this.quaternion);
      m1.transpose(m2);
      m1.scale(I2, m1);
      m1.mmult(m2, this.invInertiaWorld);
    }
  }
  /**
   * Apply force to a point of the body. This could for example be a point on the Body surface.
   * Applying force this way will add to Body.force and Body.torque.
   * @param force The amount of force to add.
   * @param relativePoint A point relative to the center of mass to apply the force on.
   */
  applyForce(force, relativePoint) {
    if (relativePoint === void 0) {
      relativePoint = new Vec3();
    }
    if (this.type !== Body.DYNAMIC) {
      return;
    }
    if (this.sleepState === Body.SLEEPING) {
      this.wakeUp();
    }
    const rotForce = Body_applyForce_rotForce;
    relativePoint.cross(force, rotForce);
    this.force.vadd(force, this.force);
    this.torque.vadd(rotForce, this.torque);
  }
  /**
   * Apply force to a local point in the body.
   * @param force The force vector to apply, defined locally in the body frame.
   * @param localPoint A local point in the body to apply the force on.
   */
  applyLocalForce(localForce, localPoint) {
    if (localPoint === void 0) {
      localPoint = new Vec3();
    }
    if (this.type !== Body.DYNAMIC) {
      return;
    }
    const worldForce = Body_applyLocalForce_worldForce;
    const relativePointWorld = Body_applyLocalForce_relativePointWorld;
    this.vectorToWorldFrame(localForce, worldForce);
    this.vectorToWorldFrame(localPoint, relativePointWorld);
    this.applyForce(worldForce, relativePointWorld);
  }
  /**
   * Apply torque to the body.
   * @param torque The amount of torque to add.
   */
  applyTorque(torque2) {
    if (this.type !== Body.DYNAMIC) {
      return;
    }
    if (this.sleepState === Body.SLEEPING) {
      this.wakeUp();
    }
    this.torque.vadd(torque2, this.torque);
  }
  /**
   * Apply impulse to a point of the body. This could for example be a point on the Body surface.
   * An impulse is a force added to a body during a short period of time (impulse = force * time).
   * Impulses will be added to Body.velocity and Body.angularVelocity.
   * @param impulse The amount of impulse to add.
   * @param relativePoint A point relative to the center of mass to apply the force on.
   */
  applyImpulse(impulse, relativePoint) {
    if (relativePoint === void 0) {
      relativePoint = new Vec3();
    }
    if (this.type !== Body.DYNAMIC) {
      return;
    }
    if (this.sleepState === Body.SLEEPING) {
      this.wakeUp();
    }
    const r = relativePoint;
    const velo = Body_applyImpulse_velo;
    velo.copy(impulse);
    velo.scale(this.invMass, velo);
    this.velocity.vadd(velo, this.velocity);
    const rotVelo = Body_applyImpulse_rotVelo;
    r.cross(impulse, rotVelo);
    this.invInertiaWorld.vmult(rotVelo, rotVelo);
    this.angularVelocity.vadd(rotVelo, this.angularVelocity);
  }
  /**
   * Apply locally-defined impulse to a local point in the body.
   * @param force The force vector to apply, defined locally in the body frame.
   * @param localPoint A local point in the body to apply the force on.
   */
  applyLocalImpulse(localImpulse, localPoint) {
    if (localPoint === void 0) {
      localPoint = new Vec3();
    }
    if (this.type !== Body.DYNAMIC) {
      return;
    }
    const worldImpulse = Body_applyLocalImpulse_worldImpulse;
    const relativePointWorld = Body_applyLocalImpulse_relativePoint;
    this.vectorToWorldFrame(localImpulse, worldImpulse);
    this.vectorToWorldFrame(localPoint, relativePointWorld);
    this.applyImpulse(worldImpulse, relativePointWorld);
  }
  /**
   * Should be called whenever you change the body shape or mass.
   */
  updateMassProperties() {
    const halfExtents = Body_updateMassProperties_halfExtents;
    this.invMass = this.mass > 0 ? 1 / this.mass : 0;
    const I2 = this.inertia;
    const fixed = this.fixedRotation;
    this.updateAABB();
    halfExtents.set((this.aabb.upperBound.x - this.aabb.lowerBound.x) / 2, (this.aabb.upperBound.y - this.aabb.lowerBound.y) / 2, (this.aabb.upperBound.z - this.aabb.lowerBound.z) / 2);
    Box.calculateInertia(halfExtents, this.mass, I2);
    this.invInertia.set(I2.x > 0 && !fixed ? 1 / I2.x : 0, I2.y > 0 && !fixed ? 1 / I2.y : 0, I2.z > 0 && !fixed ? 1 / I2.z : 0);
    this.updateInertiaWorld(true);
  }
  /**
   * Get world velocity of a point in the body.
   * @param worldPoint
   * @param result
   * @return The result vector.
   */
  getVelocityAtWorldPoint(worldPoint, result) {
    const r = new Vec3();
    worldPoint.vsub(this.position, r);
    this.angularVelocity.cross(r, result);
    this.velocity.vadd(result, result);
    return result;
  }
  /**
   * Move the body forward in time.
   * @param dt Time step
   * @param quatNormalize Set to true to normalize the body quaternion
   * @param quatNormalizeFast If the quaternion should be normalized using "fast" quaternion normalization
   */
  integrate(dt, quatNormalize, quatNormalizeFast) {
    this.previousPosition.copy(this.position);
    this.previousQuaternion.copy(this.quaternion);
    if (!(this.type === Body.DYNAMIC || this.type === Body.KINEMATIC) || this.sleepState === Body.SLEEPING) {
      return;
    }
    const velo = this.velocity;
    const angularVelo = this.angularVelocity;
    const pos = this.position;
    const force = this.force;
    const torque2 = this.torque;
    const quat = this.quaternion;
    const invMass = this.invMass;
    const invInertia = this.invInertiaWorld;
    const linearFactor = this.linearFactor;
    const iMdt = invMass * dt;
    velo.x += force.x * iMdt * linearFactor.x;
    velo.y += force.y * iMdt * linearFactor.y;
    velo.z += force.z * iMdt * linearFactor.z;
    const e = invInertia.elements;
    const angularFactor = this.angularFactor;
    const tx = torque2.x * angularFactor.x;
    const ty = torque2.y * angularFactor.y;
    const tz = torque2.z * angularFactor.z;
    angularVelo.x += dt * (e[0] * tx + e[1] * ty + e[2] * tz);
    angularVelo.y += dt * (e[3] * tx + e[4] * ty + e[5] * tz);
    angularVelo.z += dt * (e[6] * tx + e[7] * ty + e[8] * tz);
    pos.x += velo.x * dt;
    pos.y += velo.y * dt;
    pos.z += velo.z * dt;
    quat.integrate(this.angularVelocity, dt, this.angularFactor, quat);
    if (quatNormalize) {
      if (quatNormalizeFast) {
        quat.normalizeFast();
      } else {
        quat.normalize();
      }
    }
    this.aabbNeedsUpdate = true;
    this.updateInertiaWorld();
  }
};
Body.idCounter = 0;
Body.COLLIDE_EVENT_NAME = "collide";
Body.DYNAMIC = BODY_TYPES.DYNAMIC;
Body.STATIC = BODY_TYPES.STATIC;
Body.KINEMATIC = BODY_TYPES.KINEMATIC;
Body.AWAKE = BODY_SLEEP_STATES.AWAKE;
Body.SLEEPY = BODY_SLEEP_STATES.SLEEPY;
Body.SLEEPING = BODY_SLEEP_STATES.SLEEPING;
Body.wakeupEvent = {
  type: "wakeup"
};
Body.sleepyEvent = {
  type: "sleepy"
};
Body.sleepEvent = {
  type: "sleep"
};
var tmpVec = new Vec3();
var tmpQuat = new Quaternion2();
var updateAABB_shapeAABB = new AABB();
var uiw_m1 = new Mat3();
var uiw_m2 = new Mat3();
var uiw_m3 = new Mat3();
var Body_applyForce_rotForce = new Vec3();
var Body_applyLocalForce_worldForce = new Vec3();
var Body_applyLocalForce_relativePointWorld = new Vec3();
var Body_applyImpulse_velo = new Vec3();
var Body_applyImpulse_rotVelo = new Vec3();
var Body_applyLocalImpulse_worldImpulse = new Vec3();
var Body_applyLocalImpulse_relativePoint = new Vec3();
var Body_updateMassProperties_halfExtents = new Vec3();
var Broadphase = class {
  /**
   * The world to search for collisions in.
   */
  /**
   * If set to true, the broadphase uses bounding boxes for intersection tests, else it uses bounding spheres.
   */
  /**
   * Set to true if the objects in the world moved.
   */
  constructor() {
    this.world = null;
    this.useBoundingBoxes = false;
    this.dirty = true;
  }
  /**
   * Get the collision pairs from the world
   * @param world The world to search in
   * @param p1 Empty array to be filled with body objects
   * @param p2 Empty array to be filled with body objects
   */
  collisionPairs(world2, p1, p2) {
    throw new Error("collisionPairs not implemented for this BroadPhase class!");
  }
  /**
   * Check if a body pair needs to be intersection tested at all.
   */
  needBroadphaseCollision(bodyA, bodyB) {
    if ((bodyA.collisionFilterGroup & bodyB.collisionFilterMask) === 0 || (bodyB.collisionFilterGroup & bodyA.collisionFilterMask) === 0) {
      return false;
    }
    if (((bodyA.type & Body.STATIC) !== 0 || bodyA.sleepState === Body.SLEEPING) && ((bodyB.type & Body.STATIC) !== 0 || bodyB.sleepState === Body.SLEEPING)) {
      return false;
    }
    return true;
  }
  /**
   * Check if the bounding volumes of two bodies intersect.
   */
  intersectionTest(bodyA, bodyB, pairs1, pairs2) {
    if (this.useBoundingBoxes) {
      this.doBoundingBoxBroadphase(bodyA, bodyB, pairs1, pairs2);
    } else {
      this.doBoundingSphereBroadphase(bodyA, bodyB, pairs1, pairs2);
    }
  }
  /**
   * Check if the bounding spheres of two bodies are intersecting.
   * @param pairs1 bodyA is appended to this array if intersection
   * @param pairs2 bodyB is appended to this array if intersection
   */
  doBoundingSphereBroadphase(bodyA, bodyB, pairs1, pairs2) {
    const r = Broadphase_collisionPairs_r;
    bodyB.position.vsub(bodyA.position, r);
    const boundingRadiusSum2 = (bodyA.boundingRadius + bodyB.boundingRadius) ** 2;
    const norm2 = r.lengthSquared();
    if (norm2 < boundingRadiusSum2) {
      pairs1.push(bodyA);
      pairs2.push(bodyB);
    }
  }
  /**
   * Check if the bounding boxes of two bodies are intersecting.
   */
  doBoundingBoxBroadphase(bodyA, bodyB, pairs1, pairs2) {
    if (bodyA.aabbNeedsUpdate) {
      bodyA.updateAABB();
    }
    if (bodyB.aabbNeedsUpdate) {
      bodyB.updateAABB();
    }
    if (bodyA.aabb.overlaps(bodyB.aabb)) {
      pairs1.push(bodyA);
      pairs2.push(bodyB);
    }
  }
  /**
   * Removes duplicate pairs from the pair arrays.
   */
  makePairsUnique(pairs1, pairs2) {
    const t2 = Broadphase_makePairsUnique_temp;
    const p1 = Broadphase_makePairsUnique_p1;
    const p2 = Broadphase_makePairsUnique_p2;
    const N = pairs1.length;
    for (let i3 = 0; i3 !== N; i3++) {
      p1[i3] = pairs1[i3];
      p2[i3] = pairs2[i3];
    }
    pairs1.length = 0;
    pairs2.length = 0;
    for (let i3 = 0; i3 !== N; i3++) {
      const id1 = p1[i3].id;
      const id2 = p2[i3].id;
      const key = id1 < id2 ? `${id1},${id2}` : `${id2},${id1}`;
      t2[key] = i3;
      t2.keys.push(key);
    }
    for (let i3 = 0; i3 !== t2.keys.length; i3++) {
      const key = t2.keys.pop();
      const pairIndex = t2[key];
      pairs1.push(p1[pairIndex]);
      pairs2.push(p2[pairIndex]);
      delete t2[key];
    }
  }
  /**
   * To be implemented by subcasses
   */
  setWorld(world2) {
  }
  /**
   * Check if the bounding spheres of two bodies overlap.
   */
  static boundingSphereCheck(bodyA, bodyB) {
    const dist = new Vec3();
    bodyA.position.vsub(bodyB.position, dist);
    const sa = bodyA.shapes[0];
    const sb = bodyB.shapes[0];
    return Math.pow(sa.boundingSphereRadius + sb.boundingSphereRadius, 2) > dist.lengthSquared();
  }
  /**
   * Returns all the bodies within the AABB.
   */
  aabbQuery(world2, aabb2, result) {
    console.warn(".aabbQuery is not implemented in this Broadphase subclass.");
    return [];
  }
};
var Broadphase_collisionPairs_r = new Vec3();
new Vec3();
new Quaternion2();
new Vec3();
var Broadphase_makePairsUnique_temp = {
  keys: []
};
var Broadphase_makePairsUnique_p1 = [];
var Broadphase_makePairsUnique_p2 = [];
new Vec3();
var GridBroadphase_collisionPairs_d = new Vec3();
new Vec3();
var NaiveBroadphase = class extends Broadphase {
  /**
   * @todo Remove useless constructor
   */
  constructor() {
    super();
  }
  /**
   * Get all the collision pairs in the physics world
   */
  collisionPairs(world2, pairs1, pairs2) {
    const bodies = world2.bodies;
    const n = bodies.length;
    let bi;
    let bj;
    for (let i3 = 0; i3 !== n; i3++) {
      for (let j = 0; j !== i3; j++) {
        bi = bodies[i3];
        bj = bodies[j];
        if (!this.needBroadphaseCollision(bi, bj)) {
          continue;
        }
        this.intersectionTest(bi, bj, pairs1, pairs2);
      }
    }
  }
  /**
   * Returns all the bodies within an AABB.
   * @param result An array to store resulting bodies in.
   */
  aabbQuery(world2, aabb2, result) {
    if (result === void 0) {
      result = [];
    }
    for (let i3 = 0; i3 < world2.bodies.length; i3++) {
      const b5 = world2.bodies[i3];
      if (b5.aabbNeedsUpdate) {
        b5.updateAABB();
      }
      if (b5.aabb.overlaps(aabb2)) {
        result.push(b5);
      }
    }
    return result;
  }
};
var RaycastResult = class {
  /**
   * rayFromWorld
   */
  /**
   * rayToWorld
   */
  /**
   * hitNormalWorld
   */
  /**
   * hitPointWorld
   */
  /**
   * hasHit
   */
  /**
   * shape
   */
  /**
   * body
   */
  /**
   * The index of the hit triangle, if the hit shape was a trimesh
   */
  /**
   * Distance to the hit. Will be set to -1 if there was no hit
   */
  /**
   * If the ray should stop traversing the bodies
   */
  constructor() {
    this.rayFromWorld = new Vec3();
    this.rayToWorld = new Vec3();
    this.hitNormalWorld = new Vec3();
    this.hitPointWorld = new Vec3();
    this.hasHit = false;
    this.shape = null;
    this.body = null;
    this.hitFaceIndex = -1;
    this.distance = -1;
    this.shouldStop = false;
  }
  /**
   * Reset all result data.
   */
  reset() {
    this.rayFromWorld.setZero();
    this.rayToWorld.setZero();
    this.hitNormalWorld.setZero();
    this.hitPointWorld.setZero();
    this.hasHit = false;
    this.shape = null;
    this.body = null;
    this.hitFaceIndex = -1;
    this.distance = -1;
    this.shouldStop = false;
  }
  /**
   * abort
   */
  abort() {
    this.shouldStop = true;
  }
  /**
   * Set result data.
   */
  set(rayFromWorld, rayToWorld, hitNormalWorld, hitPointWorld, shape, body, distance2) {
    this.rayFromWorld.copy(rayFromWorld);
    this.rayToWorld.copy(rayToWorld);
    this.hitNormalWorld.copy(hitNormalWorld);
    this.hitPointWorld.copy(hitPointWorld);
    this.shape = shape;
    this.body = body;
    this.distance = distance2;
  }
};
var _Shape$types$SPHERE;
var _Shape$types$PLANE;
var _Shape$types$BOX;
var _Shape$types$CYLINDER;
var _Shape$types$CONVEXPO;
var _Shape$types$HEIGHTFI;
var _Shape$types$TRIMESH;
var RAY_MODES = {
  /** CLOSEST */
  CLOSEST: 1,
  /** ANY */
  ANY: 2,
  /** ALL */
  ALL: 4
};
_Shape$types$SPHERE = Shape2.types.SPHERE;
_Shape$types$PLANE = Shape2.types.PLANE;
_Shape$types$BOX = Shape2.types.BOX;
_Shape$types$CYLINDER = Shape2.types.CYLINDER;
_Shape$types$CONVEXPO = Shape2.types.CONVEXPOLYHEDRON;
_Shape$types$HEIGHTFI = Shape2.types.HEIGHTFIELD;
_Shape$types$TRIMESH = Shape2.types.TRIMESH;
var Ray2 = class {
  /**
   * from
   */
  /**
   * to
   */
  /**
   * direction
   */
  /**
   * The precision of the ray. Used when checking parallelity etc.
   * @default 0.0001
   */
  /**
   * Set to `false` if you don't want the Ray to take `collisionResponse` flags into account on bodies and shapes.
   * @default true
   */
  /**
   * If set to `true`, the ray skips any hits with normal.dot(rayDirection) < 0.
   * @default false
   */
  /**
   * collisionFilterMask
   * @default -1
   */
  /**
   * collisionFilterGroup
   * @default -1
   */
  /**
   * The intersection mode. Should be Ray.ANY, Ray.ALL or Ray.CLOSEST.
   * @default RAY.ANY
   */
  /**
   * Current result object.
   */
  /**
   * Will be set to `true` during intersectWorld() if the ray hit anything.
   */
  /**
   * User-provided result callback. Will be used if mode is Ray.ALL.
   */
  /**
   * CLOSEST
   */
  /**
   * ANY
   */
  /**
   * ALL
   */
  get [_Shape$types$SPHERE]() {
    return this._intersectSphere;
  }
  get [_Shape$types$PLANE]() {
    return this._intersectPlane;
  }
  get [_Shape$types$BOX]() {
    return this._intersectBox;
  }
  get [_Shape$types$CYLINDER]() {
    return this._intersectConvex;
  }
  get [_Shape$types$CONVEXPO]() {
    return this._intersectConvex;
  }
  get [_Shape$types$HEIGHTFI]() {
    return this._intersectHeightfield;
  }
  get [_Shape$types$TRIMESH]() {
    return this._intersectTrimesh;
  }
  constructor(from, to) {
    if (from === void 0) {
      from = new Vec3();
    }
    if (to === void 0) {
      to = new Vec3();
    }
    this.from = from.clone();
    this.to = to.clone();
    this.direction = new Vec3();
    this.precision = 1e-4;
    this.checkCollisionResponse = true;
    this.skipBackfaces = false;
    this.collisionFilterMask = -1;
    this.collisionFilterGroup = -1;
    this.mode = Ray2.ANY;
    this.result = new RaycastResult();
    this.hasHit = false;
    this.callback = (result) => {
    };
  }
  /**
   * Do itersection against all bodies in the given World.
   * @return True if the ray hit anything, otherwise false.
   */
  intersectWorld(world2, options) {
    this.mode = options.mode || Ray2.ANY;
    this.result = options.result || new RaycastResult();
    this.skipBackfaces = !!options.skipBackfaces;
    this.collisionFilterMask = typeof options.collisionFilterMask !== "undefined" ? options.collisionFilterMask : -1;
    this.collisionFilterGroup = typeof options.collisionFilterGroup !== "undefined" ? options.collisionFilterGroup : -1;
    this.checkCollisionResponse = typeof options.checkCollisionResponse !== "undefined" ? options.checkCollisionResponse : true;
    if (options.from) {
      this.from.copy(options.from);
    }
    if (options.to) {
      this.to.copy(options.to);
    }
    this.callback = options.callback || (() => {
    });
    this.hasHit = false;
    this.result.reset();
    this.updateDirection();
    this.getAABB(tmpAABB$1);
    tmpArray.length = 0;
    world2.broadphase.aabbQuery(world2, tmpAABB$1, tmpArray);
    this.intersectBodies(tmpArray);
    return this.hasHit;
  }
  /**
   * Shoot a ray at a body, get back information about the hit.
   * @deprecated @param result set the result property of the Ray instead.
   */
  intersectBody(body, result) {
    if (result) {
      this.result = result;
      this.updateDirection();
    }
    const checkCollisionResponse = this.checkCollisionResponse;
    if (checkCollisionResponse && !body.collisionResponse) {
      return;
    }
    if ((this.collisionFilterGroup & body.collisionFilterMask) === 0 || (body.collisionFilterGroup & this.collisionFilterMask) === 0) {
      return;
    }
    const xi = intersectBody_xi;
    const qi = intersectBody_qi;
    for (let i3 = 0, N = body.shapes.length; i3 < N; i3++) {
      const shape = body.shapes[i3];
      if (checkCollisionResponse && !shape.collisionResponse) {
        continue;
      }
      body.quaternion.mult(body.shapeOrientations[i3], qi);
      body.quaternion.vmult(body.shapeOffsets[i3], xi);
      xi.vadd(body.position, xi);
      this.intersectShape(shape, qi, xi, body);
      if (this.result.shouldStop) {
        break;
      }
    }
  }
  /**
   * Shoot a ray at an array bodies, get back information about the hit.
   * @param bodies An array of Body objects.
   * @deprecated @param result set the result property of the Ray instead.
   *
   */
  intersectBodies(bodies, result) {
    if (result) {
      this.result = result;
      this.updateDirection();
    }
    for (let i3 = 0, l = bodies.length; !this.result.shouldStop && i3 < l; i3++) {
      this.intersectBody(bodies[i3]);
    }
  }
  /**
   * Updates the direction vector.
   */
  updateDirection() {
    this.to.vsub(this.from, this.direction);
    this.direction.normalize();
  }
  intersectShape(shape, quat, position, body) {
    const from = this.from;
    const distance2 = distanceFromIntersection(from, this.direction, position);
    if (distance2 > shape.boundingSphereRadius) {
      return;
    }
    const intersectMethod = this[shape.type];
    if (intersectMethod) {
      intersectMethod.call(this, shape, quat, position, body, shape);
    }
  }
  _intersectBox(box, quat, position, body, reportedShape) {
    return this._intersectConvex(box.convexPolyhedronRepresentation, quat, position, body, reportedShape);
  }
  _intersectPlane(shape, quat, position, body, reportedShape) {
    const from = this.from;
    const to = this.to;
    const direction = this.direction;
    const worldNormal = new Vec3(0, 0, 1);
    quat.vmult(worldNormal, worldNormal);
    const len = new Vec3();
    from.vsub(position, len);
    const planeToFrom = len.dot(worldNormal);
    to.vsub(position, len);
    const planeToTo = len.dot(worldNormal);
    if (planeToFrom * planeToTo > 0) {
      return;
    }
    if (from.distanceTo(to) < planeToFrom) {
      return;
    }
    const n_dot_dir = worldNormal.dot(direction);
    if (Math.abs(n_dot_dir) < this.precision) {
      return;
    }
    const planePointToFrom = new Vec3();
    const dir_scaled_with_t = new Vec3();
    const hitPointWorld = new Vec3();
    from.vsub(position, planePointToFrom);
    const t2 = -worldNormal.dot(planePointToFrom) / n_dot_dir;
    direction.scale(t2, dir_scaled_with_t);
    from.vadd(dir_scaled_with_t, hitPointWorld);
    this.reportIntersection(worldNormal, hitPointWorld, reportedShape, body, -1);
  }
  /**
   * Get the world AABB of the ray.
   */
  getAABB(aabb2) {
    const {
      lowerBound,
      upperBound
    } = aabb2;
    const to = this.to;
    const from = this.from;
    lowerBound.x = Math.min(to.x, from.x);
    lowerBound.y = Math.min(to.y, from.y);
    lowerBound.z = Math.min(to.z, from.z);
    upperBound.x = Math.max(to.x, from.x);
    upperBound.y = Math.max(to.y, from.y);
    upperBound.z = Math.max(to.z, from.z);
  }
  _intersectHeightfield(shape, quat, position, body, reportedShape) {
    shape.data;
    shape.elementSize;
    const localRay2 = intersectHeightfield_localRay;
    localRay2.from.copy(this.from);
    localRay2.to.copy(this.to);
    Transform.pointToLocalFrame(position, quat, localRay2.from, localRay2.from);
    Transform.pointToLocalFrame(position, quat, localRay2.to, localRay2.to);
    localRay2.updateDirection();
    const index = intersectHeightfield_index;
    let iMinX;
    let iMinY;
    let iMaxX;
    let iMaxY;
    iMinX = iMinY = 0;
    iMaxX = iMaxY = shape.data.length - 1;
    const aabb2 = new AABB();
    localRay2.getAABB(aabb2);
    shape.getIndexOfPosition(aabb2.lowerBound.x, aabb2.lowerBound.y, index, true);
    iMinX = Math.max(iMinX, index[0]);
    iMinY = Math.max(iMinY, index[1]);
    shape.getIndexOfPosition(aabb2.upperBound.x, aabb2.upperBound.y, index, true);
    iMaxX = Math.min(iMaxX, index[0] + 1);
    iMaxY = Math.min(iMaxY, index[1] + 1);
    for (let i3 = iMinX; i3 < iMaxX; i3++) {
      for (let j = iMinY; j < iMaxY; j++) {
        if (this.result.shouldStop) {
          return;
        }
        shape.getAabbAtIndex(i3, j, aabb2);
        if (!aabb2.overlapsRay(localRay2)) {
          continue;
        }
        shape.getConvexTrianglePillar(i3, j, false);
        Transform.pointToWorldFrame(position, quat, shape.pillarOffset, worldPillarOffset);
        this._intersectConvex(shape.pillarConvex, quat, worldPillarOffset, body, reportedShape, intersectConvexOptions);
        if (this.result.shouldStop) {
          return;
        }
        shape.getConvexTrianglePillar(i3, j, true);
        Transform.pointToWorldFrame(position, quat, shape.pillarOffset, worldPillarOffset);
        this._intersectConvex(shape.pillarConvex, quat, worldPillarOffset, body, reportedShape, intersectConvexOptions);
      }
    }
  }
  _intersectSphere(sphere, quat, position, body, reportedShape) {
    const from = this.from;
    const to = this.to;
    const r = sphere.radius;
    const a4 = (to.x - from.x) ** 2 + (to.y - from.y) ** 2 + (to.z - from.z) ** 2;
    const b5 = 2 * ((to.x - from.x) * (from.x - position.x) + (to.y - from.y) * (from.y - position.y) + (to.z - from.z) * (from.z - position.z));
    const c3 = (from.x - position.x) ** 2 + (from.y - position.y) ** 2 + (from.z - position.z) ** 2 - r ** 2;
    const delta = b5 ** 2 - 4 * a4 * c3;
    const intersectionPoint = Ray_intersectSphere_intersectionPoint;
    const normal = Ray_intersectSphere_normal;
    if (delta < 0) {
      return;
    } else if (delta === 0) {
      from.lerp(to, delta, intersectionPoint);
      intersectionPoint.vsub(position, normal);
      normal.normalize();
      this.reportIntersection(normal, intersectionPoint, reportedShape, body, -1);
    } else {
      const d1 = (-b5 - Math.sqrt(delta)) / (2 * a4);
      const d2 = (-b5 + Math.sqrt(delta)) / (2 * a4);
      if (d1 >= 0 && d1 <= 1) {
        from.lerp(to, d1, intersectionPoint);
        intersectionPoint.vsub(position, normal);
        normal.normalize();
        this.reportIntersection(normal, intersectionPoint, reportedShape, body, -1);
      }
      if (this.result.shouldStop) {
        return;
      }
      if (d2 >= 0 && d2 <= 1) {
        from.lerp(to, d2, intersectionPoint);
        intersectionPoint.vsub(position, normal);
        normal.normalize();
        this.reportIntersection(normal, intersectionPoint, reportedShape, body, -1);
      }
    }
  }
  _intersectConvex(shape, quat, position, body, reportedShape, options) {
    intersectConvex_minDistNormal;
    const normal = intersectConvex_normal;
    const vector = intersectConvex_vector;
    intersectConvex_minDistIntersect;
    const faceList = options && options.faceList || null;
    const faces = shape.faces;
    const vertices = shape.vertices;
    const normals = shape.faceNormals;
    const direction = this.direction;
    const from = this.from;
    const to = this.to;
    const fromToDistance = from.distanceTo(to);
    const Nfaces = faceList ? faceList.length : faces.length;
    const result = this.result;
    for (let j = 0; !result.shouldStop && j < Nfaces; j++) {
      const fi = faceList ? faceList[j] : j;
      const face = faces[fi];
      const faceNormal = normals[fi];
      const q = quat;
      const x = position;
      vector.copy(vertices[face[0]]);
      q.vmult(vector, vector);
      vector.vadd(x, vector);
      vector.vsub(from, vector);
      q.vmult(faceNormal, normal);
      const dot = direction.dot(normal);
      if (Math.abs(dot) < this.precision) {
        continue;
      }
      const scalar = normal.dot(vector) / dot;
      if (scalar < 0) {
        continue;
      }
      direction.scale(scalar, intersectPoint);
      intersectPoint.vadd(from, intersectPoint);
      a3.copy(vertices[face[0]]);
      q.vmult(a3, a3);
      x.vadd(a3, a3);
      for (let i3 = 1; !result.shouldStop && i3 < face.length - 1; i3++) {
        b3.copy(vertices[face[i3]]);
        c2.copy(vertices[face[i3 + 1]]);
        q.vmult(b3, b3);
        q.vmult(c2, c2);
        x.vadd(b3, b3);
        x.vadd(c2, c2);
        const distance2 = intersectPoint.distanceTo(from);
        if (!(Ray2.pointInTriangle(intersectPoint, a3, b3, c2) || Ray2.pointInTriangle(intersectPoint, b3, a3, c2)) || distance2 > fromToDistance) {
          continue;
        }
        this.reportIntersection(normal, intersectPoint, reportedShape, body, fi);
      }
    }
  }
  /**
   * @todo Optimize by transforming the world to local space first.
   * @todo Use Octree lookup
   */
  _intersectTrimesh(mesh, quat, position, body, reportedShape, options) {
    const normal = intersectTrimesh_normal;
    const triangles = intersectTrimesh_triangles;
    const treeTransform = intersectTrimesh_treeTransform;
    const vector = intersectConvex_vector;
    const localDirection = intersectTrimesh_localDirection;
    const localFrom = intersectTrimesh_localFrom;
    const localTo = intersectTrimesh_localTo;
    const worldIntersectPoint = intersectTrimesh_worldIntersectPoint;
    const worldNormal = intersectTrimesh_worldNormal;
    const indices = mesh.indices;
    mesh.vertices;
    const from = this.from;
    const to = this.to;
    const direction = this.direction;
    treeTransform.position.copy(position);
    treeTransform.quaternion.copy(quat);
    Transform.vectorToLocalFrame(position, quat, direction, localDirection);
    Transform.pointToLocalFrame(position, quat, from, localFrom);
    Transform.pointToLocalFrame(position, quat, to, localTo);
    localTo.x *= mesh.scale.x;
    localTo.y *= mesh.scale.y;
    localTo.z *= mesh.scale.z;
    localFrom.x *= mesh.scale.x;
    localFrom.y *= mesh.scale.y;
    localFrom.z *= mesh.scale.z;
    localTo.vsub(localFrom, localDirection);
    localDirection.normalize();
    const fromToDistanceSquared = localFrom.distanceSquared(localTo);
    mesh.tree.rayQuery(this, treeTransform, triangles);
    for (let i3 = 0, N = triangles.length; !this.result.shouldStop && i3 !== N; i3++) {
      const trianglesIndex = triangles[i3];
      mesh.getNormal(trianglesIndex, normal);
      mesh.getVertex(indices[trianglesIndex * 3], a3);
      a3.vsub(localFrom, vector);
      const dot = localDirection.dot(normal);
      const scalar = normal.dot(vector) / dot;
      if (scalar < 0) {
        continue;
      }
      localDirection.scale(scalar, intersectPoint);
      intersectPoint.vadd(localFrom, intersectPoint);
      mesh.getVertex(indices[trianglesIndex * 3 + 1], b3);
      mesh.getVertex(indices[trianglesIndex * 3 + 2], c2);
      const squaredDistance = intersectPoint.distanceSquared(localFrom);
      if (!(Ray2.pointInTriangle(intersectPoint, b3, a3, c2) || Ray2.pointInTriangle(intersectPoint, a3, b3, c2)) || squaredDistance > fromToDistanceSquared) {
        continue;
      }
      Transform.vectorToWorldFrame(quat, normal, worldNormal);
      Transform.pointToWorldFrame(position, quat, intersectPoint, worldIntersectPoint);
      this.reportIntersection(worldNormal, worldIntersectPoint, reportedShape, body, trianglesIndex);
    }
    triangles.length = 0;
  }
  /**
   * @return True if the intersections should continue
   */
  reportIntersection(normal, hitPointWorld, shape, body, hitFaceIndex) {
    const from = this.from;
    const to = this.to;
    const distance2 = from.distanceTo(hitPointWorld);
    const result = this.result;
    if (this.skipBackfaces && normal.dot(this.direction) > 0) {
      return;
    }
    result.hitFaceIndex = typeof hitFaceIndex !== "undefined" ? hitFaceIndex : -1;
    switch (this.mode) {
      case Ray2.ALL:
        this.hasHit = true;
        result.set(from, to, normal, hitPointWorld, shape, body, distance2);
        result.hasHit = true;
        this.callback(result);
        break;
      case Ray2.CLOSEST:
        if (distance2 < result.distance || !result.hasHit) {
          this.hasHit = true;
          result.hasHit = true;
          result.set(from, to, normal, hitPointWorld, shape, body, distance2);
        }
        break;
      case Ray2.ANY:
        this.hasHit = true;
        result.hasHit = true;
        result.set(from, to, normal, hitPointWorld, shape, body, distance2);
        result.shouldStop = true;
        break;
    }
  }
  /**
   * As per "Barycentric Technique" as named
   * {@link https://www.blackpawn.com/texts/pointinpoly/default.html here} but without the division
   */
  static pointInTriangle(p, a4, b5, c3) {
    c3.vsub(a4, v0);
    b5.vsub(a4, v12);
    p.vsub(a4, v2);
    const dot00 = v0.dot(v0);
    const dot01 = v0.dot(v12);
    const dot02 = v0.dot(v2);
    const dot11 = v12.dot(v12);
    const dot12 = v12.dot(v2);
    let u;
    let v;
    return (u = dot11 * dot02 - dot01 * dot12) >= 0 && (v = dot00 * dot12 - dot01 * dot02) >= 0 && u + v < dot00 * dot11 - dot01 * dot01;
  }
};
Ray2.CLOSEST = RAY_MODES.CLOSEST;
Ray2.ANY = RAY_MODES.ANY;
Ray2.ALL = RAY_MODES.ALL;
var tmpAABB$1 = new AABB();
var tmpArray = [];
var v12 = new Vec3();
var v2 = new Vec3();
var intersectBody_xi = new Vec3();
var intersectBody_qi = new Quaternion2();
var intersectPoint = new Vec3();
var a3 = new Vec3();
var b3 = new Vec3();
var c2 = new Vec3();
new Vec3();
new RaycastResult();
var intersectConvexOptions = {
  faceList: [0]
};
var worldPillarOffset = new Vec3();
var intersectHeightfield_localRay = new Ray2();
var intersectHeightfield_index = [];
var Ray_intersectSphere_intersectionPoint = new Vec3();
var Ray_intersectSphere_normal = new Vec3();
var intersectConvex_normal = new Vec3();
var intersectConvex_minDistNormal = new Vec3();
var intersectConvex_minDistIntersect = new Vec3();
var intersectConvex_vector = new Vec3();
var intersectTrimesh_normal = new Vec3();
var intersectTrimesh_localDirection = new Vec3();
var intersectTrimesh_localFrom = new Vec3();
var intersectTrimesh_localTo = new Vec3();
var intersectTrimesh_worldNormal = new Vec3();
var intersectTrimesh_worldIntersectPoint = new Vec3();
new AABB();
var intersectTrimesh_triangles = [];
var intersectTrimesh_treeTransform = new Transform();
var v0 = new Vec3();
var intersect = new Vec3();
function distanceFromIntersection(from, direction, position) {
  position.vsub(from, v0);
  const dot = v0.dot(direction);
  direction.scale(dot, intersect);
  intersect.vadd(from, intersect);
  const distance2 = position.distanceTo(intersect);
  return distance2;
}
var Utils = class {
  /**
   * Extend an options object with default values.
   * @param options The options object. May be falsy: in this case, a new object is created and returned.
   * @param defaults An object containing default values.
   * @return The modified options object.
   */
  static defaults(options, defaults2) {
    if (options === void 0) {
      options = {};
    }
    for (let key in defaults2) {
      if (!(key in options)) {
        options[key] = defaults2[key];
      }
    }
    return options;
  }
};
var Constraint = class {
  /**
   * Equations to be solved in this constraint.
   */
  /**
   * Body A.
   */
  /**
   * Body B.
   */
  /**
   * Set to false if you don't want the bodies to collide when they are connected.
   */
  constructor(bodyA, bodyB, options) {
    if (options === void 0) {
      options = {};
    }
    options = Utils.defaults(options, {
      collideConnected: true,
      wakeUpBodies: true
    });
    this.equations = [];
    this.bodyA = bodyA;
    this.bodyB = bodyB;
    this.id = Constraint.idCounter++;
    this.collideConnected = options.collideConnected;
    if (options.wakeUpBodies) {
      if (bodyA) {
        bodyA.wakeUp();
      }
      if (bodyB) {
        bodyB.wakeUp();
      }
    }
  }
  /**
   * Update all the equations with data.
   */
  update() {
    throw new Error("method update() not implmemented in this Constraint subclass!");
  }
  /**
   * Enables all equations in the constraint.
   */
  enable() {
    const eqs = this.equations;
    for (let i3 = 0; i3 < eqs.length; i3++) {
      eqs[i3].enabled = true;
    }
  }
  /**
   * Disables all equations in the constraint.
   */
  disable() {
    const eqs = this.equations;
    for (let i3 = 0; i3 < eqs.length; i3++) {
      eqs[i3].enabled = false;
    }
  }
};
Constraint.idCounter = 0;
var JacobianElement = class {
  /**
   * spatial
   */
  /**
   * rotational
   */
  constructor() {
    this.spatial = new Vec3();
    this.rotational = new Vec3();
  }
  /**
   * Multiply with other JacobianElement
   */
  multiplyElement(element) {
    return element.spatial.dot(this.spatial) + element.rotational.dot(this.rotational);
  }
  /**
   * Multiply with two vectors
   */
  multiplyVectors(spatial, rotational) {
    return spatial.dot(this.spatial) + rotational.dot(this.rotational);
  }
};
var Equation = class {
  /**
   * Minimum (read: negative max) force to be applied by the constraint.
   */
  /**
   * Maximum (read: positive max) force to be applied by the constraint.
   */
  /**
   * SPOOK parameter
   */
  /**
   * SPOOK parameter
   */
  /**
   * SPOOK parameter
   */
  /**
   * A number, proportional to the force added to the bodies.
   */
  constructor(bi, bj, minForce, maxForce) {
    if (minForce === void 0) {
      minForce = -1e6;
    }
    if (maxForce === void 0) {
      maxForce = 1e6;
    }
    this.id = Equation.idCounter++;
    this.minForce = minForce;
    this.maxForce = maxForce;
    this.bi = bi;
    this.bj = bj;
    this.a = 0;
    this.b = 0;
    this.eps = 0;
    this.jacobianElementA = new JacobianElement();
    this.jacobianElementB = new JacobianElement();
    this.enabled = true;
    this.multiplier = 0;
    this.setSpookParams(1e7, 4, 1 / 60);
  }
  /**
   * Recalculates a, b, and eps.
   *
   * The Equation constructor sets typical SPOOK parameters as such:
   * * `stiffness` = 1e7
   * * `relaxation` = 4
   * * `timeStep`= 1 / 60, _note the hardcoded refresh rate._
   */
  setSpookParams(stiffness, relaxation, timeStep) {
    const d = relaxation;
    const k = stiffness;
    const h = timeStep;
    this.a = 4 / (h * (1 + 4 * d));
    this.b = 4 * d / (1 + 4 * d);
    this.eps = 4 / (h * h * k * (1 + 4 * d));
  }
  /**
   * Computes the right hand side of the SPOOK equation
   */
  computeB(a4, b5, h) {
    const GW = this.computeGW();
    const Gq = this.computeGq();
    const GiMf = this.computeGiMf();
    return -Gq * a4 - GW * b5 - GiMf * h;
  }
  /**
   * Computes G*q, where q are the generalized body coordinates
   */
  computeGq() {
    const GA = this.jacobianElementA;
    const GB = this.jacobianElementB;
    const bi = this.bi;
    const bj = this.bj;
    const xi = bi.position;
    const xj = bj.position;
    return GA.spatial.dot(xi) + GB.spatial.dot(xj);
  }
  /**
   * Computes G*W, where W are the body velocities
   */
  computeGW() {
    const GA = this.jacobianElementA;
    const GB = this.jacobianElementB;
    const bi = this.bi;
    const bj = this.bj;
    const vi = bi.velocity;
    const vj = bj.velocity;
    const wi = bi.angularVelocity;
    const wj = bj.angularVelocity;
    return GA.multiplyVectors(vi, wi) + GB.multiplyVectors(vj, wj);
  }
  /**
   * Computes G*Wlambda, where W are the body velocities
   */
  computeGWlambda() {
    const GA = this.jacobianElementA;
    const GB = this.jacobianElementB;
    const bi = this.bi;
    const bj = this.bj;
    const vi = bi.vlambda;
    const vj = bj.vlambda;
    const wi = bi.wlambda;
    const wj = bj.wlambda;
    return GA.multiplyVectors(vi, wi) + GB.multiplyVectors(vj, wj);
  }
  /**
   * Computes G*inv(M)*f, where M is the mass matrix with diagonal blocks for each body, and f are the forces on the bodies.
   */
  computeGiMf() {
    const GA = this.jacobianElementA;
    const GB = this.jacobianElementB;
    const bi = this.bi;
    const bj = this.bj;
    const fi = bi.force;
    const ti = bi.torque;
    const fj = bj.force;
    const tj = bj.torque;
    const invMassi = bi.invMassSolve;
    const invMassj = bj.invMassSolve;
    fi.scale(invMassi, iMfi);
    fj.scale(invMassj, iMfj);
    bi.invInertiaWorldSolve.vmult(ti, invIi_vmult_taui);
    bj.invInertiaWorldSolve.vmult(tj, invIj_vmult_tauj);
    return GA.multiplyVectors(iMfi, invIi_vmult_taui) + GB.multiplyVectors(iMfj, invIj_vmult_tauj);
  }
  /**
   * Computes G*inv(M)*G'
   */
  computeGiMGt() {
    const GA = this.jacobianElementA;
    const GB = this.jacobianElementB;
    const bi = this.bi;
    const bj = this.bj;
    const invMassi = bi.invMassSolve;
    const invMassj = bj.invMassSolve;
    const invIi = bi.invInertiaWorldSolve;
    const invIj = bj.invInertiaWorldSolve;
    let result = invMassi + invMassj;
    invIi.vmult(GA.rotational, tmp);
    result += tmp.dot(GA.rotational);
    invIj.vmult(GB.rotational, tmp);
    result += tmp.dot(GB.rotational);
    return result;
  }
  /**
   * Add constraint velocity to the bodies.
   */
  addToWlambda(deltalambda) {
    const GA = this.jacobianElementA;
    const GB = this.jacobianElementB;
    const bi = this.bi;
    const bj = this.bj;
    const temp = addToWlambda_temp;
    bi.vlambda.addScaledVector(bi.invMassSolve * deltalambda, GA.spatial, bi.vlambda);
    bj.vlambda.addScaledVector(bj.invMassSolve * deltalambda, GB.spatial, bj.vlambda);
    bi.invInertiaWorldSolve.vmult(GA.rotational, temp);
    bi.wlambda.addScaledVector(deltalambda, temp, bi.wlambda);
    bj.invInertiaWorldSolve.vmult(GB.rotational, temp);
    bj.wlambda.addScaledVector(deltalambda, temp, bj.wlambda);
  }
  /**
   * Compute the denominator part of the SPOOK equation: C = G*inv(M)*G' + eps
   */
  computeC() {
    return this.computeGiMGt() + this.eps;
  }
};
Equation.idCounter = 0;
var iMfi = new Vec3();
var iMfj = new Vec3();
var invIi_vmult_taui = new Vec3();
var invIj_vmult_tauj = new Vec3();
var tmp = new Vec3();
var addToWlambda_temp = new Vec3();
var ContactEquation = class extends Equation {
  /**
   * "bounciness": u1 = -e*u0
   */
  /**
   * World-oriented vector that goes from the center of bi to the contact point.
   */
  /**
   * World-oriented vector that starts in body j position and goes to the contact point.
   */
  /**
   * Contact normal, pointing out of body i.
   */
  constructor(bodyA, bodyB, maxForce) {
    if (maxForce === void 0) {
      maxForce = 1e6;
    }
    super(bodyA, bodyB, 0, maxForce);
    this.restitution = 0;
    this.ri = new Vec3();
    this.rj = new Vec3();
    this.ni = new Vec3();
  }
  computeB(h) {
    const a4 = this.a;
    const b5 = this.b;
    const bi = this.bi;
    const bj = this.bj;
    const ri = this.ri;
    const rj = this.rj;
    const rixn = ContactEquation_computeB_temp1;
    const rjxn = ContactEquation_computeB_temp2;
    const vi = bi.velocity;
    const wi = bi.angularVelocity;
    bi.force;
    bi.torque;
    const vj = bj.velocity;
    const wj = bj.angularVelocity;
    bj.force;
    bj.torque;
    const penetrationVec = ContactEquation_computeB_temp3;
    const GA = this.jacobianElementA;
    const GB = this.jacobianElementB;
    const n = this.ni;
    ri.cross(n, rixn);
    rj.cross(n, rjxn);
    n.negate(GA.spatial);
    rixn.negate(GA.rotational);
    GB.spatial.copy(n);
    GB.rotational.copy(rjxn);
    penetrationVec.copy(bj.position);
    penetrationVec.vadd(rj, penetrationVec);
    penetrationVec.vsub(bi.position, penetrationVec);
    penetrationVec.vsub(ri, penetrationVec);
    const g2 = n.dot(penetrationVec);
    const ePlusOne = this.restitution + 1;
    const GW = ePlusOne * vj.dot(n) - ePlusOne * vi.dot(n) + wj.dot(rjxn) - wi.dot(rixn);
    const GiMf = this.computeGiMf();
    const B2 = -g2 * a4 - GW * b5 - h * GiMf;
    return B2;
  }
  /**
   * Get the current relative velocity in the contact point.
   */
  getImpactVelocityAlongNormal() {
    const vi = ContactEquation_getImpactVelocityAlongNormal_vi;
    const vj = ContactEquation_getImpactVelocityAlongNormal_vj;
    const xi = ContactEquation_getImpactVelocityAlongNormal_xi;
    const xj = ContactEquation_getImpactVelocityAlongNormal_xj;
    const relVel = ContactEquation_getImpactVelocityAlongNormal_relVel;
    this.bi.position.vadd(this.ri, xi);
    this.bj.position.vadd(this.rj, xj);
    this.bi.getVelocityAtWorldPoint(xi, vi);
    this.bj.getVelocityAtWorldPoint(xj, vj);
    vi.vsub(vj, relVel);
    return this.ni.dot(relVel);
  }
};
var ContactEquation_computeB_temp1 = new Vec3();
var ContactEquation_computeB_temp2 = new Vec3();
var ContactEquation_computeB_temp3 = new Vec3();
var ContactEquation_getImpactVelocityAlongNormal_vi = new Vec3();
var ContactEquation_getImpactVelocityAlongNormal_vj = new Vec3();
var ContactEquation_getImpactVelocityAlongNormal_xi = new Vec3();
var ContactEquation_getImpactVelocityAlongNormal_xj = new Vec3();
var ContactEquation_getImpactVelocityAlongNormal_relVel = new Vec3();
var tmpVec1$2 = new Vec3();
var tmpVec2$2 = new Vec3();
var tmpVec1$1 = new Vec3();
var tmpVec2$1 = new Vec3();
new Vec3();
new Vec3();
var LockConstraint_update_tmpVec1 = new Vec3();
var LockConstraint_update_tmpVec2 = new Vec3();
var HingeConstraint_update_tmpVec1 = new Vec3();
var HingeConstraint_update_tmpVec2 = new Vec3();
var FrictionEquation = class extends Equation {
  // Tangent
  /**
   * @param slipForce should be +-F_friction = +-mu * F_normal = +-mu * m * g
   */
  constructor(bodyA, bodyB, slipForce) {
    super(bodyA, bodyB, -slipForce, slipForce);
    this.ri = new Vec3();
    this.rj = new Vec3();
    this.t = new Vec3();
  }
  computeB(h) {
    this.a;
    const b5 = this.b;
    this.bi;
    this.bj;
    const ri = this.ri;
    const rj = this.rj;
    const rixt = FrictionEquation_computeB_temp1;
    const rjxt = FrictionEquation_computeB_temp2;
    const t2 = this.t;
    ri.cross(t2, rixt);
    rj.cross(t2, rjxt);
    const GA = this.jacobianElementA;
    const GB = this.jacobianElementB;
    t2.negate(GA.spatial);
    rixt.negate(GA.rotational);
    GB.spatial.copy(t2);
    GB.rotational.copy(rjxt);
    const GW = this.computeGW();
    const GiMf = this.computeGiMf();
    const B2 = -GW * b5 - h * GiMf;
    return B2;
  }
};
var FrictionEquation_computeB_temp1 = new Vec3();
var FrictionEquation_computeB_temp2 = new Vec3();
var ContactMaterial = class {
  /**
   * Identifier of this material.
   */
  /**
   * Participating materials.
   */
  /**
   * Friction coefficient.
   * @default 0.3
   */
  /**
   * Restitution coefficient.
   * @default 0.3
   */
  /**
   * Stiffness of the produced contact equations.
   * @default 1e7
   */
  /**
   * Relaxation time of the produced contact equations.
   * @default 3
   */
  /**
   * Stiffness of the produced friction equations.
   * @default 1e7
   */
  /**
   * Relaxation time of the produced friction equations
   * @default 3
   */
  constructor(m1, m2, options) {
    options = Utils.defaults(options, {
      friction: 0.3,
      restitution: 0.3,
      contactEquationStiffness: 1e7,
      contactEquationRelaxation: 3,
      frictionEquationStiffness: 1e7,
      frictionEquationRelaxation: 3
    });
    this.id = ContactMaterial.idCounter++;
    this.materials = [m1, m2];
    this.friction = options.friction;
    this.restitution = options.restitution;
    this.contactEquationStiffness = options.contactEquationStiffness;
    this.contactEquationRelaxation = options.contactEquationRelaxation;
    this.frictionEquationStiffness = options.frictionEquationStiffness;
    this.frictionEquationRelaxation = options.frictionEquationRelaxation;
  }
};
ContactMaterial.idCounter = 0;
var Material2 = class {
  /**
   * Material name.
   * If options is a string, name will be set to that string.
   * @todo Deprecate this
   */
  /** Material id. */
  /**
   * Friction for this material.
   * If non-negative, it will be used instead of the friction given by ContactMaterials. If there's no matching ContactMaterial, the value from `defaultContactMaterial` in the World will be used.
   */
  /**
   * Restitution for this material.
   * If non-negative, it will be used instead of the restitution given by ContactMaterials. If there's no matching ContactMaterial, the value from `defaultContactMaterial` in the World will be used.
   */
  constructor(options) {
    if (options === void 0) {
      options = {};
    }
    let name = "";
    if (typeof options === "string") {
      name = options;
      options = {};
    }
    this.name = name;
    this.id = Material2.idCounter++;
    this.friction = typeof options.friction !== "undefined" ? options.friction : -1;
    this.restitution = typeof options.restitution !== "undefined" ? options.restitution : -1;
  }
};
Material2.idCounter = 0;
var applyForce_r = new Vec3();
var applyForce_r_unit = new Vec3();
var applyForce_u = new Vec3();
var applyForce_f = new Vec3();
var applyForce_worldAnchorA = new Vec3();
var applyForce_worldAnchorB = new Vec3();
var applyForce_ri = new Vec3();
var applyForce_rj = new Vec3();
var applyForce_ri_x_f = new Vec3();
var applyForce_rj_x_f = new Vec3();
var applyForce_tmp = new Vec3();
var chassis_velocity_at_contactPoint = new Vec3();
var relpos = new Vec3();
new Vec3();
new Vec3();
new Vec3();
var tmpVec4 = new Vec3();
var tmpVec5 = new Vec3();
var tmpVec6 = new Vec3();
new Ray2();
new Vec3();
var castRay_rayvector = new Vec3();
var castRay_target = new Vec3();
var directions = [new Vec3(1, 0, 0), new Vec3(0, 1, 0), new Vec3(0, 0, 1)];
var updateFriction_surfNormalWS_scaled_proj = new Vec3();
var calcRollingFriction_vel1 = new Vec3();
var calcRollingFriction_vel2 = new Vec3();
var calcRollingFriction_vel = new Vec3();
var computeImpulseDenominator_r0 = new Vec3();
var computeImpulseDenominator_c0 = new Vec3();
var computeImpulseDenominator_vec = new Vec3();
var computeImpulseDenominator_m = new Vec3();
var resolveSingleBilateral_vel1 = new Vec3();
var resolveSingleBilateral_vel2 = new Vec3();
var resolveSingleBilateral_vel = new Vec3();
var Sphere2 = class extends Shape2 {
  /**
   * The radius of the sphere.
   */
  /**
   *
   * @param radius The radius of the sphere, a non-negative number.
   */
  constructor(radius) {
    super({
      type: Shape2.types.SPHERE
    });
    this.radius = radius !== void 0 ? radius : 1;
    if (this.radius < 0) {
      throw new Error("The sphere radius cannot be negative.");
    }
    this.updateBoundingSphereRadius();
  }
  /** calculateLocalInertia */
  calculateLocalInertia(mass, target) {
    if (target === void 0) {
      target = new Vec3();
    }
    const I2 = 2 * mass * this.radius * this.radius / 5;
    target.x = I2;
    target.y = I2;
    target.z = I2;
    return target;
  }
  /** volume */
  volume() {
    return 4 * Math.PI * Math.pow(this.radius, 3) / 3;
  }
  updateBoundingSphereRadius() {
    this.boundingSphereRadius = this.radius;
  }
  calculateWorldAABB(pos, quat, min, max3) {
    const r = this.radius;
    const axes = ["x", "y", "z"];
    for (let i3 = 0; i3 < axes.length; i3++) {
      const ax = axes[i3];
      min[ax] = pos[ax] - r;
      max3[ax] = pos[ax] + r;
    }
  }
};
var torque = new Vec3();
var worldAxis = new Vec3();
var SPHSystem_getNeighbors_dist = new Vec3();
var SPHSystem_update_dist = new Vec3();
var SPHSystem_update_a_pressure = new Vec3();
var SPHSystem_update_a_visc = new Vec3();
var SPHSystem_update_gradW = new Vec3();
var SPHSystem_update_r_vec = new Vec3();
var SPHSystem_update_u = new Vec3();
var Cylinder = class extends ConvexPolyhedron {
  /** The radius of the top of the Cylinder. */
  /** The radius of the bottom of the Cylinder. */
  /** The height of the Cylinder. */
  /** The number of segments to build the cylinder out of. */
  /**
   * @param radiusTop The radius of the top of the Cylinder.
   * @param radiusBottom The radius of the bottom of the Cylinder.
   * @param height The height of the Cylinder.
   * @param numSegments The number of segments to build the cylinder out of.
   */
  constructor(radiusTop, radiusBottom, height, numSegments) {
    if (radiusTop === void 0) {
      radiusTop = 1;
    }
    if (radiusBottom === void 0) {
      radiusBottom = 1;
    }
    if (height === void 0) {
      height = 1;
    }
    if (numSegments === void 0) {
      numSegments = 8;
    }
    if (radiusTop < 0) {
      throw new Error("The cylinder radiusTop cannot be negative.");
    }
    if (radiusBottom < 0) {
      throw new Error("The cylinder radiusBottom cannot be negative.");
    }
    const N = numSegments;
    const vertices = [];
    const axes = [];
    const faces = [];
    const bottomface = [];
    const topface = [];
    const cos = Math.cos;
    const sin = Math.sin;
    vertices.push(new Vec3(-radiusBottom * sin(0), -height * 0.5, radiusBottom * cos(0)));
    bottomface.push(0);
    vertices.push(new Vec3(-radiusTop * sin(0), height * 0.5, radiusTop * cos(0)));
    topface.push(1);
    for (let i3 = 0; i3 < N; i3++) {
      const theta = 2 * Math.PI / N * (i3 + 1);
      const thetaN = 2 * Math.PI / N * (i3 + 0.5);
      if (i3 < N - 1) {
        vertices.push(new Vec3(-radiusBottom * sin(theta), -height * 0.5, radiusBottom * cos(theta)));
        bottomface.push(2 * i3 + 2);
        vertices.push(new Vec3(-radiusTop * sin(theta), height * 0.5, radiusTop * cos(theta)));
        topface.push(2 * i3 + 3);
        faces.push([2 * i3, 2 * i3 + 1, 2 * i3 + 3, 2 * i3 + 2]);
      } else {
        faces.push([2 * i3, 2 * i3 + 1, 1, 0]);
      }
      if (N % 2 === 1 || i3 < N / 2) {
        axes.push(new Vec3(-sin(thetaN), 0, cos(thetaN)));
      }
    }
    faces.push(bottomface);
    axes.push(new Vec3(0, 1, 0));
    const temp = [];
    for (let i3 = 0; i3 < topface.length; i3++) {
      temp.push(topface[topface.length - i3 - 1]);
    }
    faces.push(temp);
    super({
      vertices,
      faces,
      axes
    });
    this.type = Shape2.types.CYLINDER;
    this.radiusTop = radiusTop;
    this.radiusBottom = radiusBottom;
    this.height = height;
    this.numSegments = numSegments;
  }
};
var Plane2 = class extends Shape2 {
  /** worldNormal */
  /** worldNormalNeedsUpdate */
  constructor() {
    super({
      type: Shape2.types.PLANE
    });
    this.worldNormal = new Vec3();
    this.worldNormalNeedsUpdate = true;
    this.boundingSphereRadius = Number.MAX_VALUE;
  }
  /** computeWorldNormal */
  computeWorldNormal(quat) {
    const n = this.worldNormal;
    n.set(0, 0, 1);
    quat.vmult(n, n);
    this.worldNormalNeedsUpdate = false;
  }
  calculateLocalInertia(mass, target) {
    if (target === void 0) {
      target = new Vec3();
    }
    return target;
  }
  volume() {
    return (
      // The plane is infinite...
      Number.MAX_VALUE
    );
  }
  calculateWorldAABB(pos, quat, min, max3) {
    tempNormal2.set(0, 0, 1);
    quat.vmult(tempNormal2, tempNormal2);
    const maxVal = Number.MAX_VALUE;
    min.set(-maxVal, -maxVal, -maxVal);
    max3.set(maxVal, maxVal, maxVal);
    if (tempNormal2.x === 1) {
      max3.x = pos.x;
    } else if (tempNormal2.x === -1) {
      min.x = pos.x;
    }
    if (tempNormal2.y === 1) {
      max3.y = pos.y;
    } else if (tempNormal2.y === -1) {
      min.y = pos.y;
    }
    if (tempNormal2.z === 1) {
      max3.z = pos.z;
    } else if (tempNormal2.z === -1) {
      min.z = pos.z;
    }
  }
  updateBoundingSphereRadius() {
    this.boundingSphereRadius = Number.MAX_VALUE;
  }
};
var tempNormal2 = new Vec3();
var getHeightAt_weights = new Vec3();
var getHeightAt_a = new Vec3();
var getHeightAt_b = new Vec3();
var getHeightAt_c = new Vec3();
var getNormalAt_a = new Vec3();
var getNormalAt_b = new Vec3();
var getNormalAt_c = new Vec3();
var getNormalAt_e0 = new Vec3();
var getNormalAt_e1 = new Vec3();
var halfDiagonal = new Vec3();
var tmpAABB = new AABB();
var computeNormals_n = new Vec3();
var unscaledAABB = new AABB();
var getEdgeVector_va = new Vec3();
var getEdgeVector_vb = new Vec3();
var cb2 = new Vec3();
var ab2 = new Vec3();
var va = new Vec3();
var vb = new Vec3();
var vc = new Vec3();
var cli_aabb = new AABB();
var computeLocalAABB_worldVert = new Vec3();
var calculateWorldAABB_frame = new Transform();
var calculateWorldAABB_aabb = new AABB();
var Solver = class {
  /**
   * All equations to be solved
   */
  /**
   * @todo remove useless constructor
   */
  constructor() {
    this.equations = [];
  }
  /**
   * Should be implemented in subclasses!
   * @todo use abstract
   * @return number of iterations performed
   */
  solve(dt, world2) {
    return (
      // Should return the number of iterations done!
      0
    );
  }
  /**
   * Add an equation
   */
  addEquation(eq) {
    if (eq.enabled && !eq.bi.isTrigger && !eq.bj.isTrigger) {
      this.equations.push(eq);
    }
  }
  /**
   * Remove an equation
   */
  removeEquation(eq) {
    const eqs = this.equations;
    const i3 = eqs.indexOf(eq);
    if (i3 !== -1) {
      eqs.splice(i3, 1);
    }
  }
  /**
   * Add all equations
   */
  removeAllEquations() {
    this.equations.length = 0;
  }
};
var GSSolver = class extends Solver {
  /**
   * The number of solver iterations determines quality of the constraints in the world.
   * The more iterations, the more correct simulation. More iterations need more computations though. If you have a large gravity force in your world, you will need more iterations.
   */
  /**
   * When tolerance is reached, the system is assumed to be converged.
   */
  /**
   * @todo remove useless constructor
   */
  constructor() {
    super();
    this.iterations = 10;
    this.tolerance = 1e-7;
  }
  /**
   * Solve
   * @return number of iterations performed
   */
  solve(dt, world2) {
    let iter = 0;
    const maxIter = this.iterations;
    const tolSquared = this.tolerance * this.tolerance;
    const equations = this.equations;
    const Neq = equations.length;
    const bodies = world2.bodies;
    const Nbodies = bodies.length;
    const h = dt;
    let B2;
    let invC;
    let deltalambda;
    let deltalambdaTot;
    let GWlambda;
    let lambdaj;
    if (Neq !== 0) {
      for (let i3 = 0; i3 !== Nbodies; i3++) {
        bodies[i3].updateSolveMassProperties();
      }
    }
    const invCs = GSSolver_solve_invCs;
    const Bs = GSSolver_solve_Bs;
    const lambda = GSSolver_solve_lambda;
    invCs.length = Neq;
    Bs.length = Neq;
    lambda.length = Neq;
    for (let i3 = 0; i3 !== Neq; i3++) {
      const c3 = equations[i3];
      lambda[i3] = 0;
      Bs[i3] = c3.computeB(h);
      invCs[i3] = 1 / c3.computeC();
    }
    if (Neq !== 0) {
      for (let i3 = 0; i3 !== Nbodies; i3++) {
        const b5 = bodies[i3];
        const vlambda = b5.vlambda;
        const wlambda = b5.wlambda;
        vlambda.set(0, 0, 0);
        wlambda.set(0, 0, 0);
      }
      for (iter = 0; iter !== maxIter; iter++) {
        deltalambdaTot = 0;
        for (let j = 0; j !== Neq; j++) {
          const c3 = equations[j];
          B2 = Bs[j];
          invC = invCs[j];
          lambdaj = lambda[j];
          GWlambda = c3.computeGWlambda();
          deltalambda = invC * (B2 - GWlambda - c3.eps * lambdaj);
          if (lambdaj + deltalambda < c3.minForce) {
            deltalambda = c3.minForce - lambdaj;
          } else if (lambdaj + deltalambda > c3.maxForce) {
            deltalambda = c3.maxForce - lambdaj;
          }
          lambda[j] += deltalambda;
          deltalambdaTot += deltalambda > 0 ? deltalambda : -deltalambda;
          c3.addToWlambda(deltalambda);
        }
        if (deltalambdaTot * deltalambdaTot < tolSquared) {
          break;
        }
      }
      for (let i3 = 0; i3 !== Nbodies; i3++) {
        const b5 = bodies[i3];
        const v = b5.velocity;
        const w = b5.angularVelocity;
        b5.vlambda.vmul(b5.linearFactor, b5.vlambda);
        v.vadd(b5.vlambda, v);
        b5.wlambda.vmul(b5.angularFactor, b5.wlambda);
        w.vadd(b5.wlambda, w);
      }
      let l = equations.length;
      const invDt = 1 / h;
      while (l--) {
        equations[l].multiplier = lambda[l] * invDt;
      }
    }
    return iter;
  }
};
var GSSolver_solve_lambda = [];
var GSSolver_solve_invCs = [];
var GSSolver_solve_Bs = [];
var STATIC = Body.STATIC;
var Pool = class {
  constructor() {
    this.objects = [];
    this.type = Object;
  }
  /**
   * Release an object after use
   */
  release() {
    const Nargs = arguments.length;
    for (let i3 = 0; i3 !== Nargs; i3++) {
      this.objects.push(i3 < 0 || arguments.length <= i3 ? void 0 : arguments[i3]);
    }
    return this;
  }
  /**
   * Get an object
   */
  get() {
    if (this.objects.length === 0) {
      return this.constructObject();
    } else {
      return this.objects.pop();
    }
  }
  /**
   * Construct an object. Should be implemented in each subclass.
   */
  constructObject() {
    throw new Error("constructObject() not implemented in this Pool subclass yet!");
  }
  /**
   * @return Self, for chaining
   */
  resize(size2) {
    const objects = this.objects;
    while (objects.length > size2) {
      objects.pop();
    }
    while (objects.length < size2) {
      objects.push(this.constructObject());
    }
    return this;
  }
};
var Vec3Pool = class extends Pool {
  constructor() {
    super(...arguments);
    this.type = Vec3;
  }
  /**
   * Construct a vector
   */
  constructObject() {
    return new Vec3();
  }
};
var COLLISION_TYPES = {
  sphereSphere: Shape2.types.SPHERE,
  spherePlane: Shape2.types.SPHERE | Shape2.types.PLANE,
  boxBox: Shape2.types.BOX | Shape2.types.BOX,
  sphereBox: Shape2.types.SPHERE | Shape2.types.BOX,
  planeBox: Shape2.types.PLANE | Shape2.types.BOX,
  convexConvex: Shape2.types.CONVEXPOLYHEDRON,
  sphereConvex: Shape2.types.SPHERE | Shape2.types.CONVEXPOLYHEDRON,
  planeConvex: Shape2.types.PLANE | Shape2.types.CONVEXPOLYHEDRON,
  boxConvex: Shape2.types.BOX | Shape2.types.CONVEXPOLYHEDRON,
  sphereHeightfield: Shape2.types.SPHERE | Shape2.types.HEIGHTFIELD,
  boxHeightfield: Shape2.types.BOX | Shape2.types.HEIGHTFIELD,
  convexHeightfield: Shape2.types.CONVEXPOLYHEDRON | Shape2.types.HEIGHTFIELD,
  sphereParticle: Shape2.types.PARTICLE | Shape2.types.SPHERE,
  planeParticle: Shape2.types.PLANE | Shape2.types.PARTICLE,
  boxParticle: Shape2.types.BOX | Shape2.types.PARTICLE,
  convexParticle: Shape2.types.PARTICLE | Shape2.types.CONVEXPOLYHEDRON,
  cylinderCylinder: Shape2.types.CYLINDER,
  sphereCylinder: Shape2.types.SPHERE | Shape2.types.CYLINDER,
  planeCylinder: Shape2.types.PLANE | Shape2.types.CYLINDER,
  boxCylinder: Shape2.types.BOX | Shape2.types.CYLINDER,
  convexCylinder: Shape2.types.CONVEXPOLYHEDRON | Shape2.types.CYLINDER,
  heightfieldCylinder: Shape2.types.HEIGHTFIELD | Shape2.types.CYLINDER,
  particleCylinder: Shape2.types.PARTICLE | Shape2.types.CYLINDER,
  sphereTrimesh: Shape2.types.SPHERE | Shape2.types.TRIMESH,
  planeTrimesh: Shape2.types.PLANE | Shape2.types.TRIMESH
};
var Narrowphase = class {
  /**
   * Internal storage of pooled contact points.
   */
  /**
   * Pooled vectors.
   */
  get [COLLISION_TYPES.sphereSphere]() {
    return this.sphereSphere;
  }
  get [COLLISION_TYPES.spherePlane]() {
    return this.spherePlane;
  }
  get [COLLISION_TYPES.boxBox]() {
    return this.boxBox;
  }
  get [COLLISION_TYPES.sphereBox]() {
    return this.sphereBox;
  }
  get [COLLISION_TYPES.planeBox]() {
    return this.planeBox;
  }
  get [COLLISION_TYPES.convexConvex]() {
    return this.convexConvex;
  }
  get [COLLISION_TYPES.sphereConvex]() {
    return this.sphereConvex;
  }
  get [COLLISION_TYPES.planeConvex]() {
    return this.planeConvex;
  }
  get [COLLISION_TYPES.boxConvex]() {
    return this.boxConvex;
  }
  get [COLLISION_TYPES.sphereHeightfield]() {
    return this.sphereHeightfield;
  }
  get [COLLISION_TYPES.boxHeightfield]() {
    return this.boxHeightfield;
  }
  get [COLLISION_TYPES.convexHeightfield]() {
    return this.convexHeightfield;
  }
  get [COLLISION_TYPES.sphereParticle]() {
    return this.sphereParticle;
  }
  get [COLLISION_TYPES.planeParticle]() {
    return this.planeParticle;
  }
  get [COLLISION_TYPES.boxParticle]() {
    return this.boxParticle;
  }
  get [COLLISION_TYPES.convexParticle]() {
    return this.convexParticle;
  }
  get [COLLISION_TYPES.cylinderCylinder]() {
    return this.convexConvex;
  }
  get [COLLISION_TYPES.sphereCylinder]() {
    return this.sphereConvex;
  }
  get [COLLISION_TYPES.planeCylinder]() {
    return this.planeConvex;
  }
  get [COLLISION_TYPES.boxCylinder]() {
    return this.boxConvex;
  }
  get [COLLISION_TYPES.convexCylinder]() {
    return this.convexConvex;
  }
  get [COLLISION_TYPES.heightfieldCylinder]() {
    return this.heightfieldCylinder;
  }
  get [COLLISION_TYPES.particleCylinder]() {
    return this.particleCylinder;
  }
  get [COLLISION_TYPES.sphereTrimesh]() {
    return this.sphereTrimesh;
  }
  get [COLLISION_TYPES.planeTrimesh]() {
    return this.planeTrimesh;
  }
  // get [COLLISION_TYPES.convexTrimesh]() {
  //   return this.convexTrimesh
  // }
  constructor(world2) {
    this.contactPointPool = [];
    this.frictionEquationPool = [];
    this.result = [];
    this.frictionResult = [];
    this.v3pool = new Vec3Pool();
    this.world = world2;
    this.currentContactMaterial = world2.defaultContactMaterial;
    this.enableFrictionReduction = false;
  }
  /**
   * Make a contact object, by using the internal pool or creating a new one.
   */
  createContactEquation(bi, bj, si, sj, overrideShapeA, overrideShapeB) {
    let c3;
    if (this.contactPointPool.length) {
      c3 = this.contactPointPool.pop();
      c3.bi = bi;
      c3.bj = bj;
    } else {
      c3 = new ContactEquation(bi, bj);
    }
    c3.enabled = bi.collisionResponse && bj.collisionResponse && si.collisionResponse && sj.collisionResponse;
    const cm = this.currentContactMaterial;
    c3.restitution = cm.restitution;
    c3.setSpookParams(cm.contactEquationStiffness, cm.contactEquationRelaxation, this.world.dt);
    const matA = si.material || bi.material;
    const matB = sj.material || bj.material;
    if (matA && matB && matA.restitution >= 0 && matB.restitution >= 0) {
      c3.restitution = matA.restitution * matB.restitution;
    }
    c3.si = overrideShapeA || si;
    c3.sj = overrideShapeB || sj;
    return c3;
  }
  createFrictionEquationsFromContact(contactEquation, outArray) {
    const bodyA = contactEquation.bi;
    const bodyB = contactEquation.bj;
    const shapeA = contactEquation.si;
    const shapeB = contactEquation.sj;
    const world2 = this.world;
    const cm = this.currentContactMaterial;
    let friction = cm.friction;
    const matA = shapeA.material || bodyA.material;
    const matB = shapeB.material || bodyB.material;
    if (matA && matB && matA.friction >= 0 && matB.friction >= 0) {
      friction = matA.friction * matB.friction;
    }
    if (friction > 0) {
      const mug = friction * (world2.frictionGravity || world2.gravity).length();
      let reducedMass = bodyA.invMass + bodyB.invMass;
      if (reducedMass > 0) {
        reducedMass = 1 / reducedMass;
      }
      const pool = this.frictionEquationPool;
      const c1 = pool.length ? pool.pop() : new FrictionEquation(bodyA, bodyB, mug * reducedMass);
      const c22 = pool.length ? pool.pop() : new FrictionEquation(bodyA, bodyB, mug * reducedMass);
      c1.bi = c22.bi = bodyA;
      c1.bj = c22.bj = bodyB;
      c1.minForce = c22.minForce = -mug * reducedMass;
      c1.maxForce = c22.maxForce = mug * reducedMass;
      c1.ri.copy(contactEquation.ri);
      c1.rj.copy(contactEquation.rj);
      c22.ri.copy(contactEquation.ri);
      c22.rj.copy(contactEquation.rj);
      contactEquation.ni.tangents(c1.t, c22.t);
      c1.setSpookParams(cm.frictionEquationStiffness, cm.frictionEquationRelaxation, world2.dt);
      c22.setSpookParams(cm.frictionEquationStiffness, cm.frictionEquationRelaxation, world2.dt);
      c1.enabled = c22.enabled = contactEquation.enabled;
      outArray.push(c1, c22);
      return true;
    }
    return false;
  }
  /**
   * Take the average N latest contact point on the plane.
   */
  createFrictionFromAverage(numContacts) {
    let c3 = this.result[this.result.length - 1];
    if (!this.createFrictionEquationsFromContact(c3, this.frictionResult) || numContacts === 1) {
      return;
    }
    const f1 = this.frictionResult[this.frictionResult.length - 2];
    const f2 = this.frictionResult[this.frictionResult.length - 1];
    averageNormal.setZero();
    averageContactPointA.setZero();
    averageContactPointB.setZero();
    const bodyA = c3.bi;
    c3.bj;
    for (let i3 = 0; i3 !== numContacts; i3++) {
      c3 = this.result[this.result.length - 1 - i3];
      if (c3.bi !== bodyA) {
        averageNormal.vadd(c3.ni, averageNormal);
        averageContactPointA.vadd(c3.ri, averageContactPointA);
        averageContactPointB.vadd(c3.rj, averageContactPointB);
      } else {
        averageNormal.vsub(c3.ni, averageNormal);
        averageContactPointA.vadd(c3.rj, averageContactPointA);
        averageContactPointB.vadd(c3.ri, averageContactPointB);
      }
    }
    const invNumContacts = 1 / numContacts;
    averageContactPointA.scale(invNumContacts, f1.ri);
    averageContactPointB.scale(invNumContacts, f1.rj);
    f2.ri.copy(f1.ri);
    f2.rj.copy(f1.rj);
    averageNormal.normalize();
    averageNormal.tangents(f1.t, f2.t);
  }
  /**
   * Generate all contacts between a list of body pairs
   * @param p1 Array of body indices
   * @param p2 Array of body indices
   * @param result Array to store generated contacts
   * @param oldcontacts Optional. Array of reusable contact objects
   */
  getContacts(p1, p2, world2, result, oldcontacts, frictionResult, frictionPool) {
    this.contactPointPool = oldcontacts;
    this.frictionEquationPool = frictionPool;
    this.result = result;
    this.frictionResult = frictionResult;
    const qi = tmpQuat1;
    const qj = tmpQuat2;
    const xi = tmpVec1;
    const xj = tmpVec2;
    for (let k = 0, N = p1.length; k !== N; k++) {
      const bi = p1[k];
      const bj = p2[k];
      let bodyContactMaterial = null;
      if (bi.material && bj.material) {
        bodyContactMaterial = world2.getContactMaterial(bi.material, bj.material) || null;
      }
      const justTest = bi.type & Body.KINEMATIC && bj.type & Body.STATIC || bi.type & Body.STATIC && bj.type & Body.KINEMATIC || bi.type & Body.KINEMATIC && bj.type & Body.KINEMATIC;
      for (let i3 = 0; i3 < bi.shapes.length; i3++) {
        bi.quaternion.mult(bi.shapeOrientations[i3], qi);
        bi.quaternion.vmult(bi.shapeOffsets[i3], xi);
        xi.vadd(bi.position, xi);
        const si = bi.shapes[i3];
        for (let j = 0; j < bj.shapes.length; j++) {
          bj.quaternion.mult(bj.shapeOrientations[j], qj);
          bj.quaternion.vmult(bj.shapeOffsets[j], xj);
          xj.vadd(bj.position, xj);
          const sj = bj.shapes[j];
          if (!(si.collisionFilterMask & sj.collisionFilterGroup && sj.collisionFilterMask & si.collisionFilterGroup)) {
            continue;
          }
          if (xi.distanceTo(xj) > si.boundingSphereRadius + sj.boundingSphereRadius) {
            continue;
          }
          let shapeContactMaterial = null;
          if (si.material && sj.material) {
            shapeContactMaterial = world2.getContactMaterial(si.material, sj.material) || null;
          }
          this.currentContactMaterial = shapeContactMaterial || bodyContactMaterial || world2.defaultContactMaterial;
          const resolverIndex = si.type | sj.type;
          const resolver = this[resolverIndex];
          if (resolver) {
            let retval = false;
            if (si.type < sj.type) {
              retval = resolver.call(this, si, sj, xi, xj, qi, qj, bi, bj, si, sj, justTest);
            } else {
              retval = resolver.call(this, sj, si, xj, xi, qj, qi, bj, bi, si, sj, justTest);
            }
            if (retval && justTest) {
              world2.shapeOverlapKeeper.set(si.id, sj.id);
              world2.bodyOverlapKeeper.set(bi.id, bj.id);
            }
          }
        }
      }
    }
  }
  sphereSphere(si, sj, xi, xj, qi, qj, bi, bj, rsi, rsj, justTest) {
    if (justTest) {
      return xi.distanceSquared(xj) < (si.radius + sj.radius) ** 2;
    }
    const contactEq = this.createContactEquation(bi, bj, si, sj, rsi, rsj);
    xj.vsub(xi, contactEq.ni);
    contactEq.ni.normalize();
    contactEq.ri.copy(contactEq.ni);
    contactEq.rj.copy(contactEq.ni);
    contactEq.ri.scale(si.radius, contactEq.ri);
    contactEq.rj.scale(-sj.radius, contactEq.rj);
    contactEq.ri.vadd(xi, contactEq.ri);
    contactEq.ri.vsub(bi.position, contactEq.ri);
    contactEq.rj.vadd(xj, contactEq.rj);
    contactEq.rj.vsub(bj.position, contactEq.rj);
    this.result.push(contactEq);
    this.createFrictionEquationsFromContact(contactEq, this.frictionResult);
  }
  spherePlane(si, sj, xi, xj, qi, qj, bi, bj, rsi, rsj, justTest) {
    const r = this.createContactEquation(bi, bj, si, sj, rsi, rsj);
    r.ni.set(0, 0, 1);
    qj.vmult(r.ni, r.ni);
    r.ni.negate(r.ni);
    r.ni.normalize();
    r.ni.scale(si.radius, r.ri);
    xi.vsub(xj, point_on_plane_to_sphere);
    r.ni.scale(r.ni.dot(point_on_plane_to_sphere), plane_to_sphere_ortho);
    point_on_plane_to_sphere.vsub(plane_to_sphere_ortho, r.rj);
    if (-point_on_plane_to_sphere.dot(r.ni) <= si.radius) {
      if (justTest) {
        return true;
      }
      const ri = r.ri;
      const rj = r.rj;
      ri.vadd(xi, ri);
      ri.vsub(bi.position, ri);
      rj.vadd(xj, rj);
      rj.vsub(bj.position, rj);
      this.result.push(r);
      this.createFrictionEquationsFromContact(r, this.frictionResult);
    }
  }
  boxBox(si, sj, xi, xj, qi, qj, bi, bj, rsi, rsj, justTest) {
    si.convexPolyhedronRepresentation.material = si.material;
    sj.convexPolyhedronRepresentation.material = sj.material;
    si.convexPolyhedronRepresentation.collisionResponse = si.collisionResponse;
    sj.convexPolyhedronRepresentation.collisionResponse = sj.collisionResponse;
    return this.convexConvex(si.convexPolyhedronRepresentation, sj.convexPolyhedronRepresentation, xi, xj, qi, qj, bi, bj, si, sj, justTest);
  }
  sphereBox(si, sj, xi, xj, qi, qj, bi, bj, rsi, rsj, justTest) {
    const v3pool = this.v3pool;
    const sides = sphereBox_sides;
    xi.vsub(xj, box_to_sphere);
    sj.getSideNormals(sides, qj);
    const R2 = si.radius;
    let found = false;
    const side_ns = sphereBox_side_ns;
    const side_ns1 = sphereBox_side_ns1;
    const side_ns2 = sphereBox_side_ns2;
    let side_h = null;
    let side_penetrations = 0;
    let side_dot1 = 0;
    let side_dot2 = 0;
    let side_distance = null;
    for (let idx = 0, nsides = sides.length; idx !== nsides && found === false; idx++) {
      const ns = sphereBox_ns;
      ns.copy(sides[idx]);
      const h = ns.length();
      ns.normalize();
      const dot = box_to_sphere.dot(ns);
      if (dot < h + R2 && dot > 0) {
        const ns1 = sphereBox_ns1;
        const ns2 = sphereBox_ns2;
        ns1.copy(sides[(idx + 1) % 3]);
        ns2.copy(sides[(idx + 2) % 3]);
        const h1 = ns1.length();
        const h2 = ns2.length();
        ns1.normalize();
        ns2.normalize();
        const dot1 = box_to_sphere.dot(ns1);
        const dot2 = box_to_sphere.dot(ns2);
        if (dot1 < h1 && dot1 > -h1 && dot2 < h2 && dot2 > -h2) {
          const dist2 = Math.abs(dot - h - R2);
          if (side_distance === null || dist2 < side_distance) {
            side_distance = dist2;
            side_dot1 = dot1;
            side_dot2 = dot2;
            side_h = h;
            side_ns.copy(ns);
            side_ns1.copy(ns1);
            side_ns2.copy(ns2);
            side_penetrations++;
            if (justTest) {
              return true;
            }
          }
        }
      }
    }
    if (side_penetrations) {
      found = true;
      const r2 = this.createContactEquation(bi, bj, si, sj, rsi, rsj);
      side_ns.scale(-R2, r2.ri);
      r2.ni.copy(side_ns);
      r2.ni.negate(r2.ni);
      side_ns.scale(side_h, side_ns);
      side_ns1.scale(side_dot1, side_ns1);
      side_ns.vadd(side_ns1, side_ns);
      side_ns2.scale(side_dot2, side_ns2);
      side_ns.vadd(side_ns2, r2.rj);
      r2.ri.vadd(xi, r2.ri);
      r2.ri.vsub(bi.position, r2.ri);
      r2.rj.vadd(xj, r2.rj);
      r2.rj.vsub(bj.position, r2.rj);
      this.result.push(r2);
      this.createFrictionEquationsFromContact(r2, this.frictionResult);
    }
    let rj = v3pool.get();
    const sphere_to_corner = sphereBox_sphere_to_corner;
    for (let j = 0; j !== 2 && !found; j++) {
      for (let k = 0; k !== 2 && !found; k++) {
        for (let l = 0; l !== 2 && !found; l++) {
          rj.set(0, 0, 0);
          if (j) {
            rj.vadd(sides[0], rj);
          } else {
            rj.vsub(sides[0], rj);
          }
          if (k) {
            rj.vadd(sides[1], rj);
          } else {
            rj.vsub(sides[1], rj);
          }
          if (l) {
            rj.vadd(sides[2], rj);
          } else {
            rj.vsub(sides[2], rj);
          }
          xj.vadd(rj, sphere_to_corner);
          sphere_to_corner.vsub(xi, sphere_to_corner);
          if (sphere_to_corner.lengthSquared() < R2 * R2) {
            if (justTest) {
              return true;
            }
            found = true;
            const r2 = this.createContactEquation(bi, bj, si, sj, rsi, rsj);
            r2.ri.copy(sphere_to_corner);
            r2.ri.normalize();
            r2.ni.copy(r2.ri);
            r2.ri.scale(R2, r2.ri);
            r2.rj.copy(rj);
            r2.ri.vadd(xi, r2.ri);
            r2.ri.vsub(bi.position, r2.ri);
            r2.rj.vadd(xj, r2.rj);
            r2.rj.vsub(bj.position, r2.rj);
            this.result.push(r2);
            this.createFrictionEquationsFromContact(r2, this.frictionResult);
          }
        }
      }
    }
    v3pool.release(rj);
    rj = null;
    const edgeTangent = v3pool.get();
    const edgeCenter = v3pool.get();
    const r = v3pool.get();
    const orthogonal = v3pool.get();
    const dist = v3pool.get();
    const Nsides = sides.length;
    for (let j = 0; j !== Nsides && !found; j++) {
      for (let k = 0; k !== Nsides && !found; k++) {
        if (j % 3 !== k % 3) {
          sides[k].cross(sides[j], edgeTangent);
          edgeTangent.normalize();
          sides[j].vadd(sides[k], edgeCenter);
          r.copy(xi);
          r.vsub(edgeCenter, r);
          r.vsub(xj, r);
          const orthonorm = r.dot(edgeTangent);
          edgeTangent.scale(orthonorm, orthogonal);
          let l = 0;
          while (l === j % 3 || l === k % 3) {
            l++;
          }
          dist.copy(xi);
          dist.vsub(orthogonal, dist);
          dist.vsub(edgeCenter, dist);
          dist.vsub(xj, dist);
          const tdist = Math.abs(orthonorm);
          const ndist = dist.length();
          if (tdist < sides[l].length() && ndist < R2) {
            if (justTest) {
              return true;
            }
            found = true;
            const res = this.createContactEquation(bi, bj, si, sj, rsi, rsj);
            edgeCenter.vadd(orthogonal, res.rj);
            res.rj.copy(res.rj);
            dist.negate(res.ni);
            res.ni.normalize();
            res.ri.copy(res.rj);
            res.ri.vadd(xj, res.ri);
            res.ri.vsub(xi, res.ri);
            res.ri.normalize();
            res.ri.scale(R2, res.ri);
            res.ri.vadd(xi, res.ri);
            res.ri.vsub(bi.position, res.ri);
            res.rj.vadd(xj, res.rj);
            res.rj.vsub(bj.position, res.rj);
            this.result.push(res);
            this.createFrictionEquationsFromContact(res, this.frictionResult);
          }
        }
      }
    }
    v3pool.release(edgeTangent, edgeCenter, r, orthogonal, dist);
  }
  planeBox(si, sj, xi, xj, qi, qj, bi, bj, rsi, rsj, justTest) {
    sj.convexPolyhedronRepresentation.material = sj.material;
    sj.convexPolyhedronRepresentation.collisionResponse = sj.collisionResponse;
    sj.convexPolyhedronRepresentation.id = sj.id;
    return this.planeConvex(si, sj.convexPolyhedronRepresentation, xi, xj, qi, qj, bi, bj, si, sj, justTest);
  }
  convexConvex(si, sj, xi, xj, qi, qj, bi, bj, rsi, rsj, justTest, faceListA, faceListB) {
    const sepAxis = convexConvex_sepAxis;
    if (xi.distanceTo(xj) > si.boundingSphereRadius + sj.boundingSphereRadius) {
      return;
    }
    if (si.findSeparatingAxis(sj, xi, qi, xj, qj, sepAxis, faceListA, faceListB)) {
      const res = [];
      const q = convexConvex_q;
      si.clipAgainstHull(xi, qi, sj, xj, qj, sepAxis, -100, 100, res);
      let numContacts = 0;
      for (let j = 0; j !== res.length; j++) {
        if (justTest) {
          return true;
        }
        const r = this.createContactEquation(bi, bj, si, sj, rsi, rsj);
        const ri = r.ri;
        const rj = r.rj;
        sepAxis.negate(r.ni);
        res[j].normal.negate(q);
        q.scale(res[j].depth, q);
        res[j].point.vadd(q, ri);
        rj.copy(res[j].point);
        ri.vsub(xi, ri);
        rj.vsub(xj, rj);
        ri.vadd(xi, ri);
        ri.vsub(bi.position, ri);
        rj.vadd(xj, rj);
        rj.vsub(bj.position, rj);
        this.result.push(r);
        numContacts++;
        if (!this.enableFrictionReduction) {
          this.createFrictionEquationsFromContact(r, this.frictionResult);
        }
      }
      if (this.enableFrictionReduction && numContacts) {
        this.createFrictionFromAverage(numContacts);
      }
    }
  }
  sphereConvex(si, sj, xi, xj, qi, qj, bi, bj, rsi, rsj, justTest) {
    const v3pool = this.v3pool;
    xi.vsub(xj, convex_to_sphere);
    const normals = sj.faceNormals;
    const faces = sj.faces;
    const verts = sj.vertices;
    const R2 = si.radius;
    let found = false;
    for (let i3 = 0; i3 !== verts.length; i3++) {
      const v = verts[i3];
      const worldCorner = sphereConvex_worldCorner;
      qj.vmult(v, worldCorner);
      xj.vadd(worldCorner, worldCorner);
      const sphere_to_corner = sphereConvex_sphereToCorner;
      worldCorner.vsub(xi, sphere_to_corner);
      if (sphere_to_corner.lengthSquared() < R2 * R2) {
        if (justTest) {
          return true;
        }
        found = true;
        const r = this.createContactEquation(bi, bj, si, sj, rsi, rsj);
        r.ri.copy(sphere_to_corner);
        r.ri.normalize();
        r.ni.copy(r.ri);
        r.ri.scale(R2, r.ri);
        worldCorner.vsub(xj, r.rj);
        r.ri.vadd(xi, r.ri);
        r.ri.vsub(bi.position, r.ri);
        r.rj.vadd(xj, r.rj);
        r.rj.vsub(bj.position, r.rj);
        this.result.push(r);
        this.createFrictionEquationsFromContact(r, this.frictionResult);
        return;
      }
    }
    for (let i3 = 0, nfaces = faces.length; i3 !== nfaces && found === false; i3++) {
      const normal = normals[i3];
      const face = faces[i3];
      const worldNormal = sphereConvex_worldNormal;
      qj.vmult(normal, worldNormal);
      const worldPoint = sphereConvex_worldPoint;
      qj.vmult(verts[face[0]], worldPoint);
      worldPoint.vadd(xj, worldPoint);
      const worldSpherePointClosestToPlane = sphereConvex_worldSpherePointClosestToPlane;
      worldNormal.scale(-R2, worldSpherePointClosestToPlane);
      xi.vadd(worldSpherePointClosestToPlane, worldSpherePointClosestToPlane);
      const penetrationVec = sphereConvex_penetrationVec;
      worldSpherePointClosestToPlane.vsub(worldPoint, penetrationVec);
      const penetration = penetrationVec.dot(worldNormal);
      const worldPointToSphere = sphereConvex_sphereToWorldPoint;
      xi.vsub(worldPoint, worldPointToSphere);
      if (penetration < 0 && worldPointToSphere.dot(worldNormal) > 0) {
        const faceVerts = [];
        for (let j = 0, Nverts = face.length; j !== Nverts; j++) {
          const worldVertex = v3pool.get();
          qj.vmult(verts[face[j]], worldVertex);
          xj.vadd(worldVertex, worldVertex);
          faceVerts.push(worldVertex);
        }
        if (pointInPolygon(faceVerts, worldNormal, xi)) {
          if (justTest) {
            return true;
          }
          found = true;
          const r = this.createContactEquation(bi, bj, si, sj, rsi, rsj);
          worldNormal.scale(-R2, r.ri);
          worldNormal.negate(r.ni);
          const penetrationVec2 = v3pool.get();
          worldNormal.scale(-penetration, penetrationVec2);
          const penetrationSpherePoint = v3pool.get();
          worldNormal.scale(-R2, penetrationSpherePoint);
          xi.vsub(xj, r.rj);
          r.rj.vadd(penetrationSpherePoint, r.rj);
          r.rj.vadd(penetrationVec2, r.rj);
          r.rj.vadd(xj, r.rj);
          r.rj.vsub(bj.position, r.rj);
          r.ri.vadd(xi, r.ri);
          r.ri.vsub(bi.position, r.ri);
          v3pool.release(penetrationVec2);
          v3pool.release(penetrationSpherePoint);
          this.result.push(r);
          this.createFrictionEquationsFromContact(r, this.frictionResult);
          for (let j = 0, Nfaceverts = faceVerts.length; j !== Nfaceverts; j++) {
            v3pool.release(faceVerts[j]);
          }
          return;
        } else {
          for (let j = 0; j !== face.length; j++) {
            const v14 = v3pool.get();
            const v23 = v3pool.get();
            qj.vmult(verts[face[(j + 1) % face.length]], v14);
            qj.vmult(verts[face[(j + 2) % face.length]], v23);
            xj.vadd(v14, v14);
            xj.vadd(v23, v23);
            const edge = sphereConvex_edge;
            v23.vsub(v14, edge);
            const edgeUnit = sphereConvex_edgeUnit;
            edge.unit(edgeUnit);
            const p = v3pool.get();
            const v1_to_xi = v3pool.get();
            xi.vsub(v14, v1_to_xi);
            const dot = v1_to_xi.dot(edgeUnit);
            edgeUnit.scale(dot, p);
            p.vadd(v14, p);
            const xi_to_p = v3pool.get();
            p.vsub(xi, xi_to_p);
            if (dot > 0 && dot * dot < edge.lengthSquared() && xi_to_p.lengthSquared() < R2 * R2) {
              if (justTest) {
                return true;
              }
              const r = this.createContactEquation(bi, bj, si, sj, rsi, rsj);
              p.vsub(xj, r.rj);
              p.vsub(xi, r.ni);
              r.ni.normalize();
              r.ni.scale(R2, r.ri);
              r.rj.vadd(xj, r.rj);
              r.rj.vsub(bj.position, r.rj);
              r.ri.vadd(xi, r.ri);
              r.ri.vsub(bi.position, r.ri);
              this.result.push(r);
              this.createFrictionEquationsFromContact(r, this.frictionResult);
              for (let j2 = 0, Nfaceverts = faceVerts.length; j2 !== Nfaceverts; j2++) {
                v3pool.release(faceVerts[j2]);
              }
              v3pool.release(v14);
              v3pool.release(v23);
              v3pool.release(p);
              v3pool.release(xi_to_p);
              v3pool.release(v1_to_xi);
              return;
            }
            v3pool.release(v14);
            v3pool.release(v23);
            v3pool.release(p);
            v3pool.release(xi_to_p);
            v3pool.release(v1_to_xi);
          }
        }
        for (let j = 0, Nfaceverts = faceVerts.length; j !== Nfaceverts; j++) {
          v3pool.release(faceVerts[j]);
        }
      }
    }
  }
  planeConvex(planeShape, convexShape, planePosition, convexPosition, planeQuat, convexQuat, planeBody, convexBody, si, sj, justTest) {
    const worldVertex = planeConvex_v;
    const worldNormal = planeConvex_normal;
    worldNormal.set(0, 0, 1);
    planeQuat.vmult(worldNormal, worldNormal);
    let numContacts = 0;
    const relpos2 = planeConvex_relpos;
    for (let i3 = 0; i3 !== convexShape.vertices.length; i3++) {
      worldVertex.copy(convexShape.vertices[i3]);
      convexQuat.vmult(worldVertex, worldVertex);
      convexPosition.vadd(worldVertex, worldVertex);
      worldVertex.vsub(planePosition, relpos2);
      const dot = worldNormal.dot(relpos2);
      if (dot <= 0) {
        if (justTest) {
          return true;
        }
        const r = this.createContactEquation(planeBody, convexBody, planeShape, convexShape, si, sj);
        const projected = planeConvex_projected;
        worldNormal.scale(worldNormal.dot(relpos2), projected);
        worldVertex.vsub(projected, projected);
        projected.vsub(planePosition, r.ri);
        r.ni.copy(worldNormal);
        worldVertex.vsub(convexPosition, r.rj);
        r.ri.vadd(planePosition, r.ri);
        r.ri.vsub(planeBody.position, r.ri);
        r.rj.vadd(convexPosition, r.rj);
        r.rj.vsub(convexBody.position, r.rj);
        this.result.push(r);
        numContacts++;
        if (!this.enableFrictionReduction) {
          this.createFrictionEquationsFromContact(r, this.frictionResult);
        }
      }
    }
    if (this.enableFrictionReduction && numContacts) {
      this.createFrictionFromAverage(numContacts);
    }
  }
  boxConvex(si, sj, xi, xj, qi, qj, bi, bj, rsi, rsj, justTest) {
    si.convexPolyhedronRepresentation.material = si.material;
    si.convexPolyhedronRepresentation.collisionResponse = si.collisionResponse;
    return this.convexConvex(si.convexPolyhedronRepresentation, sj, xi, xj, qi, qj, bi, bj, si, sj, justTest);
  }
  sphereHeightfield(sphereShape, hfShape, spherePos, hfPos, sphereQuat, hfQuat, sphereBody, hfBody, rsi, rsj, justTest) {
    const data = hfShape.data;
    const radius = sphereShape.radius;
    const w = hfShape.elementSize;
    const worldPillarOffset2 = sphereHeightfield_tmp2;
    const localSpherePos = sphereHeightfield_tmp1;
    Transform.pointToLocalFrame(hfPos, hfQuat, spherePos, localSpherePos);
    let iMinX = Math.floor((localSpherePos.x - radius) / w) - 1;
    let iMaxX = Math.ceil((localSpherePos.x + radius) / w) + 1;
    let iMinY = Math.floor((localSpherePos.y - radius) / w) - 1;
    let iMaxY = Math.ceil((localSpherePos.y + radius) / w) + 1;
    if (iMaxX < 0 || iMaxY < 0 || iMinX > data.length || iMinY > data[0].length) {
      return;
    }
    if (iMinX < 0) {
      iMinX = 0;
    }
    if (iMaxX < 0) {
      iMaxX = 0;
    }
    if (iMinY < 0) {
      iMinY = 0;
    }
    if (iMaxY < 0) {
      iMaxY = 0;
    }
    if (iMinX >= data.length) {
      iMinX = data.length - 1;
    }
    if (iMaxX >= data.length) {
      iMaxX = data.length - 1;
    }
    if (iMaxY >= data[0].length) {
      iMaxY = data[0].length - 1;
    }
    if (iMinY >= data[0].length) {
      iMinY = data[0].length - 1;
    }
    const minMax = [];
    hfShape.getRectMinMax(iMinX, iMinY, iMaxX, iMaxY, minMax);
    const min = minMax[0];
    const max3 = minMax[1];
    if (localSpherePos.z - radius > max3 || localSpherePos.z + radius < min) {
      return;
    }
    const result = this.result;
    for (let i3 = iMinX; i3 < iMaxX; i3++) {
      for (let j = iMinY; j < iMaxY; j++) {
        const numContactsBefore = result.length;
        let intersecting = false;
        hfShape.getConvexTrianglePillar(i3, j, false);
        Transform.pointToWorldFrame(hfPos, hfQuat, hfShape.pillarOffset, worldPillarOffset2);
        if (spherePos.distanceTo(worldPillarOffset2) < hfShape.pillarConvex.boundingSphereRadius + sphereShape.boundingSphereRadius) {
          intersecting = this.sphereConvex(sphereShape, hfShape.pillarConvex, spherePos, worldPillarOffset2, sphereQuat, hfQuat, sphereBody, hfBody, sphereShape, hfShape, justTest);
        }
        if (justTest && intersecting) {
          return true;
        }
        hfShape.getConvexTrianglePillar(i3, j, true);
        Transform.pointToWorldFrame(hfPos, hfQuat, hfShape.pillarOffset, worldPillarOffset2);
        if (spherePos.distanceTo(worldPillarOffset2) < hfShape.pillarConvex.boundingSphereRadius + sphereShape.boundingSphereRadius) {
          intersecting = this.sphereConvex(sphereShape, hfShape.pillarConvex, spherePos, worldPillarOffset2, sphereQuat, hfQuat, sphereBody, hfBody, sphereShape, hfShape, justTest);
        }
        if (justTest && intersecting) {
          return true;
        }
        const numContacts = result.length - numContactsBefore;
        if (numContacts > 2) {
          return;
        }
      }
    }
  }
  boxHeightfield(si, sj, xi, xj, qi, qj, bi, bj, rsi, rsj, justTest) {
    si.convexPolyhedronRepresentation.material = si.material;
    si.convexPolyhedronRepresentation.collisionResponse = si.collisionResponse;
    return this.convexHeightfield(si.convexPolyhedronRepresentation, sj, xi, xj, qi, qj, bi, bj, si, sj, justTest);
  }
  convexHeightfield(convexShape, hfShape, convexPos, hfPos, convexQuat, hfQuat, convexBody, hfBody, rsi, rsj, justTest) {
    const data = hfShape.data;
    const w = hfShape.elementSize;
    const radius = convexShape.boundingSphereRadius;
    const worldPillarOffset2 = convexHeightfield_tmp2;
    const faceList = convexHeightfield_faceList;
    const localConvexPos = convexHeightfield_tmp1;
    Transform.pointToLocalFrame(hfPos, hfQuat, convexPos, localConvexPos);
    let iMinX = Math.floor((localConvexPos.x - radius) / w) - 1;
    let iMaxX = Math.ceil((localConvexPos.x + radius) / w) + 1;
    let iMinY = Math.floor((localConvexPos.y - radius) / w) - 1;
    let iMaxY = Math.ceil((localConvexPos.y + radius) / w) + 1;
    if (iMaxX < 0 || iMaxY < 0 || iMinX > data.length || iMinY > data[0].length) {
      return;
    }
    if (iMinX < 0) {
      iMinX = 0;
    }
    if (iMaxX < 0) {
      iMaxX = 0;
    }
    if (iMinY < 0) {
      iMinY = 0;
    }
    if (iMaxY < 0) {
      iMaxY = 0;
    }
    if (iMinX >= data.length) {
      iMinX = data.length - 1;
    }
    if (iMaxX >= data.length) {
      iMaxX = data.length - 1;
    }
    if (iMaxY >= data[0].length) {
      iMaxY = data[0].length - 1;
    }
    if (iMinY >= data[0].length) {
      iMinY = data[0].length - 1;
    }
    const minMax = [];
    hfShape.getRectMinMax(iMinX, iMinY, iMaxX, iMaxY, minMax);
    const min = minMax[0];
    const max3 = minMax[1];
    if (localConvexPos.z - radius > max3 || localConvexPos.z + radius < min) {
      return;
    }
    for (let i3 = iMinX; i3 < iMaxX; i3++) {
      for (let j = iMinY; j < iMaxY; j++) {
        let intersecting = false;
        hfShape.getConvexTrianglePillar(i3, j, false);
        Transform.pointToWorldFrame(hfPos, hfQuat, hfShape.pillarOffset, worldPillarOffset2);
        if (convexPos.distanceTo(worldPillarOffset2) < hfShape.pillarConvex.boundingSphereRadius + convexShape.boundingSphereRadius) {
          intersecting = this.convexConvex(convexShape, hfShape.pillarConvex, convexPos, worldPillarOffset2, convexQuat, hfQuat, convexBody, hfBody, null, null, justTest, faceList, null);
        }
        if (justTest && intersecting) {
          return true;
        }
        hfShape.getConvexTrianglePillar(i3, j, true);
        Transform.pointToWorldFrame(hfPos, hfQuat, hfShape.pillarOffset, worldPillarOffset2);
        if (convexPos.distanceTo(worldPillarOffset2) < hfShape.pillarConvex.boundingSphereRadius + convexShape.boundingSphereRadius) {
          intersecting = this.convexConvex(convexShape, hfShape.pillarConvex, convexPos, worldPillarOffset2, convexQuat, hfQuat, convexBody, hfBody, null, null, justTest, faceList, null);
        }
        if (justTest && intersecting) {
          return true;
        }
      }
    }
  }
  sphereParticle(sj, si, xj, xi, qj, qi, bj, bi, rsi, rsj, justTest) {
    const normal = particleSphere_normal;
    normal.set(0, 0, 1);
    xi.vsub(xj, normal);
    const lengthSquared = normal.lengthSquared();
    if (lengthSquared <= sj.radius * sj.radius) {
      if (justTest) {
        return true;
      }
      const r = this.createContactEquation(bi, bj, si, sj, rsi, rsj);
      normal.normalize();
      r.rj.copy(normal);
      r.rj.scale(sj.radius, r.rj);
      r.ni.copy(normal);
      r.ni.negate(r.ni);
      r.ri.set(0, 0, 0);
      this.result.push(r);
      this.createFrictionEquationsFromContact(r, this.frictionResult);
    }
  }
  planeParticle(sj, si, xj, xi, qj, qi, bj, bi, rsi, rsj, justTest) {
    const normal = particlePlane_normal;
    normal.set(0, 0, 1);
    bj.quaternion.vmult(normal, normal);
    const relpos2 = particlePlane_relpos;
    xi.vsub(bj.position, relpos2);
    const dot = normal.dot(relpos2);
    if (dot <= 0) {
      if (justTest) {
        return true;
      }
      const r = this.createContactEquation(bi, bj, si, sj, rsi, rsj);
      r.ni.copy(normal);
      r.ni.negate(r.ni);
      r.ri.set(0, 0, 0);
      const projected = particlePlane_projected;
      normal.scale(normal.dot(xi), projected);
      xi.vsub(projected, projected);
      r.rj.copy(projected);
      this.result.push(r);
      this.createFrictionEquationsFromContact(r, this.frictionResult);
    }
  }
  boxParticle(si, sj, xi, xj, qi, qj, bi, bj, rsi, rsj, justTest) {
    si.convexPolyhedronRepresentation.material = si.material;
    si.convexPolyhedronRepresentation.collisionResponse = si.collisionResponse;
    return this.convexParticle(si.convexPolyhedronRepresentation, sj, xi, xj, qi, qj, bi, bj, si, sj, justTest);
  }
  convexParticle(sj, si, xj, xi, qj, qi, bj, bi, rsi, rsj, justTest) {
    let penetratedFaceIndex = -1;
    const penetratedFaceNormal = convexParticle_penetratedFaceNormal;
    const worldPenetrationVec = convexParticle_worldPenetrationVec;
    let minPenetration = null;
    const local = convexParticle_local;
    local.copy(xi);
    local.vsub(xj, local);
    qj.conjugate(cqj);
    cqj.vmult(local, local);
    if (sj.pointIsInside(local)) {
      if (sj.worldVerticesNeedsUpdate) {
        sj.computeWorldVertices(xj, qj);
      }
      if (sj.worldFaceNormalsNeedsUpdate) {
        sj.computeWorldFaceNormals(qj);
      }
      for (let i3 = 0, nfaces = sj.faces.length; i3 !== nfaces; i3++) {
        const verts = [sj.worldVertices[sj.faces[i3][0]]];
        const normal = sj.worldFaceNormals[i3];
        xi.vsub(verts[0], convexParticle_vertexToParticle);
        const penetration = -normal.dot(convexParticle_vertexToParticle);
        if (minPenetration === null || Math.abs(penetration) < Math.abs(minPenetration)) {
          if (justTest) {
            return true;
          }
          minPenetration = penetration;
          penetratedFaceIndex = i3;
          penetratedFaceNormal.copy(normal);
        }
      }
      if (penetratedFaceIndex !== -1) {
        const r = this.createContactEquation(bi, bj, si, sj, rsi, rsj);
        penetratedFaceNormal.scale(minPenetration, worldPenetrationVec);
        worldPenetrationVec.vadd(xi, worldPenetrationVec);
        worldPenetrationVec.vsub(xj, worldPenetrationVec);
        r.rj.copy(worldPenetrationVec);
        penetratedFaceNormal.negate(r.ni);
        r.ri.set(0, 0, 0);
        const ri = r.ri;
        const rj = r.rj;
        ri.vadd(xi, ri);
        ri.vsub(bi.position, ri);
        rj.vadd(xj, rj);
        rj.vsub(bj.position, rj);
        this.result.push(r);
        this.createFrictionEquationsFromContact(r, this.frictionResult);
      } else {
        console.warn("Point found inside convex, but did not find penetrating face!");
      }
    }
  }
  heightfieldCylinder(hfShape, convexShape, hfPos, convexPos, hfQuat, convexQuat, hfBody, convexBody, rsi, rsj, justTest) {
    return this.convexHeightfield(convexShape, hfShape, convexPos, hfPos, convexQuat, hfQuat, convexBody, hfBody, rsi, rsj, justTest);
  }
  particleCylinder(si, sj, xi, xj, qi, qj, bi, bj, rsi, rsj, justTest) {
    return this.convexParticle(sj, si, xj, xi, qj, qi, bj, bi, rsi, rsj, justTest);
  }
  sphereTrimesh(sphereShape, trimeshShape, spherePos, trimeshPos, sphereQuat, trimeshQuat, sphereBody, trimeshBody, rsi, rsj, justTest) {
    const edgeVertexA = sphereTrimesh_edgeVertexA;
    const edgeVertexB = sphereTrimesh_edgeVertexB;
    const edgeVector = sphereTrimesh_edgeVector;
    const edgeVectorUnit = sphereTrimesh_edgeVectorUnit;
    const localSpherePos = sphereTrimesh_localSpherePos;
    const tmp2 = sphereTrimesh_tmp;
    const localSphereAABB = sphereTrimesh_localSphereAABB;
    const v23 = sphereTrimesh_v2;
    const relpos2 = sphereTrimesh_relpos;
    const triangles = sphereTrimesh_triangles;
    Transform.pointToLocalFrame(trimeshPos, trimeshQuat, spherePos, localSpherePos);
    const sphereRadius = sphereShape.radius;
    localSphereAABB.lowerBound.set(localSpherePos.x - sphereRadius, localSpherePos.y - sphereRadius, localSpherePos.z - sphereRadius);
    localSphereAABB.upperBound.set(localSpherePos.x + sphereRadius, localSpherePos.y + sphereRadius, localSpherePos.z + sphereRadius);
    trimeshShape.getTrianglesInAABB(localSphereAABB, triangles);
    const v = sphereTrimesh_v;
    const radiusSquared = sphereShape.radius * sphereShape.radius;
    for (let i3 = 0; i3 < triangles.length; i3++) {
      for (let j = 0; j < 3; j++) {
        trimeshShape.getVertex(trimeshShape.indices[triangles[i3] * 3 + j], v);
        v.vsub(localSpherePos, relpos2);
        if (relpos2.lengthSquared() <= radiusSquared) {
          v23.copy(v);
          Transform.pointToWorldFrame(trimeshPos, trimeshQuat, v23, v);
          v.vsub(spherePos, relpos2);
          if (justTest) {
            return true;
          }
          let r = this.createContactEquation(sphereBody, trimeshBody, sphereShape, trimeshShape, rsi, rsj);
          r.ni.copy(relpos2);
          r.ni.normalize();
          r.ri.copy(r.ni);
          r.ri.scale(sphereShape.radius, r.ri);
          r.ri.vadd(spherePos, r.ri);
          r.ri.vsub(sphereBody.position, r.ri);
          r.rj.copy(v);
          r.rj.vsub(trimeshBody.position, r.rj);
          this.result.push(r);
          this.createFrictionEquationsFromContact(r, this.frictionResult);
        }
      }
    }
    for (let i3 = 0; i3 < triangles.length; i3++) {
      for (let j = 0; j < 3; j++) {
        trimeshShape.getVertex(trimeshShape.indices[triangles[i3] * 3 + j], edgeVertexA);
        trimeshShape.getVertex(trimeshShape.indices[triangles[i3] * 3 + (j + 1) % 3], edgeVertexB);
        edgeVertexB.vsub(edgeVertexA, edgeVector);
        localSpherePos.vsub(edgeVertexB, tmp2);
        const positionAlongEdgeB = tmp2.dot(edgeVector);
        localSpherePos.vsub(edgeVertexA, tmp2);
        let positionAlongEdgeA = tmp2.dot(edgeVector);
        if (positionAlongEdgeA > 0 && positionAlongEdgeB < 0) {
          localSpherePos.vsub(edgeVertexA, tmp2);
          edgeVectorUnit.copy(edgeVector);
          edgeVectorUnit.normalize();
          positionAlongEdgeA = tmp2.dot(edgeVectorUnit);
          edgeVectorUnit.scale(positionAlongEdgeA, tmp2);
          tmp2.vadd(edgeVertexA, tmp2);
          const dist = tmp2.distanceTo(localSpherePos);
          if (dist < sphereShape.radius) {
            if (justTest) {
              return true;
            }
            const r = this.createContactEquation(sphereBody, trimeshBody, sphereShape, trimeshShape, rsi, rsj);
            tmp2.vsub(localSpherePos, r.ni);
            r.ni.normalize();
            r.ni.scale(sphereShape.radius, r.ri);
            r.ri.vadd(spherePos, r.ri);
            r.ri.vsub(sphereBody.position, r.ri);
            Transform.pointToWorldFrame(trimeshPos, trimeshQuat, tmp2, tmp2);
            tmp2.vsub(trimeshBody.position, r.rj);
            Transform.vectorToWorldFrame(trimeshQuat, r.ni, r.ni);
            Transform.vectorToWorldFrame(trimeshQuat, r.ri, r.ri);
            this.result.push(r);
            this.createFrictionEquationsFromContact(r, this.frictionResult);
          }
        }
      }
    }
    const va2 = sphereTrimesh_va;
    const vb2 = sphereTrimesh_vb;
    const vc2 = sphereTrimesh_vc;
    const normal = sphereTrimesh_normal;
    for (let i3 = 0, N = triangles.length; i3 !== N; i3++) {
      trimeshShape.getTriangleVertices(triangles[i3], va2, vb2, vc2);
      trimeshShape.getNormal(triangles[i3], normal);
      localSpherePos.vsub(va2, tmp2);
      let dist = tmp2.dot(normal);
      normal.scale(dist, tmp2);
      localSpherePos.vsub(tmp2, tmp2);
      dist = tmp2.distanceTo(localSpherePos);
      if (Ray2.pointInTriangle(tmp2, va2, vb2, vc2) && dist < sphereShape.radius) {
        if (justTest) {
          return true;
        }
        let r = this.createContactEquation(sphereBody, trimeshBody, sphereShape, trimeshShape, rsi, rsj);
        tmp2.vsub(localSpherePos, r.ni);
        r.ni.normalize();
        r.ni.scale(sphereShape.radius, r.ri);
        r.ri.vadd(spherePos, r.ri);
        r.ri.vsub(sphereBody.position, r.ri);
        Transform.pointToWorldFrame(trimeshPos, trimeshQuat, tmp2, tmp2);
        tmp2.vsub(trimeshBody.position, r.rj);
        Transform.vectorToWorldFrame(trimeshQuat, r.ni, r.ni);
        Transform.vectorToWorldFrame(trimeshQuat, r.ri, r.ri);
        this.result.push(r);
        this.createFrictionEquationsFromContact(r, this.frictionResult);
      }
    }
    triangles.length = 0;
  }
  planeTrimesh(planeShape, trimeshShape, planePos, trimeshPos, planeQuat, trimeshQuat, planeBody, trimeshBody, rsi, rsj, justTest) {
    const v = new Vec3();
    const normal = planeTrimesh_normal;
    normal.set(0, 0, 1);
    planeQuat.vmult(normal, normal);
    for (let i3 = 0; i3 < trimeshShape.vertices.length / 3; i3++) {
      trimeshShape.getVertex(i3, v);
      const v23 = new Vec3();
      v23.copy(v);
      Transform.pointToWorldFrame(trimeshPos, trimeshQuat, v23, v);
      const relpos2 = planeTrimesh_relpos;
      v.vsub(planePos, relpos2);
      const dot = normal.dot(relpos2);
      if (dot <= 0) {
        if (justTest) {
          return true;
        }
        const r = this.createContactEquation(planeBody, trimeshBody, planeShape, trimeshShape, rsi, rsj);
        r.ni.copy(normal);
        const projected = planeTrimesh_projected;
        normal.scale(relpos2.dot(normal), projected);
        v.vsub(projected, projected);
        r.ri.copy(projected);
        r.ri.vsub(planeBody.position, r.ri);
        r.rj.copy(v);
        r.rj.vsub(trimeshBody.position, r.rj);
        this.result.push(r);
        this.createFrictionEquationsFromContact(r, this.frictionResult);
      }
    }
  }
  // convexTrimesh(
  //   si: ConvexPolyhedron, sj: Trimesh, xi: Vec3, xj: Vec3, qi: Quaternion, qj: Quaternion,
  //   bi: Body, bj: Body, rsi?: Shape | null, rsj?: Shape | null,
  //   faceListA?: number[] | null, faceListB?: number[] | null,
  // ) {
  //   const sepAxis = convexConvex_sepAxis;
  //   if(xi.distanceTo(xj) > si.boundingSphereRadius + sj.boundingSphereRadius){
  //       return;
  //   }
  //   // Construct a temp hull for each triangle
  //   const hullB = new ConvexPolyhedron();
  //   hullB.faces = [[0,1,2]];
  //   const va = new Vec3();
  //   const vb = new Vec3();
  //   const vc = new Vec3();
  //   hullB.vertices = [
  //       va,
  //       vb,
  //       vc
  //   ];
  //   for (let i = 0; i < sj.indices.length / 3; i++) {
  //       const triangleNormal = new Vec3();
  //       sj.getNormal(i, triangleNormal);
  //       hullB.faceNormals = [triangleNormal];
  //       sj.getTriangleVertices(i, va, vb, vc);
  //       let d = si.testSepAxis(triangleNormal, hullB, xi, qi, xj, qj);
  //       if(!d){
  //           triangleNormal.scale(-1, triangleNormal);
  //           d = si.testSepAxis(triangleNormal, hullB, xi, qi, xj, qj);
  //           if(!d){
  //               continue;
  //           }
  //       }
  //       const res: ConvexPolyhedronContactPoint[] = [];
  //       const q = convexConvex_q;
  //       si.clipAgainstHull(xi,qi,hullB,xj,qj,triangleNormal,-100,100,res);
  //       for(let j = 0; j !== res.length; j++){
  //           const r = this.createContactEquation(bi,bj,si,sj,rsi,rsj),
  //               ri = r.ri,
  //               rj = r.rj;
  //           r.ni.copy(triangleNormal);
  //           r.ni.negate(r.ni);
  //           res[j].normal.negate(q);
  //           q.mult(res[j].depth, q);
  //           res[j].point.vadd(q, ri);
  //           rj.copy(res[j].point);
  //           // Contact points are in world coordinates. Transform back to relative
  //           ri.vsub(xi,ri);
  //           rj.vsub(xj,rj);
  //           // Make relative to bodies
  //           ri.vadd(xi, ri);
  //           ri.vsub(bi.position, ri);
  //           rj.vadd(xj, rj);
  //           rj.vsub(bj.position, rj);
  //           result.push(r);
  //       }
  //   }
  // }
};
var averageNormal = new Vec3();
var averageContactPointA = new Vec3();
var averageContactPointB = new Vec3();
var tmpVec1 = new Vec3();
var tmpVec2 = new Vec3();
var tmpQuat1 = new Quaternion2();
var tmpQuat2 = new Quaternion2();
var planeTrimesh_normal = new Vec3();
var planeTrimesh_relpos = new Vec3();
var planeTrimesh_projected = new Vec3();
var sphereTrimesh_normal = new Vec3();
var sphereTrimesh_relpos = new Vec3();
new Vec3();
var sphereTrimesh_v = new Vec3();
var sphereTrimesh_v2 = new Vec3();
var sphereTrimesh_edgeVertexA = new Vec3();
var sphereTrimesh_edgeVertexB = new Vec3();
var sphereTrimesh_edgeVector = new Vec3();
var sphereTrimesh_edgeVectorUnit = new Vec3();
var sphereTrimesh_localSpherePos = new Vec3();
var sphereTrimesh_tmp = new Vec3();
var sphereTrimesh_va = new Vec3();
var sphereTrimesh_vb = new Vec3();
var sphereTrimesh_vc = new Vec3();
var sphereTrimesh_localSphereAABB = new AABB();
var sphereTrimesh_triangles = [];
var point_on_plane_to_sphere = new Vec3();
var plane_to_sphere_ortho = new Vec3();
var pointInPolygon_edge = new Vec3();
var pointInPolygon_edge_x_normal = new Vec3();
var pointInPolygon_vtp = new Vec3();
function pointInPolygon(verts, normal, p) {
  let positiveResult = null;
  const N = verts.length;
  for (let i3 = 0; i3 !== N; i3++) {
    const v = verts[i3];
    const edge = pointInPolygon_edge;
    verts[(i3 + 1) % N].vsub(v, edge);
    const edge_x_normal = pointInPolygon_edge_x_normal;
    edge.cross(normal, edge_x_normal);
    const vertex_to_p = pointInPolygon_vtp;
    p.vsub(v, vertex_to_p);
    const r = edge_x_normal.dot(vertex_to_p);
    if (positiveResult === null || r > 0 && positiveResult === true || r <= 0 && positiveResult === false) {
      if (positiveResult === null) {
        positiveResult = r > 0;
      }
      continue;
    } else {
      return false;
    }
  }
  return true;
}
var box_to_sphere = new Vec3();
var sphereBox_ns = new Vec3();
var sphereBox_ns1 = new Vec3();
var sphereBox_ns2 = new Vec3();
var sphereBox_sides = [new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3()];
var sphereBox_sphere_to_corner = new Vec3();
var sphereBox_side_ns = new Vec3();
var sphereBox_side_ns1 = new Vec3();
var sphereBox_side_ns2 = new Vec3();
var convex_to_sphere = new Vec3();
var sphereConvex_edge = new Vec3();
var sphereConvex_edgeUnit = new Vec3();
var sphereConvex_sphereToCorner = new Vec3();
var sphereConvex_worldCorner = new Vec3();
var sphereConvex_worldNormal = new Vec3();
var sphereConvex_worldPoint = new Vec3();
var sphereConvex_worldSpherePointClosestToPlane = new Vec3();
var sphereConvex_penetrationVec = new Vec3();
var sphereConvex_sphereToWorldPoint = new Vec3();
new Vec3();
new Vec3();
var planeConvex_v = new Vec3();
var planeConvex_normal = new Vec3();
var planeConvex_relpos = new Vec3();
var planeConvex_projected = new Vec3();
var convexConvex_sepAxis = new Vec3();
var convexConvex_q = new Vec3();
var particlePlane_normal = new Vec3();
var particlePlane_relpos = new Vec3();
var particlePlane_projected = new Vec3();
var particleSphere_normal = new Vec3();
var cqj = new Quaternion2();
var convexParticle_local = new Vec3();
new Vec3();
var convexParticle_penetratedFaceNormal = new Vec3();
var convexParticle_vertexToParticle = new Vec3();
var convexParticle_worldPenetrationVec = new Vec3();
var convexHeightfield_tmp1 = new Vec3();
var convexHeightfield_tmp2 = new Vec3();
var convexHeightfield_faceList = [0];
var sphereHeightfield_tmp1 = new Vec3();
var sphereHeightfield_tmp2 = new Vec3();
var OverlapKeeper = class {
  /**
   * @todo Remove useless constructor
   */
  constructor() {
    this.current = [];
    this.previous = [];
  }
  /**
   * getKey
   */
  getKey(i3, j) {
    if (j < i3) {
      const temp = j;
      j = i3;
      i3 = temp;
    }
    return i3 << 16 | j;
  }
  /**
   * set
   */
  set(i3, j) {
    const key = this.getKey(i3, j);
    const current = this.current;
    let index = 0;
    while (key > current[index]) {
      index++;
    }
    if (key === current[index]) {
      return;
    }
    for (let j2 = current.length - 1; j2 >= index; j2--) {
      current[j2 + 1] = current[j2];
    }
    current[index] = key;
  }
  /**
   * tick
   */
  tick() {
    const tmp2 = this.current;
    this.current = this.previous;
    this.previous = tmp2;
    this.current.length = 0;
  }
  /**
   * getDiff
   */
  getDiff(additions2, removals2) {
    const a4 = this.current;
    const b5 = this.previous;
    const al = a4.length;
    const bl = b5.length;
    let j = 0;
    for (let i3 = 0; i3 < al; i3++) {
      let found = false;
      const keyA = a4[i3];
      while (keyA > b5[j]) {
        j++;
      }
      found = keyA === b5[j];
      if (!found) {
        unpackAndPush(additions2, keyA);
      }
    }
    j = 0;
    for (let i3 = 0; i3 < bl; i3++) {
      let found = false;
      const keyB = b5[i3];
      while (keyB > a4[j]) {
        j++;
      }
      found = a4[j] === keyB;
      if (!found) {
        unpackAndPush(removals2, keyB);
      }
    }
  }
};
function unpackAndPush(array, key) {
  array.push((key & 4294901760) >> 16, key & 65535);
}
var getKey = (i3, j) => i3 < j ? `${i3}-${j}` : `${j}-${i3}`;
var TupleDictionary = class {
  constructor() {
    this.data = {
      keys: []
    };
  }
  /** get */
  get(i3, j) {
    const key = getKey(i3, j);
    return this.data[key];
  }
  /** set */
  set(i3, j, value) {
    const key = getKey(i3, j);
    if (!this.get(i3, j)) {
      this.data.keys.push(key);
    }
    this.data[key] = value;
  }
  /** delete */
  delete(i3, j) {
    const key = getKey(i3, j);
    const index = this.data.keys.indexOf(key);
    if (index !== -1) {
      this.data.keys.splice(index, 1);
    }
    delete this.data[key];
  }
  /** reset */
  reset() {
    const data = this.data;
    const keys = data.keys;
    while (keys.length > 0) {
      const key = keys.pop();
      delete data[key];
    }
  }
};
var World = class extends EventTarget {
  /**
   * Currently / last used timestep. Is set to -1 if not available. This value is updated before each internal step, which means that it is "fresh" inside event callbacks.
   */
  /**
   * Makes bodies go to sleep when they've been inactive.
   * @default false
   */
  /**
   * All the current contacts (instances of ContactEquation) in the world.
   */
  /**
   * How often to normalize quaternions. Set to 0 for every step, 1 for every second etc.. A larger value increases performance. If bodies tend to explode, set to a smaller value (zero to be sure nothing can go wrong).
   * @default 0
   */
  /**
   * Set to true to use fast quaternion normalization. It is often enough accurate to use.
   * If bodies tend to explode, set to false.
   * @default false
   */
  /**
   * The wall-clock time since simulation start.
   */
  /**
   * Number of timesteps taken since start.
   */
  /**
   * Default and last timestep sizes.
   */
  /**
   * The gravity of the world.
   */
  /**
   * Gravity to use when approximating the friction max force (mu*mass*gravity).
   * If undefined, global gravity will be used.
   * Use to enable friction in a World with a null gravity vector (no gravity).
   */
  /**
   * The broadphase algorithm to use.
   * @default NaiveBroadphase
   */
  /**
   * All bodies in this world
   */
  /**
   * True if any bodies are not sleeping, false if every body is sleeping.
   */
  /**
   * The solver algorithm to use.
   * @default GSSolver
   */
  /**
   * collisionMatrix
   */
  /**
   * CollisionMatrix from the previous step.
   */
  /**
   * All added contactmaterials.
   */
  /**
   * Used to look up a ContactMaterial given two instances of Material.
   */
  /**
   * The default material of the bodies.
   */
  /**
   * This contact material is used if no suitable contactmaterial is found for a contact.
   */
  /**
   * Time accumulator for interpolation.
   * @see https://gafferongames.com/game-physics/fix-your-timestep/
   */
  /**
   * Dispatched after a body has been added to the world.
   */
  /**
   * Dispatched after a body has been removed from the world.
   */
  constructor(options) {
    if (options === void 0) {
      options = {};
    }
    super();
    this.dt = -1;
    this.allowSleep = !!options.allowSleep;
    this.contacts = [];
    this.frictionEquations = [];
    this.quatNormalizeSkip = options.quatNormalizeSkip !== void 0 ? options.quatNormalizeSkip : 0;
    this.quatNormalizeFast = options.quatNormalizeFast !== void 0 ? options.quatNormalizeFast : false;
    this.time = 0;
    this.stepnumber = 0;
    this.default_dt = 1 / 60;
    this.nextId = 0;
    this.gravity = new Vec3();
    if (options.gravity) {
      this.gravity.copy(options.gravity);
    }
    if (options.frictionGravity) {
      this.frictionGravity = new Vec3();
      this.frictionGravity.copy(options.frictionGravity);
    }
    this.broadphase = options.broadphase !== void 0 ? options.broadphase : new NaiveBroadphase();
    this.bodies = [];
    this.hasActiveBodies = false;
    this.solver = options.solver !== void 0 ? options.solver : new GSSolver();
    this.constraints = [];
    this.narrowphase = new Narrowphase(this);
    this.collisionMatrix = new ArrayCollisionMatrix();
    this.collisionMatrixPrevious = new ArrayCollisionMatrix();
    this.bodyOverlapKeeper = new OverlapKeeper();
    this.shapeOverlapKeeper = new OverlapKeeper();
    this.contactmaterials = [];
    this.contactMaterialTable = new TupleDictionary();
    this.defaultMaterial = new Material2("default");
    this.defaultContactMaterial = new ContactMaterial(this.defaultMaterial, this.defaultMaterial, {
      friction: 0.3,
      restitution: 0
    });
    this.doProfiling = false;
    this.profile = {
      solve: 0,
      makeContactConstraints: 0,
      broadphase: 0,
      integrate: 0,
      narrowphase: 0
    };
    this.accumulator = 0;
    this.subsystems = [];
    this.addBodyEvent = {
      type: "addBody",
      body: null
    };
    this.removeBodyEvent = {
      type: "removeBody",
      body: null
    };
    this.idToBodyMap = {};
    this.broadphase.setWorld(this);
  }
  /**
   * Get the contact material between materials m1 and m2
   * @return The contact material if it was found.
   */
  getContactMaterial(m1, m2) {
    return this.contactMaterialTable.get(m1.id, m2.id);
  }
  /**
   * Store old collision state info
   */
  collisionMatrixTick() {
    const temp = this.collisionMatrixPrevious;
    this.collisionMatrixPrevious = this.collisionMatrix;
    this.collisionMatrix = temp;
    this.collisionMatrix.reset();
    this.bodyOverlapKeeper.tick();
    this.shapeOverlapKeeper.tick();
  }
  /**
   * Add a constraint to the simulation.
   */
  addConstraint(c3) {
    this.constraints.push(c3);
  }
  /**
   * Removes a constraint
   */
  removeConstraint(c3) {
    const idx = this.constraints.indexOf(c3);
    if (idx !== -1) {
      this.constraints.splice(idx, 1);
    }
  }
  /**
   * Raycast test
   * @deprecated Use .raycastAll, .raycastClosest or .raycastAny instead.
   */
  rayTest(from, to, result) {
    if (result instanceof RaycastResult) {
      this.raycastClosest(from, to, {
        skipBackfaces: true
      }, result);
    } else {
      this.raycastAll(from, to, {
        skipBackfaces: true
      }, result);
    }
  }
  /**
   * Ray cast against all bodies. The provided callback will be executed for each hit with a RaycastResult as single argument.
   * @return True if any body was hit.
   */
  raycastAll(from, to, options, callback) {
    if (options === void 0) {
      options = {};
    }
    options.mode = Ray2.ALL;
    options.from = from;
    options.to = to;
    options.callback = callback;
    return tmpRay.intersectWorld(this, options);
  }
  /**
   * Ray cast, and stop at the first result. Note that the order is random - but the method is fast.
   * @return True if any body was hit.
   */
  raycastAny(from, to, options, result) {
    if (options === void 0) {
      options = {};
    }
    options.mode = Ray2.ANY;
    options.from = from;
    options.to = to;
    options.result = result;
    return tmpRay.intersectWorld(this, options);
  }
  /**
   * Ray cast, and return information of the closest hit.
   * @return True if any body was hit.
   */
  raycastClosest(from, to, options, result) {
    if (options === void 0) {
      options = {};
    }
    options.mode = Ray2.CLOSEST;
    options.from = from;
    options.to = to;
    options.result = result;
    return tmpRay.intersectWorld(this, options);
  }
  /**
   * Add a rigid body to the simulation.
   * @todo If the simulation has not yet started, why recrete and copy arrays for each body? Accumulate in dynamic arrays in this case.
   * @todo Adding an array of bodies should be possible. This would save some loops too
   */
  addBody(body) {
    if (this.bodies.includes(body)) {
      return;
    }
    body.index = this.bodies.length;
    this.bodies.push(body);
    body.world = this;
    body.initPosition.copy(body.position);
    body.initVelocity.copy(body.velocity);
    body.timeLastSleepy = this.time;
    if (body instanceof Body) {
      body.initAngularVelocity.copy(body.angularVelocity);
      body.initQuaternion.copy(body.quaternion);
    }
    this.collisionMatrix.setNumObjects(this.bodies.length);
    this.addBodyEvent.body = body;
    this.idToBodyMap[body.id] = body;
    this.dispatchEvent(this.addBodyEvent);
  }
  /**
   * Remove a rigid body from the simulation.
   */
  removeBody(body) {
    body.world = null;
    const n = this.bodies.length - 1;
    const bodies = this.bodies;
    const idx = bodies.indexOf(body);
    if (idx !== -1) {
      bodies.splice(idx, 1);
      for (let i3 = 0; i3 !== bodies.length; i3++) {
        bodies[i3].index = i3;
      }
      this.collisionMatrix.setNumObjects(n);
      this.removeBodyEvent.body = body;
      delete this.idToBodyMap[body.id];
      this.dispatchEvent(this.removeBodyEvent);
    }
  }
  getBodyById(id) {
    return this.idToBodyMap[id];
  }
  /**
   * @todo Make a faster map
   */
  getShapeById(id) {
    const bodies = this.bodies;
    for (let i3 = 0; i3 < bodies.length; i3++) {
      const shapes = bodies[i3].shapes;
      for (let j = 0; j < shapes.length; j++) {
        const shape = shapes[j];
        if (shape.id === id) {
          return shape;
        }
      }
    }
    return null;
  }
  /**
   * Adds a contact material to the World
   */
  addContactMaterial(cmat) {
    this.contactmaterials.push(cmat);
    this.contactMaterialTable.set(cmat.materials[0].id, cmat.materials[1].id, cmat);
  }
  /**
   * Removes a contact material from the World.
   */
  removeContactMaterial(cmat) {
    const idx = this.contactmaterials.indexOf(cmat);
    if (idx === -1) {
      return;
    }
    this.contactmaterials.splice(idx, 1);
    this.contactMaterialTable.delete(cmat.materials[0].id, cmat.materials[1].id);
  }
  /**
   * Step the simulation forward keeping track of last called time
   * to be able to step the world at a fixed rate, independently of framerate.
   *
   * @param dt The fixed time step size to use (default: 1 / 60).
   * @param maxSubSteps Maximum number of fixed steps to take per function call (default: 10).
   * @see https://gafferongames.com/post/fix_your_timestep/
   * @example
   *     // Run the simulation independently of framerate every 1 / 60 ms
   *     world.fixedStep()
   */
  fixedStep(dt, maxSubSteps) {
    if (dt === void 0) {
      dt = 1 / 60;
    }
    if (maxSubSteps === void 0) {
      maxSubSteps = 10;
    }
    const time = performance2.now() / 1e3;
    if (!this.lastCallTime) {
      this.step(dt, void 0, maxSubSteps);
    } else {
      const timeSinceLastCalled = time - this.lastCallTime;
      this.step(dt, timeSinceLastCalled, maxSubSteps);
    }
    this.lastCallTime = time;
  }
  /**
   * Step the physics world forward in time.
   *
   * There are two modes. The simple mode is fixed timestepping without interpolation. In this case you only use the first argument. The second case uses interpolation. In that you also provide the time since the function was last used, as well as the maximum fixed timesteps to take.
   *
   * @param dt The fixed time step size to use.
   * @param timeSinceLastCalled The time elapsed since the function was last called.
   * @param maxSubSteps Maximum number of fixed steps to take per function call (default: 10).
   * @see https://web.archive.org/web/20180426154531/http://bulletphysics.org/mediawiki-1.5.8/index.php/Stepping_The_World#What_do_the_parameters_to_btDynamicsWorld::stepSimulation_mean.3F
   * @example
   *     // fixed timestepping without interpolation
   *     world.step(1 / 60)
   */
  step(dt, timeSinceLastCalled, maxSubSteps) {
    if (maxSubSteps === void 0) {
      maxSubSteps = 10;
    }
    if (timeSinceLastCalled === void 0) {
      this.internalStep(dt);
      this.time += dt;
    } else {
      this.accumulator += timeSinceLastCalled;
      const t0 = performance2.now();
      let substeps = 0;
      while (this.accumulator >= dt && substeps < maxSubSteps) {
        this.internalStep(dt);
        this.accumulator -= dt;
        substeps++;
        if (performance2.now() - t0 > dt * 1e3) {
          break;
        }
      }
      this.accumulator = this.accumulator % dt;
      const t2 = this.accumulator / dt;
      for (let j = 0; j !== this.bodies.length; j++) {
        const b5 = this.bodies[j];
        b5.previousPosition.lerp(b5.position, t2, b5.interpolatedPosition);
        b5.previousQuaternion.slerp(b5.quaternion, t2, b5.interpolatedQuaternion);
        b5.previousQuaternion.normalize();
      }
      this.time += timeSinceLastCalled;
    }
  }
  internalStep(dt) {
    this.dt = dt;
    const contacts = this.contacts;
    const p1 = World_step_p1;
    const p2 = World_step_p2;
    const N = this.bodies.length;
    const bodies = this.bodies;
    const solver = this.solver;
    const gravity = this.gravity;
    const doProfiling = this.doProfiling;
    const profile = this.profile;
    const DYNAMIC = Body.DYNAMIC;
    let profilingStart = -Infinity;
    const constraints = this.constraints;
    const frictionEquationPool = World_step_frictionEquationPool;
    gravity.length();
    const gx = gravity.x;
    const gy = gravity.y;
    const gz = gravity.z;
    let i3 = 0;
    if (doProfiling) {
      profilingStart = performance2.now();
    }
    for (i3 = 0; i3 !== N; i3++) {
      const bi = bodies[i3];
      if (bi.type === DYNAMIC) {
        const f = bi.force;
        const m = bi.mass;
        f.x += m * gx;
        f.y += m * gy;
        f.z += m * gz;
      }
    }
    for (let i4 = 0, Nsubsystems = this.subsystems.length; i4 !== Nsubsystems; i4++) {
      this.subsystems[i4].update();
    }
    if (doProfiling) {
      profilingStart = performance2.now();
    }
    p1.length = 0;
    p2.length = 0;
    this.broadphase.collisionPairs(this, p1, p2);
    if (doProfiling) {
      profile.broadphase = performance2.now() - profilingStart;
    }
    let Nconstraints = constraints.length;
    for (i3 = 0; i3 !== Nconstraints; i3++) {
      const c3 = constraints[i3];
      if (!c3.collideConnected) {
        for (let j = p1.length - 1; j >= 0; j -= 1) {
          if (c3.bodyA === p1[j] && c3.bodyB === p2[j] || c3.bodyB === p1[j] && c3.bodyA === p2[j]) {
            p1.splice(j, 1);
            p2.splice(j, 1);
          }
        }
      }
    }
    this.collisionMatrixTick();
    if (doProfiling) {
      profilingStart = performance2.now();
    }
    const oldcontacts = World_step_oldContacts;
    const NoldContacts = contacts.length;
    for (i3 = 0; i3 !== NoldContacts; i3++) {
      oldcontacts.push(contacts[i3]);
    }
    contacts.length = 0;
    const NoldFrictionEquations = this.frictionEquations.length;
    for (i3 = 0; i3 !== NoldFrictionEquations; i3++) {
      frictionEquationPool.push(this.frictionEquations[i3]);
    }
    this.frictionEquations.length = 0;
    this.narrowphase.getContacts(
      p1,
      p2,
      this,
      contacts,
      oldcontacts,
      // To be reused
      this.frictionEquations,
      frictionEquationPool
    );
    if (doProfiling) {
      profile.narrowphase = performance2.now() - profilingStart;
    }
    if (doProfiling) {
      profilingStart = performance2.now();
    }
    for (i3 = 0; i3 < this.frictionEquations.length; i3++) {
      solver.addEquation(this.frictionEquations[i3]);
    }
    const ncontacts = contacts.length;
    for (let k = 0; k !== ncontacts; k++) {
      const c3 = contacts[k];
      const bi = c3.bi;
      const bj = c3.bj;
      const si = c3.si;
      const sj = c3.sj;
      let cm;
      if (bi.material && bj.material) {
        cm = this.getContactMaterial(bi.material, bj.material) || this.defaultContactMaterial;
      } else {
        cm = this.defaultContactMaterial;
      }
      cm.friction;
      if (bi.material && bj.material) {
        if (bi.material.friction >= 0 && bj.material.friction >= 0) {
          bi.material.friction * bj.material.friction;
        }
        if (bi.material.restitution >= 0 && bj.material.restitution >= 0) {
          c3.restitution = bi.material.restitution * bj.material.restitution;
        }
      }
      solver.addEquation(c3);
      if (bi.allowSleep && bi.type === Body.DYNAMIC && bi.sleepState === Body.SLEEPING && bj.sleepState === Body.AWAKE && bj.type !== Body.STATIC) {
        const speedSquaredB = bj.velocity.lengthSquared() + bj.angularVelocity.lengthSquared();
        const speedLimitSquaredB = bj.sleepSpeedLimit ** 2;
        if (speedSquaredB >= speedLimitSquaredB * 2) {
          bi.wakeUpAfterNarrowphase = true;
        }
      }
      if (bj.allowSleep && bj.type === Body.DYNAMIC && bj.sleepState === Body.SLEEPING && bi.sleepState === Body.AWAKE && bi.type !== Body.STATIC) {
        const speedSquaredA = bi.velocity.lengthSquared() + bi.angularVelocity.lengthSquared();
        const speedLimitSquaredA = bi.sleepSpeedLimit ** 2;
        if (speedSquaredA >= speedLimitSquaredA * 2) {
          bj.wakeUpAfterNarrowphase = true;
        }
      }
      this.collisionMatrix.set(bi, bj, true);
      if (!this.collisionMatrixPrevious.get(bi, bj)) {
        World_step_collideEvent.body = bj;
        World_step_collideEvent.contact = c3;
        bi.dispatchEvent(World_step_collideEvent);
        World_step_collideEvent.body = bi;
        bj.dispatchEvent(World_step_collideEvent);
      }
      this.bodyOverlapKeeper.set(bi.id, bj.id);
      this.shapeOverlapKeeper.set(si.id, sj.id);
    }
    this.emitContactEvents();
    if (doProfiling) {
      profile.makeContactConstraints = performance2.now() - profilingStart;
      profilingStart = performance2.now();
    }
    for (i3 = 0; i3 !== N; i3++) {
      const bi = bodies[i3];
      if (bi.wakeUpAfterNarrowphase) {
        bi.wakeUp();
        bi.wakeUpAfterNarrowphase = false;
      }
    }
    Nconstraints = constraints.length;
    for (i3 = 0; i3 !== Nconstraints; i3++) {
      const c3 = constraints[i3];
      c3.update();
      for (let j = 0, Neq = c3.equations.length; j !== Neq; j++) {
        const eq = c3.equations[j];
        solver.addEquation(eq);
      }
    }
    solver.solve(dt, this);
    if (doProfiling) {
      profile.solve = performance2.now() - profilingStart;
    }
    solver.removeAllEquations();
    const pow = Math.pow;
    for (i3 = 0; i3 !== N; i3++) {
      const bi = bodies[i3];
      if (bi.type & DYNAMIC) {
        const ld = pow(1 - bi.linearDamping, dt);
        const v = bi.velocity;
        v.scale(ld, v);
        const av = bi.angularVelocity;
        if (av) {
          const ad = pow(1 - bi.angularDamping, dt);
          av.scale(ad, av);
        }
      }
    }
    this.dispatchEvent(World_step_preStepEvent);
    if (doProfiling) {
      profilingStart = performance2.now();
    }
    const stepnumber = this.stepnumber;
    const quatNormalize = stepnumber % (this.quatNormalizeSkip + 1) === 0;
    const quatNormalizeFast = this.quatNormalizeFast;
    for (i3 = 0; i3 !== N; i3++) {
      bodies[i3].integrate(dt, quatNormalize, quatNormalizeFast);
    }
    this.clearForces();
    this.broadphase.dirty = true;
    if (doProfiling) {
      profile.integrate = performance2.now() - profilingStart;
    }
    this.stepnumber += 1;
    this.dispatchEvent(World_step_postStepEvent);
    let hasActiveBodies = true;
    if (this.allowSleep) {
      hasActiveBodies = false;
      for (i3 = 0; i3 !== N; i3++) {
        const bi = bodies[i3];
        bi.sleepTick(this.time);
        if (bi.sleepState !== Body.SLEEPING) {
          hasActiveBodies = true;
        }
      }
    }
    this.hasActiveBodies = hasActiveBodies;
  }
  emitContactEvents() {
    const hasBeginContact = this.hasAnyEventListener("beginContact");
    const hasEndContact = this.hasAnyEventListener("endContact");
    if (hasBeginContact || hasEndContact) {
      this.bodyOverlapKeeper.getDiff(additions, removals);
    }
    if (hasBeginContact) {
      for (let i3 = 0, l = additions.length; i3 < l; i3 += 2) {
        beginContactEvent.bodyA = this.getBodyById(additions[i3]);
        beginContactEvent.bodyB = this.getBodyById(additions[i3 + 1]);
        this.dispatchEvent(beginContactEvent);
      }
      beginContactEvent.bodyA = beginContactEvent.bodyB = null;
    }
    if (hasEndContact) {
      for (let i3 = 0, l = removals.length; i3 < l; i3 += 2) {
        endContactEvent.bodyA = this.getBodyById(removals[i3]);
        endContactEvent.bodyB = this.getBodyById(removals[i3 + 1]);
        this.dispatchEvent(endContactEvent);
      }
      endContactEvent.bodyA = endContactEvent.bodyB = null;
    }
    additions.length = removals.length = 0;
    const hasBeginShapeContact = this.hasAnyEventListener("beginShapeContact");
    const hasEndShapeContact = this.hasAnyEventListener("endShapeContact");
    if (hasBeginShapeContact || hasEndShapeContact) {
      this.shapeOverlapKeeper.getDiff(additions, removals);
    }
    if (hasBeginShapeContact) {
      for (let i3 = 0, l = additions.length; i3 < l; i3 += 2) {
        const shapeA = this.getShapeById(additions[i3]);
        const shapeB = this.getShapeById(additions[i3 + 1]);
        beginShapeContactEvent.shapeA = shapeA;
        beginShapeContactEvent.shapeB = shapeB;
        if (shapeA)
          beginShapeContactEvent.bodyA = shapeA.body;
        if (shapeB)
          beginShapeContactEvent.bodyB = shapeB.body;
        this.dispatchEvent(beginShapeContactEvent);
      }
      beginShapeContactEvent.bodyA = beginShapeContactEvent.bodyB = beginShapeContactEvent.shapeA = beginShapeContactEvent.shapeB = null;
    }
    if (hasEndShapeContact) {
      for (let i3 = 0, l = removals.length; i3 < l; i3 += 2) {
        const shapeA = this.getShapeById(removals[i3]);
        const shapeB = this.getShapeById(removals[i3 + 1]);
        endShapeContactEvent.shapeA = shapeA;
        endShapeContactEvent.shapeB = shapeB;
        if (shapeA)
          endShapeContactEvent.bodyA = shapeA.body;
        if (shapeB)
          endShapeContactEvent.bodyB = shapeB.body;
        this.dispatchEvent(endShapeContactEvent);
      }
      endShapeContactEvent.bodyA = endShapeContactEvent.bodyB = endShapeContactEvent.shapeA = endShapeContactEvent.shapeB = null;
    }
  }
  /**
   * Sets all body forces in the world to zero.
   */
  clearForces() {
    const bodies = this.bodies;
    const N = bodies.length;
    for (let i3 = 0; i3 !== N; i3++) {
      const b5 = bodies[i3];
      b5.force;
      b5.torque;
      b5.force.set(0, 0, 0);
      b5.torque.set(0, 0, 0);
    }
  }
};
new AABB();
var tmpRay = new Ray2();
var performance2 = globalThis.performance || {};
if (!performance2.now) {
  let nowOffset = Date.now();
  if (performance2.timing && performance2.timing.navigationStart) {
    nowOffset = performance2.timing.navigationStart;
  }
  performance2.now = () => Date.now() - nowOffset;
}
new Vec3();
var World_step_postStepEvent = {
  type: "postStep"
};
var World_step_preStepEvent = {
  type: "preStep"
};
var World_step_collideEvent = {
  type: Body.COLLIDE_EVENT_NAME,
  body: null,
  contact: null
};
var World_step_oldContacts = [];
var World_step_frictionEquationPool = [];
var World_step_p1 = [];
var World_step_p2 = [];
var additions = [];
var removals = [];
var beginContactEvent = {
  type: "beginContact",
  bodyA: null,
  bodyB: null
};
var endContactEvent = {
  type: "endContact",
  bodyA: null,
  bodyB: null
};
var beginShapeContactEvent = {
  type: "beginShapeContact",
  bodyA: null,
  bodyB: null,
  shapeA: null,
  shapeB: null
};
var endShapeContactEvent = {
  type: "endShapeContact",
  bodyA: null,
  bodyB: null,
  shapeA: null,
  shapeB: null
};

// node_modules/kokomi.js/dist/utils/cannon.js
var convertGeometryToShape = (geometry2) => {
  switch (geometry2.type) {
    case "BoxGeometry":
    case "BoxBufferGeometry": {
      const { width = 1, height = 1, depth = 1 } = geometry2.parameters;
      const halfExtents = new Vec3(width / 2, height / 2, depth / 2);
      return new Box(halfExtents);
    }
    case "PlaneGeometry":
    case "PlaneBufferGeometry": {
      return new Plane2();
    }
    case "SphereGeometry":
    case "SphereBufferGeometry": {
      const { radius } = geometry2.parameters;
      return new Sphere2(radius);
    }
    case "CylinderGeometry":
    case "CylinderBufferGeometry": {
      const { radiusTop, radiusBottom, height, radialSegments } = geometry2.parameters;
      return new Cylinder(radiusTop, radiusBottom, height, radialSegments);
    }
    default: {
      let geo = new BufferGeometry();
      geo.setAttribute("position", geometry2.getAttribute("position"));
      geo = mergeVertices(geo);
      const position = geo.attributes.position.array;
      const index = geo.index.array;
      const points = [];
      for (let i3 = 0; i3 < position.length; i3 += 3) {
        points.push(new Vec3(position[i3], position[i3 + 1], position[i3 + 2]));
      }
      const faces = [];
      for (let i3 = 0; i3 < index.length; i3 += 3) {
        faces.push([index[i3], index[i3 + 1], index[i3 + 2]]);
      }
      return new ConvexPolyhedron({ vertices: points, faces });
    }
  }
};

// node_modules/kokomi.js/dist/utils/dom.js
var import_imagesloaded = __toESM(require_imagesloaded());
var preloadImages = (sel = "div") => {
  return new Promise((resolve) => {
    (0, import_imagesloaded.default)(sel, { background: true }, resolve);
  });
};
var sleep = (time) => new Promise((resolve) => setTimeout(resolve, time));
var preventDefaultAndStopBubble = (e) => {
  e.preventDefault();
  e.stopPropagation();
};
var detectDeviceType = () => {
  return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ? "Mobile" : "Desktop";
};

// node_modules/kokomi.js/dist/utils/gl.js
var makeBuffer = (count = 100, fn, dimension = 3) => {
  const buffer = Float32Array.from({ length: count * dimension }, (v, k) => {
    return fn(k);
  });
  return buffer;
};
var iterateBuffer = (buffer, count, fn, dimension = 3) => {
  for (let i3 = 0; i3 < count; i3++) {
    const axis = i3 * dimension;
    const x = axis;
    const y = axis + 1;
    const z = axis + 2;
    const w = axis + 3;
    fn(buffer, { x, y, z, w }, i3);
  }
};
var convertBufferAttributeToVector = (bufferAttribute, dimension = 3) => {
  const vectorDimensionMap = {
    2: new Vector2(),
    3: new Vector3(),
    4: new Vector4()
  };
  const vectors = Array.from({ length: bufferAttribute.array.length / dimension }, (v, k) => {
    const vector = vectorDimensionMap[dimension].clone();
    return vector.fromBufferAttribute(bufferAttribute, k);
  });
  return vectors;
};
var isVector = (v) => v instanceof Vector2 || v instanceof Vector3 || v instanceof Vector4;
var normalizeVector = (v) => {
  if (Array.isArray(v))
    return v;
  else if (isVector(v))
    return v.toArray();
  return [v, v, v];
};
var isFloat32Array = (def) => def && def.constructor === Float32Array;
var expandColor = (v) => [v.r, v.g, v.b];
var usePropAsIsOrAsAttribute = (count, prop, setDefault) => {
  if (prop !== void 0) {
    if (isFloat32Array(prop)) {
      return prop;
    } else {
      if (prop instanceof Color) {
        const a4 = Array.from({ length: count * 3 }, () => expandColor(prop)).flat();
        return Float32Array.from(a4);
      } else if (isVector(prop) || Array.isArray(prop)) {
        const a4 = Array.from({ length: count * 3 }, () => normalizeVector(prop)).flat();
        return Float32Array.from(a4);
      }
      return Float32Array.from({ length: count }, () => prop);
    }
  }
  return Float32Array.from({ length: count }, setDefault);
};

// node_modules/kokomi.js/dist/utils/load.js
var loadVideoTexture = (src, options = {}) => {
  const { unsuspend = "loadedmetadata", crossOrigin = "Anonymous", loop = true, muted = true, start = true } = options;
  return new Promise((resolve) => {
    const video = Object.assign(document.createElement("video"), {
      src,
      crossOrigin,
      loop,
      muted,
      ...options
    });
    const texture = new VideoTexture(video);
    video.addEventListener(unsuspend, () => {
      if (start) {
        texture.image.play();
      }
      resolve(texture);
    });
  });
};
var dracoLoader = null;
var loadGLTF = (path, config3 = {}) => {
  const { useDraco = true } = config3;
  return new Promise((resolve) => {
    const loader = new GLTFLoader();
    if (useDraco) {
      dracoLoader = new DRACOLoader();
      dracoLoader.setDecoderPath(typeof useDraco === "string" ? useDraco : "https://www.gstatic.com/draco/versioned/decoders/1.4.3/");
      loader.setDRACOLoader(dracoLoader);
    }
    loader.load(path, (file) => {
      resolve(file);
    }, () => {
    }, () => {
      resolve(null);
    });
  });
};
var loadFBX = (path) => {
  return new Promise((resolve) => {
    const loader = new FBXLoader();
    loader.load(path, (file) => {
      resolve(file);
    }, () => {
    }, () => {
      resolve(null);
    });
  });
};
var loadHDR = (path) => {
  return new Promise((resolve) => {
    const loader = new RGBELoader();
    loader.load(path, (file) => {
      resolve(file);
    }, () => {
    }, () => {
      resolve(null);
    });
  });
};

// node_modules/kokomi.js/dist/utils/math.js
var saturate = (value) => MathUtils.clamp(value, 0, 1);
var polySort = (pointObjs) => {
  const squaredPolar = (point, centre2) => {
    return [
      Math.atan2(point[1] - centre2[1], point[0] - centre2[0]),
      (point[0] - centre2[0]) ** 2 + (point[1] - centre2[1]) ** 2
      // Square of distance
    ];
  };
  const points = pointObjs.map((item) => [item.x, item.y]);
  let centre = [
    points.reduce((sum, p) => sum + p[0], 0) / points.length,
    points.reduce((sum, p) => sum + p[1], 0) / points.length
  ];
  for (let point of points)
    point.push(...squaredPolar(point, centre));
  points.sort((a4, b5) => a4[2] - b5[2] || a4[3] - b5[3]);
  for (let point of points)
    point.length -= 2;
  const pointsResult = points.map((item) => ({
    x: item[0],
    y: item[1]
  }));
  return pointsResult;
};
var sample = (arr) => arr[Math.floor(Math.random() * arr.length)];
var range = function* (start, end, step = 1) {
  let i3 = start;
  while (i3 < end) {
    yield i3;
    i3 += step;
  }
};

// node_modules/kokomi.js/dist/utils/misc.js
var optimizeModelRender = (renderer) => {
  renderer.outputEncoding = sRGBEncoding;
  renderer.toneMapping = ACESFilmicToneMapping;
};
var enableRealisticRender = (renderer) => {
  renderer.outputEncoding = sRGBEncoding;
  renderer.toneMapping = ReinhardToneMapping;
  renderer.toneMappingExposure = 3;
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = PCFSoftShadowMap;
  renderer.physicallyCorrectLights = true;
};
var beautifyRender = (renderer) => {
  optimizeModelRender(renderer);
};
var enableShadow = (renderer) => {
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = PCFSoftShadowMap;
};
var getEnvmapFromHDRTexture = (renderer, texture) => {
  const pmremGenerator = new PMREMGenerator(renderer);
  pmremGenerator.compileEquirectangularShader();
  const envmap = pmremGenerator.fromEquirectangular(texture).texture;
  pmremGenerator.dispose();
  return envmap;
};
var getEnvmapFromScene = (renderer, scene) => {
  const pmremGenerator = new PMREMGenerator(renderer);
  const envmap = pmremGenerator.fromScene(scene).texture;
  return envmap;
};
var getBaryCoord = (bufferGeometry) => {
  const length = bufferGeometry.attributes.position.array.length;
  const count = length / 3;
  const bary = [];
  for (let i3 = 0; i3 < count; i3++) {
    bary.push(0, 0, 1, 0, 1, 0, 1, 0, 0);
  }
  const aCenter = new Float32Array(bary);
  bufferGeometry.setAttribute("aCenter", new BufferAttribute(aCenter, 3));
};
var sampleParticlesPositionFromMesh = (geometry2, count = 1e4) => {
  const material2 = new MeshBasicMaterial();
  const mesh = new Mesh(geometry2, material2);
  const sampler = new MeshSurfaceSampler(mesh).build();
  const particlesPosition = new Float32Array(count * 3);
  for (let i3 = 0; i3 < count; i3++) {
    const position = new Vector3();
    sampler.sample(position);
    particlesPosition.set([position.x, position.y, position.z], i3 * 3);
  }
  return particlesPosition;
};
var flatModel = (model) => {
  const modelPartsArray = [];
  model.traverse((obj) => {
    modelPartsArray.push(obj);
  });
  return modelPartsArray;
};
var printModel = (modelParts, modelName = "modelParts") => {
  const strArray = modelParts.map((obj, i3) => {
    const row = `const ${obj.name} = ${modelName}[${i3}];`;
    return row;
  });
  const str = strArray.join("\n");
  console.log(str);
  return str;
};
var getViewport = (camera) => {
  const position = new Vector3();
  const target = new Vector3();
  const distance2 = camera.getWorldPosition(position).distanceTo(target);
  const fov = camera.fov * Math.PI / 180;
  const h = 2 * Math.tan(fov / 2) * distance2;
  const w = h * (window.innerWidth / window.innerHeight);
  const viewport = { width: w, height: h };
  return viewport;
};
var getPositionCentroids = (geometry2, attrName = "position", centroidName = "aCenter") => {
  const position = geometry2.attributes[attrName];
  const posCount = position.count;
  const posBuffer = position.array;
  const centroidBuffer = makeBuffer(posCount, (val) => val);
  for (let i3 = 0; i3 < posCount; i3 += 3) {
    let x = posBuffer[i3 * 3];
    let y = posBuffer[i3 * 3 + 1];
    let z = posBuffer[i3 * 3 + 2];
    let x1 = posBuffer[i3 * 3 + 3];
    let y1 = posBuffer[i3 * 3 + 4];
    let z1 = posBuffer[i3 * 3 + 5];
    let x2 = posBuffer[i3 * 3 + 6];
    let y2 = posBuffer[i3 * 3 + 7];
    let z2 = posBuffer[i3 * 3 + 8];
    const centroid = new Vector3().add(new Vector3(x, y, z)).add(new Vector3(x1, y1, z1)).add(new Vector3(x2, y2, z2)).divideScalar(3);
    centroidBuffer.set([centroid.x, centroid.y, centroid.z], i3 * 3);
    centroidBuffer.set([centroid.x, centroid.y, centroid.z], (i3 + 1) * 3);
    centroidBuffer.set([centroid.x, centroid.y, centroid.z], (i3 + 2) * 3);
  }
  geometry2.setAttribute(centroidName, new BufferAttribute(centroidBuffer, 3));
  return centroidBuffer;
};
var createPolygonShape = (points, config3 = {}) => {
  const shape = new Shape();
  const { scale = 1 } = config3;
  const firstPoint = points[0];
  for (let i3 = 0; i3 < points.length; i3++) {
    const point = points[i3];
    const x = (point.x - firstPoint.x) * scale;
    const y = (point.y - firstPoint.y) * -1 * scale;
    if (i3 === 0) {
      shape.moveTo(x, y);
    } else {
      shape.lineTo(x, y);
    }
  }
  return shape;
};
var calcPerspectiveScreenSize = (targetZ = 0, camera, aspect) => {
  let screenWidth = 1;
  let screenHeight = 1;
  const fovRadian = MathUtils.degToRad(camera.fov / 2);
  screenHeight = (camera.position.z - targetZ) * Math.tan(fovRadian) * 2;
  screenWidth = screenHeight * aspect;
  return { width: screenWidth, height: screenHeight };
};
var downloadBlob = (blob, name) => {
  const a4 = document.createElement("a");
  document.body.appendChild(a4);
  a4.style.display = "none";
  const url = window.URL.createObjectURL(blob);
  a4.href = url;
  a4.download = name;
  a4.click();
};
var getBound = (object, precise = true) => {
  const box3 = new Box3().setFromObject(object, precise);
  const center2 = new Vector3();
  const sphere = new Sphere();
  box3.getCenter(center2);
  box3.getBoundingSphere(sphere);
  const width = box3.max.x - box3.min.x;
  const height = box3.max.y - box3.min.y;
  const depth = box3.max.z - box3.min.z;
  return {
    boundingBox: box3,
    center: center2,
    boundingSphere: sphere,
    width,
    height,
    depth
  };
};
var smoothNormal = (mesh) => {
  mesh.geometry = mergeVertices(mesh.geometry);
  mesh.geometry.computeVertexNormals();
};

// node_modules/simplex-noise/dist/esm/simplex-noise.js
var F2 = 0.5 * (Math.sqrt(3) - 1);
var G2 = (3 - Math.sqrt(3)) / 6;
var F3 = 1 / 3;
var G3 = 1 / 6;
var F4 = (Math.sqrt(5) - 1) / 4;
var G4 = (5 - Math.sqrt(5)) / 20;
var fastFloor = (x) => Math.floor(x) | 0;
var grad2 = new Float64Array([
  1,
  1,
  -1,
  1,
  1,
  -1,
  -1,
  -1,
  1,
  0,
  -1,
  0,
  1,
  0,
  -1,
  0,
  0,
  1,
  0,
  -1,
  0,
  1,
  0,
  -1
]);
var grad3 = new Float64Array([
  1,
  1,
  0,
  -1,
  1,
  0,
  1,
  -1,
  0,
  -1,
  -1,
  0,
  1,
  0,
  1,
  -1,
  0,
  1,
  1,
  0,
  -1,
  -1,
  0,
  -1,
  0,
  1,
  1,
  0,
  -1,
  1,
  0,
  1,
  -1,
  0,
  -1,
  -1
]);
var grad4 = new Float64Array([
  0,
  1,
  1,
  1,
  0,
  1,
  1,
  -1,
  0,
  1,
  -1,
  1,
  0,
  1,
  -1,
  -1,
  0,
  -1,
  1,
  1,
  0,
  -1,
  1,
  -1,
  0,
  -1,
  -1,
  1,
  0,
  -1,
  -1,
  -1,
  1,
  0,
  1,
  1,
  1,
  0,
  1,
  -1,
  1,
  0,
  -1,
  1,
  1,
  0,
  -1,
  -1,
  -1,
  0,
  1,
  1,
  -1,
  0,
  1,
  -1,
  -1,
  0,
  -1,
  1,
  -1,
  0,
  -1,
  -1,
  1,
  1,
  0,
  1,
  1,
  1,
  0,
  -1,
  1,
  -1,
  0,
  1,
  1,
  -1,
  0,
  -1,
  -1,
  1,
  0,
  1,
  -1,
  1,
  0,
  -1,
  -1,
  -1,
  0,
  1,
  -1,
  -1,
  0,
  -1,
  1,
  1,
  1,
  0,
  1,
  1,
  -1,
  0,
  1,
  -1,
  1,
  0,
  1,
  -1,
  -1,
  0,
  -1,
  1,
  1,
  0,
  -1,
  1,
  -1,
  0,
  -1,
  -1,
  1,
  0,
  -1,
  -1,
  -1,
  0
]);
function createNoise3D(random3 = Math.random) {
  const perm = buildPermutationTable(random3);
  const permGrad3x = new Float64Array(perm).map((v) => grad3[v % 12 * 3]);
  const permGrad3y = new Float64Array(perm).map((v) => grad3[v % 12 * 3 + 1]);
  const permGrad3z = new Float64Array(perm).map((v) => grad3[v % 12 * 3 + 2]);
  return function noise3D2(x, y, z) {
    let n0, n1, n2, n3;
    const s = (x + y + z) * F3;
    const i3 = fastFloor(x + s);
    const j = fastFloor(y + s);
    const k = fastFloor(z + s);
    const t2 = (i3 + j + k) * G3;
    const X0 = i3 - t2;
    const Y0 = j - t2;
    const Z0 = k - t2;
    const x0 = x - X0;
    const y0 = y - Y0;
    const z0 = z - Z0;
    let i1, j1, k1;
    let i22, j2, k2;
    if (x0 >= y0) {
      if (y0 >= z0) {
        i1 = 1;
        j1 = 0;
        k1 = 0;
        i22 = 1;
        j2 = 1;
        k2 = 0;
      } else if (x0 >= z0) {
        i1 = 1;
        j1 = 0;
        k1 = 0;
        i22 = 1;
        j2 = 0;
        k2 = 1;
      } else {
        i1 = 0;
        j1 = 0;
        k1 = 1;
        i22 = 1;
        j2 = 0;
        k2 = 1;
      }
    } else {
      if (y0 < z0) {
        i1 = 0;
        j1 = 0;
        k1 = 1;
        i22 = 0;
        j2 = 1;
        k2 = 1;
      } else if (x0 < z0) {
        i1 = 0;
        j1 = 1;
        k1 = 0;
        i22 = 0;
        j2 = 1;
        k2 = 1;
      } else {
        i1 = 0;
        j1 = 1;
        k1 = 0;
        i22 = 1;
        j2 = 1;
        k2 = 0;
      }
    }
    const x1 = x0 - i1 + G3;
    const y1 = y0 - j1 + G3;
    const z1 = z0 - k1 + G3;
    const x2 = x0 - i22 + 2 * G3;
    const y2 = y0 - j2 + 2 * G3;
    const z2 = z0 - k2 + 2 * G3;
    const x3 = x0 - 1 + 3 * G3;
    const y3 = y0 - 1 + 3 * G3;
    const z3 = z0 - 1 + 3 * G3;
    const ii = i3 & 255;
    const jj = j & 255;
    const kk = k & 255;
    let t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0;
    if (t0 < 0)
      n0 = 0;
    else {
      const gi0 = ii + perm[jj + perm[kk]];
      t0 *= t0;
      n0 = t0 * t0 * (permGrad3x[gi0] * x0 + permGrad3y[gi0] * y0 + permGrad3z[gi0] * z0);
    }
    let t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1;
    if (t1 < 0)
      n1 = 0;
    else {
      const gi1 = ii + i1 + perm[jj + j1 + perm[kk + k1]];
      t1 *= t1;
      n1 = t1 * t1 * (permGrad3x[gi1] * x1 + permGrad3y[gi1] * y1 + permGrad3z[gi1] * z1);
    }
    let t22 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2;
    if (t22 < 0)
      n2 = 0;
    else {
      const gi2 = ii + i22 + perm[jj + j2 + perm[kk + k2]];
      t22 *= t22;
      n2 = t22 * t22 * (permGrad3x[gi2] * x2 + permGrad3y[gi2] * y2 + permGrad3z[gi2] * z2);
    }
    let t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3;
    if (t3 < 0)
      n3 = 0;
    else {
      const gi3 = ii + 1 + perm[jj + 1 + perm[kk + 1]];
      t3 *= t3;
      n3 = t3 * t3 * (permGrad3x[gi3] * x3 + permGrad3y[gi3] * y3 + permGrad3z[gi3] * z3);
    }
    return 32 * (n0 + n1 + n2 + n3);
  };
}
function buildPermutationTable(random3) {
  const tableSize = 512;
  const p = new Uint8Array(tableSize);
  for (let i3 = 0; i3 < tableSize / 2; i3++) {
    p[i3] = i3;
  }
  for (let i3 = 0; i3 < tableSize / 2 - 1; i3++) {
    const r = i3 + ~~(random3() * (256 - i3));
    const aux = p[i3];
    p[i3] = p[r];
    p[r] = aux;
  }
  for (let i3 = 256; i3 < tableSize; i3++) {
    p[i3] = p[i3 - 256];
  }
  return p;
}

// node_modules/kokomi.js/dist/utils/noise.js
var noise3D = createNoise3D();
var computeCurl = (x, y, z) => {
  let eps = 1e-4;
  let curl = new Vector3();
  let n1 = noise3D(x, y + eps, z);
  let n2 = noise3D(x, y - eps, z);
  let a4 = (n1 - n2) / (2 * eps);
  n1 = noise3D(x, y, z + eps);
  n2 = noise3D(x, y, z - eps);
  let b5 = (n1 - n2) / (2 * eps);
  curl.x = a4 - b5;
  n1 = noise3D(x, y, z + eps);
  n2 = noise3D(x, y, z - eps);
  a4 = (n1 - n2) / (2 * eps);
  n1 = noise3D(x + eps, y, z);
  n2 = noise3D(x + eps, y, z);
  b5 = (n1 - n2) / (2 * eps);
  curl.y = a4 - b5;
  n1 = noise3D(x + eps, y, z);
  n2 = noise3D(x - eps, y, z);
  a4 = (n1 - n2) / (2 * eps);
  n1 = noise3D(x, y + eps, z);
  n2 = noise3D(x, y - eps, z);
  b5 = (n1 - n2) / (2 * eps);
  curl.z = a4 - b5;
  return curl;
};

// node_modules/kokomi.js/dist/utils/parametric.js
var hyperbolicHelicoidFunction = (u, v, target) => {
  u = Math.PI * 2 * (u - 0.5);
  v = Math.PI * 2 * (v - 0.5);
  const tau = 5;
  const bottom = 1 + Math.cosh(u) * Math.cosh(v);
  const x = Math.sinh(v) * Math.cos(tau * u) / bottom;
  const y = Math.sinh(v) * Math.sin(tau * u) / bottom;
  const z = Math.cosh(v) * Math.sinh(u) / bottom;
  target.set(x, z, y);
};
var sphubeFunction = (u1, v14, target) => {
  const s = 0.6;
  const r = 1;
  const theta = 2 * u1 * Math.PI;
  const phi = v14 * 2 * Math.PI;
  const u = Math.cos(theta) * Math.cos(phi);
  const v = Math.cos(theta) * Math.sin(phi);
  const w = Math.sin(theta);
  const z = r * u / Math.sqrt(1 - s * v ** 2 - s * w ** 2);
  const x = r * v / Math.sqrt(1 - s * u ** 2 - s * w ** 2);
  const y = r * w / Math.sqrt(1 - s * Math.cos(theta) ** 2);
  target.set(x, y, z);
};

// node_modules/kokomi.js/dist/utils/vector.js
var v13 = new Vector3();
var v22 = new Vector3();
var v3 = new Vector3();
var calcObjectPosition = (el, camera) => {
  const objectPos = v13.setFromMatrixPosition(el.matrixWorld);
  objectPos.project(camera);
  const widthHalf = window.innerWidth / 2;
  const heightHalf = window.innerHeight / 2;
  const x = objectPos.x * widthHalf + widthHalf;
  const y = -(objectPos.y * heightHalf) + heightHalf;
  const pos = new Vector2(x, y);
  return pos;
};
var isObjectBehindCamera = (el, camera) => {
  const objectPos = v13.setFromMatrixPosition(el.matrixWorld);
  const cameraPos = v22.setFromMatrixPosition(camera.matrixWorld);
  const deltaCamObj = objectPos.sub(cameraPos);
  const camDir = camera.getWorldDirection(v3);
  return deltaCamObj.angleTo(camDir) > Math.PI / 2;
};
var isObjectVisible = (el, camera, raycaster, occlude) => {
  const elPos = v13.setFromMatrixPosition(el.matrixWorld);
  const screenPos = elPos.clone();
  screenPos.project(camera);
  raycaster.setFromCamera(screenPos, camera);
  const intersects = raycaster.intersectObjects(occlude, true);
  if (intersects.length) {
    const intersectionDistance = intersects[0].distance;
    const pointDistance = elPos.distanceTo(raycaster.ray.origin);
    return pointDistance < intersectionDistance;
  }
  return true;
};
var objectZIndex = (el, camera, zIndexRange = [16777271, 0]) => {
  if (camera instanceof PerspectiveCamera || camera instanceof OrthographicCamera) {
    const objectPos = v13.setFromMatrixPosition(el.matrixWorld);
    const cameraPos = v22.setFromMatrixPosition(camera.matrixWorld);
    const dist = objectPos.distanceTo(cameraPos);
    const A2 = (zIndexRange[1] - zIndexRange[0]) / (camera.far - camera.near);
    const B2 = zIndexRange[1] - A2 * camera.far;
    return Math.round(A2 * dist + B2);
  }
  return void 0;
};
var objectScale = (el, camera) => {
  if (camera instanceof OrthographicCamera) {
    return camera.zoom;
  } else if (camera instanceof PerspectiveCamera) {
    const objectPos = v13.setFromMatrixPosition(el.matrixWorld);
    const cameraPos = v22.setFromMatrixPosition(camera.matrixWorld);
    const vFOV = camera.fov * Math.PI / 180;
    const dist = objectPos.distanceTo(cameraPos);
    const scaleFOV = 2 * Math.tan(vFOV / 2) * dist;
    return 1 / scaleFOV;
  } else {
    return 1;
  }
};
var calcTransformFov = (camera) => {
  const heightHalf = window.innerHeight / 2;
  const fov = camera.projectionMatrix.elements[5] * heightHalf;
  return fov;
};
var epsilon = (value) => Math.abs(value) < 1e-10 ? 0 : value;
var getCSSMatrix = (matrix3, multipliers, prepend = "") => {
  let matrix3d = "matrix3d(";
  for (let i3 = 0; i3 !== 16; i3++) {
    matrix3d += epsilon(multipliers[i3] * matrix3.elements[i3]) + (i3 !== 15 ? "," : ")");
  }
  return prepend + matrix3d;
};
var getCameraCSSMatrix = ((multipliers) => {
  return (matrix3) => getCSSMatrix(matrix3, multipliers);
})([1, -1, 1, 1, 1, -1, 1, 1, 1, -1, 1, 1, 1, -1, 1, 1]);
var getObjectCSSMatrix = ((scaleMultipliers) => {
  return (matrix3, factor) => getCSSMatrix(matrix3, scaleMultipliers(factor), "translate(-50%,-50%)");
})((f) => [
  1 / f,
  1 / f,
  1 / f,
  1,
  -1 / f,
  -1 / f,
  -1 / f,
  -1,
  1 / f,
  1 / f,
  1 / f,
  1,
  1,
  1,
  1,
  1
]);

// node_modules/kokomi.js/dist/utils/view.js
var computeContainerPosition = (canvasSize, trackRect) => {
  const { right, top, left: trackLeft, bottom: trackBottom, width, height } = trackRect;
  const isOffscreen = trackRect.bottom < 0 || top > canvasSize.height || right < 0 || trackRect.left > canvasSize.width;
  const canvasBottom = canvasSize.top + canvasSize.height;
  const bottom = canvasBottom - trackBottom;
  const left = trackLeft - canvasSize.left;
  return {
    position: { width, height, left, top, bottom, right },
    isOffscreen
  };
};
var applyViewScissor = (base, viewEl) => {
  const canvasSize = base.renderer.domElement.getBoundingClientRect();
  const rect = viewEl.getBoundingClientRect();
  if (rect) {
    const { position: { left, bottom, width, height } } = computeContainerPosition(canvasSize, rect);
    const aspect = width / height;
    base.camera.aspect = aspect;
    base.camera.updateProjectionMatrix();
    base.renderer.setViewport(left, bottom, width, height);
    base.renderer.setScissor(left, bottom, width, height);
    base.renderer.setScissorTest(true);
  }
};
var computeViewWindowScale = (viewEl) => {
  const viewRect = viewEl.getBoundingClientRect();
  const { width, height } = viewRect;
  const xScale = width / window.innerWidth;
  const yScale = height / window.innerHeight;
  return { xScale, yScale };
};

// node_modules/kokomi.js/dist/utils/web.js
var getPointsInPath = (path, pointNum = 4) => {
  const points = [];
  const pathLength = path.getTotalLength();
  const pointCount = Math.floor(pathLength / pointNum);
  for (let i3 = 0; i3 < pointCount; i3++) {
    const distance2 = pathLength * i3 / pointCount;
    const point = path.getPointAtLength(distance2);
    points.push(point);
  }
  return points;
};

// node_modules/kokomi.js/dist/components/assetManager.js
var AssetManager = class extends Component {
  constructor(base, list, config3 = {}) {
    super(base);
    __publicField(this, "config");
    __publicField(this, "resourceList");
    __publicField(this, "items");
    __publicField(this, "toLoad");
    __publicField(this, "loaded");
    __publicField(this, "loaders");
    const { useDracoLoader = false, dracoDecoderPath = "https://www.gstatic.com/draco/versioned/decoders/1.4.3/", ktx2TranscoderPath = "https://unpkg.com/three/examples/jsm/libs/basis/" } = config3;
    this.config = { useDracoLoader, dracoDecoderPath, ktx2TranscoderPath };
    this.resourceList = list;
    this.items = {};
    this.toLoad = list.length;
    this.loaded = 0;
    this.loaders = {};
    this.setLoaders();
    if (useDracoLoader) {
      this.setDracoLoader();
    }
    this.setKTX2Loader();
    this.startLoading();
  }
  // 设置加载器
  setLoaders() {
    this.loaders.gltfLoader = new GLTFLoader();
    this.loaders.textureLoader = new TextureLoader();
    this.loaders.cubeTextureLoader = new CubeTextureLoader();
    this.loaders.fontLoader = new FontLoader();
    this.loaders.fbxLoader = new FBXLoader2();
    this.loaders.audioLoader = new AudioLoader();
    this.loaders.objLoader = new OBJLoader();
    this.loaders.hdrTextureLoader = new RGBELoader();
    this.loaders.svgLoader = new SVGLoader();
    this.loaders.exrLoader = new EXRLoader();
    this.loaders.ktx2Loader = new KTX2Loader();
  }
  // 设置draco加载器
  setDracoLoader() {
    var _a4;
    const dracoLoader2 = new DRACOLoader();
    dracoLoader2.setDecoderPath(this.config.dracoDecoderPath);
    (_a4 = this.loaders.gltfLoader) == null ? void 0 : _a4.setDRACOLoader(dracoLoader2);
  }
  // 设置ktx2转码器
  setKTX2Loader() {
    var _a4, _b4, _c;
    (_b4 = (_a4 = this.loaders.ktx2Loader) == null ? void 0 : _a4.setTranscoderPath(this.config.ktx2TranscoderPath)) == null ? void 0 : _b4.detectSupport(this.base.renderer);
    if (this.loaders.ktx2Loader) {
      (_c = this.loaders.gltfLoader) == null ? void 0 : _c.setKTX2Loader(this.loaders.ktx2Loader);
    }
  }
  // 开始加载
  startLoading() {
    var _a4, _b4, _c, _d, _e, _f, _g, _h, _i, _j, _k;
    for (const resource of this.resourceList) {
      if (resource.type === "gltfModel") {
        (_a4 = this.loaders.gltfLoader) == null ? void 0 : _a4.load(resource.path, (file) => {
          this.resourceLoaded(resource, file);
        });
      } else if (resource.type === "texture") {
        (_b4 = this.loaders.textureLoader) == null ? void 0 : _b4.load(resource.path, (file) => {
          this.resourceLoaded(resource, file);
        });
      } else if (resource.type === "cubeTexture") {
        (_c = this.loaders.cubeTextureLoader) == null ? void 0 : _c.load(resource.path, (file) => {
          this.resourceLoaded(resource, file);
        });
      } else if (resource.type === "font") {
        (_d = this.loaders.fontLoader) == null ? void 0 : _d.load(resource.path, (file) => {
          this.resourceLoaded(resource, file);
        });
      } else if (resource.type === "fbxModel") {
        (_e = this.loaders.fbxLoader) == null ? void 0 : _e.load(resource.path, (file) => {
          this.resourceLoaded(resource, file);
        });
      } else if (resource.type === "audio") {
        (_f = this.loaders.audioLoader) == null ? void 0 : _f.load(resource.path, (file) => {
          this.resourceLoaded(resource, file);
        });
      } else if (resource.type === "objModel") {
        (_g = this.loaders.objLoader) == null ? void 0 : _g.load(resource.path, (file) => {
          this.resourceLoaded(resource, file);
        });
      } else if (resource.type === "hdrTexture") {
        (_h = this.loaders.hdrTextureLoader) == null ? void 0 : _h.load(resource.path, (file) => {
          this.resourceLoaded(resource, file);
        });
      } else if (resource.type === "svg") {
        (_i = this.loaders.svgLoader) == null ? void 0 : _i.load(resource.path, (file) => {
          this.resourceLoaded(resource, file);
        });
      } else if (resource.type === "exrTexture") {
        (_j = this.loaders.exrLoader) == null ? void 0 : _j.load(resource.path, (file) => {
          this.resourceLoaded(resource, file);
        });
      } else if (resource.type === "video") {
        loadVideoTexture(resource.path).then((file) => {
          this.resourceLoaded(resource, file);
        });
      } else if (resource.type === "ktx2Texture") {
        (_k = this.loaders.ktx2Loader) == null ? void 0 : _k.load(resource.path, (file) => {
          this.resourceLoaded(resource, file);
        });
      }
    }
  }
  // 加载完单个素材
  resourceLoaded(resource, file) {
    this.items[resource.name] = file;
    this.loaded += 1;
    if (this.isLoaded) {
      this.emit("ready");
    }
  }
  // 加载进度
  get loadProgress() {
    return this.loaded / this.toLoad;
  }
  // 是否加载完毕
  get isLoaded() {
    return this.loaded === this.toLoad;
  }
};

// node_modules/kokomi.js/dist/components/center.js
var Center = class extends Component {
  constructor(base, config3 = {}) {
    super(base);
    __publicField(this, "top");
    __publicField(this, "right");
    __publicField(this, "bottom");
    __publicField(this, "left");
    __publicField(this, "front");
    __publicField(this, "back");
    __publicField(this, "disable");
    __publicField(this, "disableX");
    __publicField(this, "disableY");
    __publicField(this, "disableZ");
    __publicField(this, "precise");
    __publicField(this, "group");
    __publicField(this, "groupOuter");
    __publicField(this, "groupInner");
    __publicField(this, "bound");
    const { top = false, right = false, bottom = false, left = false, front = false, back = false, disable = false, disableX = false, disableY = false, disableZ = false, precise = true } = config3;
    this.top = top;
    this.right = right;
    this.bottom = bottom;
    this.left = left;
    this.front = front;
    this.back = back;
    this.disable = disable;
    this.disableX = disableX;
    this.disableY = disableY;
    this.disableZ = disableZ;
    this.precise = precise;
    const group = new Group();
    this.group = group;
    const groupOuter = new Group();
    this.groupOuter = groupOuter;
    const groupInner = new Group();
    this.groupInner = groupInner;
    this.bound = null;
    this.adjustPosition();
  }
  addExisting() {
    this.container.add(this.group);
    this.group.add(this.groupOuter);
    this.groupOuter.add(this.groupInner);
    this.adjustPosition();
  }
  add(...object) {
    this.groupInner.add(...object);
    this.adjustPosition();
  }
  adjustPosition() {
    const { top, right, bottom, left, front, back, disable, disableX, disableY, disableZ, precise } = this;
    this.groupOuter.matrix.identity();
    const bound = getBound(this.groupInner, precise);
    this.bound = bound;
    const { center: center2, width, height, depth } = bound;
    const vAlign = top ? height / 2 : bottom ? -height / 2 : 0;
    const hAlign = left ? -width / 2 : right ? width / 2 : 0;
    const dAlign = front ? depth / 2 : back ? -depth / 2 : 0;
    this.groupOuter.position.set(disable || disableX ? 0 : -center2.x + hAlign, disable || disableY ? 0 : -center2.y + vAlign, disable || disableZ ? 0 : -center2.z + dAlign);
  }
};

// node_modules/kokomi.js/dist/components/clock.js
var Clock2 = class extends Component {
  constructor(base) {
    super(base);
    __publicField(this, "clock");
    __publicField(this, "deltaTime");
    __publicField(this, "elapsedTime");
    const clock = new Clock();
    this.clock = clock;
    this.deltaTime = 0;
    this.elapsedTime = 0;
  }
  update(time) {
    const newElapsedTime = this.clock.getElapsedTime();
    const deltaTime = newElapsedTime - this.elapsedTime;
    this.deltaTime = deltaTime;
    this.elapsedTime = newElapsedTime;
    this.emit("tick");
  }
};

// node_modules/kokomi.js/dist/components/float.js
var Float = class extends Component {
  constructor(base, config3 = {}) {
    super(base);
    __publicField(this, "group");
    __publicField(this, "speed");
    __publicField(this, "rotationIntensity");
    __publicField(this, "floatIntensity");
    __publicField(this, "floatingRange");
    __publicField(this, "offset");
    const { speed = 1, rotationIntensity = 1, floatIntensity = 1, floatingRange = [-0.1, 0.1] } = config3;
    this.speed = speed;
    this.rotationIntensity = rotationIntensity;
    this.floatIntensity = floatIntensity;
    this.floatingRange = floatingRange;
    const group = new Group();
    this.group = group;
    this.offset = Math.random() * 114514;
  }
  addExisting() {
    this.container.add(this.group);
  }
  add(...object) {
    this.group.add(...object);
  }
  update(time) {
    const { speed, rotationIntensity, floatIntensity, floatingRange, offset } = this;
    const t2 = offset + this.base.clock.elapsedTime;
    this.group.rotation.x = Math.cos(t2 / 4 * speed) / 8 * rotationIntensity;
    this.group.rotation.y = Math.sin(t2 / 4 * speed) / 8 * rotationIntensity;
    this.group.rotation.z = Math.sin(t2 / 4 * speed) / 20 * rotationIntensity;
    let yPosition = Math.sin(t2 / 4 * speed) / 10;
    yPosition = MathUtils.mapLinear(yPosition, -0.1, 0.1, (floatingRange == null ? void 0 : floatingRange[0]) ?? -0.1, (floatingRange == null ? void 0 : floatingRange[1]) ?? 0.1);
    this.group.position.y = yPosition * floatIntensity;
  }
};

// node_modules/three/examples/jsm/misc/GPUComputationRenderer.js
var GPUComputationRenderer2 = class {
  constructor(sizeX, sizeY, renderer) {
    this.variables = [];
    this.currentTextureIndex = 0;
    let dataType = FloatType;
    const scene = new Scene();
    const camera = new Camera();
    camera.position.z = 1;
    const passThruUniforms = {
      passThruTexture: { value: null }
    };
    const passThruShader = createShaderMaterial(getPassThroughFragmentShader(), passThruUniforms);
    const mesh = new Mesh(new PlaneGeometry(2, 2), passThruShader);
    scene.add(mesh);
    this.setDataType = function(type) {
      dataType = type;
      return this;
    };
    this.addVariable = function(variableName, computeFragmentShader, initialValueTexture) {
      const material2 = this.createShaderMaterial(computeFragmentShader);
      const variable = {
        name: variableName,
        initialValueTexture,
        material: material2,
        dependencies: null,
        renderTargets: [],
        wrapS: null,
        wrapT: null,
        minFilter: NearestFilter,
        magFilter: NearestFilter
      };
      this.variables.push(variable);
      return variable;
    };
    this.setVariableDependencies = function(variable, dependencies) {
      variable.dependencies = dependencies;
    };
    this.init = function() {
      if (renderer.capabilities.isWebGL2 === false && renderer.extensions.has("OES_texture_float") === false) {
        return "No OES_texture_float support for float textures.";
      }
      if (renderer.capabilities.maxVertexTextures === 0) {
        return "No support for vertex shader textures.";
      }
      for (let i3 = 0; i3 < this.variables.length; i3++) {
        const variable = this.variables[i3];
        variable.renderTargets[0] = this.createRenderTarget(sizeX, sizeY, variable.wrapS, variable.wrapT, variable.minFilter, variable.magFilter);
        variable.renderTargets[1] = this.createRenderTarget(sizeX, sizeY, variable.wrapS, variable.wrapT, variable.minFilter, variable.magFilter);
        this.renderTexture(variable.initialValueTexture, variable.renderTargets[0]);
        this.renderTexture(variable.initialValueTexture, variable.renderTargets[1]);
        const material2 = variable.material;
        const uniforms = material2.uniforms;
        if (variable.dependencies !== null) {
          for (let d = 0; d < variable.dependencies.length; d++) {
            const depVar = variable.dependencies[d];
            if (depVar.name !== variable.name) {
              let found = false;
              for (let j = 0; j < this.variables.length; j++) {
                if (depVar.name === this.variables[j].name) {
                  found = true;
                  break;
                }
              }
              if (!found) {
                return "Variable dependency not found. Variable=" + variable.name + ", dependency=" + depVar.name;
              }
            }
            uniforms[depVar.name] = { value: null };
            material2.fragmentShader = "\nuniform sampler2D " + depVar.name + ";\n" + material2.fragmentShader;
          }
        }
      }
      this.currentTextureIndex = 0;
      return null;
    };
    this.compute = function() {
      const currentTextureIndex = this.currentTextureIndex;
      const nextTextureIndex = this.currentTextureIndex === 0 ? 1 : 0;
      for (let i3 = 0, il = this.variables.length; i3 < il; i3++) {
        const variable = this.variables[i3];
        if (variable.dependencies !== null) {
          const uniforms = variable.material.uniforms;
          for (let d = 0, dl = variable.dependencies.length; d < dl; d++) {
            const depVar = variable.dependencies[d];
            uniforms[depVar.name].value = depVar.renderTargets[currentTextureIndex].texture;
          }
        }
        this.doRenderTarget(variable.material, variable.renderTargets[nextTextureIndex]);
      }
      this.currentTextureIndex = nextTextureIndex;
    };
    this.getCurrentRenderTarget = function(variable) {
      return variable.renderTargets[this.currentTextureIndex];
    };
    this.getAlternateRenderTarget = function(variable) {
      return variable.renderTargets[this.currentTextureIndex === 0 ? 1 : 0];
    };
    this.dispose = function() {
      mesh.geometry.dispose();
      mesh.material.dispose();
      const variables = this.variables;
      for (let i3 = 0; i3 < variables.length; i3++) {
        const variable = variables[i3];
        if (variable.initialValueTexture)
          variable.initialValueTexture.dispose();
        const renderTargets = variable.renderTargets;
        for (let j = 0; j < renderTargets.length; j++) {
          const renderTarget = renderTargets[j];
          renderTarget.dispose();
        }
      }
    };
    function addResolutionDefine(materialShader) {
      materialShader.defines.resolution = "vec2( " + sizeX.toFixed(1) + ", " + sizeY.toFixed(1) + " )";
    }
    this.addResolutionDefine = addResolutionDefine;
    function createShaderMaterial(computeFragmentShader, uniforms) {
      uniforms = uniforms || {};
      const material2 = new ShaderMaterial({
        uniforms,
        vertexShader: getPassThroughVertexShader(),
        fragmentShader: computeFragmentShader
      });
      addResolutionDefine(material2);
      return material2;
    }
    this.createShaderMaterial = createShaderMaterial;
    this.createRenderTarget = function(sizeXTexture, sizeYTexture, wrapS, wrapT, minFilter, magFilter) {
      sizeXTexture = sizeXTexture || sizeX;
      sizeYTexture = sizeYTexture || sizeY;
      wrapS = wrapS || ClampToEdgeWrapping;
      wrapT = wrapT || ClampToEdgeWrapping;
      minFilter = minFilter || NearestFilter;
      magFilter = magFilter || NearestFilter;
      const renderTarget = new WebGLRenderTarget(sizeXTexture, sizeYTexture, {
        wrapS,
        wrapT,
        minFilter,
        magFilter,
        format: RGBAFormat,
        type: dataType,
        depthBuffer: false
      });
      return renderTarget;
    };
    this.createTexture = function() {
      const data = new Float32Array(sizeX * sizeY * 4);
      const texture = new DataTexture(data, sizeX, sizeY, RGBAFormat, FloatType);
      texture.needsUpdate = true;
      return texture;
    };
    this.renderTexture = function(input, output) {
      passThruUniforms.passThruTexture.value = input;
      this.doRenderTarget(passThruShader, output);
      passThruUniforms.passThruTexture.value = null;
    };
    this.doRenderTarget = function(material2, output) {
      const currentRenderTarget = renderer.getRenderTarget();
      const currentXrEnabled = renderer.xr.enabled;
      const currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;
      const currentOutputEncoding = renderer.outputEncoding;
      const currentToneMapping = renderer.toneMapping;
      renderer.xr.enabled = false;
      renderer.shadowMap.autoUpdate = false;
      renderer.outputEncoding = LinearEncoding;
      renderer.toneMapping = NoToneMapping;
      mesh.material = material2;
      renderer.setRenderTarget(output);
      renderer.render(scene, camera);
      mesh.material = passThruShader;
      renderer.xr.enabled = currentXrEnabled;
      renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;
      renderer.outputEncoding = currentOutputEncoding;
      renderer.toneMapping = currentToneMapping;
      renderer.setRenderTarget(currentRenderTarget);
    };
    function getPassThroughVertexShader() {
      return "void main()	{\n\n	gl_Position = vec4( position, 1.0 );\n\n}\n";
    }
    function getPassThroughFragmentShader() {
      return "uniform sampler2D passThruTexture;\n\nvoid main() {\n\n	vec2 uv = gl_FragCoord.xy / resolution.xy;\n\n	gl_FragColor = texture2D( passThruTexture, uv );\n\n}\n";
    }
  }
};

// node_modules/kokomi.js/dist/components/uniformInjector.js
var UniformInjector = class extends Component {
  constructor(base) {
    super(base);
    __publicField(this, "shadertoyUniforms");
    this.shadertoyUniforms = {
      iGlobalTime: {
        value: 0
      },
      iTime: {
        value: 0
      },
      iTimeDelta: {
        value: 0
      },
      iResolution: {
        value: new Vector3(window.innerWidth, window.innerHeight, 1)
      },
      iMouse: {
        value: new Vector4(0, 0, 0, 0)
      },
      iFrame: {
        value: 0
      },
      iDate: {
        value: new Vector4((/* @__PURE__ */ new Date()).getFullYear(), (/* @__PURE__ */ new Date()).getMonth() + 1, (/* @__PURE__ */ new Date()).getDate(), (/* @__PURE__ */ new Date()).getHours())
      },
      iSampleRate: {
        value: 44100
      },
      iChannelTime: {
        value: [0, 0, 0, 0]
      }
    };
  }
  injectShadertoyUniforms(uniforms = this.shadertoyUniforms) {
    const t2 = this.base.clock.elapsedTime;
    uniforms.iGlobalTime.value = t2;
    uniforms.iTime.value = t2;
    const delta = this.base.clock.deltaTime;
    uniforms.iTimeDelta.value = delta;
    uniforms.iResolution.value = new Vector3(window.innerWidth, window.innerHeight, 1);
    const { x, y } = this.base.iMouse.mouse;
    uniforms.iMouse.value = new Vector4(x, y, 0, 0);
    uniforms.iDate.value = new Vector4((/* @__PURE__ */ new Date()).getFullYear(), (/* @__PURE__ */ new Date()).getMonth() + 1, (/* @__PURE__ */ new Date()).getDate(), (/* @__PURE__ */ new Date()).getHours());
    uniforms.iChannelTime.value = [t2, t2, t2, t2];
  }
};

// node_modules/kokomi.js/dist/components/GPUComputer.js
var GPUComputer = class extends Component {
  constructor(base, config3 = {}) {
    super(base);
    __publicField(this, "gpu");
    __publicField(this, "uj");
    const { width = 128, height = 128 } = config3;
    const gpu = new GPUComputationRenderer2(width, height, base.renderer);
    this.gpu = gpu;
    const uj = new UniformInjector(this.base);
    this.uj = uj;
  }
  createTexture() {
    return this.gpu.createTexture();
  }
  createVariable(name, computeShader, texture, uniforms) {
    const variable = this.gpu.addVariable(name, computeShader, texture);
    variable.wrapS = RepeatWrapping;
    variable.wrapT = RepeatWrapping;
    variable.material.uniforms = {
      ...variable.material.uniforms,
      ...this.uj.shadertoyUniforms,
      ...uniforms
    };
    return variable;
  }
  init() {
    this.gpu.init();
  }
  update(time) {
    const variables = this.gpu.variables;
    if (variables) {
      variables.forEach((variable) => {
        this.uj.injectShadertoyUniforms(variable.material.uniforms);
      });
    }
    this.gpu.compute();
  }
  getVariableRt(variable) {
    return this.gpu.getCurrentRenderTarget(variable).texture;
  }
};

// node_modules/kokomi.js/dist/components/iMouse.js
var IMouse = class extends Component {
  constructor(base) {
    super(base);
    __publicField(this, "mouse");
    __publicField(this, "mouseDOM");
    __publicField(this, "mouseScreen");
    __publicField(this, "prevMouseDOM");
    __publicField(this, "isMouseMoving");
    __publicField(this, "mouseMoveOffset");
    __publicField(this, "mouseDOMDelta");
    const mouse = new Vector2(0, 0);
    this.mouse = mouse;
    const mouseDOM = new Vector2(0, 0);
    this.mouseDOM = mouseDOM;
    const mouseScreen = new Vector2(0, 0);
    this.mouseScreen = mouseScreen;
    this.prevMouseDOM = new Vector2(0, 0);
    this.isMouseMoving = false;
    this.mouseMoveOffset = 4;
    this.mouseDOMDelta = new Vector2(0, 0);
  }
  getMouse(x, y) {
    const mouse = new Vector2(x, window.innerHeight - y);
    return mouse;
  }
  getMouseDOM(x, y) {
    const mouseDOM = new Vector2(x, y);
    return mouseDOM;
  }
  getMouseScreen(x, y) {
    const mouseScreen = new Vector2(x - window.innerWidth / 2, -(y - window.innerHeight / 2));
    return mouseScreen;
  }
  listenForMouse() {
    const deviceType = detectDeviceType();
    if (deviceType === "Desktop") {
      this.listenForDesktop();
    } else if (deviceType === "Mobile") {
      this.listenForMobile();
    }
  }
  listenForDesktop() {
    window.addEventListener("mousemove", (e) => {
      const iMouseNew = this.getMouse(e.clientX, e.clientY);
      this.mouse = iMouseNew;
      const mouseDOM = this.getMouseDOM(e.clientX, e.clientY);
      this.mouseDOM = mouseDOM;
      const mouseScreen = this.getMouseScreen(e.clientX, e.clientY);
      this.mouseScreen = mouseScreen;
    });
  }
  listenForMobile() {
    window.addEventListener("touchstart", (e) => {
      const iMouseNew = this.getMouse(e.touches[0].clientX, e.touches[0].clientY);
      this.mouse = iMouseNew;
      const mouseDOM = this.getMouseDOM(e.touches[0].clientX, e.touches[0].clientY);
      this.mouseDOM = mouseDOM;
      const mouseScreen = this.getMouseScreen(e.touches[0].clientX, e.touches[0].clientY);
      this.mouseScreen = mouseScreen;
    });
    window.addEventListener("touchmove", (e) => {
      const iMouseNew = this.getMouse(e.touches[0].clientX, e.touches[0].clientY);
      this.mouse = iMouseNew;
      const mouseDOM = this.getMouseDOM(e.touches[0].clientX, e.touches[0].clientY);
      this.mouseDOM = mouseDOM;
      const mouseScreen = this.getMouseScreen(e.touches[0].clientX, e.touches[0].clientY);
      this.mouseScreen = mouseScreen;
    });
  }
  syncMouseDOM() {
    this.prevMouseDOM.x = this.mouseDOM.x;
    this.prevMouseDOM.y = this.mouseDOM.y;
  }
  judgeIsMouseMoving() {
    if (Math.abs(this.mouseDOMDelta.x) < this.mouseMoveOffset && Math.abs(this.mouseDOMDelta.y) < this.mouseMoveOffset) {
      this.isMouseMoving = false;
    } else {
      this.isMouseMoving = true;
    }
  }
  getMouseDOMDelta() {
    const x = this.mouseDOM.x - this.prevMouseDOM.x;
    const y = this.mouseDOM.y - this.prevMouseDOM.y;
    const mouseDOMDelta = new Vector2(x, y);
    this.mouseDOMDelta = mouseDOMDelta;
  }
  update(time) {
    this.getMouseDOMDelta();
    this.judgeIsMouseMoving();
    this.syncMouseDOM();
  }
};

// node_modules/nipplejs/src/utils.js
var distance = (p1, p2) => {
  const dx = p2.x - p1.x;
  const dy = p2.y - p1.y;
  return Math.sqrt(dx * dx + dy * dy);
};
var angle = (p1, p2) => {
  const dx = p2.x - p1.x;
  const dy = p2.y - p1.y;
  return degrees(Math.atan2(dy, dx));
};
var findCoord = (p, d, a4) => {
  const b5 = { x: 0, y: 0 };
  a4 = radians(a4);
  b5.x = p.x - d * Math.cos(a4);
  b5.y = p.y - d * Math.sin(a4);
  return b5;
};
var radians = (a4) => {
  return a4 * (Math.PI / 180);
};
var degrees = (a4) => {
  return a4 * (180 / Math.PI);
};
var isPressed = (evt) => {
  if (isNaN(evt.buttons)) {
    return evt.pressure !== 0;
  }
  return evt.buttons !== 0;
};
var timers = /* @__PURE__ */ new Map();
var throttle = (cb3) => {
  if (timers.has(cb3)) {
    clearTimeout(timers.get(cb3));
  }
  timers.set(cb3, setTimeout(cb3, 100));
};
var bindEvt = (el, arg, handler) => {
  const types = arg.split(/[ ,]+/g);
  let type;
  for (let i3 = 0; i3 < types.length; i3 += 1) {
    type = types[i3];
    if (el.addEventListener) {
      el.addEventListener(type, handler, false);
    } else if (el.attachEvent) {
      el.attachEvent(type, handler);
    }
  }
};
var unbindEvt = (el, arg, handler) => {
  const types = arg.split(/[ ,]+/g);
  let type;
  for (let i3 = 0; i3 < types.length; i3 += 1) {
    type = types[i3];
    if (el.removeEventListener) {
      el.removeEventListener(type, handler);
    } else if (el.detachEvent) {
      el.detachEvent(type, handler);
    }
  }
};
var prepareEvent = (evt) => {
  evt.preventDefault();
  return evt.type.match(/^touch/) ? evt.changedTouches : evt;
};
var getScroll = () => {
  const x = window.pageXOffset !== void 0 ? window.pageXOffset : (document.documentElement || document.body.parentNode || document.body).scrollLeft;
  const y = window.pageYOffset !== void 0 ? window.pageYOffset : (document.documentElement || document.body.parentNode || document.body).scrollTop;
  return {
    x,
    y
  };
};
var applyPosition = (el, pos) => {
  if (pos.top || pos.right || pos.bottom || pos.left) {
    el.style.top = pos.top;
    el.style.right = pos.right;
    el.style.bottom = pos.bottom;
    el.style.left = pos.left;
  } else {
    el.style.left = pos.x + "px";
    el.style.top = pos.y + "px";
  }
};
var getTransitionStyle = (property, values, time) => {
  const obj = configStylePropertyObject(property);
  for (let i3 in obj) {
    if (obj.hasOwnProperty(i3)) {
      if (typeof values === "string") {
        obj[i3] = values + " " + time;
      } else {
        let st = "";
        for (let j = 0, max3 = values.length; j < max3; j += 1) {
          st += values[j] + " " + time + ", ";
        }
        obj[i3] = st.slice(0, -2);
      }
    }
  }
  return obj;
};
var getVendorStyle = (property, value) => {
  const obj = configStylePropertyObject(property);
  for (let i3 in obj) {
    if (obj.hasOwnProperty(i3)) {
      obj[i3] = value;
    }
  }
  return obj;
};
var configStylePropertyObject = (prop) => {
  const obj = {};
  obj[prop] = "";
  const vendors = ["webkit", "Moz", "o"];
  vendors.forEach(function(vendor) {
    obj[vendor + prop.charAt(0).toUpperCase() + prop.slice(1)] = "";
  });
  return obj;
};
var extend = (objA, objB) => {
  for (let i3 in objB) {
    if (objB.hasOwnProperty(i3)) {
      objA[i3] = objB[i3];
    }
  }
  return objA;
};
var safeExtend = (objA, objB) => {
  const obj = {};
  for (let i3 in objA) {
    if (objA.hasOwnProperty(i3) && objB.hasOwnProperty(i3)) {
      obj[i3] = objB[i3];
    } else if (objA.hasOwnProperty(i3)) {
      obj[i3] = objA[i3];
    }
  }
  return obj;
};
var map = (ar, fn) => {
  if (ar.length) {
    for (let i3 = 0, max3 = ar.length; i3 < max3; i3 += 1) {
      fn(ar[i3]);
    }
  } else {
    fn(ar);
  }
};
var clamp = (pos, nipplePos, size2) => ({
  //                          left-clamping        right-clamping
  x: Math.min(Math.max(pos.x, nipplePos.x - size2), nipplePos.x + size2),
  //                          top-clamping         bottom-clamping
  y: Math.min(Math.max(pos.y, nipplePos.y - size2), nipplePos.y + size2)
});

// node_modules/nipplejs/src/super.js
var isTouch = !!("ontouchstart" in window);
var isPointer = window.PointerEvent ? true : false;
var isMSPointer = window.MSPointerEvent ? true : false;
var events = {
  touch: {
    start: "touchstart",
    move: "touchmove",
    end: "touchend, touchcancel"
  },
  mouse: {
    start: "mousedown",
    move: "mousemove",
    end: "mouseup"
  },
  pointer: {
    start: "pointerdown",
    move: "pointermove",
    end: "pointerup, pointercancel"
  },
  MSPointer: {
    start: "MSPointerDown",
    move: "MSPointerMove",
    end: "MSPointerUp"
  }
};
var toBind;
var secondBind = {};
if (isPointer) {
  toBind = events.pointer;
} else if (isMSPointer) {
  toBind = events.MSPointer;
} else if (isTouch) {
  toBind = events.touch;
  secondBind = events.mouse;
} else {
  toBind = events.mouse;
}
function Super() {
}
Super.prototype.on = function(arg, cb3) {
  var self2 = this;
  var types = arg.split(/[ ,]+/g);
  var type;
  self2._handlers_ = self2._handlers_ || {};
  for (var i3 = 0; i3 < types.length; i3 += 1) {
    type = types[i3];
    self2._handlers_[type] = self2._handlers_[type] || [];
    self2._handlers_[type].push(cb3);
  }
  return self2;
};
Super.prototype.off = function(type, cb3) {
  var self2 = this;
  self2._handlers_ = self2._handlers_ || {};
  if (type === void 0) {
    self2._handlers_ = {};
  } else if (cb3 === void 0) {
    self2._handlers_[type] = null;
  } else if (self2._handlers_[type] && self2._handlers_[type].indexOf(cb3) >= 0) {
    self2._handlers_[type].splice(self2._handlers_[type].indexOf(cb3), 1);
  }
  return self2;
};
Super.prototype.trigger = function(arg, data) {
  var self2 = this;
  var types = arg.split(/[ ,]+/g);
  var type;
  self2._handlers_ = self2._handlers_ || {};
  for (var i3 = 0; i3 < types.length; i3 += 1) {
    type = types[i3];
    if (self2._handlers_[type] && self2._handlers_[type].length) {
      self2._handlers_[type].forEach(function(handler) {
        handler.call(self2, {
          type,
          target: self2
        }, data);
      });
    }
  }
};
Super.prototype.config = function(options) {
  var self2 = this;
  self2.options = self2.defaults || {};
  if (options) {
    self2.options = safeExtend(self2.options, options);
  }
};
Super.prototype.bindEvt = function(el, type) {
  var self2 = this;
  self2._domHandlers_ = self2._domHandlers_ || {};
  self2._domHandlers_[type] = function() {
    if (typeof self2["on" + type] === "function") {
      self2["on" + type].apply(self2, arguments);
    } else {
      console.warn('[WARNING] : Missing "on' + type + '" handler.');
    }
  };
  bindEvt(el, toBind[type], self2._domHandlers_[type]);
  if (secondBind[type]) {
    bindEvt(el, secondBind[type], self2._domHandlers_[type]);
  }
  return self2;
};
Super.prototype.unbindEvt = function(el, type) {
  var self2 = this;
  self2._domHandlers_ = self2._domHandlers_ || {};
  unbindEvt(el, toBind[type], self2._domHandlers_[type]);
  if (secondBind[type]) {
    unbindEvt(el, secondBind[type], self2._domHandlers_[type]);
  }
  delete self2._domHandlers_[type];
  return this;
};
var super_default = Super;

// node_modules/nipplejs/src/nipple.js
function Nipple(collection, options) {
  this.identifier = options.identifier;
  this.position = options.position;
  this.frontPosition = options.frontPosition;
  this.collection = collection;
  this.defaults = {
    size: 100,
    threshold: 0.1,
    color: "white",
    fadeTime: 250,
    dataOnly: false,
    restJoystick: true,
    restOpacity: 0.5,
    mode: "dynamic",
    zone: document.body,
    lockX: false,
    lockY: false,
    shape: "circle"
  };
  this.config(options);
  if (this.options.mode === "dynamic") {
    this.options.restOpacity = 0;
  }
  this.id = Nipple.id;
  Nipple.id += 1;
  this.buildEl().stylize();
  this.instance = {
    el: this.ui.el,
    on: this.on.bind(this),
    off: this.off.bind(this),
    show: this.show.bind(this),
    hide: this.hide.bind(this),
    add: this.addToDom.bind(this),
    remove: this.removeFromDom.bind(this),
    destroy: this.destroy.bind(this),
    setPosition: this.setPosition.bind(this),
    resetDirection: this.resetDirection.bind(this),
    computeDirection: this.computeDirection.bind(this),
    trigger: this.trigger.bind(this),
    position: this.position,
    frontPosition: this.frontPosition,
    ui: this.ui,
    identifier: this.identifier,
    id: this.id,
    options: this.options
  };
  return this.instance;
}
Nipple.prototype = new super_default();
Nipple.constructor = Nipple;
Nipple.id = 0;
Nipple.prototype.buildEl = function(options) {
  this.ui = {};
  if (this.options.dataOnly) {
    return this;
  }
  this.ui.el = document.createElement("div");
  this.ui.back = document.createElement("div");
  this.ui.front = document.createElement("div");
  this.ui.el.className = "nipple collection_" + this.collection.id;
  this.ui.back.className = "back";
  this.ui.front.className = "front";
  this.ui.el.setAttribute("id", "nipple_" + this.collection.id + "_" + this.id);
  this.ui.el.appendChild(this.ui.back);
  this.ui.el.appendChild(this.ui.front);
  return this;
};
Nipple.prototype.stylize = function() {
  if (this.options.dataOnly) {
    return this;
  }
  var animTime = this.options.fadeTime + "ms";
  var borderStyle = getVendorStyle("borderRadius", "50%");
  var transitStyle = getTransitionStyle("transition", "opacity", animTime);
  var styles = {};
  styles.el = {
    position: "absolute",
    opacity: this.options.restOpacity,
    display: "block",
    "zIndex": 999
  };
  styles.back = {
    position: "absolute",
    display: "block",
    width: this.options.size + "px",
    height: this.options.size + "px",
    marginLeft: -this.options.size / 2 + "px",
    marginTop: -this.options.size / 2 + "px",
    background: this.options.color,
    "opacity": ".5"
  };
  styles.front = {
    width: this.options.size / 2 + "px",
    height: this.options.size / 2 + "px",
    position: "absolute",
    display: "block",
    marginLeft: -this.options.size / 4 + "px",
    marginTop: -this.options.size / 4 + "px",
    background: this.options.color,
    "opacity": ".5",
    transform: "translate(0px, 0px)"
  };
  extend(styles.el, transitStyle);
  if (this.options.shape === "circle") {
    extend(styles.back, borderStyle);
  }
  extend(styles.front, borderStyle);
  this.applyStyles(styles);
  return this;
};
Nipple.prototype.applyStyles = function(styles) {
  for (var i3 in this.ui) {
    if (this.ui.hasOwnProperty(i3)) {
      for (var j in styles[i3]) {
        this.ui[i3].style[j] = styles[i3][j];
      }
    }
  }
  return this;
};
Nipple.prototype.addToDom = function() {
  if (this.options.dataOnly || document.body.contains(this.ui.el)) {
    return this;
  }
  this.options.zone.appendChild(this.ui.el);
  return this;
};
Nipple.prototype.removeFromDom = function() {
  if (this.options.dataOnly || !document.body.contains(this.ui.el)) {
    return this;
  }
  this.options.zone.removeChild(this.ui.el);
  return this;
};
Nipple.prototype.destroy = function() {
  clearTimeout(this.removeTimeout);
  clearTimeout(this.showTimeout);
  clearTimeout(this.restTimeout);
  this.trigger("destroyed", this.instance);
  this.removeFromDom();
  this.off();
};
Nipple.prototype.show = function(cb3) {
  var self2 = this;
  if (self2.options.dataOnly) {
    return self2;
  }
  clearTimeout(self2.removeTimeout);
  clearTimeout(self2.showTimeout);
  clearTimeout(self2.restTimeout);
  self2.addToDom();
  self2.restCallback();
  setTimeout(function() {
    self2.ui.el.style.opacity = 1;
  }, 0);
  self2.showTimeout = setTimeout(function() {
    self2.trigger("shown", self2.instance);
    if (typeof cb3 === "function") {
      cb3.call(this);
    }
  }, self2.options.fadeTime);
  return self2;
};
Nipple.prototype.hide = function(cb3) {
  var self2 = this;
  if (self2.options.dataOnly) {
    return self2;
  }
  self2.ui.el.style.opacity = self2.options.restOpacity;
  clearTimeout(self2.removeTimeout);
  clearTimeout(self2.showTimeout);
  clearTimeout(self2.restTimeout);
  self2.removeTimeout = setTimeout(
    function() {
      var display = self2.options.mode === "dynamic" ? "none" : "block";
      self2.ui.el.style.display = display;
      if (typeof cb3 === "function") {
        cb3.call(self2);
      }
      self2.trigger("hidden", self2.instance);
    },
    self2.options.fadeTime
  );
  if (self2.options.restJoystick) {
    const rest = self2.options.restJoystick;
    const newPosition = {};
    newPosition.x = rest === true || rest.x !== false ? 0 : self2.instance.frontPosition.x;
    newPosition.y = rest === true || rest.y !== false ? 0 : self2.instance.frontPosition.y;
    self2.setPosition(cb3, newPosition);
  }
  return self2;
};
Nipple.prototype.setPosition = function(cb3, position) {
  var self2 = this;
  self2.frontPosition = {
    x: position.x,
    y: position.y
  };
  var animTime = self2.options.fadeTime + "ms";
  var transitStyle = {};
  transitStyle.front = getTransitionStyle(
    "transition",
    ["transform"],
    animTime
  );
  var styles = { front: {} };
  styles.front = {
    transform: "translate(" + self2.frontPosition.x + "px," + self2.frontPosition.y + "px)"
  };
  self2.applyStyles(transitStyle);
  self2.applyStyles(styles);
  self2.restTimeout = setTimeout(
    function() {
      if (typeof cb3 === "function") {
        cb3.call(self2);
      }
      self2.restCallback();
    },
    self2.options.fadeTime
  );
};
Nipple.prototype.restCallback = function() {
  var self2 = this;
  var transitStyle = {};
  transitStyle.front = getTransitionStyle("transition", "none", "");
  self2.applyStyles(transitStyle);
  self2.trigger("rested", self2.instance);
};
Nipple.prototype.resetDirection = function() {
  this.direction = {
    x: false,
    y: false,
    angle: false
  };
};
Nipple.prototype.computeDirection = function(obj) {
  var rAngle = obj.angle.radian;
  var angle45 = Math.PI / 4;
  var angle90 = Math.PI / 2;
  var direction, directionX, directionY;
  if (rAngle > angle45 && rAngle < angle45 * 3 && !obj.lockX) {
    direction = "up";
  } else if (rAngle > -angle45 && rAngle <= angle45 && !obj.lockY) {
    direction = "left";
  } else if (rAngle > -angle45 * 3 && rAngle <= -angle45 && !obj.lockX) {
    direction = "down";
  } else if (!obj.lockY) {
    direction = "right";
  }
  if (!obj.lockY) {
    if (rAngle > -angle90 && rAngle < angle90) {
      directionX = "left";
    } else {
      directionX = "right";
    }
  }
  if (!obj.lockX) {
    if (rAngle > 0) {
      directionY = "up";
    } else {
      directionY = "down";
    }
  }
  if (obj.force > this.options.threshold) {
    var oldDirection = {};
    var i3;
    for (i3 in this.direction) {
      if (this.direction.hasOwnProperty(i3)) {
        oldDirection[i3] = this.direction[i3];
      }
    }
    var same = {};
    this.direction = {
      x: directionX,
      y: directionY,
      angle: direction
    };
    obj.direction = this.direction;
    for (i3 in oldDirection) {
      if (oldDirection[i3] === this.direction[i3]) {
        same[i3] = true;
      }
    }
    if (same.x && same.y && same.angle) {
      return obj;
    }
    if (!same.x || !same.y) {
      this.trigger("plain", obj);
    }
    if (!same.x) {
      this.trigger("plain:" + directionX, obj);
    }
    if (!same.y) {
      this.trigger("plain:" + directionY, obj);
    }
    if (!same.angle) {
      this.trigger("dir dir:" + direction, obj);
    }
  } else {
    this.resetDirection();
  }
  return obj;
};
var nipple_default = Nipple;

// node_modules/nipplejs/src/collection.js
function Collection(manager, options) {
  var self2 = this;
  self2.nipples = [];
  self2.idles = [];
  self2.actives = [];
  self2.ids = [];
  self2.pressureIntervals = {};
  self2.manager = manager;
  self2.id = Collection.id;
  Collection.id += 1;
  self2.defaults = {
    zone: document.body,
    multitouch: false,
    maxNumberOfNipples: 10,
    mode: "dynamic",
    position: { top: 0, left: 0 },
    catchDistance: 200,
    size: 100,
    threshold: 0.1,
    color: "white",
    fadeTime: 250,
    dataOnly: false,
    restJoystick: true,
    restOpacity: 0.5,
    lockX: false,
    lockY: false,
    shape: "circle",
    dynamicPage: false,
    follow: false
  };
  self2.config(options);
  if (self2.options.mode === "static" || self2.options.mode === "semi") {
    self2.options.multitouch = false;
  }
  if (!self2.options.multitouch) {
    self2.options.maxNumberOfNipples = 1;
  }
  const computedStyle = getComputedStyle(self2.options.zone.parentElement);
  if (computedStyle && computedStyle.display === "flex") {
    self2.parentIsFlex = true;
  }
  self2.updateBox();
  self2.prepareNipples();
  self2.bindings();
  self2.begin();
  return self2.nipples;
}
Collection.prototype = new super_default();
Collection.constructor = Collection;
Collection.id = 0;
Collection.prototype.prepareNipples = function() {
  var self2 = this;
  var nips = self2.nipples;
  nips.on = self2.on.bind(self2);
  nips.off = self2.off.bind(self2);
  nips.options = self2.options;
  nips.destroy = self2.destroy.bind(self2);
  nips.ids = self2.ids;
  nips.id = self2.id;
  nips.processOnMove = self2.processOnMove.bind(self2);
  nips.processOnEnd = self2.processOnEnd.bind(self2);
  nips.get = function(id) {
    if (id === void 0) {
      return nips[0];
    }
    for (var i3 = 0, max3 = nips.length; i3 < max3; i3 += 1) {
      if (nips[i3].identifier === id) {
        return nips[i3];
      }
    }
    return false;
  };
};
Collection.prototype.bindings = function() {
  var self2 = this;
  self2.bindEvt(self2.options.zone, "start");
  self2.options.zone.style.touchAction = "none";
  self2.options.zone.style.msTouchAction = "none";
};
Collection.prototype.begin = function() {
  var self2 = this;
  var opts = self2.options;
  if (opts.mode === "static") {
    var nipple = self2.createNipple(
      opts.position,
      self2.manager.getIdentifier()
    );
    nipple.add();
    self2.idles.push(nipple);
  }
};
Collection.prototype.createNipple = function(position, identifier) {
  var self2 = this;
  var scroll = self2.manager.scroll;
  var toPutOn = {};
  var opts = self2.options;
  var offset = {
    x: self2.parentIsFlex ? scroll.x : scroll.x + self2.box.left,
    y: self2.parentIsFlex ? scroll.y : scroll.y + self2.box.top
  };
  if (position.x && position.y) {
    toPutOn = {
      x: position.x - offset.x,
      y: position.y - offset.y
    };
  } else if (position.top || position.right || position.bottom || position.left) {
    var dumb = document.createElement("DIV");
    dumb.style.display = "hidden";
    dumb.style.top = position.top;
    dumb.style.right = position.right;
    dumb.style.bottom = position.bottom;
    dumb.style.left = position.left;
    dumb.style.position = "absolute";
    opts.zone.appendChild(dumb);
    var dumbBox = dumb.getBoundingClientRect();
    opts.zone.removeChild(dumb);
    toPutOn = position;
    position = {
      x: dumbBox.left + scroll.x,
      y: dumbBox.top + scroll.y
    };
  }
  var nipple = new nipple_default(self2, {
    color: opts.color,
    size: opts.size,
    threshold: opts.threshold,
    fadeTime: opts.fadeTime,
    dataOnly: opts.dataOnly,
    restJoystick: opts.restJoystick,
    restOpacity: opts.restOpacity,
    mode: opts.mode,
    identifier,
    position,
    zone: opts.zone,
    frontPosition: {
      x: 0,
      y: 0
    },
    shape: opts.shape
  });
  if (!opts.dataOnly) {
    applyPosition(nipple.ui.el, toPutOn);
    applyPosition(nipple.ui.front, nipple.frontPosition);
  }
  self2.nipples.push(nipple);
  self2.trigger("added " + nipple.identifier + ":added", nipple);
  self2.manager.trigger("added " + nipple.identifier + ":added", nipple);
  self2.bindNipple(nipple);
  return nipple;
};
Collection.prototype.updateBox = function() {
  var self2 = this;
  self2.box = self2.options.zone.getBoundingClientRect();
};
Collection.prototype.bindNipple = function(nipple) {
  var self2 = this;
  var type;
  var handler = function(evt, data) {
    type = evt.type + " " + data.id + ":" + evt.type;
    self2.trigger(type, data);
  };
  nipple.on("destroyed", self2.onDestroyed.bind(self2));
  nipple.on("shown hidden rested dir plain", handler);
  nipple.on("dir:up dir:right dir:down dir:left", handler);
  nipple.on("plain:up plain:right plain:down plain:left", handler);
};
Collection.prototype.pressureFn = function(touch, nipple, identifier) {
  var self2 = this;
  var previousPressure = 0;
  clearInterval(self2.pressureIntervals[identifier]);
  self2.pressureIntervals[identifier] = setInterval(function() {
    var pressure = touch.force || touch.pressure || touch.webkitForce || 0;
    if (pressure !== previousPressure) {
      nipple.trigger("pressure", pressure);
      self2.trigger("pressure " + nipple.identifier + ":pressure", pressure);
      previousPressure = pressure;
    }
  }.bind(self2), 100);
};
Collection.prototype.onstart = function(evt) {
  var self2 = this;
  var opts = self2.options;
  var origEvt = evt;
  evt = prepareEvent(evt);
  self2.updateBox();
  var process2 = function(touch) {
    if (self2.actives.length < opts.maxNumberOfNipples) {
      self2.processOnStart(touch);
    } else if (origEvt.type.match(/^touch/)) {
      Object.keys(self2.manager.ids).forEach(function(k) {
        if (Object.values(origEvt.touches).findIndex(function(t2) {
          return t2.identifier === k;
        }) < 0) {
          var e = [evt[0]];
          e.identifier = k;
          self2.processOnEnd(e);
        }
      });
      if (self2.actives.length < opts.maxNumberOfNipples) {
        self2.processOnStart(touch);
      }
    }
  };
  map(evt, process2);
  self2.manager.bindDocument();
  return false;
};
Collection.prototype.processOnStart = function(evt) {
  var self2 = this;
  var opts = self2.options;
  var indexInIdles;
  var identifier = self2.manager.getIdentifier(evt);
  var pressure = evt.force || evt.pressure || evt.webkitForce || 0;
  var position = {
    x: evt.pageX,
    y: evt.pageY
  };
  var nipple = self2.getOrCreate(identifier, position);
  if (nipple.identifier !== identifier) {
    self2.manager.removeIdentifier(nipple.identifier);
  }
  nipple.identifier = identifier;
  var process2 = function(nip) {
    nip.trigger("start", nip);
    self2.trigger("start " + nip.id + ":start", nip);
    nip.show();
    if (pressure > 0) {
      self2.pressureFn(evt, nip, nip.identifier);
    }
    self2.processOnMove(evt);
  };
  if ((indexInIdles = self2.idles.indexOf(nipple)) >= 0) {
    self2.idles.splice(indexInIdles, 1);
  }
  self2.actives.push(nipple);
  self2.ids.push(nipple.identifier);
  if (opts.mode !== "semi") {
    process2(nipple);
  } else {
    var distance2 = distance(position, nipple.position);
    if (distance2 <= opts.catchDistance) {
      process2(nipple);
    } else {
      nipple.destroy();
      self2.processOnStart(evt);
      return;
    }
  }
  return nipple;
};
Collection.prototype.getOrCreate = function(identifier, position) {
  var self2 = this;
  var opts = self2.options;
  var nipple;
  if (/(semi|static)/.test(opts.mode)) {
    nipple = self2.idles[0];
    if (nipple) {
      self2.idles.splice(0, 1);
      return nipple;
    }
    if (opts.mode === "semi") {
      return self2.createNipple(position, identifier);
    }
    console.warn("Coudln't find the needed nipple.");
    return false;
  }
  nipple = self2.createNipple(position, identifier);
  return nipple;
};
Collection.prototype.processOnMove = function(evt) {
  var self2 = this;
  var opts = self2.options;
  var identifier = self2.manager.getIdentifier(evt);
  var nipple = self2.nipples.get(identifier);
  var scroll = self2.manager.scroll;
  if (!isPressed(evt)) {
    this.processOnEnd(evt);
    return;
  }
  if (!nipple) {
    console.error("Found zombie joystick with ID " + identifier);
    self2.manager.removeIdentifier(identifier);
    return;
  }
  if (opts.dynamicPage) {
    var elBox = nipple.el.getBoundingClientRect();
    nipple.position = {
      x: scroll.x + elBox.left,
      y: scroll.y + elBox.top
    };
  }
  nipple.identifier = identifier;
  var size2 = nipple.options.size / 2;
  var pos = {
    x: evt.pageX,
    y: evt.pageY
  };
  if (opts.lockX) {
    pos.y = nipple.position.y;
  }
  if (opts.lockY) {
    pos.x = nipple.position.x;
  }
  var dist = distance(pos, nipple.position);
  var angle2 = angle(pos, nipple.position);
  var rAngle = radians(angle2);
  var force = dist / size2;
  var raw = {
    distance: dist,
    position: pos
  };
  var clamped_dist;
  var clamped_pos;
  if (nipple.options.shape === "circle") {
    clamped_dist = Math.min(dist, size2);
    clamped_pos = findCoord(nipple.position, clamped_dist, angle2);
  } else {
    clamped_pos = clamp(pos, nipple.position, size2);
    clamped_dist = distance(clamped_pos, nipple.position);
  }
  if (opts.follow) {
    if (dist > size2) {
      let delta_x = pos.x - clamped_pos.x;
      let delta_y = pos.y - clamped_pos.y;
      nipple.position.x += delta_x;
      nipple.position.y += delta_y;
      nipple.el.style.top = nipple.position.y - (self2.box.top + scroll.y) + "px";
      nipple.el.style.left = nipple.position.x - (self2.box.left + scroll.x) + "px";
      dist = distance(pos, nipple.position);
    }
  } else {
    pos = clamped_pos;
    dist = clamped_dist;
  }
  var xPosition = pos.x - nipple.position.x;
  var yPosition = pos.y - nipple.position.y;
  nipple.frontPosition = {
    x: xPosition,
    y: yPosition
  };
  if (!opts.dataOnly) {
    nipple.ui.front.style.transform = "translate(" + xPosition + "px," + yPosition + "px)";
  }
  var toSend = {
    identifier: nipple.identifier,
    position: pos,
    force,
    pressure: evt.force || evt.pressure || evt.webkitForce || 0,
    distance: dist,
    angle: {
      radian: rAngle,
      degree: angle2
    },
    vector: {
      x: xPosition / size2,
      y: -yPosition / size2
    },
    raw,
    instance: nipple,
    lockX: opts.lockX,
    lockY: opts.lockY
  };
  toSend = nipple.computeDirection(toSend);
  toSend.angle = {
    radian: radians(180 - angle2),
    degree: 180 - angle2
  };
  nipple.trigger("move", toSend);
  self2.trigger("move " + nipple.id + ":move", toSend);
};
Collection.prototype.processOnEnd = function(evt) {
  var self2 = this;
  var opts = self2.options;
  var identifier = self2.manager.getIdentifier(evt);
  var nipple = self2.nipples.get(identifier);
  var removedIdentifier = self2.manager.removeIdentifier(nipple.identifier);
  if (!nipple) {
    return;
  }
  if (!opts.dataOnly) {
    nipple.hide(function() {
      if (opts.mode === "dynamic") {
        nipple.trigger("removed", nipple);
        self2.trigger("removed " + nipple.id + ":removed", nipple);
        self2.manager.trigger("removed " + nipple.id + ":removed", nipple);
        nipple.destroy();
      }
    });
  }
  clearInterval(self2.pressureIntervals[nipple.identifier]);
  nipple.resetDirection();
  nipple.trigger("end", nipple);
  self2.trigger("end " + nipple.id + ":end", nipple);
  if (self2.ids.indexOf(nipple.identifier) >= 0) {
    self2.ids.splice(self2.ids.indexOf(nipple.identifier), 1);
  }
  if (self2.actives.indexOf(nipple) >= 0) {
    self2.actives.splice(self2.actives.indexOf(nipple), 1);
  }
  if (/(semi|static)/.test(opts.mode)) {
    self2.idles.push(nipple);
  } else if (self2.nipples.indexOf(nipple) >= 0) {
    self2.nipples.splice(self2.nipples.indexOf(nipple), 1);
  }
  self2.manager.unbindDocument();
  if (/(semi|static)/.test(opts.mode)) {
    self2.manager.ids[removedIdentifier.id] = removedIdentifier.identifier;
  }
};
Collection.prototype.onDestroyed = function(evt, nipple) {
  var self2 = this;
  if (self2.nipples.indexOf(nipple) >= 0) {
    self2.nipples.splice(self2.nipples.indexOf(nipple), 1);
  }
  if (self2.actives.indexOf(nipple) >= 0) {
    self2.actives.splice(self2.actives.indexOf(nipple), 1);
  }
  if (self2.idles.indexOf(nipple) >= 0) {
    self2.idles.splice(self2.idles.indexOf(nipple), 1);
  }
  if (self2.ids.indexOf(nipple.identifier) >= 0) {
    self2.ids.splice(self2.ids.indexOf(nipple.identifier), 1);
  }
  self2.manager.removeIdentifier(nipple.identifier);
  self2.manager.unbindDocument();
};
Collection.prototype.destroy = function() {
  var self2 = this;
  self2.unbindEvt(self2.options.zone, "start");
  self2.nipples.forEach(function(nipple) {
    nipple.destroy();
  });
  for (var i3 in self2.pressureIntervals) {
    if (self2.pressureIntervals.hasOwnProperty(i3)) {
      clearInterval(self2.pressureIntervals[i3]);
    }
  }
  self2.trigger("destroyed", self2.nipples);
  self2.manager.unbindDocument();
  self2.off();
};
var collection_default = Collection;

// node_modules/nipplejs/src/manager.js
function Manager(options) {
  var self2 = this;
  self2.ids = {};
  self2.index = 0;
  self2.collections = [];
  self2.scroll = getScroll();
  self2.config(options);
  self2.prepareCollections();
  var resizeHandler = function() {
    var pos;
    self2.collections.forEach(function(collection) {
      collection.forEach(function(nipple) {
        pos = nipple.el.getBoundingClientRect();
        nipple.position = {
          x: self2.scroll.x + pos.left,
          y: self2.scroll.y + pos.top
        };
      });
    });
  };
  bindEvt(window, "resize", function() {
    throttle(resizeHandler);
  });
  var scrollHandler = function() {
    self2.scroll = getScroll();
  };
  bindEvt(window, "scroll", function() {
    throttle(scrollHandler);
  });
  return self2.collections;
}
Manager.prototype = new super_default();
Manager.constructor = Manager;
Manager.prototype.prepareCollections = function() {
  var self2 = this;
  self2.collections.create = self2.create.bind(self2);
  self2.collections.on = self2.on.bind(self2);
  self2.collections.off = self2.off.bind(self2);
  self2.collections.destroy = self2.destroy.bind(self2);
  self2.collections.get = function(id) {
    var nipple;
    self2.collections.every(function(collection) {
      nipple = collection.get(id);
      return nipple ? false : true;
    });
    return nipple;
  };
};
Manager.prototype.create = function(options) {
  return this.createCollection(options);
};
Manager.prototype.createCollection = function(options) {
  var self2 = this;
  var collection = new collection_default(self2, options);
  self2.bindCollection(collection);
  self2.collections.push(collection);
  return collection;
};
Manager.prototype.bindCollection = function(collection) {
  var self2 = this;
  var type;
  var handler = function(evt, data) {
    type = evt.type + " " + data.id + ":" + evt.type;
    self2.trigger(type, data);
  };
  collection.on("destroyed", self2.onDestroyed.bind(self2));
  collection.on("shown hidden rested dir plain", handler);
  collection.on("dir:up dir:right dir:down dir:left", handler);
  collection.on("plain:up plain:right plain:down plain:left", handler);
};
Manager.prototype.bindDocument = function() {
  var self2 = this;
  if (!self2.binded) {
    self2.bindEvt(document, "move").bindEvt(document, "end");
    self2.binded = true;
  }
};
Manager.prototype.unbindDocument = function(force) {
  var self2 = this;
  if (!Object.keys(self2.ids).length || force === true) {
    self2.unbindEvt(document, "move").unbindEvt(document, "end");
    self2.binded = false;
  }
};
Manager.prototype.getIdentifier = function(evt) {
  var id;
  if (!evt) {
    id = this.index;
  } else {
    id = evt.identifier === void 0 ? evt.pointerId : evt.identifier;
    if (id === void 0) {
      id = this.latest || 0;
    }
  }
  if (this.ids[id] === void 0) {
    this.ids[id] = this.index;
    this.index += 1;
  }
  this.latest = id;
  return this.ids[id];
};
Manager.prototype.removeIdentifier = function(identifier) {
  var removed = {};
  for (var id in this.ids) {
    if (this.ids[id] === identifier) {
      removed.id = id;
      removed.identifier = this.ids[id];
      delete this.ids[id];
      break;
    }
  }
  return removed;
};
Manager.prototype.onmove = function(evt) {
  var self2 = this;
  self2.onAny("move", evt);
  return false;
};
Manager.prototype.onend = function(evt) {
  var self2 = this;
  self2.onAny("end", evt);
  return false;
};
Manager.prototype.oncancel = function(evt) {
  var self2 = this;
  self2.onAny("end", evt);
  return false;
};
Manager.prototype.onAny = function(which, evt) {
  var self2 = this;
  var id;
  var processFn = "processOn" + which.charAt(0).toUpperCase() + which.slice(1);
  evt = prepareEvent(evt);
  var processColl = function(e, id2, coll) {
    if (coll.ids.indexOf(id2) >= 0) {
      coll[processFn](e);
      e._found_ = true;
    }
  };
  var processEvt = function(e) {
    id = self2.getIdentifier(e);
    map(self2.collections, processColl.bind(null, e, id));
    if (!e._found_) {
      self2.removeIdentifier(id);
    }
  };
  map(evt, processEvt);
  return false;
};
Manager.prototype.destroy = function() {
  var self2 = this;
  self2.unbindDocument(true);
  self2.ids = {};
  self2.index = 0;
  self2.collections.forEach(function(collection) {
    collection.destroy();
  });
  self2.off();
};
Manager.prototype.onDestroyed = function(evt, coll) {
  var self2 = this;
  if (self2.collections.indexOf(coll) < 0) {
    return false;
  }
  self2.collections.splice(self2.collections.indexOf(coll), 1);
};
var manager_default = Manager;

// node_modules/nipplejs/src/index.js
var factory = new manager_default();
var src_default = {
  create: function(options) {
    return factory.create(options);
  },
  factory
};

// node_modules/kokomi.js/dist/components/joystick.js
var Joystick = class extends Component {
  constructor(base, config3 = {}) {
    super(base);
    __publicField(this, "manager");
    __publicField(this, "data");
    if (config3.zone) {
      config3.zone.onmousedown = preventDefaultAndStopBubble;
      config3.zone.onpointerdown = preventDefaultAndStopBubble;
      config3.zone.ontouchstart = preventDefaultAndStopBubble;
    }
    const manager = src_default.create({
      mode: "static",
      position: {
        left: "75px",
        bottom: "75px"
      },
      ...config3
    });
    this.manager = manager;
    this.data = {};
  }
  listenForGesture() {
    this.manager.on("start", () => {
      this.emit("move-start", this.data);
    });
    this.manager.on("move", (_, data) => {
      this.emit("move", data);
      this.data = data;
    });
    this.manager.on("end", () => {
      this.emit("move-end", this.data);
    });
  }
};

// node_modules/kokomi.js/dist/components/keyboard.js
var Keyboard = class {
  constructor() {
    __publicField(this, "keys");
    this.keys = {};
  }
  listenForKey() {
    window.addEventListener("keydown", (e) => {
      this.onKeyDown(e);
    });
    window.addEventListener("keyup", (e) => {
      this.onKeyUp(e);
    });
  }
  onKeyDown(e) {
    this.keys[e.key] = true;
  }
  onKeyUp(e) {
    this.keys[e.key] = false;
  }
  get isUpKeyDown() {
    return this.keys["w"] || this.keys["ArrowUp"];
  }
  get isDownKeyDown() {
    return this.keys["s"] || this.keys["ArrowDown"];
  }
  get isLeftKeyDown() {
    return this.keys["a"] || this.keys["ArrowLeft"];
  }
  get isRightKeyDown() {
    return this.keys["d"] || this.keys["ArrowRight"];
  }
  get isSpaceKeyDown() {
    return this.keys[" "];
  }
  get isEnterKeyDown() {
    return this.keys["Enter"];
  }
  get isBackspaceKeyDown() {
    return this.keys["Backspace"];
  }
  get isCtrlKeyDown() {
    return this.keys["Control"];
  }
  get isShiftKeyDown() {
    return this.keys["Shift"];
  }
  get isTabKeyDown() {
    return this.keys["Tab"];
  }
  get isEscKeyDown() {
    return this.keys["Escape"];
  }
};

// node_modules/kokomi.js/dist/components/physics.js
var Physics = class extends Component {
  constructor(base) {
    super(base);
    __publicField(this, "world");
    __publicField(this, "meshPhysicsObjects");
    const world2 = new World();
    world2.gravity.set(0, -9.82, 0);
    this.world = world2;
    this.meshPhysicsObjects = [];
  }
  // 添加物体
  add({ mesh, body, copyPosition = true, copyQuaternion = true }) {
    const obj = new MeshPhysicsObject(mesh, body, copyPosition, copyQuaternion);
    this.base.physics.world.addBody(body);
    this.meshPhysicsObjects.push(obj);
  }
  // 帧
  tick() {
    const world2 = this.world;
    const deltaTime = this.base.clock.deltaTime;
    world2.step(1 / 60, deltaTime, 3);
  }
  // 同步物理和渲染
  sync() {
    this.meshPhysicsObjects.forEach((obj) => {
      const { mesh, body, copyPosition, copyQuaternion } = obj;
      if (copyPosition) {
        mesh.position.copy(body.position);
      }
      if (copyQuaternion) {
        mesh.quaternion.copy(body.quaternion);
      }
    });
  }
  update(time) {
    this.sync();
    this.tick();
  }
};
var MeshPhysicsObject = class {
  constructor(mesh, body, copyPosition = true, copyQuaternion = true) {
    __publicField(this, "mesh");
    __publicField(this, "body");
    __publicField(this, "copyPosition");
    __publicField(this, "copyQuaternion");
    this.mesh = mesh;
    this.body = body;
    this.copyPosition = copyPosition;
    this.copyQuaternion = copyQuaternion;
  }
};

// node_modules/kokomi.js/dist/components/raycastSelector.js
var RaycastSelector = class extends Component {
  constructor(base) {
    super(base);
    __publicField(this, "raycaster");
    this.raycaster = new Raycaster();
  }
  // 获取点击物
  getInterSects(targets = this.container.children) {
    this.raycaster.setFromCamera(this.base.interactionManager.mouse, this.base.camera);
    const intersects = this.raycaster.intersectObjects(targets, true);
    return intersects;
  }
  // 获取第一个选中物
  getFirstIntersect(targets = this.container.children) {
    const intersects = this.getInterSects(targets);
    const intersect2 = intersects[0];
    if (!intersect2 || !intersect2.face) {
      return null;
    }
    return intersect2;
  }
  // 选中点击物时
  onChooseIntersect(target) {
    const intersect2 = this.getFirstIntersect();
    if (!intersect2) {
      return null;
    }
    const object = intersect2.object;
    return target === object ? intersect2 : null;
  }
  // 选中物包含某个点击物时
  onChooseInclude(target) {
    const targets = this.getInterSects();
    const includedTarget = targets.find((item) => item.object === target);
    return includedTarget ? includedTarget : null;
  }
};

// node_modules/kokomi.js/dist/camera/firstPersonCamera.js
var FirstPersonCamera = class extends Component {
  constructor(base, config3 = {}) {
    super(base);
    __publicField(this, "camera");
    __publicField(this, "rotation");
    __publicField(this, "phi");
    __publicField(this, "theta");
    __publicField(this, "phiSpeed");
    __publicField(this, "thetaSpeed");
    __publicField(this, "rotationEnabled");
    __publicField(this, "translation");
    __publicField(this, "forwardSpeed");
    __publicField(this, "leftSpeed");
    __publicField(this, "translationEnabled");
    const { camera = this.base.camera, phiSpeed = 8, thetaSpeed = 5, translation = new Vector3(0, 2, 0), forwardSpeed = 1, leftSpeed = 1 } = config3;
    this.camera = camera;
    this.rotation = new Quaternion();
    this.phi = 0;
    this.theta = 0;
    this.phiSpeed = phiSpeed;
    this.thetaSpeed = thetaSpeed;
    this.rotationEnabled = true;
    this.translation = translation;
    this.forwardSpeed = forwardSpeed;
    this.leftSpeed = leftSpeed;
    this.translationEnabled = true;
  }
  update(time) {
    if (this.rotationEnabled) {
      this.updateRotation();
    }
    this.updateCamera();
    if (this.translationEnabled) {
      this.updateTranslation();
    }
  }
  updateRotation() {
    const xh = this.base.iMouse.mouseDOMDelta.x / window.innerWidth;
    const yh = this.base.iMouse.mouseDOMDelta.y / window.innerHeight;
    this.phi += -xh * this.phiSpeed;
    this.theta = MathUtils.clamp(this.theta + -yh * this.thetaSpeed, -Math.PI / 3, Math.PI / 3);
    const qx = new Quaternion();
    qx.setFromAxisAngle(new Vector3(0, 1, 0), this.phi);
    const qz = new Quaternion();
    qz.setFromAxisAngle(new Vector3(1, 0, 0), this.theta);
    const q = new Quaternion();
    q.multiply(qx);
    q.multiply(qz);
    this.rotation.copy(q);
  }
  updateTranslation() {
    const fv = (this.base.keyboard.isUpKeyDown ? 1 : 0) + (this.base.keyboard.isDownKeyDown ? -1 : 0);
    const sv = (this.base.keyboard.isLeftKeyDown ? 1 : 0) + (this.base.keyboard.isRightKeyDown ? -1 : 0);
    const dt = this.base.clock.deltaTime;
    const qx = new Quaternion();
    qx.setFromAxisAngle(new Vector3(0, 1, 0), this.phi);
    const forward = new Vector3(0, 0, -1);
    forward.applyQuaternion(qx);
    forward.multiplyScalar(fv * dt * 10 * this.forwardSpeed);
    const left = new Vector3(-1, 0, 0);
    left.applyQuaternion(qx);
    left.multiplyScalar(sv * dt * 10 * this.leftSpeed);
    this.translation.add(forward);
    this.translation.add(left);
  }
  updateCamera() {
    this.camera.quaternion.copy(this.rotation);
    this.camera.position.copy(this.translation);
  }
};

// node_modules/kokomi.js/dist/camera/orthographicCamera.js
var OrthographicCamera2 = class extends OrthographicCamera {
  constructor(config3 = {}) {
    const aspect = window.innerWidth / window.innerHeight;
    const { frustum: frustum2 = 5.7, near = 0.1, far = 2e3, useAspect = true } = config3;
    const actualAspect = useAspect ? aspect : 1;
    super(actualAspect * frustum2 * -0.5, actualAspect * frustum2 * 0.5, frustum2 * 0.5, frustum2 * -0.5, near, far);
    __publicField(this, "frustum");
    __publicField(this, "useAspect");
    this.frustum = frustum2;
    this.useAspect = useAspect;
  }
};

// node_modules/maku.js/dist/maku.js
var Maku = class {
  // 细分数
  constructor(el, material2, scene, config3 = {}) {
    __publicField(this, "el");
    // 元素
    __publicField(this, "rect");
    // 元素矩阵
    __publicField(this, "mesh");
    // 网格
    __publicField(this, "scene");
    // 所属场景
    __publicField(this, "segments");
    const { meshType = "mesh", meshSizeType = "size", segments = {
      width: 64,
      height: 64
    }, textureUniform = "uTexture", useTextureLoader = true } = config3;
    this.el = el;
    this.scene = scene;
    this.segments = segments;
    const texture = useTextureLoader && !(el instanceof HTMLCanvasElement) ? new TextureLoader().load(el.src) : new Texture(el);
    texture.needsUpdate = true;
    const materialCopy = material2.clone();
    materialCopy.uniforms[textureUniform].value = texture;
    const rect = el.getBoundingClientRect();
    const { width, height } = rect;
    this.rect = rect;
    const geometryMap = {
      size: new PlaneGeometry(width, height, segments.width, segments.height),
      scale: new PlaneGeometry(1, 1, segments.width, segments.height)
    };
    const geometry2 = geometryMap[meshSizeType];
    const meshMap = {
      points: new Points(geometry2, materialCopy),
      mesh: new Mesh(geometry2, materialCopy)
    };
    const mesh = meshMap[meshType];
    if (meshSizeType === "scale") {
      mesh.scale.set(width, height, 1);
    }
    scene.add(mesh);
    this.mesh = mesh;
  }
  // 同步位置
  setPosition(deltaY = window.scrollY) {
    const { mesh, rect } = this;
    const { top, left, width, height } = rect;
    const x = left + width / 2 - window.innerWidth / 2;
    const y = -(top + height / 2 - window.innerHeight / 2) + deltaY;
    mesh.position.set(x, y, 0);
  }
  // 消除
  destroy() {
    this.scene.remove(this.mesh);
  }
};
var MakuGroup = class {
  constructor() {
    __publicField(this, "makus");
    this.makus = [];
  }
  // 添加元素
  add(maku) {
    this.makus.push(maku);
    return maku;
  }
  // 批量添加元素
  addMultiple(makus) {
    makus.forEach((maku) => {
      this.add(maku);
    });
  }
  // 批量同步元素位置
  setPositions(deltaY = window.scrollY) {
    const { makus } = this;
    makus.forEach((obj) => {
      obj.setPosition(deltaY);
    });
  }
  // 清空所有元素
  clear() {
    this.makus.forEach((maku) => maku.destroy());
  }
};
var Scroller = class {
  constructor() {
    __publicField(this, "scroll");
    this.scroll = {
      current: 0,
      target: 0,
      ease: 0.05,
      last: 0,
      delta: 0,
      direction: ""
    };
  }
  // 监听滚动
  listenForScroll() {
    window.addEventListener("scroll", () => {
      const oldScrollY = this.scroll.target;
      const newScrollY = window.scrollY;
      const scrollYDelta = newScrollY - oldScrollY;
      this.scroll.target += scrollYDelta;
    });
  }
  // 同步滚动的数据
  syncScroll() {
    this.scroll.current = MathUtils.lerp(this.scroll.current, this.scroll.target, this.scroll.ease);
    this.scroll.delta = this.scroll.current - this.scroll.last;
    this.scroll.direction = this.scroll.delta > 0 ? "down" : "up";
    this.scroll.last = this.scroll.current;
  }
};
var getScreenFov = (z) => {
  return MathUtils.radToDeg(2 * Math.atan(window.innerHeight / 2 / z));
};

// node_modules/kokomi.js/dist/camera/screenCamera.js
var ScreenCamera = class extends Component {
  constructor(base, config3 = {}) {
    super(base);
    __publicField(this, "camera");
    const { position = new Vector3(0, 0, 600), near = 100, far = 2e3 } = config3;
    const fov = getScreenFov(position.z);
    const container = base.container;
    const aspect = container.clientWidth / container.clientHeight;
    const camera = new PerspectiveCamera(fov, aspect, near, far);
    camera.position.copy(position);
    this.camera = camera;
  }
  addExisting() {
    this.base.camera = this.camera;
    this.base.interactionManager.camera = this.camera;
  }
};

// node_modules/kokomi.js/dist/camera/thirdPersonCamera.js
var ThirdPersonCamera = class extends Component {
  constructor(base, target, config3 = {}) {
    super(base);
    __publicField(this, "target");
    __publicField(this, "camera");
    __publicField(this, "currentPosition");
    __publicField(this, "currentLookAt");
    __publicField(this, "offset");
    __publicField(this, "lookAt");
    __publicField(this, "enabled");
    this.target = target;
    const { camera = this.base.camera, offset = new Vector3(0, 0, -2), lookAt = target.position.clone() } = config3;
    this.camera = camera;
    this.offset = offset;
    this.lookAt = lookAt;
    this.currentPosition = new Vector3();
    this.currentLookAt = new Vector3();
    this.enabled = true;
  }
  get idealOffset() {
    const offset = this.offset.clone();
    offset.applyQuaternion(this.target.quaternion);
    offset.add(this.target.position);
    return offset;
  }
  get idealLookAt() {
    const lookAt = this.lookAt.clone();
    lookAt.applyQuaternion(this.target.quaternion);
    lookAt.add(this.target.position);
    return lookAt;
  }
  update(time) {
    if (!this.enabled) {
      return;
    }
    const { idealOffset, idealLookAt } = this;
    const dt = this.base.clock.deltaTime;
    const dt2 = 1 - Math.pow(1e-3, dt);
    this.currentPosition.lerp(idealOffset, dt2);
    this.currentLookAt.lerp(idealLookAt, dt2);
    this.camera.position.copy(this.currentPosition);
    this.camera.lookAt(this.currentLookAt);
  }
};

// node_modules/kokomi.js/dist/components/resizer.js
var Resizer = class extends Component {
  constructor(base) {
    super(base);
    __publicField(this, "enabled");
    this.enabled = true;
  }
  get aspect() {
    return window.innerWidth / window.innerHeight;
  }
  resizeRenderer(renderer) {
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(2, window.devicePixelRatio));
  }
  resizeComposer(composer) {
    composer.setSize(window.innerWidth, window.innerHeight);
    if (composer.setPixelRatio) {
      composer.setPixelRatio(Math.min(2, window.devicePixelRatio));
    }
  }
  resizeCamera(camera) {
    const { aspect } = this;
    if (camera instanceof PerspectiveCamera) {
      camera.aspect = aspect;
      camera.updateProjectionMatrix();
    } else if (camera instanceof OrthographicCamera2) {
      const { frustum: frustum2, useAspect } = camera;
      if (frustum2) {
        const actualAspect = useAspect ? aspect : 1;
        [camera.left, camera.right, camera.top, camera.bottom] = [
          actualAspect * frustum2 * -0.5,
          actualAspect * frustum2 * 0.5,
          frustum2 * 0.5,
          frustum2 * -0.5
        ];
        camera.updateProjectionMatrix();
      }
    }
  }
  resize() {
    const { base } = this;
    const { renderer, camera, composer } = base;
    this.resizeRenderer(renderer);
    if (composer) {
      this.resizeComposer(composer);
    }
    this.resizeCamera(camera);
    this.emit("resize");
  }
  listenForResize() {
    window.addEventListener("resize", () => {
      if (!this.enabled) {
        return;
      }
      this.resize();
    });
  }
  enable() {
    this.enabled = true;
  }
  disable() {
    this.enabled = false;
  }
};

// node_modules/kokomi.js/dist/components/stats.js
var import_stats = __toESM(require_stats_min());
var Stats = class extends Component {
  constructor(base) {
    super(base);
    __publicField(this, "stats");
    const stats = new import_stats.default();
    this.stats = stats;
    this.base.container.appendChild(this.stats.dom);
  }
  update(time) {
    this.stats.update();
  }
};

// node_modules/kokomi.js/dist/base/base.js
var Base = class {
  constructor(sel = "#sketch", config3 = {}) {
    __publicField(this, "camera");
    __publicField(this, "scene");
    __publicField(this, "renderer");
    __publicField(this, "container");
    __publicField(this, "animator");
    __publicField(this, "interactionManager");
    __publicField(this, "composer");
    __publicField(this, "clock");
    __publicField(this, "iMouse");
    __publicField(this, "physics");
    __publicField(this, "resizer");
    __publicField(this, "keyboard");
    const { hello = true, gl = {} } = config3;
    if (hello) {
      console.log(`%c- powered by kokomi.js -`, `padding: 5px 10px; background: #030A8C; font-size: 11px`);
    }
    const camera = new PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 100);
    camera.position.z = 1;
    this.camera = camera;
    const scene = new Scene();
    this.scene = scene;
    const renderer = new WebGLRenderer({
      antialias: true,
      alpha: true,
      ...gl
    });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(2, window.devicePixelRatio));
    this.renderer = renderer;
    const container = document.querySelector(sel);
    container == null ? void 0 : container.appendChild(renderer.domElement);
    this.container = container;
    const animator = new Animator(this);
    this.animator = animator;
    const interactionManager = new a(this.renderer, this.camera, this.renderer.domElement);
    this.interactionManager = interactionManager;
    this.composer = null;
    const clock = new Clock2(this);
    this.clock = clock;
    const iMouse = new IMouse(this);
    this.iMouse = iMouse;
    const physics = new Physics(this);
    this.physics = physics;
    const resizer = new Resizer(this);
    this.resizer = resizer;
    const keyboard = new Keyboard();
    this.keyboard = keyboard;
    this.init();
    this.addEventListeners();
  }
  addEventListeners() {
    this.resizer.listenForResize();
    this.iMouse.listenForMouse();
    this.keyboard.listenForKey();
  }
  update(fn) {
    this.animator.add(fn);
  }
  init() {
    this.update(() => {
      this.interactionManager.update();
    });
    this.animator.update();
  }
  render() {
    if (this.composer) {
      this.composer.render();
    } else {
      this.renderer.render(this.scene, this.camera);
    }
  }
  async saveScreenshot(name = `screenshot.png`) {
    this.render();
    const blob = await new Promise((resolve) => {
      this.renderer.domElement.toBlob(resolve, "image/png");
    });
    if (blob) {
      downloadBlob(blob, name);
    }
  }
};

// node_modules/camera-controls/dist/camera-controls.module.js
var MOUSE_BUTTON = {
  LEFT: 1,
  RIGHT: 2,
  MIDDLE: 4
};
var ACTION = Object.freeze({
  NONE: 0,
  ROTATE: 1,
  TRUCK: 2,
  OFFSET: 4,
  DOLLY: 8,
  ZOOM: 16,
  TOUCH_ROTATE: 32,
  TOUCH_TRUCK: 64,
  TOUCH_OFFSET: 128,
  TOUCH_DOLLY: 256,
  TOUCH_ZOOM: 512,
  TOUCH_DOLLY_TRUCK: 1024,
  TOUCH_DOLLY_OFFSET: 2048,
  TOUCH_DOLLY_ROTATE: 4096,
  TOUCH_ZOOM_TRUCK: 8192,
  TOUCH_ZOOM_OFFSET: 16384,
  TOUCH_ZOOM_ROTATE: 32768
});
var DOLLY_DIRECTION = {
  NONE: 0,
  IN: 1,
  OUT: -1
};
function isPerspectiveCamera(camera) {
  return camera.isPerspectiveCamera;
}
function isOrthographicCamera(camera) {
  return camera.isOrthographicCamera;
}
var PI_2 = Math.PI * 2;
var PI_HALF = Math.PI / 2;
var EPSILON = 1e-5;
var DEG2RAD = Math.PI / 180;
function clamp2(value, min, max3) {
  return Math.max(min, Math.min(max3, value));
}
function approxZero(number, error = EPSILON) {
  return Math.abs(number) < error;
}
function approxEquals(a4, b5, error = EPSILON) {
  return approxZero(a4 - b5, error);
}
function roundToStep(value, step) {
  return Math.round(value / step) * step;
}
function infinityToMaxNumber(value) {
  if (isFinite(value))
    return value;
  if (value < 0)
    return -Number.MAX_VALUE;
  return Number.MAX_VALUE;
}
function maxNumberToInfinity(value) {
  if (Math.abs(value) < Number.MAX_VALUE)
    return value;
  return value * Infinity;
}
function smoothDamp(current, target, currentVelocityRef, smoothTime, maxSpeed = Infinity, deltaTime) {
  smoothTime = Math.max(1e-4, smoothTime);
  const omega = 2 / smoothTime;
  const x = omega * deltaTime;
  const exp = 1 / (1 + x + 0.48 * x * x + 0.235 * x * x * x);
  let change = current - target;
  const originalTo = target;
  const maxChange = maxSpeed * smoothTime;
  change = clamp2(change, -maxChange, maxChange);
  target = current - change;
  const temp = (currentVelocityRef.value + omega * change) * deltaTime;
  currentVelocityRef.value = (currentVelocityRef.value - omega * temp) * exp;
  let output = target + (change + temp) * exp;
  if (originalTo - current > 0 === output > originalTo) {
    output = originalTo;
    currentVelocityRef.value = (output - originalTo) / deltaTime;
  }
  return output;
}
function smoothDampVec3(current, target, currentVelocityRef, smoothTime, maxSpeed = Infinity, deltaTime, out) {
  smoothTime = Math.max(1e-4, smoothTime);
  const omega = 2 / smoothTime;
  const x = omega * deltaTime;
  const exp = 1 / (1 + x + 0.48 * x * x + 0.235 * x * x * x);
  let targetX = target.x;
  let targetY = target.y;
  let targetZ = target.z;
  let changeX = current.x - targetX;
  let changeY = current.y - targetY;
  let changeZ = current.z - targetZ;
  const originalToX = targetX;
  const originalToY = targetY;
  const originalToZ = targetZ;
  const maxChange = maxSpeed * smoothTime;
  const maxChangeSq = maxChange * maxChange;
  const magnitudeSq = changeX * changeX + changeY * changeY + changeZ * changeZ;
  if (magnitudeSq > maxChangeSq) {
    const magnitude = Math.sqrt(magnitudeSq);
    changeX = changeX / magnitude * maxChange;
    changeY = changeY / magnitude * maxChange;
    changeZ = changeZ / magnitude * maxChange;
  }
  targetX = current.x - changeX;
  targetY = current.y - changeY;
  targetZ = current.z - changeZ;
  const tempX = (currentVelocityRef.x + omega * changeX) * deltaTime;
  const tempY = (currentVelocityRef.y + omega * changeY) * deltaTime;
  const tempZ = (currentVelocityRef.z + omega * changeZ) * deltaTime;
  currentVelocityRef.x = (currentVelocityRef.x - omega * tempX) * exp;
  currentVelocityRef.y = (currentVelocityRef.y - omega * tempY) * exp;
  currentVelocityRef.z = (currentVelocityRef.z - omega * tempZ) * exp;
  out.x = targetX + (changeX + tempX) * exp;
  out.y = targetY + (changeY + tempY) * exp;
  out.z = targetZ + (changeZ + tempZ) * exp;
  const origMinusCurrentX = originalToX - current.x;
  const origMinusCurrentY = originalToY - current.y;
  const origMinusCurrentZ = originalToZ - current.z;
  const outMinusOrigX = out.x - originalToX;
  const outMinusOrigY = out.y - originalToY;
  const outMinusOrigZ = out.z - originalToZ;
  if (origMinusCurrentX * outMinusOrigX + origMinusCurrentY * outMinusOrigY + origMinusCurrentZ * outMinusOrigZ > 0) {
    out.x = originalToX;
    out.y = originalToY;
    out.z = originalToZ;
    currentVelocityRef.x = (out.x - originalToX) / deltaTime;
    currentVelocityRef.y = (out.y - originalToY) / deltaTime;
    currentVelocityRef.z = (out.z - originalToZ) / deltaTime;
  }
  return out;
}
function extractClientCoordFromEvent(pointers, out) {
  out.set(0, 0);
  pointers.forEach((pointer) => {
    out.x += pointer.clientX;
    out.y += pointer.clientY;
  });
  out.x /= pointers.length;
  out.y /= pointers.length;
}
function notSupportedInOrthographicCamera(camera, message) {
  if (isOrthographicCamera(camera)) {
    console.warn(`${message} is not supported in OrthographicCamera`);
    return true;
  }
  return false;
}
var EventDispatcher2 = class {
  constructor() {
    this._listeners = {};
  }
  /**
   * Adds the specified event listener.
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  addEventListener(type, listener) {
    const listeners = this._listeners;
    if (listeners[type] === void 0)
      listeners[type] = [];
    if (listeners[type].indexOf(listener) === -1)
      listeners[type].push(listener);
  }
  /**
   * Presence of the specified event listener.
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  hasEventListener(type, listener) {
    const listeners = this._listeners;
    return listeners[type] !== void 0 && listeners[type].indexOf(listener) !== -1;
  }
  /**
   * Removes the specified event listener
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  removeEventListener(type, listener) {
    const listeners = this._listeners;
    const listenerArray = listeners[type];
    if (listenerArray !== void 0) {
      const index = listenerArray.indexOf(listener);
      if (index !== -1)
        listenerArray.splice(index, 1);
    }
  }
  /**
   * Removes all event listeners
   * @param type event name
   * @category Methods
   */
  removeAllEventListeners(type) {
    if (!type) {
      this._listeners = {};
      return;
    }
    if (Array.isArray(this._listeners[type]))
      this._listeners[type].length = 0;
  }
  /**
   * Fire an event type.
   * @param event DispatcherEvent
   * @category Methods
   */
  dispatchEvent(event) {
    const listeners = this._listeners;
    const listenerArray = listeners[event.type];
    if (listenerArray !== void 0) {
      event.target = this;
      const array = listenerArray.slice(0);
      for (let i3 = 0, l = array.length; i3 < l; i3++) {
        array[i3].call(this, event);
      }
    }
  }
};
var VERSION2 = "2.7.0";
var TOUCH_DOLLY_FACTOR = 1 / 8;
var isBrowser2 = typeof window !== "undefined";
var isMac = isBrowser2 && /Mac/.test(navigator.platform);
var isPointerEventsNotSupported = !(isBrowser2 && "PointerEvent" in window);
var THREE;
var _ORIGIN;
var _AXIS_Y;
var _AXIS_Z;
var _v25;
var _v3A;
var _v3B;
var _v3C;
var _cameraDirection;
var _xColumn;
var _yColumn;
var _zColumn;
var _deltaTarget;
var _deltaOffset;
var _sphericalA;
var _sphericalB;
var _box3A;
var _box3B;
var _sphere3;
var _quaternionA;
var _quaternionB;
var _rotationMatrix;
var _raycaster;
var CameraControls2 = class extends EventDispatcher2 {
  /**
       * Injects THREE as the dependency. You can then proceed to use CameraControls.
       *
       * e.g
       * ```javascript
       * CameraControls.install( { THREE: THREE } );
       * ```
       *
       * Note: If you do not wish to use enter three.js to reduce file size(tree-shaking for example), make a subset to install.
       *
       * ```js
       * import {
       * 	Vector2,
       * 	Vector3,
       * 	Vector4,
       * 	Quaternion,
       * 	Matrix4,
       * 	Spherical,
       * 	Box3,
       * 	Sphere,
       * 	Raycaster,
       * 	MathUtils,
       * } from 'three';
       *
       * const subsetOfTHREE = {
       * 	Vector2   : Vector2,
       * 	Vector3   : Vector3,
       * 	Vector4   : Vector4,
       * 	Quaternion: Quaternion,
       * 	Matrix4   : Matrix4,
       * 	Spherical : Spherical,
       * 	Box3      : Box3,
       * 	Sphere    : Sphere,
       * 	Raycaster : Raycaster,
       * };
  
       * CameraControls.install( { THREE: subsetOfTHREE } );
       * ```
       * @category Statics
       */
  static install(libs) {
    THREE = libs.THREE;
    _ORIGIN = Object.freeze(new THREE.Vector3(0, 0, 0));
    _AXIS_Y = Object.freeze(new THREE.Vector3(0, 1, 0));
    _AXIS_Z = Object.freeze(new THREE.Vector3(0, 0, 1));
    _v25 = new THREE.Vector2();
    _v3A = new THREE.Vector3();
    _v3B = new THREE.Vector3();
    _v3C = new THREE.Vector3();
    _cameraDirection = new THREE.Vector3();
    _xColumn = new THREE.Vector3();
    _yColumn = new THREE.Vector3();
    _zColumn = new THREE.Vector3();
    _deltaTarget = new THREE.Vector3();
    _deltaOffset = new THREE.Vector3();
    _sphericalA = new THREE.Spherical();
    _sphericalB = new THREE.Spherical();
    _box3A = new THREE.Box3();
    _box3B = new THREE.Box3();
    _sphere3 = new THREE.Sphere();
    _quaternionA = new THREE.Quaternion();
    _quaternionB = new THREE.Quaternion();
    _rotationMatrix = new THREE.Matrix4();
    _raycaster = new THREE.Raycaster();
  }
  /**
   * list all ACTIONs
   * @category Statics
   */
  static get ACTION() {
    return ACTION;
  }
  /**
   * Creates a `CameraControls` instance.
   *
   * Note:
   * You **must install** three.js before using camera-controls. see [#install](#install)
   * Not doing so will lead to runtime errors (`undefined` references to THREE).
   *
   * e.g.
   * ```
   * CameraControls.install( { THREE } );
   * const cameraControls = new CameraControls( camera, domElement );
   * ```
   *
   * @param camera A `THREE.PerspectiveCamera` or `THREE.OrthographicCamera` to be controlled.
   * @param domElement A `HTMLElement` for the draggable area, usually `renderer.domElement`.
   * @category Constructor
   */
  constructor(camera, domElement) {
    super();
    this.minPolarAngle = 0;
    this.maxPolarAngle = Math.PI;
    this.minAzimuthAngle = -Infinity;
    this.maxAzimuthAngle = Infinity;
    this.minDistance = Number.EPSILON;
    this.maxDistance = Infinity;
    this.infinityDolly = false;
    this.minZoom = 0.01;
    this.maxZoom = Infinity;
    this.smoothTime = 0.25;
    this.draggingSmoothTime = 0.125;
    this.maxSpeed = Infinity;
    this.azimuthRotateSpeed = 1;
    this.polarRotateSpeed = 1;
    this.dollySpeed = 1;
    this.dollyDragInverted = false;
    this.truckSpeed = 2;
    this.dollyToCursor = false;
    this.dragToOffset = false;
    this.verticalDragToForward = false;
    this.boundaryFriction = 0;
    this.restThreshold = 0.01;
    this.colliderMeshes = [];
    this.cancel = () => {
    };
    this._enabled = true;
    this._state = ACTION.NONE;
    this._viewport = null;
    this._changedDolly = 0;
    this._changedZoom = 0;
    this._hasRested = true;
    this._boundaryEnclosesCamera = false;
    this._needsUpdate = true;
    this._updatedLastTime = false;
    this._elementRect = new DOMRect();
    this._isDragging = false;
    this._activePointers = [];
    this._lockedPointer = null;
    this._interactiveArea = new DOMRect(0, 0, 1, 1);
    this._isUserControllingRotate = false;
    this._isUserControllingDolly = false;
    this._isUserControllingTruck = false;
    this._isUserControllingOffset = false;
    this._isUserControllingZoom = false;
    this._lastDollyDirection = DOLLY_DIRECTION.NONE;
    this._thetaVelocity = { value: 0 };
    this._phiVelocity = { value: 0 };
    this._radiusVelocity = { value: 0 };
    this._targetVelocity = new THREE.Vector3();
    this._focalOffsetVelocity = new THREE.Vector3();
    this._zoomVelocity = { value: 0 };
    this._truckInternal = (deltaX, deltaY, dragToOffset) => {
      let truckX;
      let pedestalY;
      if (isPerspectiveCamera(this._camera)) {
        const offset = _v3A.copy(this._camera.position).sub(this._target);
        const fov = this._camera.getEffectiveFOV() * DEG2RAD;
        const targetDistance = offset.length() * Math.tan(fov * 0.5);
        truckX = this.truckSpeed * deltaX * targetDistance / this._elementRect.height;
        pedestalY = this.truckSpeed * deltaY * targetDistance / this._elementRect.height;
      } else if (isOrthographicCamera(this._camera)) {
        const camera2 = this._camera;
        truckX = deltaX * (camera2.right - camera2.left) / camera2.zoom / this._elementRect.width;
        pedestalY = deltaY * (camera2.top - camera2.bottom) / camera2.zoom / this._elementRect.height;
      } else {
        return;
      }
      if (this.verticalDragToForward) {
        dragToOffset ? this.setFocalOffset(this._focalOffsetEnd.x + truckX, this._focalOffsetEnd.y, this._focalOffsetEnd.z, true) : this.truck(truckX, 0, true);
        this.forward(-pedestalY, true);
      } else {
        dragToOffset ? this.setFocalOffset(this._focalOffsetEnd.x + truckX, this._focalOffsetEnd.y + pedestalY, this._focalOffsetEnd.z, true) : this.truck(truckX, pedestalY, true);
      }
    };
    this._rotateInternal = (deltaX, deltaY) => {
      const theta = PI_2 * this.azimuthRotateSpeed * deltaX / this._elementRect.height;
      const phi = PI_2 * this.polarRotateSpeed * deltaY / this._elementRect.height;
      this.rotate(theta, phi, true);
    };
    this._dollyInternal = (delta, x, y) => {
      const dollyScale = Math.pow(0.95, -delta * this.dollySpeed);
      const lastDistance = this._sphericalEnd.radius;
      const distance2 = this._sphericalEnd.radius * dollyScale;
      const clampedDistance = THREE.MathUtils.clamp(distance2, this.minDistance, this.maxDistance);
      const overflowedDistance = clampedDistance - distance2;
      if (this.infinityDolly && this.dollyToCursor) {
        this._dollyToNoClamp(distance2, true);
      } else if (this.infinityDolly && !this.dollyToCursor) {
        this.dollyInFixed(overflowedDistance, true);
        this._dollyToNoClamp(clampedDistance, true);
      } else {
        this._dollyToNoClamp(clampedDistance, true);
      }
      if (this.dollyToCursor) {
        this._changedDolly += (this.infinityDolly ? distance2 : clampedDistance) - lastDistance;
        this._dollyControlCoord.set(x, y);
      }
      this._lastDollyDirection = Math.sign(-delta);
    };
    this._zoomInternal = (delta, x, y) => {
      const zoomScale = Math.pow(0.95, delta * this.dollySpeed);
      const lastZoom = this._zoom;
      const zoom = this._zoom * zoomScale;
      this.zoomTo(zoom, true);
      if (this.dollyToCursor) {
        this._changedZoom += zoom - lastZoom;
        this._dollyControlCoord.set(x, y);
      }
    };
    if (typeof THREE === "undefined") {
      console.error("camera-controls: `THREE` is undefined. You must first run `CameraControls.install( { THREE: THREE } )`. Check the docs for further information.");
    }
    this._camera = camera;
    this._yAxisUpSpace = new THREE.Quaternion().setFromUnitVectors(this._camera.up, _AXIS_Y);
    this._yAxisUpSpaceInverse = this._yAxisUpSpace.clone().invert();
    this._state = ACTION.NONE;
    this._target = new THREE.Vector3();
    this._targetEnd = this._target.clone();
    this._focalOffset = new THREE.Vector3();
    this._focalOffsetEnd = this._focalOffset.clone();
    this._spherical = new THREE.Spherical().setFromVector3(_v3A.copy(this._camera.position).applyQuaternion(this._yAxisUpSpace));
    this._sphericalEnd = this._spherical.clone();
    this._lastDistance = this._spherical.radius;
    this._zoom = this._camera.zoom;
    this._zoomEnd = this._zoom;
    this._lastZoom = this._zoom;
    this._nearPlaneCorners = [
      new THREE.Vector3(),
      new THREE.Vector3(),
      new THREE.Vector3(),
      new THREE.Vector3()
    ];
    this._updateNearPlaneCorners();
    this._boundary = new THREE.Box3(new THREE.Vector3(-Infinity, -Infinity, -Infinity), new THREE.Vector3(Infinity, Infinity, Infinity));
    this._cameraUp0 = this._camera.up.clone();
    this._target0 = this._target.clone();
    this._position0 = this._camera.position.clone();
    this._zoom0 = this._zoom;
    this._focalOffset0 = this._focalOffset.clone();
    this._dollyControlCoord = new THREE.Vector2();
    this.mouseButtons = {
      left: ACTION.ROTATE,
      middle: ACTION.DOLLY,
      right: ACTION.TRUCK,
      wheel: isPerspectiveCamera(this._camera) ? ACTION.DOLLY : isOrthographicCamera(this._camera) ? ACTION.ZOOM : ACTION.NONE
    };
    this.touches = {
      one: ACTION.TOUCH_ROTATE,
      two: isPerspectiveCamera(this._camera) ? ACTION.TOUCH_DOLLY_TRUCK : isOrthographicCamera(this._camera) ? ACTION.TOUCH_ZOOM_TRUCK : ACTION.NONE,
      three: ACTION.TOUCH_TRUCK
    };
    const dragStartPosition = new THREE.Vector2();
    const lastDragPosition = new THREE.Vector2();
    const dollyStart = new THREE.Vector2();
    const onPointerDown = (event) => {
      if (!this._enabled || !this._domElement)
        return;
      if (this._interactiveArea.left !== 0 || this._interactiveArea.top !== 0 || this._interactiveArea.width !== 1 || this._interactiveArea.height !== 1) {
        const elRect = this._domElement.getBoundingClientRect();
        const left = event.clientX / elRect.width;
        const top = event.clientY / elRect.height;
        if (left < this._interactiveArea.left || left > this._interactiveArea.right || top < this._interactiveArea.top || top > this._interactiveArea.bottom)
          return;
      }
      const mouseButton = event.pointerType !== "mouse" ? null : (event.buttons & MOUSE_BUTTON.LEFT) === MOUSE_BUTTON.LEFT ? MOUSE_BUTTON.LEFT : (event.buttons & MOUSE_BUTTON.MIDDLE) === MOUSE_BUTTON.MIDDLE ? MOUSE_BUTTON.MIDDLE : (event.buttons & MOUSE_BUTTON.RIGHT) === MOUSE_BUTTON.RIGHT ? MOUSE_BUTTON.RIGHT : null;
      if (mouseButton !== null) {
        const zombiePointer = this._findPointerByMouseButton(mouseButton);
        zombiePointer && this._disposePointer(zombiePointer);
      }
      if ((event.buttons & MOUSE_BUTTON.LEFT) === MOUSE_BUTTON.LEFT && this._lockedPointer)
        return;
      const pointer = {
        pointerId: event.pointerId,
        clientX: event.clientX,
        clientY: event.clientY,
        deltaX: 0,
        deltaY: 0,
        mouseButton
      };
      this._activePointers.push(pointer);
      this._domElement.ownerDocument.removeEventListener("pointermove", onPointerMove, { passive: false });
      this._domElement.ownerDocument.removeEventListener("pointerup", onPointerUp);
      this._domElement.ownerDocument.addEventListener("pointermove", onPointerMove, { passive: false });
      this._domElement.ownerDocument.addEventListener("pointerup", onPointerUp);
      this._isDragging = true;
      startDragging(event);
    };
    const onMouseDown = (event) => {
      if (!this._enabled || !this._domElement || this._lockedPointer)
        return;
      if (this._interactiveArea.left !== 0 || this._interactiveArea.top !== 0 || this._interactiveArea.width !== 1 || this._interactiveArea.height !== 1) {
        const elRect = this._domElement.getBoundingClientRect();
        const left = event.clientX / elRect.width;
        const top = event.clientY / elRect.height;
        if (left < this._interactiveArea.left || left > this._interactiveArea.right || top < this._interactiveArea.top || top > this._interactiveArea.bottom)
          return;
      }
      const mouseButton = (event.buttons & MOUSE_BUTTON.LEFT) === MOUSE_BUTTON.LEFT ? MOUSE_BUTTON.LEFT : (event.buttons & MOUSE_BUTTON.MIDDLE) === MOUSE_BUTTON.MIDDLE ? MOUSE_BUTTON.MIDDLE : (event.buttons & MOUSE_BUTTON.RIGHT) === MOUSE_BUTTON.RIGHT ? MOUSE_BUTTON.RIGHT : null;
      if (mouseButton !== null) {
        const zombiePointer = this._findPointerByMouseButton(mouseButton);
        zombiePointer && this._disposePointer(zombiePointer);
      }
      const pointer = {
        pointerId: 1,
        clientX: event.clientX,
        clientY: event.clientY,
        deltaX: 0,
        deltaY: 0,
        mouseButton: (event.buttons & MOUSE_BUTTON.LEFT) === MOUSE_BUTTON.LEFT ? MOUSE_BUTTON.LEFT : (event.buttons & MOUSE_BUTTON.MIDDLE) === MOUSE_BUTTON.LEFT ? MOUSE_BUTTON.MIDDLE : (event.buttons & MOUSE_BUTTON.RIGHT) === MOUSE_BUTTON.LEFT ? MOUSE_BUTTON.RIGHT : null
      };
      this._activePointers.push(pointer);
      this._domElement.ownerDocument.removeEventListener("mousemove", onMouseMove);
      this._domElement.ownerDocument.removeEventListener("mouseup", onMouseUp);
      this._domElement.ownerDocument.addEventListener("mousemove", onMouseMove);
      this._domElement.ownerDocument.addEventListener("mouseup", onMouseUp);
      this._isDragging = true;
      startDragging(event);
    };
    const onPointerMove = (event) => {
      if (event.cancelable)
        event.preventDefault();
      const pointerId = event.pointerId;
      const pointer = this._lockedPointer || this._findPointerById(pointerId);
      if (!pointer)
        return;
      pointer.clientX = event.clientX;
      pointer.clientY = event.clientY;
      pointer.deltaX = event.movementX;
      pointer.deltaY = event.movementY;
      this._state = 0;
      if (event.pointerType === "touch") {
        switch (this._activePointers.length) {
          case 1:
            this._state = this.touches.one;
            break;
          case 2:
            this._state = this.touches.two;
            break;
          case 3:
            this._state = this.touches.three;
            break;
        }
      } else {
        if (!this._isDragging && this._lockedPointer || this._isDragging && (event.buttons & MOUSE_BUTTON.LEFT) === MOUSE_BUTTON.LEFT) {
          this._state = this._state | this.mouseButtons.left;
        }
        if (this._isDragging && (event.buttons & MOUSE_BUTTON.MIDDLE) === MOUSE_BUTTON.MIDDLE) {
          this._state = this._state | this.mouseButtons.middle;
        }
        if (this._isDragging && (event.buttons & MOUSE_BUTTON.RIGHT) === MOUSE_BUTTON.RIGHT) {
          this._state = this._state | this.mouseButtons.right;
        }
      }
      dragging();
    };
    const onMouseMove = (event) => {
      const pointer = this._lockedPointer || this._findPointerById(1);
      if (!pointer)
        return;
      pointer.clientX = event.clientX;
      pointer.clientY = event.clientY;
      pointer.deltaX = event.movementX;
      pointer.deltaY = event.movementY;
      this._state = 0;
      if (this._lockedPointer || (event.buttons & MOUSE_BUTTON.LEFT) === MOUSE_BUTTON.LEFT) {
        this._state = this._state | this.mouseButtons.left;
      }
      if ((event.buttons & MOUSE_BUTTON.MIDDLE) === MOUSE_BUTTON.MIDDLE) {
        this._state = this._state | this.mouseButtons.middle;
      }
      if ((event.buttons & MOUSE_BUTTON.RIGHT) === MOUSE_BUTTON.RIGHT) {
        this._state = this._state | this.mouseButtons.right;
      }
      dragging();
    };
    const onPointerUp = (event) => {
      const pointer = this._findPointerById(event.pointerId);
      if (pointer && pointer === this._lockedPointer)
        return;
      pointer && this._disposePointer(pointer);
      if (event.pointerType === "touch") {
        switch (this._activePointers.length) {
          case 0:
            this._state = ACTION.NONE;
            break;
          case 1:
            this._state = this.touches.one;
            break;
          case 2:
            this._state = this.touches.two;
            break;
          case 3:
            this._state = this.touches.three;
            break;
        }
      } else {
        this._state = ACTION.NONE;
      }
      endDragging();
    };
    const onMouseUp = () => {
      const pointer = this._findPointerById(1);
      if (pointer && pointer === this._lockedPointer)
        return;
      pointer && this._disposePointer(pointer);
      this._state = ACTION.NONE;
      endDragging();
    };
    let lastScrollTimeStamp = -1;
    const onMouseWheel = (event) => {
      if (!this._domElement)
        return;
      if (!this._enabled || this.mouseButtons.wheel === ACTION.NONE)
        return;
      if (this._interactiveArea.left !== 0 || this._interactiveArea.top !== 0 || this._interactiveArea.width !== 1 || this._interactiveArea.height !== 1) {
        const elRect = this._domElement.getBoundingClientRect();
        const left = event.clientX / elRect.width;
        const top = event.clientY / elRect.height;
        if (left < this._interactiveArea.left || left > this._interactiveArea.right || top < this._interactiveArea.top || top > this._interactiveArea.bottom)
          return;
      }
      event.preventDefault();
      if (this.dollyToCursor || this.mouseButtons.wheel === ACTION.ROTATE || this.mouseButtons.wheel === ACTION.TRUCK) {
        const now2 = performance.now();
        if (lastScrollTimeStamp - now2 < 1e3)
          this._getClientRect(this._elementRect);
        lastScrollTimeStamp = now2;
      }
      const deltaYFactor = isMac ? -1 : -3;
      const delta = event.deltaMode === 1 ? event.deltaY / deltaYFactor : event.deltaY / (deltaYFactor * 10);
      const x = this.dollyToCursor ? (event.clientX - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0;
      const y = this.dollyToCursor ? (event.clientY - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0;
      switch (this.mouseButtons.wheel) {
        case ACTION.ROTATE: {
          this._rotateInternal(event.deltaX, event.deltaY);
          this._isUserControllingRotate = true;
          break;
        }
        case ACTION.TRUCK: {
          this._truckInternal(event.deltaX, event.deltaY, false);
          this._isUserControllingTruck = true;
          break;
        }
        case ACTION.OFFSET: {
          this._truckInternal(event.deltaX, event.deltaY, true);
          this._isUserControllingOffset = true;
          break;
        }
        case ACTION.DOLLY: {
          this._dollyInternal(-delta, x, y);
          this._isUserControllingDolly = true;
          break;
        }
        case ACTION.ZOOM: {
          this._zoomInternal(-delta, x, y);
          this._isUserControllingZoom = true;
          break;
        }
      }
      this.dispatchEvent({ type: "control" });
    };
    const onContextMenu = (event) => {
      if (!this._domElement || !this._enabled)
        return;
      if (this.mouseButtons.right === CameraControls2.ACTION.NONE) {
        const pointerId = event instanceof PointerEvent ? event.pointerId : event instanceof MouseEvent ? 0 : 0;
        const pointer = this._findPointerById(pointerId);
        pointer && this._disposePointer(pointer);
        this._domElement.ownerDocument.removeEventListener("pointermove", onPointerMove, { passive: false });
        this._domElement.ownerDocument.removeEventListener("pointerup", onPointerUp);
        this._domElement.ownerDocument.removeEventListener("mousemove", onMouseMove);
        this._domElement.ownerDocument.removeEventListener("mouseup", onMouseUp);
        return;
      }
      event.preventDefault();
    };
    const startDragging = (event) => {
      if (!this._enabled)
        return;
      extractClientCoordFromEvent(this._activePointers, _v25);
      this._getClientRect(this._elementRect);
      dragStartPosition.copy(_v25);
      lastDragPosition.copy(_v25);
      const isMultiTouch = this._activePointers.length >= 2;
      if (isMultiTouch) {
        const dx = _v25.x - this._activePointers[1].clientX;
        const dy = _v25.y - this._activePointers[1].clientY;
        const distance2 = Math.sqrt(dx * dx + dy * dy);
        dollyStart.set(0, distance2);
        const x = (this._activePointers[0].clientX + this._activePointers[1].clientX) * 0.5;
        const y = (this._activePointers[0].clientY + this._activePointers[1].clientY) * 0.5;
        lastDragPosition.set(x, y);
      }
      this._state = 0;
      if (!event) {
        if (this._lockedPointer)
          this._state = this._state | this.mouseButtons.left;
      } else if ("pointerType" in event && event.pointerType === "touch") {
        switch (this._activePointers.length) {
          case 1:
            this._state = this.touches.one;
            break;
          case 2:
            this._state = this.touches.two;
            break;
          case 3:
            this._state = this.touches.three;
            break;
        }
      } else {
        if (!this._lockedPointer && (event.buttons & MOUSE_BUTTON.LEFT) === MOUSE_BUTTON.LEFT) {
          this._state = this._state | this.mouseButtons.left;
        }
        if ((event.buttons & MOUSE_BUTTON.MIDDLE) === MOUSE_BUTTON.MIDDLE) {
          this._state = this._state | this.mouseButtons.middle;
        }
        if ((event.buttons & MOUSE_BUTTON.RIGHT) === MOUSE_BUTTON.RIGHT) {
          this._state = this._state | this.mouseButtons.right;
        }
      }
      if ((this._state & ACTION.ROTATE) === ACTION.ROTATE || (this._state & ACTION.TOUCH_ROTATE) === ACTION.TOUCH_ROTATE || (this._state & ACTION.TOUCH_DOLLY_ROTATE) === ACTION.TOUCH_DOLLY_ROTATE || (this._state & ACTION.TOUCH_ZOOM_ROTATE) === ACTION.TOUCH_ZOOM_ROTATE) {
        this._sphericalEnd.theta = this._spherical.theta;
        this._sphericalEnd.phi = this._spherical.phi;
        this._thetaVelocity.value = 0;
        this._phiVelocity.value = 0;
      }
      if ((this._state & ACTION.TRUCK) === ACTION.TRUCK || (this._state & ACTION.TOUCH_TRUCK) === ACTION.TOUCH_TRUCK || (this._state & ACTION.TOUCH_DOLLY_TRUCK) === ACTION.TOUCH_DOLLY_TRUCK || (this._state & ACTION.TOUCH_ZOOM_TRUCK) === ACTION.TOUCH_ZOOM_TRUCK) {
        this._targetEnd.copy(this._target);
        this._targetVelocity.set(0, 0, 0);
      }
      if ((this._state & ACTION.DOLLY) === ACTION.DOLLY || (this._state & ACTION.TOUCH_DOLLY) === ACTION.TOUCH_DOLLY || (this._state & ACTION.TOUCH_DOLLY_TRUCK) === ACTION.TOUCH_DOLLY_TRUCK || (this._state & ACTION.TOUCH_DOLLY_OFFSET) === ACTION.TOUCH_DOLLY_OFFSET || (this._state & ACTION.TOUCH_DOLLY_ROTATE) === ACTION.TOUCH_DOLLY_ROTATE) {
        this._sphericalEnd.radius = this._spherical.radius;
        this._radiusVelocity.value = 0;
      }
      if ((this._state & ACTION.ZOOM) === ACTION.ZOOM || (this._state & ACTION.TOUCH_ZOOM) === ACTION.TOUCH_ZOOM || (this._state & ACTION.TOUCH_ZOOM_TRUCK) === ACTION.TOUCH_ZOOM_TRUCK || (this._state & ACTION.TOUCH_ZOOM_OFFSET) === ACTION.TOUCH_ZOOM_OFFSET || (this._state & ACTION.TOUCH_ZOOM_ROTATE) === ACTION.TOUCH_ZOOM_ROTATE) {
        this._zoomEnd = this._zoom;
        this._zoomVelocity.value = 0;
      }
      if ((this._state & ACTION.OFFSET) === ACTION.OFFSET || (this._state & ACTION.TOUCH_OFFSET) === ACTION.TOUCH_OFFSET || (this._state & ACTION.TOUCH_DOLLY_OFFSET) === ACTION.TOUCH_DOLLY_OFFSET || (this._state & ACTION.TOUCH_ZOOM_OFFSET) === ACTION.TOUCH_ZOOM_OFFSET) {
        this._focalOffsetEnd.copy(this._focalOffset);
        this._focalOffsetVelocity.set(0, 0, 0);
      }
      this.dispatchEvent({ type: "controlstart" });
    };
    const dragging = () => {
      if (!this._enabled)
        return;
      extractClientCoordFromEvent(this._activePointers, _v25);
      const isPointerLockActive = this._domElement && document.pointerLockElement === this._domElement;
      const lockedPointer = isPointerLockActive ? this._lockedPointer || this._activePointers[0] : null;
      const deltaX = lockedPointer ? -lockedPointer.deltaX : lastDragPosition.x - _v25.x;
      const deltaY = lockedPointer ? -lockedPointer.deltaY : lastDragPosition.y - _v25.y;
      lastDragPosition.copy(_v25);
      if ((this._state & ACTION.ROTATE) === ACTION.ROTATE || (this._state & ACTION.TOUCH_ROTATE) === ACTION.TOUCH_ROTATE || (this._state & ACTION.TOUCH_DOLLY_ROTATE) === ACTION.TOUCH_DOLLY_ROTATE || (this._state & ACTION.TOUCH_ZOOM_ROTATE) === ACTION.TOUCH_ZOOM_ROTATE) {
        this._rotateInternal(deltaX, deltaY);
        this._isUserControllingRotate = true;
      }
      if ((this._state & ACTION.DOLLY) === ACTION.DOLLY || (this._state & ACTION.ZOOM) === ACTION.ZOOM) {
        const dollyX = this.dollyToCursor ? (dragStartPosition.x - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0;
        const dollyY = this.dollyToCursor ? (dragStartPosition.y - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0;
        const dollyDirection = this.dollyDragInverted ? -1 : 1;
        if ((this._state & ACTION.DOLLY) === ACTION.DOLLY) {
          this._dollyInternal(dollyDirection * deltaY * TOUCH_DOLLY_FACTOR, dollyX, dollyY);
          this._isUserControllingDolly = true;
        } else {
          this._zoomInternal(dollyDirection * deltaY * TOUCH_DOLLY_FACTOR, dollyX, dollyY);
          this._isUserControllingZoom = true;
        }
      }
      if ((this._state & ACTION.TOUCH_DOLLY) === ACTION.TOUCH_DOLLY || (this._state & ACTION.TOUCH_ZOOM) === ACTION.TOUCH_ZOOM || (this._state & ACTION.TOUCH_DOLLY_TRUCK) === ACTION.TOUCH_DOLLY_TRUCK || (this._state & ACTION.TOUCH_ZOOM_TRUCK) === ACTION.TOUCH_ZOOM_TRUCK || (this._state & ACTION.TOUCH_DOLLY_OFFSET) === ACTION.TOUCH_DOLLY_OFFSET || (this._state & ACTION.TOUCH_ZOOM_OFFSET) === ACTION.TOUCH_ZOOM_OFFSET || (this._state & ACTION.TOUCH_DOLLY_ROTATE) === ACTION.TOUCH_DOLLY_ROTATE || (this._state & ACTION.TOUCH_ZOOM_ROTATE) === ACTION.TOUCH_ZOOM_ROTATE) {
        const dx = _v25.x - this._activePointers[1].clientX;
        const dy = _v25.y - this._activePointers[1].clientY;
        const distance2 = Math.sqrt(dx * dx + dy * dy);
        const dollyDelta = dollyStart.y - distance2;
        dollyStart.set(0, distance2);
        const dollyX = this.dollyToCursor ? (lastDragPosition.x - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0;
        const dollyY = this.dollyToCursor ? (lastDragPosition.y - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0;
        if ((this._state & ACTION.TOUCH_DOLLY) === ACTION.TOUCH_DOLLY || (this._state & ACTION.TOUCH_DOLLY_ROTATE) === ACTION.TOUCH_DOLLY_ROTATE || (this._state & ACTION.TOUCH_DOLLY_TRUCK) === ACTION.TOUCH_DOLLY_TRUCK || (this._state & ACTION.TOUCH_DOLLY_OFFSET) === ACTION.TOUCH_DOLLY_OFFSET) {
          this._dollyInternal(dollyDelta * TOUCH_DOLLY_FACTOR, dollyX, dollyY);
          this._isUserControllingDolly = true;
        } else {
          this._zoomInternal(dollyDelta * TOUCH_DOLLY_FACTOR, dollyX, dollyY);
          this._isUserControllingZoom = true;
        }
      }
      if ((this._state & ACTION.TRUCK) === ACTION.TRUCK || (this._state & ACTION.TOUCH_TRUCK) === ACTION.TOUCH_TRUCK || (this._state & ACTION.TOUCH_DOLLY_TRUCK) === ACTION.TOUCH_DOLLY_TRUCK || (this._state & ACTION.TOUCH_ZOOM_TRUCK) === ACTION.TOUCH_ZOOM_TRUCK) {
        this._truckInternal(deltaX, deltaY, false);
        this._isUserControllingTruck = true;
      }
      if ((this._state & ACTION.OFFSET) === ACTION.OFFSET || (this._state & ACTION.TOUCH_OFFSET) === ACTION.TOUCH_OFFSET || (this._state & ACTION.TOUCH_DOLLY_OFFSET) === ACTION.TOUCH_DOLLY_OFFSET || (this._state & ACTION.TOUCH_ZOOM_OFFSET) === ACTION.TOUCH_ZOOM_OFFSET) {
        this._truckInternal(deltaX, deltaY, true);
        this._isUserControllingOffset = true;
      }
      this.dispatchEvent({ type: "control" });
    };
    const endDragging = () => {
      extractClientCoordFromEvent(this._activePointers, _v25);
      lastDragPosition.copy(_v25);
      if (this._activePointers.length === 0 || this._activePointers.length === 1 && this._activePointers[0] === this._lockedPointer) {
        this._isDragging = false;
      }
      if (this._activePointers.length === 0 && this._domElement) {
        this._domElement.ownerDocument.removeEventListener("pointermove", onPointerMove, { passive: false });
        this._domElement.ownerDocument.removeEventListener("mousemove", onMouseMove);
        this._domElement.ownerDocument.removeEventListener("pointerup", onPointerUp);
        this._domElement.ownerDocument.removeEventListener("mouseup", onMouseUp);
        this.dispatchEvent({ type: "controlend" });
      }
    };
    this.lockPointer = () => {
      if (!this._enabled || !this._domElement)
        return;
      this.cancel();
      this._lockedPointer = {
        pointerId: -1,
        clientX: 0,
        clientY: 0,
        deltaX: 0,
        deltaY: 0,
        mouseButton: null
      };
      this._activePointers.push(this._lockedPointer);
      this._domElement.ownerDocument.removeEventListener("pointermove", onPointerMove, { passive: false });
      this._domElement.ownerDocument.removeEventListener("pointerup", onPointerUp);
      this._domElement.requestPointerLock();
      this._domElement.ownerDocument.addEventListener("pointerlockchange", onPointerLockChange);
      this._domElement.ownerDocument.addEventListener("pointerlockerror", onPointerLockError);
      this._domElement.ownerDocument.addEventListener("pointermove", onPointerMove, { passive: false });
      this._domElement.ownerDocument.addEventListener("pointerup", onPointerUp);
      startDragging();
    };
    this.unlockPointer = () => {
      if (this._lockedPointer !== null) {
        this._disposePointer(this._lockedPointer);
        this._lockedPointer = null;
      }
      document.exitPointerLock();
      this.cancel();
      if (!this._domElement)
        return;
      this._domElement.ownerDocument.removeEventListener("pointerlockchange", onPointerLockChange);
      this._domElement.ownerDocument.removeEventListener("pointerlockerror", onPointerLockError);
    };
    const onPointerLockChange = () => {
      const isPointerLockActive = this._domElement && this._domElement.ownerDocument.pointerLockElement === this._domElement;
      if (!isPointerLockActive)
        this.unlockPointer();
    };
    const onPointerLockError = () => {
      this.unlockPointer();
    };
    this._addAllEventListeners = (domElement2) => {
      this._domElement = domElement2;
      this._domElement.style.touchAction = "none";
      this._domElement.style.userSelect = "none";
      this._domElement.style.webkitUserSelect = "none";
      this._domElement.addEventListener("pointerdown", onPointerDown);
      isPointerEventsNotSupported && this._domElement.addEventListener("mousedown", onMouseDown);
      this._domElement.addEventListener("pointercancel", onPointerUp);
      this._domElement.addEventListener("wheel", onMouseWheel, { passive: false });
      this._domElement.addEventListener("contextmenu", onContextMenu);
    };
    this._removeAllEventListeners = () => {
      if (!this._domElement)
        return;
      this._domElement.style.touchAction = "";
      this._domElement.style.userSelect = "";
      this._domElement.style.webkitUserSelect = "";
      this._domElement.removeEventListener("pointerdown", onPointerDown);
      this._domElement.removeEventListener("mousedown", onMouseDown);
      this._domElement.removeEventListener("pointercancel", onPointerUp);
      this._domElement.removeEventListener("wheel", onMouseWheel, { passive: false });
      this._domElement.removeEventListener("contextmenu", onContextMenu);
      this._domElement.ownerDocument.removeEventListener("pointermove", onPointerMove, { passive: false });
      this._domElement.ownerDocument.removeEventListener("mousemove", onMouseMove);
      this._domElement.ownerDocument.removeEventListener("pointerup", onPointerUp);
      this._domElement.ownerDocument.removeEventListener("mouseup", onMouseUp);
      this._domElement.ownerDocument.removeEventListener("pointerlockchange", onPointerLockChange);
      this._domElement.ownerDocument.removeEventListener("pointerlockerror", onPointerLockError);
    };
    this.cancel = () => {
      if (this._state === ACTION.NONE)
        return;
      this._state = ACTION.NONE;
      this._activePointers.length = 0;
      endDragging();
    };
    if (domElement)
      this.connect(domElement);
    this.update(0);
  }
  /**
   * The camera to be controlled
   * @category Properties
   */
  get camera() {
    return this._camera;
  }
  set camera(camera) {
    this._camera = camera;
    this.updateCameraUp();
    this._camera.updateProjectionMatrix();
    this._updateNearPlaneCorners();
    this._needsUpdate = true;
  }
  /**
   * Whether or not the controls are enabled.
   * `false` to disable user dragging/touch-move, but all methods works.
   * @category Properties
   */
  get enabled() {
    return this._enabled;
  }
  set enabled(enabled) {
    this._enabled = enabled;
    if (!this._domElement)
      return;
    if (enabled) {
      this._domElement.style.touchAction = "none";
      this._domElement.style.userSelect = "none";
      this._domElement.style.webkitUserSelect = "none";
    } else {
      this.cancel();
      this._domElement.style.touchAction = "";
      this._domElement.style.userSelect = "";
      this._domElement.style.webkitUserSelect = "";
    }
  }
  /**
   * Returns `true` if the controls are active updating.
   * readonly value.
   * @category Properties
   */
  get active() {
    return !this._hasRested;
  }
  /**
   * Getter for the current `ACTION`.
   * readonly value.
   * @category Properties
   */
  get currentAction() {
    return this._state;
  }
  /**
   * get/set Current distance.
   * @category Properties
   */
  get distance() {
    return this._spherical.radius;
  }
  set distance(distance2) {
    if (this._spherical.radius === distance2 && this._sphericalEnd.radius === distance2)
      return;
    this._spherical.radius = distance2;
    this._sphericalEnd.radius = distance2;
    this._needsUpdate = true;
  }
  // horizontal angle
  /**
   * get/set the azimuth angle (horizontal) in radians.
   * Every 360 degrees turn is added to `.azimuthAngle` value, which is accumulative.
   * @category Properties
   */
  get azimuthAngle() {
    return this._spherical.theta;
  }
  set azimuthAngle(azimuthAngle) {
    if (this._spherical.theta === azimuthAngle && this._sphericalEnd.theta === azimuthAngle)
      return;
    this._spherical.theta = azimuthAngle;
    this._sphericalEnd.theta = azimuthAngle;
    this._needsUpdate = true;
  }
  // vertical angle
  /**
   * get/set the polar angle (vertical) in radians.
   * @category Properties
   */
  get polarAngle() {
    return this._spherical.phi;
  }
  set polarAngle(polarAngle) {
    if (this._spherical.phi === polarAngle && this._sphericalEnd.phi === polarAngle)
      return;
    this._spherical.phi = polarAngle;
    this._sphericalEnd.phi = polarAngle;
    this._needsUpdate = true;
  }
  /**
   * Whether camera position should be enclosed in the boundary or not.
   * @category Properties
   */
  get boundaryEnclosesCamera() {
    return this._boundaryEnclosesCamera;
  }
  set boundaryEnclosesCamera(boundaryEnclosesCamera) {
    this._boundaryEnclosesCamera = boundaryEnclosesCamera;
    this._needsUpdate = true;
  }
  /**
   * Set drag-start, touches and wheel enable area in the domElement.
   * each values are between `0` and `1` inclusive, where `0` is left/top and `1` is right/bottom of the screen.
   * e.g. `{ x: 0, y: 0, width: 1, height: 1 }` for entire area.
   * @category Properties
   */
  set interactiveArea(interactiveArea) {
    this._interactiveArea.width = clamp2(interactiveArea.width, 0, 1);
    this._interactiveArea.height = clamp2(interactiveArea.height, 0, 1);
    this._interactiveArea.x = clamp2(interactiveArea.x, 0, 1 - this._interactiveArea.width);
    this._interactiveArea.y = clamp2(interactiveArea.x, 0, 1 - this._interactiveArea.height);
  }
  /**
   * Adds the specified event listener.
   * Applicable event types (which is `K`) are:
   * | Event name          | Timing |
   * | ------------------- | ------ |
   * | `'controlstart'`    | When the user starts to control the camera via mouse / touches. ¹ |
   * | `'control'`         | When the user controls the camera (dragging). |
   * | `'controlend'`      | When the user ends to control the camera. ¹ |
   * | `'transitionstart'` | When any kind of transition starts, either user control or using a method with `enableTransition = true` |
   * | `'update'`          | When the camera position is updated. |
   * | `'wake'`            | When the camera starts moving. |
   * | `'rest'`            | When the camera movement is below `.restThreshold` ². |
   * | `'sleep'`           | When the camera end moving. |
   *
   * 1. `mouseButtons.wheel` (Mouse wheel control) does not emit `'controlstart'` and `'controlend'`. `mouseButtons.wheel` uses scroll-event internally, and scroll-event happens intermittently. That means "start" and "end" cannot be detected.
   * 2. Due to damping, `sleep` will usually fire a few seconds after the camera _appears_ to have stopped moving. If you want to do something (e.g. enable UI, perform another transition) at the point when the camera has stopped, you probably want the `rest` event. This can be fine tuned using the `.restThreshold` parameter. See the [Rest and Sleep Example](https://yomotsu.github.io/camera-controls/examples/rest-and-sleep.html).
   *
   * e.g.
   * ```
   * cameraControl.addEventListener( 'controlstart', myCallbackFunction );
   * ```
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  addEventListener(type, listener) {
    super.addEventListener(type, listener);
  }
  /**
   * Removes the specified event listener
   * e.g.
   * ```
   * cameraControl.addEventListener( 'controlstart', myCallbackFunction );
   * ```
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  removeEventListener(type, listener) {
    super.removeEventListener(type, listener);
  }
  /**
   * Rotate azimuthal angle(horizontal) and polar angle(vertical).
   * Every value is added to the current value.
   * @param azimuthAngle Azimuth rotate angle. In radian.
   * @param polarAngle Polar rotate angle. In radian.
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  rotate(azimuthAngle, polarAngle, enableTransition = false) {
    return this.rotateTo(this._sphericalEnd.theta + azimuthAngle, this._sphericalEnd.phi + polarAngle, enableTransition);
  }
  /**
   * Rotate azimuthal angle(horizontal) to the given angle and keep the same polar angle(vertical) target.
   *
   * e.g.
   * ```
   * cameraControls.rotateAzimuthTo( 30 * THREE.MathUtils.DEG2RAD, true );
   * ```
   * @param azimuthAngle Azimuth rotate angle. In radian.
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  rotateAzimuthTo(azimuthAngle, enableTransition = false) {
    return this.rotateTo(azimuthAngle, this._sphericalEnd.phi, enableTransition);
  }
  /**
   * Rotate polar angle(vertical) to the given angle and keep the same azimuthal angle(horizontal) target.
   *
   * e.g.
   * ```
   * cameraControls.rotatePolarTo( 30 * THREE.MathUtils.DEG2RAD, true );
   * ```
   * @param polarAngle Polar rotate angle. In radian.
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  rotatePolarTo(polarAngle, enableTransition = false) {
    return this.rotateTo(this._sphericalEnd.theta, polarAngle, enableTransition);
  }
  /**
   * Rotate azimuthal angle(horizontal) and polar angle(vertical) to the given angle.
   * Camera view will rotate over the orbit pivot absolutely:
   *
   * azimuthAngle
   * ```
   *       0º
   *         \
   * 90º -----+----- -90º
   *           \
   *           180º
   * ```
   * | direction | angle                  |
   * | --------- | ---------------------- |
   * | front     | 0º                     |
   * | left      | 90º (`Math.PI / 2`)    |
   * | right     | -90º (`- Math.PI / 2`) |
   * | back      | 180º (`Math.PI`)       |
   *
   * polarAngle
   * ```
   *     180º
   *      |
   *      90º
   *      |
   *      0º
   * ```
   * | direction            | angle                  |
   * | -------------------- | ---------------------- |
   * | top/sky              | 180º (`Math.PI`)       |
   * | horizontal from view | 90º (`Math.PI / 2`)    |
   * | bottom/floor         | 0º                     |
   *
   * @param azimuthAngle Azimuth rotate angle to. In radian.
   * @param polarAngle Polar rotate angle to. In radian.
   * @param enableTransition  Whether to move smoothly or immediately
   * @category Methods
   */
  rotateTo(azimuthAngle, polarAngle, enableTransition = false) {
    this._isUserControllingRotate = false;
    const theta = clamp2(azimuthAngle, this.minAzimuthAngle, this.maxAzimuthAngle);
    const phi = clamp2(polarAngle, this.minPolarAngle, this.maxPolarAngle);
    this._sphericalEnd.theta = theta;
    this._sphericalEnd.phi = phi;
    this._sphericalEnd.makeSafe();
    this._needsUpdate = true;
    if (!enableTransition) {
      this._spherical.theta = this._sphericalEnd.theta;
      this._spherical.phi = this._sphericalEnd.phi;
    }
    const resolveImmediately = !enableTransition || approxEquals(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) && approxEquals(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold);
    return this._createOnRestPromise(resolveImmediately);
  }
  /**
   * Dolly in/out camera position.
   * @param distance Distance of dollyIn. Negative number for dollyOut.
   * @param enableTransition Whether to move smoothly or immediately.
   * @category Methods
   */
  dolly(distance2, enableTransition = false) {
    return this.dollyTo(this._sphericalEnd.radius - distance2, enableTransition);
  }
  /**
   * Dolly in/out camera position to given distance.
   * @param distance Distance of dolly.
   * @param enableTransition Whether to move smoothly or immediately.
   * @category Methods
   */
  dollyTo(distance2, enableTransition = false) {
    this._isUserControllingDolly = false;
    this._lastDollyDirection = DOLLY_DIRECTION.NONE;
    this._changedDolly = 0;
    return this._dollyToNoClamp(clamp2(distance2, this.minDistance, this.maxDistance), enableTransition);
  }
  _dollyToNoClamp(distance2, enableTransition = false) {
    const lastRadius = this._sphericalEnd.radius;
    const hasCollider = this.colliderMeshes.length >= 1;
    if (hasCollider) {
      const maxDistanceByCollisionTest = this._collisionTest();
      const isCollided = approxEquals(maxDistanceByCollisionTest, this._spherical.radius);
      const isDollyIn = lastRadius > distance2;
      if (!isDollyIn && isCollided)
        return Promise.resolve();
      this._sphericalEnd.radius = Math.min(distance2, maxDistanceByCollisionTest);
    } else {
      this._sphericalEnd.radius = distance2;
    }
    this._needsUpdate = true;
    if (!enableTransition) {
      this._spherical.radius = this._sphericalEnd.radius;
    }
    const resolveImmediately = !enableTransition || approxEquals(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold);
    return this._createOnRestPromise(resolveImmediately);
  }
  /**
   * Dolly in, but does not change the distance between the target and the camera, and moves the target position instead.
   * Specify a negative value for dolly out.
   * @param distance Distance of dolly.
   * @param enableTransition Whether to move smoothly or immediately.
   * @category Methods
   */
  dollyInFixed(distance2, enableTransition = false) {
    this._targetEnd.add(this._getCameraDirection(_cameraDirection).multiplyScalar(distance2));
    if (!enableTransition) {
      this._target.copy(this._targetEnd);
    }
    const resolveImmediately = !enableTransition || approxEquals(this._target.x, this._targetEnd.x, this.restThreshold) && approxEquals(this._target.y, this._targetEnd.y, this.restThreshold) && approxEquals(this._target.z, this._targetEnd.z, this.restThreshold);
    return this._createOnRestPromise(resolveImmediately);
  }
  /**
   * Zoom in/out camera. The value is added to camera zoom.
   * Limits set with `.minZoom` and `.maxZoom`
   * @param zoomStep zoom scale
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  zoom(zoomStep, enableTransition = false) {
    return this.zoomTo(this._zoomEnd + zoomStep, enableTransition);
  }
  /**
   * Zoom in/out camera to given scale. The value overwrites camera zoom.
   * Limits set with .minZoom and .maxZoom
   * @param zoom
   * @param enableTransition
   * @category Methods
   */
  zoomTo(zoom, enableTransition = false) {
    this._isUserControllingZoom = false;
    this._zoomEnd = clamp2(zoom, this.minZoom, this.maxZoom);
    this._needsUpdate = true;
    if (!enableTransition) {
      this._zoom = this._zoomEnd;
    }
    const resolveImmediately = !enableTransition || approxEquals(this._zoom, this._zoomEnd, this.restThreshold);
    this._changedZoom = 0;
    return this._createOnRestPromise(resolveImmediately);
  }
  /**
   * @deprecated `pan()` has been renamed to `truck()`
   * @category Methods
   */
  pan(x, y, enableTransition = false) {
    console.warn("`pan` has been renamed to `truck`");
    return this.truck(x, y, enableTransition);
  }
  /**
   * Truck and pedestal camera using current azimuthal angle
   * @param x Horizontal translate amount
   * @param y Vertical translate amount
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  truck(x, y, enableTransition = false) {
    this._camera.updateMatrix();
    _xColumn.setFromMatrixColumn(this._camera.matrix, 0);
    _yColumn.setFromMatrixColumn(this._camera.matrix, 1);
    _xColumn.multiplyScalar(x);
    _yColumn.multiplyScalar(-y);
    const offset = _v3A.copy(_xColumn).add(_yColumn);
    const to = _v3B.copy(this._targetEnd).add(offset);
    return this.moveTo(to.x, to.y, to.z, enableTransition);
  }
  /**
   * Move forward / backward.
   * @param distance Amount to move forward / backward. Negative value to move backward
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  forward(distance2, enableTransition = false) {
    _v3A.setFromMatrixColumn(this._camera.matrix, 0);
    _v3A.crossVectors(this._camera.up, _v3A);
    _v3A.multiplyScalar(distance2);
    const to = _v3B.copy(this._targetEnd).add(_v3A);
    return this.moveTo(to.x, to.y, to.z, enableTransition);
  }
  /**
   * Move up / down.
   * @param height Amount to move up / down. Negative value to move down
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  elevate(height, enableTransition = false) {
    _v3A.copy(this._camera.up).multiplyScalar(height);
    return this.moveTo(this._targetEnd.x + _v3A.x, this._targetEnd.y + _v3A.y, this._targetEnd.z + _v3A.z, enableTransition);
  }
  /**
   * Move target position to given point.
   * @param x x coord to move center position
   * @param y y coord to move center position
   * @param z z coord to move center position
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  moveTo(x, y, z, enableTransition = false) {
    this._isUserControllingTruck = false;
    const offset = _v3A.set(x, y, z).sub(this._targetEnd);
    this._encloseToBoundary(this._targetEnd, offset, this.boundaryFriction);
    this._needsUpdate = true;
    if (!enableTransition) {
      this._target.copy(this._targetEnd);
    }
    const resolveImmediately = !enableTransition || approxEquals(this._target.x, this._targetEnd.x, this.restThreshold) && approxEquals(this._target.y, this._targetEnd.y, this.restThreshold) && approxEquals(this._target.z, this._targetEnd.z, this.restThreshold);
    return this._createOnRestPromise(resolveImmediately);
  }
  /**
   * Look in the given point direction.
   * @param x point x.
   * @param y point y.
   * @param z point z.
   * @param enableTransition Whether to move smoothly or immediately.
   * @returns Transition end promise
   * @category Methods
   */
  lookInDirectionOf(x, y, z, enableTransition = false) {
    const point = _v3A.set(x, y, z);
    const direction = point.sub(this._targetEnd).normalize();
    const position = direction.multiplyScalar(-this._sphericalEnd.radius);
    return this.setPosition(position.x, position.y, position.z, enableTransition);
  }
  /**
   * Fit the viewport to the box or the bounding box of the object, using the nearest axis. paddings are in unit.
   * set `cover: true` to fill enter screen.
   * e.g.
   * ```
   * cameraControls.fitToBox( myMesh );
   * ```
   * @param box3OrObject Axis aligned bounding box to fit the view.
   * @param enableTransition Whether to move smoothly or immediately.
   * @param options | `<object>` { cover: boolean, paddingTop: number, paddingLeft: number, paddingBottom: number, paddingRight: number }
   * @returns Transition end promise
   * @category Methods
   */
  fitToBox(box3OrObject, enableTransition, { cover = false, paddingLeft = 0, paddingRight = 0, paddingBottom = 0, paddingTop = 0 } = {}) {
    const promises = [];
    const aabb2 = box3OrObject.isBox3 ? _box3A.copy(box3OrObject) : _box3A.setFromObject(box3OrObject);
    if (aabb2.isEmpty()) {
      console.warn("camera-controls: fitTo() cannot be used with an empty box. Aborting");
      Promise.resolve();
    }
    const theta = roundToStep(this._sphericalEnd.theta, PI_HALF);
    const phi = roundToStep(this._sphericalEnd.phi, PI_HALF);
    promises.push(this.rotateTo(theta, phi, enableTransition));
    const normal = _v3A.setFromSpherical(this._sphericalEnd).normalize();
    const rotation = _quaternionA.setFromUnitVectors(normal, _AXIS_Z);
    const viewFromPolar = approxEquals(Math.abs(normal.y), 1);
    if (viewFromPolar) {
      rotation.multiply(_quaternionB.setFromAxisAngle(_AXIS_Y, theta));
    }
    rotation.multiply(this._yAxisUpSpaceInverse);
    const bb = _box3B.makeEmpty();
    _v3B.copy(aabb2.min).applyQuaternion(rotation);
    bb.expandByPoint(_v3B);
    _v3B.copy(aabb2.min).setX(aabb2.max.x).applyQuaternion(rotation);
    bb.expandByPoint(_v3B);
    _v3B.copy(aabb2.min).setY(aabb2.max.y).applyQuaternion(rotation);
    bb.expandByPoint(_v3B);
    _v3B.copy(aabb2.max).setZ(aabb2.min.z).applyQuaternion(rotation);
    bb.expandByPoint(_v3B);
    _v3B.copy(aabb2.min).setZ(aabb2.max.z).applyQuaternion(rotation);
    bb.expandByPoint(_v3B);
    _v3B.copy(aabb2.max).setY(aabb2.min.y).applyQuaternion(rotation);
    bb.expandByPoint(_v3B);
    _v3B.copy(aabb2.max).setX(aabb2.min.x).applyQuaternion(rotation);
    bb.expandByPoint(_v3B);
    _v3B.copy(aabb2.max).applyQuaternion(rotation);
    bb.expandByPoint(_v3B);
    bb.min.x -= paddingLeft;
    bb.min.y -= paddingBottom;
    bb.max.x += paddingRight;
    bb.max.y += paddingTop;
    rotation.setFromUnitVectors(_AXIS_Z, normal);
    if (viewFromPolar) {
      rotation.premultiply(_quaternionB.invert());
    }
    rotation.premultiply(this._yAxisUpSpace);
    const bbSize = bb.getSize(_v3A);
    const center2 = bb.getCenter(_v3B).applyQuaternion(rotation);
    if (isPerspectiveCamera(this._camera)) {
      const distance2 = this.getDistanceToFitBox(bbSize.x, bbSize.y, bbSize.z, cover);
      promises.push(this.moveTo(center2.x, center2.y, center2.z, enableTransition));
      promises.push(this.dollyTo(distance2, enableTransition));
      promises.push(this.setFocalOffset(0, 0, 0, enableTransition));
    } else if (isOrthographicCamera(this._camera)) {
      const camera = this._camera;
      const width = camera.right - camera.left;
      const height = camera.top - camera.bottom;
      const zoom = cover ? Math.max(width / bbSize.x, height / bbSize.y) : Math.min(width / bbSize.x, height / bbSize.y);
      promises.push(this.moveTo(center2.x, center2.y, center2.z, enableTransition));
      promises.push(this.zoomTo(zoom, enableTransition));
      promises.push(this.setFocalOffset(0, 0, 0, enableTransition));
    }
    return Promise.all(promises);
  }
  /**
   * Fit the viewport to the sphere or the bounding sphere of the object.
   * @param sphereOrMesh
   * @param enableTransition
   * @category Methods
   */
  fitToSphere(sphereOrMesh, enableTransition) {
    const promises = [];
    const isSphere = sphereOrMesh instanceof THREE.Sphere;
    const boundingSphere = isSphere ? _sphere3.copy(sphereOrMesh) : CameraControls2.createBoundingSphere(sphereOrMesh, _sphere3);
    promises.push(this.moveTo(boundingSphere.center.x, boundingSphere.center.y, boundingSphere.center.z, enableTransition));
    if (isPerspectiveCamera(this._camera)) {
      const distanceToFit = this.getDistanceToFitSphere(boundingSphere.radius);
      promises.push(this.dollyTo(distanceToFit, enableTransition));
    } else if (isOrthographicCamera(this._camera)) {
      const width = this._camera.right - this._camera.left;
      const height = this._camera.top - this._camera.bottom;
      const diameter = 2 * boundingSphere.radius;
      const zoom = Math.min(width / diameter, height / diameter);
      promises.push(this.zoomTo(zoom, enableTransition));
    }
    promises.push(this.setFocalOffset(0, 0, 0, enableTransition));
    return Promise.all(promises);
  }
  /**
   * Look at the `target` from the `position`.
   * @param positionX
   * @param positionY
   * @param positionZ
   * @param targetX
   * @param targetY
   * @param targetZ
   * @param enableTransition
   * @category Methods
   */
  setLookAt(positionX, positionY, positionZ, targetX, targetY, targetZ, enableTransition = false) {
    this._isUserControllingRotate = false;
    this._isUserControllingDolly = false;
    this._isUserControllingTruck = false;
    this._lastDollyDirection = DOLLY_DIRECTION.NONE;
    this._changedDolly = 0;
    const target = _v3B.set(targetX, targetY, targetZ);
    const position = _v3A.set(positionX, positionY, positionZ);
    this._targetEnd.copy(target);
    this._sphericalEnd.setFromVector3(position.sub(target).applyQuaternion(this._yAxisUpSpace));
    this.normalizeRotations();
    this._needsUpdate = true;
    if (!enableTransition) {
      this._target.copy(this._targetEnd);
      this._spherical.copy(this._sphericalEnd);
    }
    const resolveImmediately = !enableTransition || approxEquals(this._target.x, this._targetEnd.x, this.restThreshold) && approxEquals(this._target.y, this._targetEnd.y, this.restThreshold) && approxEquals(this._target.z, this._targetEnd.z, this.restThreshold) && approxEquals(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) && approxEquals(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold) && approxEquals(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold);
    return this._createOnRestPromise(resolveImmediately);
  }
  /**
   * Similar to setLookAt, but it interpolates between two states.
   * @param positionAX
   * @param positionAY
   * @param positionAZ
   * @param targetAX
   * @param targetAY
   * @param targetAZ
   * @param positionBX
   * @param positionBY
   * @param positionBZ
   * @param targetBX
   * @param targetBY
   * @param targetBZ
   * @param t
   * @param enableTransition
   * @category Methods
   */
  lerpLookAt(positionAX, positionAY, positionAZ, targetAX, targetAY, targetAZ, positionBX, positionBY, positionBZ, targetBX, targetBY, targetBZ, t2, enableTransition = false) {
    this._isUserControllingRotate = false;
    this._isUserControllingDolly = false;
    this._isUserControllingTruck = false;
    this._lastDollyDirection = DOLLY_DIRECTION.NONE;
    this._changedDolly = 0;
    const targetA = _v3A.set(targetAX, targetAY, targetAZ);
    const positionA = _v3B.set(positionAX, positionAY, positionAZ);
    _sphericalA.setFromVector3(positionA.sub(targetA).applyQuaternion(this._yAxisUpSpace));
    const targetB = _v3C.set(targetBX, targetBY, targetBZ);
    const positionB = _v3B.set(positionBX, positionBY, positionBZ);
    _sphericalB.setFromVector3(positionB.sub(targetB).applyQuaternion(this._yAxisUpSpace));
    this._targetEnd.copy(targetA.lerp(targetB, t2));
    const deltaTheta = _sphericalB.theta - _sphericalA.theta;
    const deltaPhi = _sphericalB.phi - _sphericalA.phi;
    const deltaRadius = _sphericalB.radius - _sphericalA.radius;
    this._sphericalEnd.set(_sphericalA.radius + deltaRadius * t2, _sphericalA.phi + deltaPhi * t2, _sphericalA.theta + deltaTheta * t2);
    this.normalizeRotations();
    this._needsUpdate = true;
    if (!enableTransition) {
      this._target.copy(this._targetEnd);
      this._spherical.copy(this._sphericalEnd);
    }
    const resolveImmediately = !enableTransition || approxEquals(this._target.x, this._targetEnd.x, this.restThreshold) && approxEquals(this._target.y, this._targetEnd.y, this.restThreshold) && approxEquals(this._target.z, this._targetEnd.z, this.restThreshold) && approxEquals(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) && approxEquals(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold) && approxEquals(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold);
    return this._createOnRestPromise(resolveImmediately);
  }
  /**
   * Set angle and distance by given position.
   * An alias of `setLookAt()`, without target change. Thus keep gazing at the current target
   * @param positionX
   * @param positionY
   * @param positionZ
   * @param enableTransition
   * @category Methods
   */
  setPosition(positionX, positionY, positionZ, enableTransition = false) {
    return this.setLookAt(positionX, positionY, positionZ, this._targetEnd.x, this._targetEnd.y, this._targetEnd.z, enableTransition);
  }
  /**
   * Set the target position where gaze at.
   * An alias of `setLookAt()`, without position change. Thus keep the same position.
   * @param targetX
   * @param targetY
   * @param targetZ
   * @param enableTransition
   * @category Methods
   */
  setTarget(targetX, targetY, targetZ, enableTransition = false) {
    const pos = this.getPosition(_v3A);
    const promise = this.setLookAt(pos.x, pos.y, pos.z, targetX, targetY, targetZ, enableTransition);
    this._sphericalEnd.phi = clamp2(this._sphericalEnd.phi, this.minPolarAngle, this.maxPolarAngle);
    return promise;
  }
  /**
   * Set focal offset using the screen parallel coordinates. z doesn't affect in Orthographic as with Dolly.
   * @param x
   * @param y
   * @param z
   * @param enableTransition
   * @category Methods
   */
  setFocalOffset(x, y, z, enableTransition = false) {
    this._isUserControllingOffset = false;
    this._focalOffsetEnd.set(x, y, z);
    this._needsUpdate = true;
    if (!enableTransition)
      this._focalOffset.copy(this._focalOffsetEnd);
    const resolveImmediately = !enableTransition || approxEquals(this._focalOffset.x, this._focalOffsetEnd.x, this.restThreshold) && approxEquals(this._focalOffset.y, this._focalOffsetEnd.y, this.restThreshold) && approxEquals(this._focalOffset.z, this._focalOffsetEnd.z, this.restThreshold);
    return this._createOnRestPromise(resolveImmediately);
  }
  /**
   * Set orbit point without moving the camera.
   * SHOULD NOT RUN DURING ANIMATIONS. `setOrbitPoint()` will immediately fix the positions.
   * @param targetX
   * @param targetY
   * @param targetZ
   * @category Methods
   */
  setOrbitPoint(targetX, targetY, targetZ) {
    this._camera.updateMatrixWorld();
    _xColumn.setFromMatrixColumn(this._camera.matrixWorldInverse, 0);
    _yColumn.setFromMatrixColumn(this._camera.matrixWorldInverse, 1);
    _zColumn.setFromMatrixColumn(this._camera.matrixWorldInverse, 2);
    const position = _v3A.set(targetX, targetY, targetZ);
    const distance2 = position.distanceTo(this._camera.position);
    const cameraToPoint = position.sub(this._camera.position);
    _xColumn.multiplyScalar(cameraToPoint.x);
    _yColumn.multiplyScalar(cameraToPoint.y);
    _zColumn.multiplyScalar(cameraToPoint.z);
    _v3A.copy(_xColumn).add(_yColumn).add(_zColumn);
    _v3A.z = _v3A.z + distance2;
    this.dollyTo(distance2, false);
    this.setFocalOffset(-_v3A.x, _v3A.y, -_v3A.z, false);
    this.moveTo(targetX, targetY, targetZ, false);
  }
  /**
   * Set the boundary box that encloses the target of the camera. box3 is in THREE.Box3
   * @param box3
   * @category Methods
   */
  setBoundary(box3) {
    if (!box3) {
      this._boundary.min.set(-Infinity, -Infinity, -Infinity);
      this._boundary.max.set(Infinity, Infinity, Infinity);
      this._needsUpdate = true;
      return;
    }
    this._boundary.copy(box3);
    this._boundary.clampPoint(this._targetEnd, this._targetEnd);
    this._needsUpdate = true;
  }
  /**
   * Set (or unset) the current viewport.
   * Set this when you want to use renderer viewport and .dollyToCursor feature at the same time.
   * @param viewportOrX
   * @param y
   * @param width
   * @param height
   * @category Methods
   */
  setViewport(viewportOrX, y, width, height) {
    if (viewportOrX === null) {
      this._viewport = null;
      return;
    }
    this._viewport = this._viewport || new THREE.Vector4();
    if (typeof viewportOrX === "number") {
      this._viewport.set(viewportOrX, y, width, height);
    } else {
      this._viewport.copy(viewportOrX);
    }
  }
  /**
   * Calculate the distance to fit the box.
   * @param width box width
   * @param height box height
   * @param depth box depth
   * @returns distance
   * @category Methods
   */
  getDistanceToFitBox(width, height, depth, cover = false) {
    if (notSupportedInOrthographicCamera(this._camera, "getDistanceToFitBox"))
      return this._spherical.radius;
    const boundingRectAspect = width / height;
    const fov = this._camera.getEffectiveFOV() * DEG2RAD;
    const aspect = this._camera.aspect;
    const heightToFit = (cover ? boundingRectAspect > aspect : boundingRectAspect < aspect) ? height : width / aspect;
    return heightToFit * 0.5 / Math.tan(fov * 0.5) + depth * 0.5;
  }
  /**
   * Calculate the distance to fit the sphere.
   * @param radius sphere radius
   * @returns distance
   * @category Methods
   */
  getDistanceToFitSphere(radius) {
    if (notSupportedInOrthographicCamera(this._camera, "getDistanceToFitSphere"))
      return this._spherical.radius;
    const vFOV = this._camera.getEffectiveFOV() * DEG2RAD;
    const hFOV = Math.atan(Math.tan(vFOV * 0.5) * this._camera.aspect) * 2;
    const fov = 1 < this._camera.aspect ? vFOV : hFOV;
    return radius / Math.sin(fov * 0.5);
  }
  /**
   * Returns the orbit center position, where the camera looking at.
   * @param out The receiving Vector3 instance to copy the result
   * @param receiveEndValue Whether receive the transition end coords or current. default is `true`
   * @category Methods
   */
  getTarget(out, receiveEndValue = true) {
    const _out = !!out && out.isVector3 ? out : new THREE.Vector3();
    return _out.copy(receiveEndValue ? this._targetEnd : this._target);
  }
  /**
   * Returns the camera position.
   * @param out The receiving Vector3 instance to copy the result
   * @param receiveEndValue Whether receive the transition end coords or current. default is `true`
   * @category Methods
   */
  getPosition(out, receiveEndValue = true) {
    const _out = !!out && out.isVector3 ? out : new THREE.Vector3();
    return _out.setFromSpherical(receiveEndValue ? this._sphericalEnd : this._spherical).applyQuaternion(this._yAxisUpSpaceInverse).add(receiveEndValue ? this._targetEnd : this._target);
  }
  /**
   * Returns the spherical coordinates of the orbit.
   * @param out The receiving Spherical instance to copy the result
   * @param receiveEndValue Whether receive the transition end coords or current. default is `true`
   * @category Methods
   */
  getSpherical(out, receiveEndValue = true) {
    const _out = !!out && out instanceof THREE.Spherical ? out : new THREE.Spherical();
    return _out.copy(receiveEndValue ? this._sphericalEnd : this._spherical);
  }
  /**
   * Returns the focal offset, which is how much the camera appears to be translated in screen parallel coordinates.
   * @param out The receiving Vector3 instance to copy the result
   * @param receiveEndValue Whether receive the transition end coords or current. default is `true`
   * @category Methods
   */
  getFocalOffset(out, receiveEndValue = true) {
    const _out = !!out && out.isVector3 ? out : new THREE.Vector3();
    return _out.copy(receiveEndValue ? this._focalOffsetEnd : this._focalOffset);
  }
  /**
   * Normalize camera azimuth angle rotation between 0 and 360 degrees.
   * @category Methods
   */
  normalizeRotations() {
    this._sphericalEnd.theta = this._sphericalEnd.theta % PI_2;
    if (this._sphericalEnd.theta < 0)
      this._sphericalEnd.theta += PI_2;
    this._spherical.theta += PI_2 * Math.round((this._sphericalEnd.theta - this._spherical.theta) / PI_2);
  }
  /**
   * Reset all rotation and position to defaults.
   * @param enableTransition
   * @category Methods
   */
  reset(enableTransition = false) {
    if (!approxEquals(this._camera.up.x, this._cameraUp0.x) || !approxEquals(this._camera.up.y, this._cameraUp0.y) || !approxEquals(this._camera.up.z, this._cameraUp0.z)) {
      this._camera.up.copy(this._cameraUp0);
      const position = this.getPosition(_v3A);
      this.updateCameraUp();
      this.setPosition(position.x, position.y, position.z);
    }
    const promises = [
      this.setLookAt(this._position0.x, this._position0.y, this._position0.z, this._target0.x, this._target0.y, this._target0.z, enableTransition),
      this.setFocalOffset(this._focalOffset0.x, this._focalOffset0.y, this._focalOffset0.z, enableTransition),
      this.zoomTo(this._zoom0, enableTransition)
    ];
    return Promise.all(promises);
  }
  /**
   * Set current camera position as the default position.
   * @category Methods
   */
  saveState() {
    this._cameraUp0.copy(this._camera.up);
    this.getTarget(this._target0);
    this.getPosition(this._position0);
    this._zoom0 = this._zoom;
    this._focalOffset0.copy(this._focalOffset);
  }
  /**
   * Sync camera-up direction.
   * When camera-up vector is changed, `.updateCameraUp()` must be called.
   * @category Methods
   */
  updateCameraUp() {
    this._yAxisUpSpace.setFromUnitVectors(this._camera.up, _AXIS_Y);
    this._yAxisUpSpaceInverse.copy(this._yAxisUpSpace).invert();
  }
  /**
   * Apply current camera-up direction to the camera.
   * The orbit system will be re-initialized with the current position.
   * @category Methods
   */
  applyCameraUp() {
    const cameraDirection = _v3A.subVectors(this._target, this._camera.position).normalize();
    const side = _v3B.crossVectors(cameraDirection, this._camera.up);
    this._camera.up.crossVectors(side, cameraDirection);
    this._camera.updateMatrixWorld();
    const position = this.getPosition(_v3A);
    this.updateCameraUp();
    this.setPosition(position.x, position.y, position.z);
  }
  /**
   * Update camera position and directions.
   * This should be called in your tick loop every time, and returns true if re-rendering is needed.
   * @param delta
   * @returns updated
   * @category Methods
   */
  update(delta) {
    const deltaTheta = this._sphericalEnd.theta - this._spherical.theta;
    const deltaPhi = this._sphericalEnd.phi - this._spherical.phi;
    const deltaRadius = this._sphericalEnd.radius - this._spherical.radius;
    const deltaTarget = _deltaTarget.subVectors(this._targetEnd, this._target);
    const deltaOffset = _deltaOffset.subVectors(this._focalOffsetEnd, this._focalOffset);
    const deltaZoom = this._zoomEnd - this._zoom;
    if (approxZero(deltaTheta)) {
      this._thetaVelocity.value = 0;
      this._spherical.theta = this._sphericalEnd.theta;
    } else {
      const smoothTime = this._isUserControllingRotate ? this.draggingSmoothTime : this.smoothTime;
      this._spherical.theta = smoothDamp(this._spherical.theta, this._sphericalEnd.theta, this._thetaVelocity, smoothTime, Infinity, delta);
      this._needsUpdate = true;
    }
    if (approxZero(deltaPhi)) {
      this._phiVelocity.value = 0;
      this._spherical.phi = this._sphericalEnd.phi;
    } else {
      const smoothTime = this._isUserControllingRotate ? this.draggingSmoothTime : this.smoothTime;
      this._spherical.phi = smoothDamp(this._spherical.phi, this._sphericalEnd.phi, this._phiVelocity, smoothTime, Infinity, delta);
      this._needsUpdate = true;
    }
    if (approxZero(deltaRadius)) {
      this._radiusVelocity.value = 0;
      this._spherical.radius = this._sphericalEnd.radius;
    } else {
      const smoothTime = this._isUserControllingDolly ? this.draggingSmoothTime : this.smoothTime;
      this._spherical.radius = smoothDamp(this._spherical.radius, this._sphericalEnd.radius, this._radiusVelocity, smoothTime, this.maxSpeed, delta);
      this._needsUpdate = true;
    }
    if (approxZero(deltaTarget.x) && approxZero(deltaTarget.y) && approxZero(deltaTarget.z)) {
      this._targetVelocity.set(0, 0, 0);
      this._target.copy(this._targetEnd);
    } else {
      const smoothTime = this._isUserControllingTruck ? this.draggingSmoothTime : this.smoothTime;
      smoothDampVec3(this._target, this._targetEnd, this._targetVelocity, smoothTime, this.maxSpeed, delta, this._target);
      this._needsUpdate = true;
    }
    if (approxZero(deltaOffset.x) && approxZero(deltaOffset.y) && approxZero(deltaOffset.z)) {
      this._focalOffsetVelocity.set(0, 0, 0);
      this._focalOffset.copy(this._focalOffsetEnd);
    } else {
      const smoothTime = this._isUserControllingOffset ? this.draggingSmoothTime : this.smoothTime;
      smoothDampVec3(this._focalOffset, this._focalOffsetEnd, this._focalOffsetVelocity, smoothTime, this.maxSpeed, delta, this._focalOffset);
      this._needsUpdate = true;
    }
    if (approxZero(deltaZoom)) {
      this._zoomVelocity.value = 0;
      this._zoom = this._zoomEnd;
    } else {
      const smoothTime = this._isUserControllingZoom ? this.draggingSmoothTime : this.smoothTime;
      this._zoom = smoothDamp(this._zoom, this._zoomEnd, this._zoomVelocity, smoothTime, Infinity, delta);
    }
    if (this.dollyToCursor) {
      if (isPerspectiveCamera(this._camera) && this._changedDolly !== 0) {
        const dollyControlAmount = this._spherical.radius - this._lastDistance;
        const camera = this._camera;
        const cameraDirection = this._getCameraDirection(_cameraDirection);
        const planeX = _v3A.copy(cameraDirection).cross(camera.up).normalize();
        if (planeX.lengthSq() === 0)
          planeX.x = 1;
        const planeY = _v3B.crossVectors(planeX, cameraDirection);
        const worldToScreen = this._sphericalEnd.radius * Math.tan(camera.getEffectiveFOV() * DEG2RAD * 0.5);
        const prevRadius = this._sphericalEnd.radius - dollyControlAmount;
        const lerpRatio = (prevRadius - this._sphericalEnd.radius) / this._sphericalEnd.radius;
        const cursor = _v3C.copy(this._targetEnd).add(planeX.multiplyScalar(this._dollyControlCoord.x * worldToScreen * camera.aspect)).add(planeY.multiplyScalar(this._dollyControlCoord.y * worldToScreen));
        const newTargetEnd = _v3A.copy(this._targetEnd).lerp(cursor, lerpRatio);
        const isMin = this._lastDollyDirection === DOLLY_DIRECTION.IN && this._spherical.radius <= this.minDistance;
        const isMax = this._lastDollyDirection === DOLLY_DIRECTION.OUT && this.maxDistance <= this._spherical.radius;
        if (this.infinityDolly && (isMin || isMax)) {
          this._sphericalEnd.radius -= dollyControlAmount;
          this._spherical.radius -= dollyControlAmount;
          const dollyAmount = _v3B.copy(cameraDirection).multiplyScalar(-dollyControlAmount);
          newTargetEnd.add(dollyAmount);
        }
        this._boundary.clampPoint(newTargetEnd, newTargetEnd);
        const targetEndDiff = _v3B.subVectors(newTargetEnd, this._targetEnd);
        this._targetEnd.copy(newTargetEnd);
        this._target.add(targetEndDiff);
        this._changedDolly -= dollyControlAmount;
        if (approxZero(this._changedDolly))
          this._changedDolly = 0;
      } else if (isOrthographicCamera(this._camera) && this._changedZoom !== 0) {
        const dollyControlAmount = this._zoom - this._lastZoom;
        const camera = this._camera;
        const worldCursorPosition = _v3A.set(this._dollyControlCoord.x, this._dollyControlCoord.y, (camera.near + camera.far) / (camera.near - camera.far)).unproject(camera);
        const quaternion = _v3B.set(0, 0, -1).applyQuaternion(camera.quaternion);
        const cursor = _v3C.copy(worldCursorPosition).add(quaternion.multiplyScalar(-worldCursorPosition.dot(camera.up)));
        const prevZoom = this._zoom - dollyControlAmount;
        const lerpRatio = -(prevZoom - this._zoom) / this._zoom;
        const cameraDirection = this._getCameraDirection(_cameraDirection);
        const prevPlaneConstant = this._targetEnd.dot(cameraDirection);
        const newTargetEnd = _v3A.copy(this._targetEnd).lerp(cursor, lerpRatio);
        const newPlaneConstant = newTargetEnd.dot(cameraDirection);
        const pullBack = cameraDirection.multiplyScalar(newPlaneConstant - prevPlaneConstant);
        newTargetEnd.sub(pullBack);
        this._boundary.clampPoint(newTargetEnd, newTargetEnd);
        const targetEndDiff = _v3B.subVectors(newTargetEnd, this._targetEnd);
        this._targetEnd.copy(newTargetEnd);
        this._target.add(targetEndDiff);
        this._changedZoom -= dollyControlAmount;
        if (approxZero(this._changedZoom))
          this._changedZoom = 0;
      }
    }
    if (this._camera.zoom !== this._zoom) {
      this._camera.zoom = this._zoom;
      this._camera.updateProjectionMatrix();
      this._updateNearPlaneCorners();
      this._needsUpdate = true;
    }
    const maxDistance = this._collisionTest();
    this._spherical.radius = Math.min(this._spherical.radius, maxDistance);
    this._spherical.makeSafe();
    this._camera.position.setFromSpherical(this._spherical).applyQuaternion(this._yAxisUpSpaceInverse).add(this._target);
    this._camera.lookAt(this._target);
    const affectOffset = !approxZero(this._focalOffset.x) || !approxZero(this._focalOffset.y) || !approxZero(this._focalOffset.z);
    if (affectOffset) {
      this._camera.updateMatrixWorld();
      _xColumn.setFromMatrixColumn(this._camera.matrix, 0);
      _yColumn.setFromMatrixColumn(this._camera.matrix, 1);
      _zColumn.setFromMatrixColumn(this._camera.matrix, 2);
      _xColumn.multiplyScalar(this._focalOffset.x);
      _yColumn.multiplyScalar(-this._focalOffset.y);
      _zColumn.multiplyScalar(this._focalOffset.z);
      _v3A.copy(_xColumn).add(_yColumn).add(_zColumn);
      this._camera.position.add(_v3A);
    }
    if (this._boundaryEnclosesCamera) {
      this._encloseToBoundary(this._camera.position.copy(this._target), _v3A.setFromSpherical(this._spherical).applyQuaternion(this._yAxisUpSpaceInverse), 1);
    }
    const updated = this._needsUpdate;
    if (updated && !this._updatedLastTime) {
      this._hasRested = false;
      this.dispatchEvent({ type: "wake" });
      this.dispatchEvent({ type: "update" });
    } else if (updated) {
      this.dispatchEvent({ type: "update" });
      if (approxZero(deltaTheta, this.restThreshold) && approxZero(deltaPhi, this.restThreshold) && approxZero(deltaRadius, this.restThreshold) && approxZero(deltaTarget.x, this.restThreshold) && approxZero(deltaTarget.y, this.restThreshold) && approxZero(deltaTarget.z, this.restThreshold) && approxZero(deltaOffset.x, this.restThreshold) && approxZero(deltaOffset.y, this.restThreshold) && approxZero(deltaOffset.z, this.restThreshold) && approxZero(deltaZoom, this.restThreshold) && !this._hasRested) {
        this._hasRested = true;
        this.dispatchEvent({ type: "rest" });
      }
    } else if (!updated && this._updatedLastTime) {
      this.dispatchEvent({ type: "sleep" });
    }
    this._lastDistance = this._spherical.radius;
    this._lastZoom = this._zoom;
    this._updatedLastTime = updated;
    this._needsUpdate = false;
    return updated;
  }
  /**
   * Get all state in JSON string
   * @category Methods
   */
  toJSON() {
    return JSON.stringify({
      enabled: this._enabled,
      minDistance: this.minDistance,
      maxDistance: infinityToMaxNumber(this.maxDistance),
      minZoom: this.minZoom,
      maxZoom: infinityToMaxNumber(this.maxZoom),
      minPolarAngle: this.minPolarAngle,
      maxPolarAngle: infinityToMaxNumber(this.maxPolarAngle),
      minAzimuthAngle: infinityToMaxNumber(this.minAzimuthAngle),
      maxAzimuthAngle: infinityToMaxNumber(this.maxAzimuthAngle),
      smoothTime: this.smoothTime,
      draggingSmoothTime: this.draggingSmoothTime,
      dollySpeed: this.dollySpeed,
      truckSpeed: this.truckSpeed,
      dollyToCursor: this.dollyToCursor,
      verticalDragToForward: this.verticalDragToForward,
      target: this._targetEnd.toArray(),
      position: _v3A.setFromSpherical(this._sphericalEnd).add(this._targetEnd).toArray(),
      zoom: this._zoomEnd,
      focalOffset: this._focalOffsetEnd.toArray(),
      target0: this._target0.toArray(),
      position0: this._position0.toArray(),
      zoom0: this._zoom0,
      focalOffset0: this._focalOffset0.toArray()
    });
  }
  /**
   * Reproduce the control state with JSON. enableTransition is where anim or not in a boolean.
   * @param json
   * @param enableTransition
   * @category Methods
   */
  fromJSON(json, enableTransition = false) {
    const obj = JSON.parse(json);
    this.enabled = obj.enabled;
    this.minDistance = obj.minDistance;
    this.maxDistance = maxNumberToInfinity(obj.maxDistance);
    this.minZoom = obj.minZoom;
    this.maxZoom = maxNumberToInfinity(obj.maxZoom);
    this.minPolarAngle = obj.minPolarAngle;
    this.maxPolarAngle = maxNumberToInfinity(obj.maxPolarAngle);
    this.minAzimuthAngle = maxNumberToInfinity(obj.minAzimuthAngle);
    this.maxAzimuthAngle = maxNumberToInfinity(obj.maxAzimuthAngle);
    this.smoothTime = obj.smoothTime;
    this.draggingSmoothTime = obj.draggingSmoothTime;
    this.dollySpeed = obj.dollySpeed;
    this.truckSpeed = obj.truckSpeed;
    this.dollyToCursor = obj.dollyToCursor;
    this.verticalDragToForward = obj.verticalDragToForward;
    this._target0.fromArray(obj.target0);
    this._position0.fromArray(obj.position0);
    this._zoom0 = obj.zoom0;
    this._focalOffset0.fromArray(obj.focalOffset0);
    this.moveTo(obj.target[0], obj.target[1], obj.target[2], enableTransition);
    _sphericalA.setFromVector3(_v3A.fromArray(obj.position).sub(this._targetEnd).applyQuaternion(this._yAxisUpSpace));
    this.rotateTo(_sphericalA.theta, _sphericalA.phi, enableTransition);
    this.dollyTo(_sphericalA.radius, enableTransition);
    this.zoomTo(obj.zoom, enableTransition);
    this.setFocalOffset(obj.focalOffset[0], obj.focalOffset[1], obj.focalOffset[2], enableTransition);
    this._needsUpdate = true;
  }
  /**
   * Attach all internal event handlers to enable drag control.
   * @category Methods
   */
  connect(domElement) {
    if (this._domElement) {
      console.warn("camera-controls is already connected.");
      return;
    }
    domElement.setAttribute("data-camera-controls-version", VERSION2);
    this._addAllEventListeners(domElement);
  }
  /**
   * Detach all internal event handlers to disable drag control.
   */
  disconnect() {
    this.cancel();
    this._removeAllEventListeners();
    if (this._domElement) {
      this._domElement.removeAttribute("data-camera-controls-version");
      this._domElement = void 0;
    }
  }
  /**
   * Dispose the cameraControls instance itself, remove all eventListeners.
   * @category Methods
   */
  dispose() {
    this.removeAllEventListeners();
    this.disconnect();
  }
  // it's okay to expose public though
  _getTargetDirection(out) {
    return out.setFromSpherical(this._spherical).divideScalar(this._spherical.radius).applyQuaternion(this._yAxisUpSpaceInverse);
  }
  // it's okay to expose public though
  _getCameraDirection(out) {
    return this._getTargetDirection(out).negate();
  }
  _findPointerById(pointerId) {
    return this._activePointers.find((activePointer) => activePointer.pointerId === pointerId);
  }
  _findPointerByMouseButton(mouseButton) {
    return this._activePointers.find((activePointer) => activePointer.mouseButton === mouseButton);
  }
  _disposePointer(pointer) {
    this._activePointers.splice(this._activePointers.indexOf(pointer), 1);
  }
  _encloseToBoundary(position, offset, friction) {
    const offsetLength2 = offset.lengthSq();
    if (offsetLength2 === 0) {
      return position;
    }
    const newTarget = _v3B.copy(offset).add(position);
    const clampedTarget = this._boundary.clampPoint(newTarget, _v3C);
    const deltaClampedTarget = clampedTarget.sub(newTarget);
    const deltaClampedTargetLength2 = deltaClampedTarget.lengthSq();
    if (deltaClampedTargetLength2 === 0) {
      return position.add(offset);
    } else if (deltaClampedTargetLength2 === offsetLength2) {
      return position;
    } else if (friction === 0) {
      return position.add(offset).add(deltaClampedTarget);
    } else {
      const offsetFactor = 1 + friction * deltaClampedTargetLength2 / offset.dot(deltaClampedTarget);
      return position.add(_v3B.copy(offset).multiplyScalar(offsetFactor)).add(deltaClampedTarget.multiplyScalar(1 - friction));
    }
  }
  _updateNearPlaneCorners() {
    if (isPerspectiveCamera(this._camera)) {
      const camera = this._camera;
      const near = camera.near;
      const fov = camera.getEffectiveFOV() * DEG2RAD;
      const heightHalf = Math.tan(fov * 0.5) * near;
      const widthHalf = heightHalf * camera.aspect;
      this._nearPlaneCorners[0].set(-widthHalf, -heightHalf, 0);
      this._nearPlaneCorners[1].set(widthHalf, -heightHalf, 0);
      this._nearPlaneCorners[2].set(widthHalf, heightHalf, 0);
      this._nearPlaneCorners[3].set(-widthHalf, heightHalf, 0);
    } else if (isOrthographicCamera(this._camera)) {
      const camera = this._camera;
      const zoomInv = 1 / camera.zoom;
      const left = camera.left * zoomInv;
      const right = camera.right * zoomInv;
      const top = camera.top * zoomInv;
      const bottom = camera.bottom * zoomInv;
      this._nearPlaneCorners[0].set(left, top, 0);
      this._nearPlaneCorners[1].set(right, top, 0);
      this._nearPlaneCorners[2].set(right, bottom, 0);
      this._nearPlaneCorners[3].set(left, bottom, 0);
    }
  }
  // lateUpdate
  _collisionTest() {
    let distance2 = Infinity;
    const hasCollider = this.colliderMeshes.length >= 1;
    if (!hasCollider)
      return distance2;
    if (notSupportedInOrthographicCamera(this._camera, "_collisionTest"))
      return distance2;
    const rayDirection = this._getTargetDirection(_cameraDirection);
    _rotationMatrix.lookAt(_ORIGIN, rayDirection, this._camera.up);
    for (let i3 = 0; i3 < 4; i3++) {
      const nearPlaneCorner = _v3B.copy(this._nearPlaneCorners[i3]);
      nearPlaneCorner.applyMatrix4(_rotationMatrix);
      const origin2 = _v3C.addVectors(this._target, nearPlaneCorner);
      _raycaster.set(origin2, rayDirection);
      _raycaster.far = this._spherical.radius + 1;
      const intersects = _raycaster.intersectObjects(this.colliderMeshes);
      if (intersects.length !== 0 && intersects[0].distance < distance2) {
        distance2 = intersects[0].distance;
      }
    }
    return distance2;
  }
  /**
   * Get its client rect and package into given `DOMRect` .
   */
  _getClientRect(target) {
    if (!this._domElement)
      return;
    const rect = this._domElement.getBoundingClientRect();
    target.x = rect.left;
    target.y = rect.top;
    if (this._viewport) {
      target.x += this._viewport.x;
      target.y += rect.height - this._viewport.w - this._viewport.y;
      target.width = this._viewport.z;
      target.height = this._viewport.w;
    } else {
      target.width = rect.width;
      target.height = rect.height;
    }
    return target;
  }
  _createOnRestPromise(resolveImmediately) {
    if (resolveImmediately)
      return Promise.resolve();
    this._hasRested = false;
    this.dispatchEvent({ type: "transitionstart" });
    return new Promise((resolve) => {
      const onResolve = () => {
        this.removeEventListener("rest", onResolve);
        resolve();
      };
      this.addEventListener("rest", onResolve);
    });
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _addAllEventListeners(_domElement) {
  }
  _removeAllEventListeners() {
  }
  /**
   * backward compatible
   * @deprecated use smoothTime (in seconds) instead
   * @category Properties
   */
  get dampingFactor() {
    console.warn(".dampingFactor has been deprecated. use smoothTime (in seconds) instead.");
    return 0;
  }
  /**
   * backward compatible
   * @deprecated use smoothTime (in seconds) instead
   * @category Properties
   */
  set dampingFactor(_) {
    console.warn(".dampingFactor has been deprecated. use smoothTime (in seconds) instead.");
  }
  /**
   * backward compatible
   * @deprecated use draggingSmoothTime (in seconds) instead
   * @category Properties
   */
  get draggingDampingFactor() {
    console.warn(".draggingDampingFactor has been deprecated. use draggingSmoothTime (in seconds) instead.");
    return 0;
  }
  /**
   * backward compatible
   * @deprecated use draggingSmoothTime (in seconds) instead
   * @category Properties
   */
  set draggingDampingFactor(_) {
    console.warn(".draggingDampingFactor has been deprecated. use draggingSmoothTime (in seconds) instead.");
  }
  static createBoundingSphere(object3d, out = new THREE.Sphere()) {
    const boundingSphere = out;
    const center2 = boundingSphere.center;
    _box3A.makeEmpty();
    object3d.traverseVisible((object) => {
      if (!object.isMesh)
        return;
      _box3A.expandByObject(object);
    });
    _box3A.getCenter(center2);
    let maxRadiusSq = 0;
    object3d.traverseVisible((object) => {
      if (!object.isMesh)
        return;
      const mesh = object;
      const geometry2 = mesh.geometry.clone();
      geometry2.applyMatrix4(mesh.matrixWorld);
      const bufferGeometry = geometry2;
      const position = bufferGeometry.attributes.position;
      for (let i3 = 0, l = position.count; i3 < l; i3++) {
        _v3A.fromBufferAttribute(position, i3);
        maxRadiusSq = Math.max(maxRadiusSq, center2.distanceToSquared(_v3A));
      }
    });
    boundingSphere.radius = Math.sqrt(maxRadiusSq);
    return boundingSphere;
  }
};

// node_modules/kokomi.js/dist/controls/cameraControls.js
var CameraControls3 = class extends Component {
  constructor(base) {
    super(base);
    __publicField(this, "controls");
    CameraControls2.install({ THREE: three_module_exports });
    const controls = new CameraControls2(base.camera, base.renderer.domElement);
    this.controls = controls;
  }
  update(time) {
    this.controls.update(this.base.clock.deltaTime);
  }
};

// node_modules/kokomi.js/dist/controls/orbitControls.js
var OrbitControls2 = class extends Component {
  constructor(base, config3 = {}) {
    super(base);
    __publicField(this, "controls");
    const { enableDamping = true } = config3;
    const controls = new OrbitControls(base.camera, base.renderer.domElement);
    this.controls = controls;
    controls.enableDamping = enableDamping;
  }
  update(time) {
    this.controls.update();
  }
};

// node_modules/kokomi.js/dist/effects/persistenceEffect.js
var PersistenceEffect = class extends Component {
  constructor(base, config3 = {}) {
    super(base);
    __publicField(this, "isActive");
    __publicField(this, "clearColor");
    __publicField(this, "fadeFactor");
    __publicField(this, "fadeColor");
    __publicField(this, "scaleX");
    __publicField(this, "scaleY");
    __publicField(this, "rotationAngle");
    __publicField(this, "orthoCamera");
    __publicField(this, "uvMatrix");
    __publicField(this, "fadeMaterial");
    __publicField(this, "fadePlane");
    __publicField(this, "resultPlane");
    __publicField(this, "framebuffer1");
    __publicField(this, "framebuffer2");
    this.isActive = false;
    const { clearColor = 1118481, fadeFactor = 0.2, fadeColor = new Color("#000000"), scaleX = 0, scaleY = 0, rotationAngle = 0 } = config3;
    this.clearColor = clearColor;
    this.fadeFactor = fadeFactor;
    this.fadeColor = fadeColor;
    this.scaleX = scaleX;
    this.scaleY = scaleY;
    this.rotationAngle = rotationAngle;
    const leftScreenBorder = -innerWidth / 2;
    const rightScreenBorder = innerWidth / 2;
    const topScreenBorder = -innerHeight / 2;
    const bottomScreenBorder = innerHeight / 2;
    const near = -100;
    const far = 100;
    const orthoCamera = new OrthographicCamera(leftScreenBorder, rightScreenBorder, topScreenBorder, bottomScreenBorder, near, far);
    orthoCamera.position.z = -10;
    orthoCamera.lookAt(new Vector3(0, 0, 0));
    this.orthoCamera = orthoCamera;
    const fullscreenQuadGeometry2 = new PlaneGeometry(innerWidth, innerHeight);
    const uvMatrix = new Matrix3();
    this.uvMatrix = uvMatrix;
    const fadeMaterial = new ShaderMaterial({
      uniforms: {
        inputTexture: { value: null },
        fadeFactor: { value: this.fadeFactor },
        fadeColor: { value: this.fadeColor },
        uvMatrix: { value: uvMatrix }
      },
      vertexShader: (
        /* glsl */
        `
        uniform mat3 uvMatrix;
        varying vec2 vUv;
        void main () {
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
          vUv = (uvMatrix * vec3(uv, 1.0)).xy;
        }
      `
      ),
      fragmentShader: (
        /* glsl */
        `
        uniform sampler2D inputTexture;
        uniform float fadeFactor;
        uniform vec3 fadeColor;
        varying vec2 vUv;
        void main () {
          vec4 texColor = texture2D(inputTexture, vUv);
          vec4 fadeColorWithAlpha = vec4(fadeColor, 1.0);
          gl_FragColor = mix(texColor, fadeColorWithAlpha, fadeFactor);
        }
      `
      )
    });
    this.fadeMaterial = fadeMaterial;
    const fadePlane = new Mesh(fullscreenQuadGeometry2, fadeMaterial);
    this.fadePlane = fadePlane;
    const resultMaterial = new MeshBasicMaterial({ map: null });
    const resultPlane = new Mesh(fullscreenQuadGeometry2, resultMaterial);
    this.resultPlane = resultPlane;
    const framebuffer1 = new WebGLRenderTarget(innerWidth, innerHeight);
    const framebuffer2 = new WebGLRenderTarget(innerWidth, innerHeight);
    this.framebuffer1 = framebuffer1;
    this.framebuffer2 = framebuffer2;
  }
  addExisting() {
    const { base } = this;
    const { renderer } = base;
    const { framebuffer1, framebuffer2 } = this;
    renderer.setClearColor(this.clearColor);
    renderer.setRenderTarget(framebuffer1);
    renderer.clearColor();
    renderer.setRenderTarget(framebuffer2);
    renderer.clearColor();
    this.enable();
  }
  enable() {
    this.isActive = true;
  }
  disable() {
    this.isActive = false;
  }
  update(time) {
    if (!this.isActive) {
      return;
    }
    const { base } = this;
    const { renderer, scene, camera } = base;
    const { orthoCamera, uvMatrix, fadeMaterial, fadePlane, resultPlane } = this;
    const { framebuffer1, framebuffer2 } = this;
    renderer.autoClearColor = false;
    fadeMaterial.uniforms.inputTexture.value = framebuffer1.texture;
    fadeMaterial.uniforms.fadeFactor.value = this.fadeFactor;
    renderer.setRenderTarget(framebuffer2);
    renderer.render(fadePlane, orthoCamera);
    renderer.render(scene, camera);
    renderer.setRenderTarget(null);
    resultPlane.material.map = framebuffer2.texture;
    renderer.render(resultPlane, orthoCamera);
    const uvScaleX = MathUtils.mapLinear(this.scaleX, -1, 1, 1.05, 0.95);
    const uvScaleY = MathUtils.mapLinear(this.scaleY, -1, 1, 1.05, 0.95);
    const rotation = MathUtils.degToRad(this.rotationAngle);
    uvMatrix.setUvTransform(0, 0, uvScaleX, uvScaleY, rotation, 0.5, 0.5);
    const swap = framebuffer1;
    this.framebuffer1 = framebuffer2;
    this.framebuffer2 = swap;
  }
};

// node_modules/kokomi.js/dist/geometries/hyperbolicHelicoid.js
var HyperbolicHelicoidGeometry = class extends ParametricGeometry {
  constructor(slices, stacks) {
    super(hyperbolicHelicoidFunction, slices, stacks);
  }
};

// node_modules/kokomi.js/dist/geometries/sphube.js
var SphubeGeometry = class extends ParametricGeometry {
  constructor(slices, stacks) {
    super(sphubeFunction, slices, stacks);
  }
};

// node_modules/kokomi.js/dist/shadows/contactShadows.js
var ContactShadows = class extends Component {
  constructor(base, config3 = {}) {
    super(base);
    __publicField(this, "frames");
    __publicField(this, "blur");
    __publicField(this, "smooth");
    __publicField(this, "shadowCamera");
    __publicField(this, "renderTarget");
    __publicField(this, "renderTargetBlur");
    __publicField(this, "blurPlane");
    __publicField(this, "depthMaterial");
    __publicField(this, "horizontalBlurMaterial");
    __publicField(this, "verticalBlurMaterial");
    __publicField(this, "count");
    __publicField(this, "group");
    __publicField(this, "mesh");
    let { scale = 10, frames = Infinity, opacity = 1, width = 1, height = 1, blur = 1, far = 10, resolution = 512, smooth = true, color = "#000000", depthWrite = false } = config3;
    this.frames = frames;
    this.blur = blur;
    this.smooth = smooth;
    width = width * (Array.isArray(scale) ? scale[0] : scale || 1);
    height = height * (Array.isArray(scale) ? scale[1] : scale || 1);
    const gl = this.base.renderer;
    const shadowCamera = new OrthographicCamera(-width / 2, width / 2, height / 2, -height / 2, 0, far);
    this.shadowCamera = shadowCamera;
    const renderTarget = new WebGLRenderTarget(resolution, resolution);
    this.renderTarget = renderTarget;
    const renderTargetBlur = new WebGLRenderTarget(resolution, resolution);
    this.renderTargetBlur = renderTargetBlur;
    renderTargetBlur.texture.generateMipmaps = renderTarget.texture.generateMipmaps = false;
    const planeGeometry = new PlaneGeometry(width, height).rotateX(Math.PI / 2);
    const blurPlane = new Mesh(planeGeometry);
    this.blurPlane = blurPlane;
    const depthMaterial = new MeshDepthMaterial();
    this.depthMaterial = depthMaterial;
    depthMaterial.depthTest = depthMaterial.depthWrite = false;
    depthMaterial.onBeforeCompile = (shader) => {
      shader.uniforms = {
        ...shader.uniforms,
        ucolor: {
          value: new Color(color)
        }
      };
      shader.fragmentShader = shader.fragmentShader.replace(
        `void main() {`,
        //
        `uniform vec3 ucolor;
         void main() {
        `
      );
      shader.fragmentShader = shader.fragmentShader.replace(
        "vec4( vec3( 1.0 - fragCoordZ ), opacity );",
        // Colorize the shadow, multiply by the falloff so that the center can remain darker
        "vec4( ucolor * fragCoordZ * 2.0, ( 1.0 - fragCoordZ ) * 1.0 );"
      );
    };
    const horizontalBlurMaterial = new ShaderMaterial(HorizontalBlurShader);
    this.horizontalBlurMaterial = horizontalBlurMaterial;
    const verticalBlurMaterial = new ShaderMaterial(VerticalBlurShader);
    this.verticalBlurMaterial = verticalBlurMaterial;
    verticalBlurMaterial.depthTest = horizontalBlurMaterial.depthTest = false;
    this.count = 0;
    const group = new Group();
    this.group = group;
    group.rotation.x = Math.PI / 2;
    const planeMaterial = new MeshBasicMaterial({
      map: renderTarget.texture,
      transparent: true,
      opacity,
      depthWrite
    });
    if (planeMaterial.map) {
      planeMaterial.map.encoding = gl.outputEncoding;
    }
    const mesh = new Mesh(planeGeometry, planeMaterial);
    this.mesh = mesh;
    mesh.scale.set(1, -1, 1);
    mesh.rotation.set(-Math.PI / 2, 0, 0);
  }
  addExisting() {
    this.group.add(this.mesh);
    this.group.add(this.shadowCamera);
    this.container.add(this.group);
  }
  blurShadows(blur) {
    const { shadowCamera, renderTarget, renderTargetBlur, blurPlane, horizontalBlurMaterial, verticalBlurMaterial } = this;
    const gl = this.base.renderer;
    blurPlane.visible = true;
    blurPlane.material = horizontalBlurMaterial;
    horizontalBlurMaterial.uniforms.tDiffuse.value = renderTarget.texture;
    horizontalBlurMaterial.uniforms.h.value = blur * 1 / 256;
    gl.setRenderTarget(renderTargetBlur);
    gl.render(blurPlane, shadowCamera);
    blurPlane.material = verticalBlurMaterial;
    verticalBlurMaterial.uniforms.tDiffuse.value = renderTargetBlur.texture;
    verticalBlurMaterial.uniforms.v.value = blur * 1 / 256;
    gl.setRenderTarget(renderTarget);
    gl.render(blurPlane, shadowCamera);
    blurPlane.visible = false;
  }
  update(time) {
    let { shadowCamera, frames, blur, smooth, depthMaterial, renderTarget } = this;
    const scene = this.container;
    const gl = this.base.renderer;
    if (shadowCamera && (frames === Infinity || this.count < frames)) {
      const initialBackground = scene.background;
      scene.background = null;
      const initialOverrideMaterial = scene.overrideMaterial;
      scene.overrideMaterial = depthMaterial;
      gl.setRenderTarget(renderTarget);
      gl.render(scene, shadowCamera);
      scene.overrideMaterial = initialOverrideMaterial;
      this.blurShadows(blur);
      if (smooth) {
        this.blurShadows(blur * 0.4);
      }
      gl.setRenderTarget(null);
      scene.background = initialBackground;
      this.count += 1;
    }
  }
};

// node_modules/kokomi.js/dist/lights/stage.js
var presets = {
  rembrandt: {
    main: [1, 2, 1],
    fill: [-2, -0.5, -2]
  },
  portrait: {
    main: [-1, 2, 0.5],
    fill: [-1, 0.5, -1.5]
  },
  upfront: {
    main: [0, 2, 1],
    fill: [-1, 0.5, -1.5]
  },
  soft: {
    main: [-2, 4, 4],
    fill: [-1, 0.5, -1.5]
  }
};
var Stage = class extends Component {
  constructor(base, config3 = {}) {
    super(base);
    __publicField(this, "group");
    __publicField(this, "center");
    __publicField(this, "shadow");
    __publicField(this, "presetData");
    __publicField(this, "ambientLight");
    __publicField(this, "spotLight");
    __publicField(this, "pointLight");
    __publicField(this, "contactShadows");
    const { preset = "rembrandt", shadow = "contact", intensity = 0.5 } = config3;
    this.shadow = shadow;
    const group = new Group();
    this.group = group;
    const center2 = new Center(this.base);
    this.center = center2;
    const presetData = typeof preset === "string" ? presets[preset] : preset;
    this.presetData = presetData;
    const ambientLight = new AmbientLight(16777215, intensity / 3);
    this.ambientLight = ambientLight;
    const spotLight = new SpotLight(16777215, intensity * 2, 0, Math.PI / 3, 1);
    this.spotLight = spotLight;
    this.spotLight.castShadow = !!shadow;
    this.spotLight.shadow.bias = -1e-4;
    this.spotLight.shadow.mapSize.set(1024, 1024);
    const pointLight = new PointLight(16777215, intensity);
    this.pointLight = pointLight;
    this.adjustAll();
  }
  addExisting() {
    this.container.add(this.ambientLight);
    this.container.add(this.spotLight);
    this.container.add(this.pointLight);
    this.container.add(this.group);
    this.center.addExisting();
    this.center.add(this.group);
    this.adjustAll();
  }
  add(...object) {
    this.group.add(...object);
    this.adjustAll();
  }
  adjustAll() {
    this.adjustLightPositions();
    this.adjustShadow();
  }
  adjustLightPositions() {
    const { presetData } = this;
    this.center.adjustPosition();
    const bound = this.center.bound;
    const { boundingSphere, height } = bound;
    const { radius } = boundingSphere;
    this.spotLight.position.set(presetData.main[0] * radius, presetData.main[1] * radius, presetData.main[2] * radius);
    this.pointLight.position.set(presetData.fill[0] * radius, presetData.fill[1] * radius, presetData.fill[2] * radius);
  }
  adjustShadow() {
    this.center.adjustPosition();
    const bound = this.center.bound;
    const { boundingSphere, height } = bound;
    const { radius } = boundingSphere;
    if (this.shadow === "contact") {
      if (this.contactShadows) {
        this.contactShadows.group.clear();
        this.contactShadows = null;
      }
      const contactShadows = new ContactShadows(this.base, {
        scale: radius * 4,
        far: radius,
        blur: 2
      });
      this.contactShadows = contactShadows;
      this.contactShadows.group.position.set(0, -height / 2, 0);
      this.contactShadows.addExisting();
    }
  }
};

// node_modules/kokomi.js/dist/materials/glassMaterial.js
var GlassMaterial = class extends MeshPhysicalMaterial {
  constructor(parameters) {
    super({
      roughness: 0.6,
      transmission: 1,
      // @ts-ignore
      thickness: 1.2,
      clearcoat: 1,
      clearcoatRoughness: 0.1,
      clearcoatNormalScale: new Vector2(0.3, 0.3),
      ...parameters
    });
  }
};

// node_modules/kokomi.js/dist/lib/other/ConvolutionMaterial.js
var ConvolutionMaterial = class extends ShaderMaterial {
  constructor(texelSize = new Vector2()) {
    super({
      uniforms: {
        inputBuffer: new Uniform(null),
        depthBuffer: new Uniform(null),
        resolution: new Uniform(new Vector2()),
        texelSize: new Uniform(new Vector2()),
        halfTexelSize: new Uniform(new Vector2()),
        kernel: new Uniform(0),
        scale: new Uniform(1),
        cameraNear: new Uniform(0),
        cameraFar: new Uniform(1),
        minDepthThreshold: new Uniform(0),
        maxDepthThreshold: new Uniform(1),
        depthScale: new Uniform(0),
        depthToBlurRatioBias: new Uniform(0.25)
      },
      fragmentShader: (
        /* glsl */
        `#include <common>
        #include <dithering_pars_fragment>      
        uniform sampler2D inputBuffer;
        uniform sampler2D depthBuffer;
        uniform float cameraNear;
        uniform float cameraFar;
        uniform float minDepthThreshold;
        uniform float maxDepthThreshold;
        uniform float depthScale;
        uniform float depthToBlurRatioBias;
        varying vec2 vUv;
        varying vec2 vUv0;
        varying vec2 vUv1;
        varying vec2 vUv2;
        varying vec2 vUv3;

        void main() {
          float depthFactor = 0.0;
          
          #ifdef USE_DEPTH
            vec4 depth = texture2D(depthBuffer, vUv);
            depthFactor = smoothstep(minDepthThreshold, maxDepthThreshold, 1.0-(depth.r * depth.a));
            depthFactor *= depthScale;
            depthFactor = max(0.0, min(1.0, depthFactor + 0.25));
          #endif
          
          vec4 sum = texture2D(inputBuffer, mix(vUv0, vUv, depthFactor));
          sum += texture2D(inputBuffer, mix(vUv1, vUv, depthFactor));
          sum += texture2D(inputBuffer, mix(vUv2, vUv, depthFactor));
          sum += texture2D(inputBuffer, mix(vUv3, vUv, depthFactor));
          gl_FragColor = sum * 0.25 ;

          #include <dithering_fragment>
          #include <tonemapping_fragment>
          #include <encodings_fragment>
        }`
      ),
      vertexShader: (
        /* glsl */
        `uniform vec2 texelSize;
        uniform vec2 halfTexelSize;
        uniform float kernel;
        uniform float scale;
        varying vec2 vUv;
        varying vec2 vUv0;
        varying vec2 vUv1;
        varying vec2 vUv2;
        varying vec2 vUv3;

        void main() {
          vec2 uv = position.xy * 0.5 + 0.5;
          vUv = uv;

          vec2 dUv = (texelSize * vec2(kernel) + halfTexelSize) * scale;
          vUv0 = vec2(uv.x - dUv.x, uv.y + dUv.y);
          vUv1 = vec2(uv.x + dUv.x, uv.y + dUv.y);
          vUv2 = vec2(uv.x + dUv.x, uv.y - dUv.y);
          vUv3 = vec2(uv.x - dUv.x, uv.y - dUv.y);

          gl_Position = vec4(position.xy, 1.0, 1.0);
        }`
      ),
      blending: NoBlending,
      depthWrite: false,
      depthTest: false
    });
    __publicField(this, "kernel");
    this.toneMapped = false;
    this.setTexelSize(texelSize.x, texelSize.y);
    this.kernel = new Float32Array([0, 1, 2, 2, 3]);
  }
  setTexelSize(x, y) {
    this.uniforms.texelSize.value.set(x, y);
    this.uniforms.halfTexelSize.value.set(x, y).multiplyScalar(0.5);
  }
  setResolution(resolution) {
    this.uniforms.resolution.value.copy(resolution);
  }
};

// node_modules/kokomi.js/dist/lib/other/BlurPass.js
var BlurPass = class {
  constructor({ gl, resolution, width = 500, height = 500, minDepthThreshold = 0, maxDepthThreshold = 1, depthScale = 0, depthToBlurRatioBias = 0.25 }) {
    __publicField(this, "renderTargetA");
    __publicField(this, "renderTargetB");
    __publicField(this, "convolutionMaterial");
    __publicField(this, "scene");
    __publicField(this, "camera");
    __publicField(this, "screen");
    __publicField(this, "renderToScreen");
    this.renderToScreen = false;
    this.renderTargetA = new WebGLRenderTarget(resolution, resolution, {
      minFilter: LinearFilter,
      magFilter: LinearFilter,
      stencilBuffer: false,
      depthBuffer: false,
      type: HalfFloatType
    });
    this.renderTargetB = this.renderTargetA.clone();
    this.convolutionMaterial = new ConvolutionMaterial();
    this.convolutionMaterial.setTexelSize(1 / width, 1 / height);
    this.convolutionMaterial.setResolution(new Vector2(width, height));
    this.scene = new Scene();
    this.camera = new Camera();
    this.convolutionMaterial.uniforms.minDepthThreshold.value = minDepthThreshold;
    this.convolutionMaterial.uniforms.maxDepthThreshold.value = maxDepthThreshold;
    this.convolutionMaterial.uniforms.depthScale.value = depthScale;
    this.convolutionMaterial.uniforms.depthToBlurRatioBias.value = depthToBlurRatioBias;
    this.convolutionMaterial.defines.USE_DEPTH = depthScale > 0;
    const vertices = new Float32Array([-1, -1, 0, 3, -1, 0, -1, 3, 0]);
    const uvs = new Float32Array([0, 0, 2, 0, 0, 2]);
    const geometry2 = new BufferGeometry();
    geometry2.setAttribute("position", new BufferAttribute(vertices, 3));
    geometry2.setAttribute("uv", new BufferAttribute(uvs, 2));
    this.screen = new Mesh(geometry2, this.convolutionMaterial);
    this.screen.frustumCulled = false;
    this.scene.add(this.screen);
  }
  render(renderer, inputBuffer, outputBuffer) {
    const scene = this.scene;
    const camera = this.camera;
    const renderTargetA = this.renderTargetA;
    const renderTargetB = this.renderTargetB;
    let material2 = this.convolutionMaterial;
    let uniforms = material2.uniforms;
    uniforms.depthBuffer.value = inputBuffer.depthTexture;
    const kernel = material2.kernel;
    let lastRT = inputBuffer;
    let destRT;
    let i3, l;
    for (i3 = 0, l = kernel.length - 1; i3 < l; ++i3) {
      destRT = (i3 & 1) === 0 ? renderTargetA : renderTargetB;
      uniforms.kernel.value = kernel[i3];
      uniforms.inputBuffer.value = lastRT.texture;
      renderer.setRenderTarget(destRT);
      renderer.render(scene, camera);
      lastRT = destRT;
    }
    uniforms.kernel.value = kernel[i3];
    uniforms.inputBuffer.value = lastRT.texture;
    renderer.setRenderTarget(this.renderToScreen ? null : outputBuffer);
    renderer.render(scene, camera);
  }
};

// node_modules/kokomi.js/dist/materials/meshReflectorMaterial.js
var MeshReflectorMaterial = class extends Component {
  constructor(base, parent, config3 = {}) {
    super(base);
    __publicField(this, "parent");
    __publicField(this, "material");
    __publicField(this, "virtualCamera");
    __publicField(this, "fbo1");
    __publicField(this, "fbo2");
    __publicField(this, "blurpass");
    __publicField(this, "hasBlur");
    __publicField(this, "ignoreObjects");
    __publicField(this, "beforeRender");
    this.parent = parent;
    let { resolution = 256, mixBlur = 0, mixStrength = 1, blur = [0, 0], mirror = 0, ignoreObjects = [] } = config3;
    this.ignoreObjects = ignoreObjects;
    blur = Array.isArray(blur) ? blur : [blur, blur];
    const hasBlur = blur[0] + blur[1] > 0;
    this.hasBlur = hasBlur;
    const gl = this.base.renderer;
    const scope = parent;
    const reflectorPlane = new Plane();
    const normal = new Vector3();
    const reflectorWorldPosition = new Vector3();
    const cameraWorldPosition = new Vector3();
    const rotationMatrix2 = new Matrix4();
    const lookAtPosition = new Vector3(0, 0, -1);
    const clipPlane = new Vector4();
    const view = new Vector3();
    const target = new Vector3();
    const q = new Vector4();
    const textureMatrix = new Matrix4();
    const virtualCamera = new PerspectiveCamera();
    this.virtualCamera = virtualCamera;
    const camera = this.base.camera;
    this.beforeRender = () => {
      reflectorWorldPosition.setFromMatrixPosition(scope.matrixWorld);
      cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);
      rotationMatrix2.extractRotation(scope.matrixWorld);
      normal.set(0, 0, 1);
      normal.applyMatrix4(rotationMatrix2);
      view.subVectors(reflectorWorldPosition, cameraWorldPosition);
      if (view.dot(normal) > 0)
        return;
      view.reflect(normal).negate();
      view.add(reflectorWorldPosition);
      rotationMatrix2.extractRotation(camera.matrixWorld);
      lookAtPosition.set(0, 0, -1);
      lookAtPosition.applyMatrix4(rotationMatrix2);
      lookAtPosition.add(cameraWorldPosition);
      target.subVectors(reflectorWorldPosition, lookAtPosition);
      target.reflect(normal).negate();
      target.add(reflectorWorldPosition);
      virtualCamera.position.copy(view);
      virtualCamera.up.set(0, 1, 0);
      virtualCamera.up.applyMatrix4(rotationMatrix2);
      virtualCamera.up.reflect(normal);
      virtualCamera.lookAt(target);
      virtualCamera.far = camera.far;
      virtualCamera.updateMatrixWorld();
      virtualCamera.projectionMatrix.copy(camera.projectionMatrix);
      textureMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);
      textureMatrix.multiply(virtualCamera.projectionMatrix);
      textureMatrix.multiply(virtualCamera.matrixWorldInverse);
      textureMatrix.multiply(scope.matrixWorld);
      reflectorPlane.setFromNormalAndCoplanarPoint(normal, reflectorWorldPosition);
      reflectorPlane.applyMatrix4(virtualCamera.matrixWorldInverse);
      clipPlane.set(reflectorPlane.normal.x, reflectorPlane.normal.y, reflectorPlane.normal.z, reflectorPlane.constant);
      const projectionMatrix = virtualCamera.projectionMatrix;
      q.x = (Math.sign(clipPlane.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];
      q.y = (Math.sign(clipPlane.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];
      q.z = -1;
      q.w = (1 + projectionMatrix.elements[10]) / projectionMatrix.elements[14];
      clipPlane.multiplyScalar(2 / clipPlane.dot(q));
      projectionMatrix.elements[2] = clipPlane.x;
      projectionMatrix.elements[6] = clipPlane.y;
      projectionMatrix.elements[10] = clipPlane.z + 1;
      projectionMatrix.elements[14] = clipPlane.w;
    };
    const parameters = {
      minFilter: LinearFilter,
      magFilter: LinearFilter,
      type: HalfFloatType
    };
    const fbo1 = new WebGLRenderTarget(resolution, resolution, parameters);
    fbo1.depthBuffer = true;
    fbo1.depthTexture = new DepthTexture(resolution, resolution);
    fbo1.depthTexture.format = DepthFormat;
    fbo1.depthTexture.type = UnsignedShortType;
    const fbo2 = new WebGLRenderTarget(resolution, resolution, parameters);
    const blurpass = new BlurPass({
      gl,
      resolution,
      width: blur[0],
      height: blur[1]
    });
    const reflectorProps = {
      mirror,
      textureMatrix,
      mixBlur,
      tDiffuse: fbo1.texture,
      tDepth: fbo1.depthTexture,
      tDiffuseBlur: fbo2.texture,
      hasBlur,
      mixStrength
    };
    const defines = {
      "defines-USE_BLUR": hasBlur ? "" : void 0
    };
    this.fbo1 = fbo1;
    this.fbo2 = fbo2;
    this.blurpass = blurpass;
    const material2 = new MeshReflectorMaterialImpl(reflectorProps);
    material2.defines.USE_BLUR = defines["defines-USE_BLUR"];
    this.material = material2;
  }
  update(time) {
    const { parent, beforeRender, virtualCamera, fbo1, fbo2, blurpass, hasBlur, ignoreObjects } = this;
    const gl = this.base.renderer;
    const scene = this.base.scene;
    parent.visible = false;
    ignoreObjects.forEach((item) => {
      item.visible = false;
    });
    const currentXrEnabled = gl.xr.enabled;
    const currentShadowAutoUpdate = gl.shadowMap.autoUpdate;
    beforeRender();
    gl.xr.enabled = false;
    gl.shadowMap.autoUpdate = false;
    gl.setRenderTarget(fbo1);
    gl.state.buffers.depth.setMask(true);
    if (!gl.autoClear) {
      gl.clear();
    }
    gl.render(scene, virtualCamera);
    if (hasBlur) {
      blurpass.render(gl, fbo1, fbo2);
    }
    gl.xr.enabled = currentXrEnabled;
    gl.shadowMap.autoUpdate = currentShadowAutoUpdate;
    parent.visible = true;
    ignoreObjects.forEach((item) => {
      item.visible = true;
    });
    gl.setRenderTarget(null);
  }
};

// node_modules/kokomi.js/dist/renderTargets/fbo.js
var FBO = class extends Component {
  constructor(base, config3 = {}) {
    super(base);
    __publicField(this, "rt");
    const { width = window.innerWidth * window.devicePixelRatio, height = window.innerHeight * window.devicePixelRatio, samples = 0 } = config3;
    const rt = new WebGLRenderTarget(width, height);
    this.rt = rt;
    if (samples) {
      rt.samples = samples;
    }
    this.base.resizer.on("resize", () => {
      this.rt.setSize(window.innerWidth * window.devicePixelRatio, window.innerHeight * window.devicePixelRatio);
    });
  }
};

// node_modules/kokomi.js/dist/renderTargets/renderTexture.js
var RenderTexture = class extends Component {
  constructor(base, config3 = {}) {
    super(base);
    __publicField(this, "fbo");
    __publicField(this, "texture");
    __publicField(this, "rtScene");
    __publicField(this, "rtCamera");
    const { rtScene = new Scene(), rtCamera = new PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 100) } = config3;
    this.rtScene = rtScene;
    this.rtCamera = rtCamera;
    const fbo = new FBO(base, { ...config3 });
    this.fbo = fbo;
    const texture = fbo.rt.texture;
    this.texture = texture;
  }
  update() {
    this.base.renderer.setRenderTarget(this.fbo.rt);
    this.base.renderer.render(this.rtScene, this.rtCamera);
    this.base.renderer.setRenderTarget(null);
  }
  add(obj) {
    this.rtScene.add(obj);
  }
};

// node_modules/kokomi.js/dist/materials/meshTransmissionMaterial.js
var transmissionVertexShader = (
  /* glsl */
  `
uniform float iTime;
uniform vec2 iResolution;
uniform vec2 iMouse;

varying vec2 vUv;

varying vec3 vNormal;
varying vec3 vEyeVector;

#define GLSLIFY 1
// https://tympanus.net/codrops/2019/10/29/real-time-multiside-refraction-in-three-steps/
vec4 getWorldPosition(mat4 modelMat,vec3 pos){
    vec4 worldPosition=modelMat*vec4(pos,1.);
    return worldPosition;
}

// https://tympanus.net/codrops/2019/10/29/real-time-multiside-refraction-in-three-steps/
vec3 getEyeVector(mat4 modelMat,vec3 pos,vec3 camPos){
    vec4 worldPosition=getWorldPosition(modelMat,pos);
    vec3 eyeVector=normalize(worldPosition.xyz-camPos);
    return eyeVector;
}

void main(){
    vec3 p=position;
    gl_Position=projectionMatrix*modelViewMatrix*vec4(p,1.);
    
    vUv=uv;

    vNormal=normalize(normalMatrix*normal);
    vEyeVector=getEyeVector(modelMatrix,p,cameraPosition);
}
`
);
var transmissionFragmentShader = (
  /* glsl */
  `
uniform float iTime;
uniform vec2 iResolution;
uniform vec2 iMouse;

varying vec2 vUv;

uniform sampler2D uTexture;
uniform vec2 uFBOResolution;

varying vec3 vNormal;
varying vec3 vEyeVector;

uniform float uChromaticAberration;
uniform float uRefraction;
uniform float uSaturation;
uniform vec3 uLightPosition;
uniform float uDiffuse;
uniform float uSpecular;
uniform float uFresnel;
uniform vec3 uFresnelColor;

vec3 saturation(vec3 rgb,float adjustment){
    const vec3 W=vec3(.2125,.7154,.0721);
    vec3 intensity=vec3(dot(rgb,W));
    return mix(intensity,rgb,adjustment);
}

float saturate(float a){
    return clamp(a,0.,1.);
}

float diffuse(vec3 n,vec3 l){
    float diff=saturate(dot(n,l));
    return diff;
}

float specular2(vec3 n,vec3 l,float shininess){
    float spec=pow(saturate(pow(dot(n,l),2.)),shininess);
    return spec;
}

float lighting(vec3 light,vec3 normal,vec3 eyeVector,float d,float s){
    vec3 N=normal;
    vec3 L=normalize(-light);
    vec3 H=normalize(eyeVector+L);
    
    float diff=diffuse(N,L)*d;
    float spec=specular2(N,H,s);
    float lin=diff+spec;
    return lin;
}

float fresnel2(vec3 eyeVector,vec3 worldNormal,float power){
    float fresnelFactor=abs(dot(eyeVector,worldNormal));
    float inversefresnelFactor=1.-fresnelFactor;
    return pow(inversefresnelFactor,power);
}

void main(){
    vec2 p=gl_FragCoord.xy/uFBOResolution.xy;
    
    vec3 col=vec3(0.);
    
    float iorR=1.15;
    float iorY=1.16;
    float iorG=1.18;
    float iorC=1.22;
    float iorB=1.22;
    float iorP=1.22;
    
    float cr=uChromaticAberration;
    float refra=uRefraction;
    float sat=uSaturation;
    
    vec3 lightPos=uLightPosition;
    float d=uDiffuse;
    float s=uSpecular;
    
    float fr=uFresnel;
    vec3 frCol=uFresnelColor;
    
    for(int i=0;i<SAMPLES;i++){
        float slide=float(i)/float(SAMPLES)*.1;
        
        vec3 refractVecR=refract(vEyeVector,vNormal,(1./iorR));
        vec3 refractVecY=refract(vEyeVector,vNormal,(1./iorY));
        vec3 refractVecG=refract(vEyeVector,vNormal,(1./iorG));
        vec3 refractVecC=refract(vEyeVector,vNormal,(1./iorC));
        vec3 refractVecB=refract(vEyeVector,vNormal,(1./iorB));
        vec3 refractVecP=refract(vEyeVector,vNormal,(1./iorP));
        
        float r=texture(uTexture,p+refractVecR.xy*(refra+slide*1.)*cr).x*.5;
        
        float y=(texture(uTexture,p+refractVecY.xy*(refra+slide*1.)*cr).x*2.+
        texture(uTexture,p+refractVecY.xy*(refra+slide*1.)*cr).y*2.-
        texture(uTexture,p+refractVecY.xy*(refra+slide*1.)*cr).z)/6.;
        
        float g=texture(uTexture,p+refractVecG.xy*(refra+slide*2.)*cr).y*.5;
        
        float c=(texture(uTexture,p+refractVecC.xy*(refra+slide*2.5)*cr).y*2.+
        texture(uTexture,p+refractVecC.xy*(refra+slide*2.5)*cr).z*2.-
        texture(uTexture,p+refractVecC.xy*(refra+slide*2.5)*cr).x)/6.;
        
        float b=texture(uTexture,p+refractVecB.xy*(refra+slide*3.)*cr).z*.5;
        
        float p=(texture(uTexture,p+refractVecP.xy*(refra+slide*1.)*cr).z*2.+
        texture(uTexture,p+refractVecP.xy*(refra+slide*1.)*cr).x*2.-
        texture(uTexture,p+refractVecP.xy*(refra+slide*1.)*cr).y)/6.;
        
        float R=r+(2.*p+2.*y-c)/3.;
        float G=g+(2.*y+2.*c-p)/3.;
        float B=b+(2.*c+2.*p-y)/3.;
        
        col.r+=R;
        col.g+=G;
        col.b+=B;
        
        col=saturation(col,sat);
    }
    
    col/=float(SAMPLES);
    
    float lin=lighting(lightPos,vNormal,vEyeVector,d,s);
    col+=vec3(lin);
    
    float F=fresnel2(vEyeVector,vNormal,fr);
    col+=vec3(F)*frCol;
    
    gl_FragColor=vec4(col,1.);
}
`
);
var MeshTransmissionMaterial = class extends Component {
  constructor(base, parent, config3 = {}) {
    super(base);
    __publicField(this, "fbo");
    __publicField(this, "fboBack");
    __publicField(this, "material");
    __publicField(this, "parent");
    __publicField(this, "backside");
    __publicField(this, "background");
    __publicField(this, "oldBg");
    const { backside = true, samples = 16, background = null, chromaticAberration = 0.5, refraction = 0.25, saturation = 1.14, lightPosition = new Vector3(-1, 1, 1), diffuse = 0.2, specular = 15, fresnel = 8, fresnelColor = new Color("#ffffff") } = config3;
    this.backside = backside;
    this.background = background;
    this.parent = parent;
    const fbo = new FBO(this.base);
    this.fbo = fbo;
    const fboBack = new FBO(this.base);
    this.fboBack = fboBack;
    const material2 = new ShaderMaterial({
      vertexShader: transmissionVertexShader,
      fragmentShader: transmissionFragmentShader,
      defines: {
        SAMPLES: samples
      },
      uniforms: {
        uTexture: {
          value: null
        },
        uFBOResolution: {
          value: new Vector2(fbo.rt.width, fbo.rt.height)
        },
        uChromaticAberration: {
          value: chromaticAberration
        },
        uRefraction: {
          value: refraction
        },
        uSaturation: {
          value: saturation
        },
        uLightPosition: {
          value: lightPosition
        },
        uDiffuse: {
          value: diffuse
        },
        uSpecular: {
          value: specular
        },
        uFresnel: {
          value: fresnel
        },
        uFresnelColor: {
          value: fresnelColor
        }
      }
    });
    this.material = material2;
    this.oldBg = null;
    this.base.resizer.on("resize", () => {
      material2.uniforms.uFBOResolution.value = new Vector2(fbo.rt.width, fbo.rt.height);
    });
  }
  update(time) {
    const { fbo, fboBack } = this;
    this.oldBg = this.base.scene.background;
    if (this.background) {
      this.base.scene.background = this.background;
    }
    this.parent.visible = false;
    const mat = this.parent.material;
    if (this.backside) {
      this.base.renderer.setRenderTarget(fboBack.rt);
      this.base.renderer.render(this.base.scene, this.base.camera);
      mat.uniforms.uTexture.value = fboBack.rt.texture;
      mat.side = BackSide;
      this.parent.visible = true;
    }
    this.base.renderer.setRenderTarget(fbo.rt);
    this.base.renderer.render(this.base.scene, this.base.camera);
    mat.uniforms.uTexture.value = fbo.rt.texture;
    mat.side = FrontSide;
    this.base.scene.background = this.oldBg;
    this.base.renderer.setRenderTarget(null);
    this.parent.visible = true;
  }
};

// node_modules/gsap/gsap-core.js
function _assertThisInitialized(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}
var _config = {
  autoSleep: 120,
  force3D: "auto",
  nullTargetWarn: 1,
  units: {
    lineHeight: ""
  }
};
var _defaults = {
  duration: 0.5,
  overwrite: false,
  delay: 0
};
var _suppressOverwrites;
var _reverting;
var _context;
var _bigNum = 1e8;
var _tinyNum = 1 / _bigNum;
var _2PI = Math.PI * 2;
var _HALF_PI = _2PI / 4;
var _gsID = 0;
var _sqrt = Math.sqrt;
var _cos = Math.cos;
var _sin = Math.sin;
var _isString = function _isString2(value) {
  return typeof value === "string";
};
var _isFunction = function _isFunction2(value) {
  return typeof value === "function";
};
var _isNumber = function _isNumber2(value) {
  return typeof value === "number";
};
var _isUndefined = function _isUndefined2(value) {
  return typeof value === "undefined";
};
var _isObject = function _isObject2(value) {
  return typeof value === "object";
};
var _isNotFalse = function _isNotFalse2(value) {
  return value !== false;
};
var _windowExists = function _windowExists2() {
  return typeof window !== "undefined";
};
var _isFuncOrString = function _isFuncOrString2(value) {
  return _isFunction(value) || _isString(value);
};
var _isTypedArray = typeof ArrayBuffer === "function" && ArrayBuffer.isView || function() {
};
var _isArray = Array.isArray;
var _strictNumExp = /(?:-?\.?\d|\.)+/gi;
var _numExp = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g;
var _numWithUnitExp = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g;
var _complexStringNumExp = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi;
var _relExp = /[+-]=-?[.\d]+/;
var _delimitedValueExp = /[^,'"\[\]\s]+/gi;
var _unitExp = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i;
var _globalTimeline;
var _win;
var _coreInitted;
var _doc;
var _globals = {};
var _installScope = {};
var _coreReady;
var _install = function _install2(scope) {
  return (_installScope = _merge(scope, _globals)) && gsap;
};
var _missingPlugin = function _missingPlugin2(property, value) {
  return console.warn("Invalid property", property, "set to", value, "Missing plugin? gsap.registerPlugin()");
};
var _warn = function _warn2(message, suppress) {
  return !suppress && console.warn(message);
};
var _addGlobal = function _addGlobal2(name, obj) {
  return name && (_globals[name] = obj) && _installScope && (_installScope[name] = obj) || _globals;
};
var _emptyFunc = function _emptyFunc2() {
  return 0;
};
var _startAtRevertConfig = {
  suppressEvents: true,
  isStart: true,
  kill: false
};
var _revertConfigNoKill = {
  suppressEvents: true,
  kill: false
};
var _revertConfig = {
  suppressEvents: true
};
var _reservedProps = {};
var _lazyTweens = [];
var _lazyLookup = {};
var _lastRenderedFrame;
var _plugins = {};
var _effects = {};
var _nextGCFrame = 30;
var _harnessPlugins = [];
var _callbackNames = "";
var _harness = function _harness2(targets) {
  var target = targets[0], harnessPlugin, i3;
  _isObject(target) || _isFunction(target) || (targets = [targets]);
  if (!(harnessPlugin = (target._gsap || {}).harness)) {
    i3 = _harnessPlugins.length;
    while (i3-- && !_harnessPlugins[i3].targetTest(target)) {
    }
    harnessPlugin = _harnessPlugins[i3];
  }
  i3 = targets.length;
  while (i3--) {
    targets[i3] && (targets[i3]._gsap || (targets[i3]._gsap = new GSCache(targets[i3], harnessPlugin))) || targets.splice(i3, 1);
  }
  return targets;
};
var _getCache = function _getCache2(target) {
  return target._gsap || _harness(toArray(target))[0]._gsap;
};
var _getProperty = function _getProperty2(target, property, v) {
  return (v = target[property]) && _isFunction(v) ? target[property]() : _isUndefined(v) && target.getAttribute && target.getAttribute(property) || v;
};
var _forEachName = function _forEachName2(names, func) {
  return (names = names.split(",")).forEach(func) || names;
};
var _round = function _round2(value) {
  return Math.round(value * 1e5) / 1e5 || 0;
};
var _roundPrecise = function _roundPrecise2(value) {
  return Math.round(value * 1e7) / 1e7 || 0;
};
var _parseRelative = function _parseRelative2(start, value) {
  var operator = value.charAt(0), end = parseFloat(value.substr(2));
  start = parseFloat(start);
  return operator === "+" ? start + end : operator === "-" ? start - end : operator === "*" ? start * end : start / end;
};
var _arrayContainsAny = function _arrayContainsAny2(toSearch, toFind) {
  var l = toFind.length, i3 = 0;
  for (; toSearch.indexOf(toFind[i3]) < 0 && ++i3 < l; ) {
  }
  return i3 < l;
};
var _lazyRender = function _lazyRender2() {
  var l = _lazyTweens.length, a4 = _lazyTweens.slice(0), i3, tween;
  _lazyLookup = {};
  _lazyTweens.length = 0;
  for (i3 = 0; i3 < l; i3++) {
    tween = a4[i3];
    tween && tween._lazy && (tween.render(tween._lazy[0], tween._lazy[1], true)._lazy = 0);
  }
};
var _lazySafeRender = function _lazySafeRender2(animation, time, suppressEvents, force) {
  _lazyTweens.length && !_reverting && _lazyRender();
  animation.render(time, suppressEvents, force || _reverting && time < 0 && (animation._initted || animation._startAt));
  _lazyTweens.length && !_reverting && _lazyRender();
};
var _numericIfPossible = function _numericIfPossible2(value) {
  var n = parseFloat(value);
  return (n || n === 0) && (value + "").match(_delimitedValueExp).length < 2 ? n : _isString(value) ? value.trim() : value;
};
var _passThrough = function _passThrough2(p) {
  return p;
};
var _setDefaults = function _setDefaults2(obj, defaults2) {
  for (var p in defaults2) {
    p in obj || (obj[p] = defaults2[p]);
  }
  return obj;
};
var _setKeyframeDefaults = function _setKeyframeDefaults2(excludeDuration) {
  return function(obj, defaults2) {
    for (var p in defaults2) {
      p in obj || p === "duration" && excludeDuration || p === "ease" || (obj[p] = defaults2[p]);
    }
  };
};
var _merge = function _merge2(base, toMerge) {
  for (var p in toMerge) {
    base[p] = toMerge[p];
  }
  return base;
};
var _mergeDeep = function _mergeDeep2(base, toMerge) {
  for (var p in toMerge) {
    p !== "__proto__" && p !== "constructor" && p !== "prototype" && (base[p] = _isObject(toMerge[p]) ? _mergeDeep2(base[p] || (base[p] = {}), toMerge[p]) : toMerge[p]);
  }
  return base;
};
var _copyExcluding = function _copyExcluding2(obj, excluding) {
  var copy = {}, p;
  for (p in obj) {
    p in excluding || (copy[p] = obj[p]);
  }
  return copy;
};
var _inheritDefaults = function _inheritDefaults2(vars) {
  var parent = vars.parent || _globalTimeline, func = vars.keyframes ? _setKeyframeDefaults(_isArray(vars.keyframes)) : _setDefaults;
  if (_isNotFalse(vars.inherit)) {
    while (parent) {
      func(vars, parent.vars.defaults);
      parent = parent.parent || parent._dp;
    }
  }
  return vars;
};
var _arraysMatch = function _arraysMatch2(a1, a22) {
  var i3 = a1.length, match = i3 === a22.length;
  while (match && i3-- && a1[i3] === a22[i3]) {
  }
  return i3 < 0;
};
var _addLinkedListItem = function _addLinkedListItem2(parent, child, firstProp, lastProp, sortBy) {
  if (firstProp === void 0) {
    firstProp = "_first";
  }
  if (lastProp === void 0) {
    lastProp = "_last";
  }
  var prev = parent[lastProp], t2;
  if (sortBy) {
    t2 = child[sortBy];
    while (prev && prev[sortBy] > t2) {
      prev = prev._prev;
    }
  }
  if (prev) {
    child._next = prev._next;
    prev._next = child;
  } else {
    child._next = parent[firstProp];
    parent[firstProp] = child;
  }
  if (child._next) {
    child._next._prev = child;
  } else {
    parent[lastProp] = child;
  }
  child._prev = prev;
  child.parent = child._dp = parent;
  return child;
};
var _removeLinkedListItem = function _removeLinkedListItem2(parent, child, firstProp, lastProp) {
  if (firstProp === void 0) {
    firstProp = "_first";
  }
  if (lastProp === void 0) {
    lastProp = "_last";
  }
  var prev = child._prev, next = child._next;
  if (prev) {
    prev._next = next;
  } else if (parent[firstProp] === child) {
    parent[firstProp] = next;
  }
  if (next) {
    next._prev = prev;
  } else if (parent[lastProp] === child) {
    parent[lastProp] = prev;
  }
  child._next = child._prev = child.parent = null;
};
var _removeFromParent = function _removeFromParent2(child, onlyIfParentHasAutoRemove) {
  child.parent && (!onlyIfParentHasAutoRemove || child.parent.autoRemoveChildren) && child.parent.remove && child.parent.remove(child);
  child._act = 0;
};
var _uncache = function _uncache2(animation, child) {
  if (animation && (!child || child._end > animation._dur || child._start < 0)) {
    var a4 = animation;
    while (a4) {
      a4._dirty = 1;
      a4 = a4.parent;
    }
  }
  return animation;
};
var _recacheAncestors = function _recacheAncestors2(animation) {
  var parent = animation.parent;
  while (parent && parent.parent) {
    parent._dirty = 1;
    parent.totalDuration();
    parent = parent.parent;
  }
  return animation;
};
var _rewindStartAt = function _rewindStartAt2(tween, totalTime, suppressEvents, force) {
  return tween._startAt && (_reverting ? tween._startAt.revert(_revertConfigNoKill) : tween.vars.immediateRender && !tween.vars.autoRevert || tween._startAt.render(totalTime, true, force));
};
var _hasNoPausedAncestors = function _hasNoPausedAncestors2(animation) {
  return !animation || animation._ts && _hasNoPausedAncestors2(animation.parent);
};
var _elapsedCycleDuration = function _elapsedCycleDuration2(animation) {
  return animation._repeat ? _animationCycle(animation._tTime, animation = animation.duration() + animation._rDelay) * animation : 0;
};
var _animationCycle = function _animationCycle2(tTime, cycleDuration) {
  var whole = Math.floor(tTime /= cycleDuration);
  return tTime && whole === tTime ? whole - 1 : whole;
};
var _parentToChildTotalTime = function _parentToChildTotalTime2(parentTime, child) {
  return (parentTime - child._start) * child._ts + (child._ts >= 0 ? 0 : child._dirty ? child.totalDuration() : child._tDur);
};
var _setEnd = function _setEnd2(animation) {
  return animation._end = _roundPrecise(animation._start + (animation._tDur / Math.abs(animation._ts || animation._rts || _tinyNum) || 0));
};
var _alignPlayhead = function _alignPlayhead2(animation, totalTime) {
  var parent = animation._dp;
  if (parent && parent.smoothChildTiming && animation._ts) {
    animation._start = _roundPrecise(parent._time - (animation._ts > 0 ? totalTime / animation._ts : ((animation._dirty ? animation.totalDuration() : animation._tDur) - totalTime) / -animation._ts));
    _setEnd(animation);
    parent._dirty || _uncache(parent, animation);
  }
  return animation;
};
var _postAddChecks = function _postAddChecks2(timeline2, child) {
  var t2;
  if (child._time || !child._dur && child._initted || child._start < timeline2._time && (child._dur || !child.add)) {
    t2 = _parentToChildTotalTime(timeline2.rawTime(), child);
    if (!child._dur || _clamp(0, child.totalDuration(), t2) - child._tTime > _tinyNum) {
      child.render(t2, true);
    }
  }
  if (_uncache(timeline2, child)._dp && timeline2._initted && timeline2._time >= timeline2._dur && timeline2._ts) {
    if (timeline2._dur < timeline2.duration()) {
      t2 = timeline2;
      while (t2._dp) {
        t2.rawTime() >= 0 && t2.totalTime(t2._tTime);
        t2 = t2._dp;
      }
    }
    timeline2._zTime = -_tinyNum;
  }
};
var _addToTimeline = function _addToTimeline2(timeline2, child, position, skipChecks) {
  child.parent && _removeFromParent(child);
  child._start = _roundPrecise((_isNumber(position) ? position : position || timeline2 !== _globalTimeline ? _parsePosition(timeline2, position, child) : timeline2._time) + child._delay);
  child._end = _roundPrecise(child._start + (child.totalDuration() / Math.abs(child.timeScale()) || 0));
  _addLinkedListItem(timeline2, child, "_first", "_last", timeline2._sort ? "_start" : 0);
  _isFromOrFromStart(child) || (timeline2._recent = child);
  skipChecks || _postAddChecks(timeline2, child);
  timeline2._ts < 0 && _alignPlayhead(timeline2, timeline2._tTime);
  return timeline2;
};
var _scrollTrigger = function _scrollTrigger2(animation, trigger) {
  return (_globals.ScrollTrigger || _missingPlugin("scrollTrigger", trigger)) && _globals.ScrollTrigger.create(trigger, animation);
};
var _attemptInitTween = function _attemptInitTween2(tween, time, force, suppressEvents, tTime) {
  _initTween(tween, time, tTime);
  if (!tween._initted) {
    return 1;
  }
  if (!force && tween._pt && !_reverting && (tween._dur && tween.vars.lazy !== false || !tween._dur && tween.vars.lazy) && _lastRenderedFrame !== _ticker.frame) {
    _lazyTweens.push(tween);
    tween._lazy = [tTime, suppressEvents];
    return 1;
  }
};
var _parentPlayheadIsBeforeStart = function _parentPlayheadIsBeforeStart2(_ref) {
  var parent = _ref.parent;
  return parent && parent._ts && parent._initted && !parent._lock && (parent.rawTime() < 0 || _parentPlayheadIsBeforeStart2(parent));
};
var _isFromOrFromStart = function _isFromOrFromStart2(_ref2) {
  var data = _ref2.data;
  return data === "isFromStart" || data === "isStart";
};
var _renderZeroDurationTween = function _renderZeroDurationTween2(tween, totalTime, suppressEvents, force) {
  var prevRatio = tween.ratio, ratio = totalTime < 0 || !totalTime && (!tween._start && _parentPlayheadIsBeforeStart(tween) && !(!tween._initted && _isFromOrFromStart(tween)) || (tween._ts < 0 || tween._dp._ts < 0) && !_isFromOrFromStart(tween)) ? 0 : 1, repeatDelay = tween._rDelay, tTime = 0, pt, iteration, prevIteration;
  if (repeatDelay && tween._repeat) {
    tTime = _clamp(0, tween._tDur, totalTime);
    iteration = _animationCycle(tTime, repeatDelay);
    tween._yoyo && iteration & 1 && (ratio = 1 - ratio);
    if (iteration !== _animationCycle(tween._tTime, repeatDelay)) {
      prevRatio = 1 - ratio;
      tween.vars.repeatRefresh && tween._initted && tween.invalidate();
    }
  }
  if (ratio !== prevRatio || _reverting || force || tween._zTime === _tinyNum || !totalTime && tween._zTime) {
    if (!tween._initted && _attemptInitTween(tween, totalTime, force, suppressEvents, tTime)) {
      return;
    }
    prevIteration = tween._zTime;
    tween._zTime = totalTime || (suppressEvents ? _tinyNum : 0);
    suppressEvents || (suppressEvents = totalTime && !prevIteration);
    tween.ratio = ratio;
    tween._from && (ratio = 1 - ratio);
    tween._time = 0;
    tween._tTime = tTime;
    pt = tween._pt;
    while (pt) {
      pt.r(ratio, pt.d);
      pt = pt._next;
    }
    totalTime < 0 && _rewindStartAt(tween, totalTime, suppressEvents, true);
    tween._onUpdate && !suppressEvents && _callback(tween, "onUpdate");
    tTime && tween._repeat && !suppressEvents && tween.parent && _callback(tween, "onRepeat");
    if ((totalTime >= tween._tDur || totalTime < 0) && tween.ratio === ratio) {
      ratio && _removeFromParent(tween, 1);
      if (!suppressEvents && !_reverting) {
        _callback(tween, ratio ? "onComplete" : "onReverseComplete", true);
        tween._prom && tween._prom();
      }
    }
  } else if (!tween._zTime) {
    tween._zTime = totalTime;
  }
};
var _findNextPauseTween = function _findNextPauseTween2(animation, prevTime, time) {
  var child;
  if (time > prevTime) {
    child = animation._first;
    while (child && child._start <= time) {
      if (child.data === "isPause" && child._start > prevTime) {
        return child;
      }
      child = child._next;
    }
  } else {
    child = animation._last;
    while (child && child._start >= time) {
      if (child.data === "isPause" && child._start < prevTime) {
        return child;
      }
      child = child._prev;
    }
  }
};
var _setDuration = function _setDuration2(animation, duration, skipUncache, leavePlayhead) {
  var repeat = animation._repeat, dur = _roundPrecise(duration) || 0, totalProgress = animation._tTime / animation._tDur;
  totalProgress && !leavePlayhead && (animation._time *= dur / animation._dur);
  animation._dur = dur;
  animation._tDur = !repeat ? dur : repeat < 0 ? 1e10 : _roundPrecise(dur * (repeat + 1) + animation._rDelay * repeat);
  totalProgress > 0 && !leavePlayhead && _alignPlayhead(animation, animation._tTime = animation._tDur * totalProgress);
  animation.parent && _setEnd(animation);
  skipUncache || _uncache(animation.parent, animation);
  return animation;
};
var _onUpdateTotalDuration = function _onUpdateTotalDuration2(animation) {
  return animation instanceof Timeline ? _uncache(animation) : _setDuration(animation, animation._dur);
};
var _zeroPosition = {
  _start: 0,
  endTime: _emptyFunc,
  totalDuration: _emptyFunc
};
var _parsePosition = function _parsePosition2(animation, position, percentAnimation) {
  var labels = animation.labels, recent = animation._recent || _zeroPosition, clippedDuration = animation.duration() >= _bigNum ? recent.endTime(false) : animation._dur, i3, offset, isPercent;
  if (_isString(position) && (isNaN(position) || position in labels)) {
    offset = position.charAt(0);
    isPercent = position.substr(-1) === "%";
    i3 = position.indexOf("=");
    if (offset === "<" || offset === ">") {
      i3 >= 0 && (position = position.replace(/=/, ""));
      return (offset === "<" ? recent._start : recent.endTime(recent._repeat >= 0)) + (parseFloat(position.substr(1)) || 0) * (isPercent ? (i3 < 0 ? recent : percentAnimation).totalDuration() / 100 : 1);
    }
    if (i3 < 0) {
      position in labels || (labels[position] = clippedDuration);
      return labels[position];
    }
    offset = parseFloat(position.charAt(i3 - 1) + position.substr(i3 + 1));
    if (isPercent && percentAnimation) {
      offset = offset / 100 * (_isArray(percentAnimation) ? percentAnimation[0] : percentAnimation).totalDuration();
    }
    return i3 > 1 ? _parsePosition2(animation, position.substr(0, i3 - 1), percentAnimation) + offset : clippedDuration + offset;
  }
  return position == null ? clippedDuration : +position;
};
var _createTweenType = function _createTweenType2(type, params, timeline2) {
  var isLegacy = _isNumber(params[1]), varsIndex = (isLegacy ? 2 : 1) + (type < 2 ? 0 : 1), vars = params[varsIndex], irVars, parent;
  isLegacy && (vars.duration = params[1]);
  vars.parent = timeline2;
  if (type) {
    irVars = vars;
    parent = timeline2;
    while (parent && !("immediateRender" in irVars)) {
      irVars = parent.vars.defaults || {};
      parent = _isNotFalse(parent.vars.inherit) && parent.parent;
    }
    vars.immediateRender = _isNotFalse(irVars.immediateRender);
    type < 2 ? vars.runBackwards = 1 : vars.startAt = params[varsIndex - 1];
  }
  return new Tween(params[0], vars, params[varsIndex + 1]);
};
var _conditionalReturn = function _conditionalReturn2(value, func) {
  return value || value === 0 ? func(value) : func;
};
var _clamp = function _clamp2(min, max3, value) {
  return value < min ? min : value > max3 ? max3 : value;
};
var getUnit = function getUnit2(value, v) {
  return !_isString(value) || !(v = _unitExp.exec(value)) ? "" : v[1];
};
var clamp3 = function clamp4(min, max3, value) {
  return _conditionalReturn(value, function(v) {
    return _clamp(min, max3, v);
  });
};
var _slice = [].slice;
var _isArrayLike = function _isArrayLike2(value, nonEmpty) {
  return value && _isObject(value) && "length" in value && (!nonEmpty && !value.length || value.length - 1 in value && _isObject(value[0])) && !value.nodeType && value !== _win;
};
var _flatten = function _flatten2(ar, leaveStrings, accumulator) {
  if (accumulator === void 0) {
    accumulator = [];
  }
  return ar.forEach(function(value) {
    var _accumulator;
    return _isString(value) && !leaveStrings || _isArrayLike(value, 1) ? (_accumulator = accumulator).push.apply(_accumulator, toArray(value)) : accumulator.push(value);
  }) || accumulator;
};
var toArray = function toArray2(value, scope, leaveStrings) {
  return _context && !scope && _context.selector ? _context.selector(value) : _isString(value) && !leaveStrings && (_coreInitted || !_wake()) ? _slice.call((scope || _doc).querySelectorAll(value), 0) : _isArray(value) ? _flatten(value, leaveStrings) : _isArrayLike(value) ? _slice.call(value, 0) : value ? [value] : [];
};
var selector = function selector2(value) {
  value = toArray(value)[0] || _warn("Invalid scope") || {};
  return function(v) {
    var el = value.current || value.nativeElement || value;
    return toArray(v, el.querySelectorAll ? el : el === value ? _warn("Invalid scope") || _doc.createElement("div") : value);
  };
};
var shuffle = function shuffle2(a4) {
  return a4.sort(function() {
    return 0.5 - Math.random();
  });
};
var distribute = function distribute2(v) {
  if (_isFunction(v)) {
    return v;
  }
  var vars = _isObject(v) ? v : {
    each: v
  }, ease = _parseEase(vars.ease), from = vars.from || 0, base = parseFloat(vars.base) || 0, cache = {}, isDecimal = from > 0 && from < 1, ratios = isNaN(from) || isDecimal, axis = vars.axis, ratioX = from, ratioY = from;
  if (_isString(from)) {
    ratioX = ratioY = {
      center: 0.5,
      edges: 0.5,
      end: 1
    }[from] || 0;
  } else if (!isDecimal && ratios) {
    ratioX = from[0];
    ratioY = from[1];
  }
  return function(i3, target, a4) {
    var l = (a4 || vars).length, distances = cache[l], originX, originY, x, y, d, j, max3, min, wrapAt;
    if (!distances) {
      wrapAt = vars.grid === "auto" ? 0 : (vars.grid || [1, _bigNum])[1];
      if (!wrapAt) {
        max3 = -_bigNum;
        while (max3 < (max3 = a4[wrapAt++].getBoundingClientRect().left) && wrapAt < l) {
        }
        wrapAt--;
      }
      distances = cache[l] = [];
      originX = ratios ? Math.min(wrapAt, l) * ratioX - 0.5 : from % wrapAt;
      originY = wrapAt === _bigNum ? 0 : ratios ? l * ratioY / wrapAt - 0.5 : from / wrapAt | 0;
      max3 = 0;
      min = _bigNum;
      for (j = 0; j < l; j++) {
        x = j % wrapAt - originX;
        y = originY - (j / wrapAt | 0);
        distances[j] = d = !axis ? _sqrt(x * x + y * y) : Math.abs(axis === "y" ? y : x);
        d > max3 && (max3 = d);
        d < min && (min = d);
      }
      from === "random" && shuffle(distances);
      distances.max = max3 - min;
      distances.min = min;
      distances.v = l = (parseFloat(vars.amount) || parseFloat(vars.each) * (wrapAt > l ? l - 1 : !axis ? Math.max(wrapAt, l / wrapAt) : axis === "y" ? l / wrapAt : wrapAt) || 0) * (from === "edges" ? -1 : 1);
      distances.b = l < 0 ? base - l : base;
      distances.u = getUnit(vars.amount || vars.each) || 0;
      ease = ease && l < 0 ? _invertEase(ease) : ease;
    }
    l = (distances[i3] - distances.min) / distances.max || 0;
    return _roundPrecise(distances.b + (ease ? ease(l) : l) * distances.v) + distances.u;
  };
};
var _roundModifier = function _roundModifier2(v) {
  var p = Math.pow(10, ((v + "").split(".")[1] || "").length);
  return function(raw) {
    var n = _roundPrecise(Math.round(parseFloat(raw) / v) * v * p);
    return (n - n % 1) / p + (_isNumber(raw) ? 0 : getUnit(raw));
  };
};
var snap = function snap2(snapTo, value) {
  var isArray = _isArray(snapTo), radius, is2D;
  if (!isArray && _isObject(snapTo)) {
    radius = isArray = snapTo.radius || _bigNum;
    if (snapTo.values) {
      snapTo = toArray(snapTo.values);
      if (is2D = !_isNumber(snapTo[0])) {
        radius *= radius;
      }
    } else {
      snapTo = _roundModifier(snapTo.increment);
    }
  }
  return _conditionalReturn(value, !isArray ? _roundModifier(snapTo) : _isFunction(snapTo) ? function(raw) {
    is2D = snapTo(raw);
    return Math.abs(is2D - raw) <= radius ? is2D : raw;
  } : function(raw) {
    var x = parseFloat(is2D ? raw.x : raw), y = parseFloat(is2D ? raw.y : 0), min = _bigNum, closest = 0, i3 = snapTo.length, dx, dy;
    while (i3--) {
      if (is2D) {
        dx = snapTo[i3].x - x;
        dy = snapTo[i3].y - y;
        dx = dx * dx + dy * dy;
      } else {
        dx = Math.abs(snapTo[i3] - x);
      }
      if (dx < min) {
        min = dx;
        closest = i3;
      }
    }
    closest = !radius || min <= radius ? snapTo[closest] : raw;
    return is2D || closest === raw || _isNumber(raw) ? closest : closest + getUnit(raw);
  });
};
var random = function random2(min, max3, roundingIncrement, returnFunction) {
  return _conditionalReturn(_isArray(min) ? !max3 : roundingIncrement === true ? !!(roundingIncrement = 0) : !returnFunction, function() {
    return _isArray(min) ? min[~~(Math.random() * min.length)] : (roundingIncrement = roundingIncrement || 1e-5) && (returnFunction = roundingIncrement < 1 ? Math.pow(10, (roundingIncrement + "").length - 2) : 1) && Math.floor(Math.round((min - roundingIncrement / 2 + Math.random() * (max3 - min + roundingIncrement * 0.99)) / roundingIncrement) * roundingIncrement * returnFunction) / returnFunction;
  });
};
var pipe = function pipe2() {
  for (var _len = arguments.length, functions = new Array(_len), _key = 0; _key < _len; _key++) {
    functions[_key] = arguments[_key];
  }
  return function(value) {
    return functions.reduce(function(v, f) {
      return f(v);
    }, value);
  };
};
var unitize = function unitize2(func, unit) {
  return function(value) {
    return func(parseFloat(value)) + (unit || getUnit(value));
  };
};
var normalize = function normalize2(min, max3, value) {
  return mapRange(min, max3, 0, 1, value);
};
var _wrapArray = function _wrapArray2(a4, wrapper, value) {
  return _conditionalReturn(value, function(index) {
    return a4[~~wrapper(index)];
  });
};
var wrap = function wrap2(min, max3, value) {
  var range2 = max3 - min;
  return _isArray(min) ? _wrapArray(min, wrap2(0, min.length), max3) : _conditionalReturn(value, function(value2) {
    return (range2 + (value2 - min) % range2) % range2 + min;
  });
};
var wrapYoyo = function wrapYoyo2(min, max3, value) {
  var range2 = max3 - min, total = range2 * 2;
  return _isArray(min) ? _wrapArray(min, wrapYoyo2(0, min.length - 1), max3) : _conditionalReturn(value, function(value2) {
    value2 = (total + (value2 - min) % total) % total || 0;
    return min + (value2 > range2 ? total - value2 : value2);
  });
};
var _replaceRandom = function _replaceRandom2(value) {
  var prev = 0, s = "", i3, nums, end, isArray;
  while (~(i3 = value.indexOf("random(", prev))) {
    end = value.indexOf(")", i3);
    isArray = value.charAt(i3 + 7) === "[";
    nums = value.substr(i3 + 7, end - i3 - 7).match(isArray ? _delimitedValueExp : _strictNumExp);
    s += value.substr(prev, i3 - prev) + random(isArray ? nums : +nums[0], isArray ? 0 : +nums[1], +nums[2] || 1e-5);
    prev = end + 1;
  }
  return s + value.substr(prev, value.length - prev);
};
var mapRange = function mapRange2(inMin, inMax, outMin, outMax, value) {
  var inRange = inMax - inMin, outRange = outMax - outMin;
  return _conditionalReturn(value, function(value2) {
    return outMin + ((value2 - inMin) / inRange * outRange || 0);
  });
};
var interpolate = function interpolate2(start, end, progress, mutate) {
  var func = isNaN(start + end) ? 0 : function(p2) {
    return (1 - p2) * start + p2 * end;
  };
  if (!func) {
    var isString = _isString(start), master = {}, p, i3, interpolators, l, il;
    progress === true && (mutate = 1) && (progress = null);
    if (isString) {
      start = {
        p: start
      };
      end = {
        p: end
      };
    } else if (_isArray(start) && !_isArray(end)) {
      interpolators = [];
      l = start.length;
      il = l - 2;
      for (i3 = 1; i3 < l; i3++) {
        interpolators.push(interpolate2(start[i3 - 1], start[i3]));
      }
      l--;
      func = function func2(p2) {
        p2 *= l;
        var i4 = Math.min(il, ~~p2);
        return interpolators[i4](p2 - i4);
      };
      progress = end;
    } else if (!mutate) {
      start = _merge(_isArray(start) ? [] : {}, start);
    }
    if (!interpolators) {
      for (p in end) {
        _addPropTween.call(master, start, p, "get", end[p]);
      }
      func = function func2(p2) {
        return _renderPropTweens(p2, master) || (isString ? start.p : start);
      };
    }
  }
  return _conditionalReturn(progress, func);
};
var _getLabelInDirection = function _getLabelInDirection2(timeline2, fromTime, backward) {
  var labels = timeline2.labels, min = _bigNum, p, distance2, label;
  for (p in labels) {
    distance2 = labels[p] - fromTime;
    if (distance2 < 0 === !!backward && distance2 && min > (distance2 = Math.abs(distance2))) {
      label = p;
      min = distance2;
    }
  }
  return label;
};
var _callback = function _callback2(animation, type, executeLazyFirst) {
  var v = animation.vars, callback = v[type], prevContext = _context, context3 = animation._ctx, params, scope, result;
  if (!callback) {
    return;
  }
  params = v[type + "Params"];
  scope = v.callbackScope || animation;
  executeLazyFirst && _lazyTweens.length && _lazyRender();
  context3 && (_context = context3);
  result = params ? callback.apply(scope, params) : callback.call(scope);
  _context = prevContext;
  return result;
};
var _interrupt = function _interrupt2(animation) {
  _removeFromParent(animation);
  animation.scrollTrigger && animation.scrollTrigger.kill(!!_reverting);
  animation.progress() < 1 && _callback(animation, "onInterrupt");
  return animation;
};
var _quickTween;
var _registerPluginQueue = [];
var _createPlugin = function _createPlugin2(config3) {
  if (_windowExists() && config3) {
    config3 = !config3.name && config3["default"] || config3;
    var name = config3.name, isFunc = _isFunction(config3), Plugin = name && !isFunc && config3.init ? function() {
      this._props = [];
    } : config3, instanceDefaults = {
      init: _emptyFunc,
      render: _renderPropTweens,
      add: _addPropTween,
      kill: _killPropTweensOf,
      modifier: _addPluginModifier,
      rawVars: 0
    }, statics = {
      targetTest: 0,
      get: 0,
      getSetter: _getSetter,
      aliases: {},
      register: 0
    };
    _wake();
    if (config3 !== Plugin) {
      if (_plugins[name]) {
        return;
      }
      _setDefaults(Plugin, _setDefaults(_copyExcluding(config3, instanceDefaults), statics));
      _merge(Plugin.prototype, _merge(instanceDefaults, _copyExcluding(config3, statics)));
      _plugins[Plugin.prop = name] = Plugin;
      if (config3.targetTest) {
        _harnessPlugins.push(Plugin);
        _reservedProps[name] = 1;
      }
      name = (name === "css" ? "CSS" : name.charAt(0).toUpperCase() + name.substr(1)) + "Plugin";
    }
    _addGlobal(name, Plugin);
    config3.register && config3.register(gsap, Plugin, PropTween);
  } else {
    config3 && _registerPluginQueue.push(config3);
  }
};
var _255 = 255;
var _colorLookup = {
  aqua: [0, _255, _255],
  lime: [0, _255, 0],
  silver: [192, 192, 192],
  black: [0, 0, 0],
  maroon: [128, 0, 0],
  teal: [0, 128, 128],
  blue: [0, 0, _255],
  navy: [0, 0, 128],
  white: [_255, _255, _255],
  olive: [128, 128, 0],
  yellow: [_255, _255, 0],
  orange: [_255, 165, 0],
  gray: [128, 128, 128],
  purple: [128, 0, 128],
  green: [0, 128, 0],
  red: [_255, 0, 0],
  pink: [_255, 192, 203],
  cyan: [0, _255, _255],
  transparent: [_255, _255, _255, 0]
};
var _hue = function _hue2(h, m1, m2) {
  h += h < 0 ? 1 : h > 1 ? -1 : 0;
  return (h * 6 < 1 ? m1 + (m2 - m1) * h * 6 : h < 0.5 ? m2 : h * 3 < 2 ? m1 + (m2 - m1) * (2 / 3 - h) * 6 : m1) * _255 + 0.5 | 0;
};
var splitColor = function splitColor2(v, toHSL, forceAlpha) {
  var a4 = !v ? _colorLookup.black : _isNumber(v) ? [v >> 16, v >> 8 & _255, v & _255] : 0, r, g2, b5, h, s, l, max3, min, d, wasHSL;
  if (!a4) {
    if (v.substr(-1) === ",") {
      v = v.substr(0, v.length - 1);
    }
    if (_colorLookup[v]) {
      a4 = _colorLookup[v];
    } else if (v.charAt(0) === "#") {
      if (v.length < 6) {
        r = v.charAt(1);
        g2 = v.charAt(2);
        b5 = v.charAt(3);
        v = "#" + r + r + g2 + g2 + b5 + b5 + (v.length === 5 ? v.charAt(4) + v.charAt(4) : "");
      }
      if (v.length === 9) {
        a4 = parseInt(v.substr(1, 6), 16);
        return [a4 >> 16, a4 >> 8 & _255, a4 & _255, parseInt(v.substr(7), 16) / 255];
      }
      v = parseInt(v.substr(1), 16);
      a4 = [v >> 16, v >> 8 & _255, v & _255];
    } else if (v.substr(0, 3) === "hsl") {
      a4 = wasHSL = v.match(_strictNumExp);
      if (!toHSL) {
        h = +a4[0] % 360 / 360;
        s = +a4[1] / 100;
        l = +a4[2] / 100;
        g2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;
        r = l * 2 - g2;
        a4.length > 3 && (a4[3] *= 1);
        a4[0] = _hue(h + 1 / 3, r, g2);
        a4[1] = _hue(h, r, g2);
        a4[2] = _hue(h - 1 / 3, r, g2);
      } else if (~v.indexOf("=")) {
        a4 = v.match(_numExp);
        forceAlpha && a4.length < 4 && (a4[3] = 1);
        return a4;
      }
    } else {
      a4 = v.match(_strictNumExp) || _colorLookup.transparent;
    }
    a4 = a4.map(Number);
  }
  if (toHSL && !wasHSL) {
    r = a4[0] / _255;
    g2 = a4[1] / _255;
    b5 = a4[2] / _255;
    max3 = Math.max(r, g2, b5);
    min = Math.min(r, g2, b5);
    l = (max3 + min) / 2;
    if (max3 === min) {
      h = s = 0;
    } else {
      d = max3 - min;
      s = l > 0.5 ? d / (2 - max3 - min) : d / (max3 + min);
      h = max3 === r ? (g2 - b5) / d + (g2 < b5 ? 6 : 0) : max3 === g2 ? (b5 - r) / d + 2 : (r - g2) / d + 4;
      h *= 60;
    }
    a4[0] = ~~(h + 0.5);
    a4[1] = ~~(s * 100 + 0.5);
    a4[2] = ~~(l * 100 + 0.5);
  }
  forceAlpha && a4.length < 4 && (a4[3] = 1);
  return a4;
};
var _colorOrderData = function _colorOrderData2(v) {
  var values = [], c3 = [], i3 = -1;
  v.split(_colorExp).forEach(function(v4) {
    var a4 = v4.match(_numWithUnitExp) || [];
    values.push.apply(values, a4);
    c3.push(i3 += a4.length + 1);
  });
  values.c = c3;
  return values;
};
var _formatColors = function _formatColors2(s, toHSL, orderMatchData) {
  var result = "", colors = (s + result).match(_colorExp), type = toHSL ? "hsla(" : "rgba(", i3 = 0, c3, shell, d, l;
  if (!colors) {
    return s;
  }
  colors = colors.map(function(color) {
    return (color = splitColor(color, toHSL, 1)) && type + (toHSL ? color[0] + "," + color[1] + "%," + color[2] + "%," + color[3] : color.join(",")) + ")";
  });
  if (orderMatchData) {
    d = _colorOrderData(s);
    c3 = orderMatchData.c;
    if (c3.join(result) !== d.c.join(result)) {
      shell = s.replace(_colorExp, "1").split(_numWithUnitExp);
      l = shell.length - 1;
      for (; i3 < l; i3++) {
        result += shell[i3] + (~c3.indexOf(i3) ? colors.shift() || type + "0,0,0,0)" : (d.length ? d : colors.length ? colors : orderMatchData).shift());
      }
    }
  }
  if (!shell) {
    shell = s.split(_colorExp);
    l = shell.length - 1;
    for (; i3 < l; i3++) {
      result += shell[i3] + colors[i3];
    }
  }
  return result + shell[l];
};
var _colorExp = function() {
  var s = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b", p;
  for (p in _colorLookup) {
    s += "|" + p + "\\b";
  }
  return new RegExp(s + ")", "gi");
}();
var _hslExp = /hsl[a]?\(/;
var _colorStringFilter = function _colorStringFilter2(a4) {
  var combined = a4.join(" "), toHSL;
  _colorExp.lastIndex = 0;
  if (_colorExp.test(combined)) {
    toHSL = _hslExp.test(combined);
    a4[1] = _formatColors(a4[1], toHSL);
    a4[0] = _formatColors(a4[0], toHSL, _colorOrderData(a4[1]));
    return true;
  }
};
var _tickerActive;
var _ticker = function() {
  var _getTime = Date.now, _lagThreshold = 500, _adjustedLag = 33, _startTime = _getTime(), _lastUpdate = _startTime, _gap = 1e3 / 240, _nextTime = _gap, _listeners2 = [], _id, _req, _raf, _self, _delta, _i, _tick = function _tick2(v) {
    var elapsed = _getTime() - _lastUpdate, manual = v === true, overlap, dispatch, time, frame;
    elapsed > _lagThreshold && (_startTime += elapsed - _adjustedLag);
    _lastUpdate += elapsed;
    time = _lastUpdate - _startTime;
    overlap = time - _nextTime;
    if (overlap > 0 || manual) {
      frame = ++_self.frame;
      _delta = time - _self.time * 1e3;
      _self.time = time = time / 1e3;
      _nextTime += overlap + (overlap >= _gap ? 4 : _gap - overlap);
      dispatch = 1;
    }
    manual || (_id = _req(_tick2));
    if (dispatch) {
      for (_i = 0; _i < _listeners2.length; _i++) {
        _listeners2[_i](time, _delta, frame, v);
      }
    }
  };
  _self = {
    time: 0,
    frame: 0,
    tick: function tick() {
      _tick(true);
    },
    deltaRatio: function deltaRatio(fps) {
      return _delta / (1e3 / (fps || 60));
    },
    wake: function wake() {
      if (_coreReady) {
        if (!_coreInitted && _windowExists()) {
          _win = _coreInitted = window;
          _doc = _win.document || {};
          _globals.gsap = gsap;
          (_win.gsapVersions || (_win.gsapVersions = [])).push(gsap.version);
          _install(_installScope || _win.GreenSockGlobals || !_win.gsap && _win || {});
          _raf = _win.requestAnimationFrame;
          _registerPluginQueue.forEach(_createPlugin);
        }
        _id && _self.sleep();
        _req = _raf || function(f) {
          return setTimeout(f, _nextTime - _self.time * 1e3 + 1 | 0);
        };
        _tickerActive = 1;
        _tick(2);
      }
    },
    sleep: function sleep2() {
      (_raf ? _win.cancelAnimationFrame : clearTimeout)(_id);
      _tickerActive = 0;
      _req = _emptyFunc;
    },
    lagSmoothing: function lagSmoothing(threshold, adjustedLag) {
      _lagThreshold = threshold || Infinity;
      _adjustedLag = Math.min(adjustedLag || 33, _lagThreshold);
    },
    fps: function fps(_fps) {
      _gap = 1e3 / (_fps || 240);
      _nextTime = _self.time * 1e3 + _gap;
    },
    add: function add(callback, once, prioritize) {
      var func = once ? function(t2, d, f, v) {
        callback(t2, d, f, v);
        _self.remove(func);
      } : callback;
      _self.remove(callback);
      _listeners2[prioritize ? "unshift" : "push"](func);
      _wake();
      return func;
    },
    remove: function remove(callback, i3) {
      ~(i3 = _listeners2.indexOf(callback)) && _listeners2.splice(i3, 1) && _i >= i3 && _i--;
    },
    _listeners: _listeners2
  };
  return _self;
}();
var _wake = function _wake2() {
  return !_tickerActive && _ticker.wake();
};
var _easeMap = {};
var _customEaseExp = /^[\d.\-M][\d.\-,\s]/;
var _quotesExp = /["']/g;
var _parseObjectInString = function _parseObjectInString2(value) {
  var obj = {}, split = value.substr(1, value.length - 3).split(":"), key = split[0], i3 = 1, l = split.length, index, val, parsedVal;
  for (; i3 < l; i3++) {
    val = split[i3];
    index = i3 !== l - 1 ? val.lastIndexOf(",") : val.length;
    parsedVal = val.substr(0, index);
    obj[key] = isNaN(parsedVal) ? parsedVal.replace(_quotesExp, "").trim() : +parsedVal;
    key = val.substr(index + 1).trim();
  }
  return obj;
};
var _valueInParentheses = function _valueInParentheses2(value) {
  var open = value.indexOf("(") + 1, close = value.indexOf(")"), nested = value.indexOf("(", open);
  return value.substring(open, ~nested && nested < close ? value.indexOf(")", close + 1) : close);
};
var _configEaseFromString = function _configEaseFromString2(name) {
  var split = (name + "").split("("), ease = _easeMap[split[0]];
  return ease && split.length > 1 && ease.config ? ease.config.apply(null, ~name.indexOf("{") ? [_parseObjectInString(split[1])] : _valueInParentheses(name).split(",").map(_numericIfPossible)) : _easeMap._CE && _customEaseExp.test(name) ? _easeMap._CE("", name) : ease;
};
var _invertEase = function _invertEase2(ease) {
  return function(p) {
    return 1 - ease(1 - p);
  };
};
var _propagateYoyoEase = function _propagateYoyoEase2(timeline2, isYoyo) {
  var child = timeline2._first, ease;
  while (child) {
    if (child instanceof Timeline) {
      _propagateYoyoEase2(child, isYoyo);
    } else if (child.vars.yoyoEase && (!child._yoyo || !child._repeat) && child._yoyo !== isYoyo) {
      if (child.timeline) {
        _propagateYoyoEase2(child.timeline, isYoyo);
      } else {
        ease = child._ease;
        child._ease = child._yEase;
        child._yEase = ease;
        child._yoyo = isYoyo;
      }
    }
    child = child._next;
  }
};
var _parseEase = function _parseEase2(ease, defaultEase) {
  return !ease ? defaultEase : (_isFunction(ease) ? ease : _easeMap[ease] || _configEaseFromString(ease)) || defaultEase;
};
var _insertEase = function _insertEase2(names, easeIn, easeOut, easeInOut) {
  if (easeOut === void 0) {
    easeOut = function easeOut2(p) {
      return 1 - easeIn(1 - p);
    };
  }
  if (easeInOut === void 0) {
    easeInOut = function easeInOut2(p) {
      return p < 0.5 ? easeIn(p * 2) / 2 : 1 - easeIn((1 - p) * 2) / 2;
    };
  }
  var ease = {
    easeIn,
    easeOut,
    easeInOut
  }, lowercaseName;
  _forEachName(names, function(name) {
    _easeMap[name] = _globals[name] = ease;
    _easeMap[lowercaseName = name.toLowerCase()] = easeOut;
    for (var p in ease) {
      _easeMap[lowercaseName + (p === "easeIn" ? ".in" : p === "easeOut" ? ".out" : ".inOut")] = _easeMap[name + "." + p] = ease[p];
    }
  });
  return ease;
};
var _easeInOutFromOut = function _easeInOutFromOut2(easeOut) {
  return function(p) {
    return p < 0.5 ? (1 - easeOut(1 - p * 2)) / 2 : 0.5 + easeOut((p - 0.5) * 2) / 2;
  };
};
var _configElastic = function _configElastic2(type, amplitude, period) {
  var p1 = amplitude >= 1 ? amplitude : 1, p2 = (period || (type ? 0.3 : 0.45)) / (amplitude < 1 ? amplitude : 1), p3 = p2 / _2PI * (Math.asin(1 / p1) || 0), easeOut = function easeOut2(p) {
    return p === 1 ? 1 : p1 * Math.pow(2, -10 * p) * _sin((p - p3) * p2) + 1;
  }, ease = type === "out" ? easeOut : type === "in" ? function(p) {
    return 1 - easeOut(1 - p);
  } : _easeInOutFromOut(easeOut);
  p2 = _2PI / p2;
  ease.config = function(amplitude2, period2) {
    return _configElastic2(type, amplitude2, period2);
  };
  return ease;
};
var _configBack = function _configBack2(type, overshoot) {
  if (overshoot === void 0) {
    overshoot = 1.70158;
  }
  var easeOut = function easeOut2(p) {
    return p ? --p * p * ((overshoot + 1) * p + overshoot) + 1 : 0;
  }, ease = type === "out" ? easeOut : type === "in" ? function(p) {
    return 1 - easeOut(1 - p);
  } : _easeInOutFromOut(easeOut);
  ease.config = function(overshoot2) {
    return _configBack2(type, overshoot2);
  };
  return ease;
};
_forEachName("Linear,Quad,Cubic,Quart,Quint,Strong", function(name, i3) {
  var power = i3 < 5 ? i3 + 1 : i3;
  _insertEase(name + ",Power" + (power - 1), i3 ? function(p) {
    return Math.pow(p, power);
  } : function(p) {
    return p;
  }, function(p) {
    return 1 - Math.pow(1 - p, power);
  }, function(p) {
    return p < 0.5 ? Math.pow(p * 2, power) / 2 : 1 - Math.pow((1 - p) * 2, power) / 2;
  });
});
_easeMap.Linear.easeNone = _easeMap.none = _easeMap.Linear.easeIn;
_insertEase("Elastic", _configElastic("in"), _configElastic("out"), _configElastic());
(function(n, c3) {
  var n1 = 1 / c3, n2 = 2 * n1, n3 = 2.5 * n1, easeOut = function easeOut2(p) {
    return p < n1 ? n * p * p : p < n2 ? n * Math.pow(p - 1.5 / c3, 2) + 0.75 : p < n3 ? n * (p -= 2.25 / c3) * p + 0.9375 : n * Math.pow(p - 2.625 / c3, 2) + 0.984375;
  };
  _insertEase("Bounce", function(p) {
    return 1 - easeOut(1 - p);
  }, easeOut);
})(7.5625, 2.75);
_insertEase("Expo", function(p) {
  return p ? Math.pow(2, 10 * (p - 1)) : 0;
});
_insertEase("Circ", function(p) {
  return -(_sqrt(1 - p * p) - 1);
});
_insertEase("Sine", function(p) {
  return p === 1 ? 1 : -_cos(p * _HALF_PI) + 1;
});
_insertEase("Back", _configBack("in"), _configBack("out"), _configBack());
_easeMap.SteppedEase = _easeMap.steps = _globals.SteppedEase = {
  config: function config(steps, immediateStart) {
    if (steps === void 0) {
      steps = 1;
    }
    var p1 = 1 / steps, p2 = steps + (immediateStart ? 0 : 1), p3 = immediateStart ? 1 : 0, max3 = 1 - _tinyNum;
    return function(p) {
      return ((p2 * _clamp(0, max3, p) | 0) + p3) * p1;
    };
  }
};
_defaults.ease = _easeMap["quad.out"];
_forEachName("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", function(name) {
  return _callbackNames += name + "," + name + "Params,";
});
var GSCache = function GSCache2(target, harness) {
  this.id = _gsID++;
  target._gsap = this;
  this.target = target;
  this.harness = harness;
  this.get = harness ? harness.get : _getProperty;
  this.set = harness ? harness.getSetter : _getSetter;
};
var Animation = function() {
  function Animation2(vars) {
    this.vars = vars;
    this._delay = +vars.delay || 0;
    if (this._repeat = vars.repeat === Infinity ? -2 : vars.repeat || 0) {
      this._rDelay = vars.repeatDelay || 0;
      this._yoyo = !!vars.yoyo || !!vars.yoyoEase;
    }
    this._ts = 1;
    _setDuration(this, +vars.duration, 1, 1);
    this.data = vars.data;
    if (_context) {
      this._ctx = _context;
      _context.data.push(this);
    }
    _tickerActive || _ticker.wake();
  }
  var _proto = Animation2.prototype;
  _proto.delay = function delay(value) {
    if (value || value === 0) {
      this.parent && this.parent.smoothChildTiming && this.startTime(this._start + value - this._delay);
      this._delay = value;
      return this;
    }
    return this._delay;
  };
  _proto.duration = function duration(value) {
    return arguments.length ? this.totalDuration(this._repeat > 0 ? value + (value + this._rDelay) * this._repeat : value) : this.totalDuration() && this._dur;
  };
  _proto.totalDuration = function totalDuration(value) {
    if (!arguments.length) {
      return this._tDur;
    }
    this._dirty = 0;
    return _setDuration(this, this._repeat < 0 ? value : (value - this._repeat * this._rDelay) / (this._repeat + 1));
  };
  _proto.totalTime = function totalTime(_totalTime, suppressEvents) {
    _wake();
    if (!arguments.length) {
      return this._tTime;
    }
    var parent = this._dp;
    if (parent && parent.smoothChildTiming && this._ts) {
      _alignPlayhead(this, _totalTime);
      !parent._dp || parent.parent || _postAddChecks(parent, this);
      while (parent && parent.parent) {
        if (parent.parent._time !== parent._start + (parent._ts >= 0 ? parent._tTime / parent._ts : (parent.totalDuration() - parent._tTime) / -parent._ts)) {
          parent.totalTime(parent._tTime, true);
        }
        parent = parent.parent;
      }
      if (!this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && _totalTime < this._tDur || this._ts < 0 && _totalTime > 0 || !this._tDur && !_totalTime)) {
        _addToTimeline(this._dp, this, this._start - this._delay);
      }
    }
    if (this._tTime !== _totalTime || !this._dur && !suppressEvents || this._initted && Math.abs(this._zTime) === _tinyNum || !_totalTime && !this._initted && (this.add || this._ptLookup)) {
      this._ts || (this._pTime = _totalTime);
      _lazySafeRender(this, _totalTime, suppressEvents);
    }
    return this;
  };
  _proto.time = function time(value, suppressEvents) {
    return arguments.length ? this.totalTime(Math.min(this.totalDuration(), value + _elapsedCycleDuration(this)) % (this._dur + this._rDelay) || (value ? this._dur : 0), suppressEvents) : this._time;
  };
  _proto.totalProgress = function totalProgress(value, suppressEvents) {
    return arguments.length ? this.totalTime(this.totalDuration() * value, suppressEvents) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.ratio;
  };
  _proto.progress = function progress(value, suppressEvents) {
    return arguments.length ? this.totalTime(this.duration() * (this._yoyo && !(this.iteration() & 1) ? 1 - value : value) + _elapsedCycleDuration(this), suppressEvents) : this.duration() ? Math.min(1, this._time / this._dur) : this.ratio;
  };
  _proto.iteration = function iteration(value, suppressEvents) {
    var cycleDuration = this.duration() + this._rDelay;
    return arguments.length ? this.totalTime(this._time + (value - 1) * cycleDuration, suppressEvents) : this._repeat ? _animationCycle(this._tTime, cycleDuration) + 1 : 1;
  };
  _proto.timeScale = function timeScale(value) {
    if (!arguments.length) {
      return this._rts === -_tinyNum ? 0 : this._rts;
    }
    if (this._rts === value) {
      return this;
    }
    var tTime = this.parent && this._ts ? _parentToChildTotalTime(this.parent._time, this) : this._tTime;
    this._rts = +value || 0;
    this._ts = this._ps || value === -_tinyNum ? 0 : this._rts;
    this.totalTime(_clamp(-Math.abs(this._delay), this._tDur, tTime), true);
    _setEnd(this);
    return _recacheAncestors(this);
  };
  _proto.paused = function paused(value) {
    if (!arguments.length) {
      return this._ps;
    }
    if (this._ps !== value) {
      this._ps = value;
      if (value) {
        this._pTime = this._tTime || Math.max(-this._delay, this.rawTime());
        this._ts = this._act = 0;
      } else {
        _wake();
        this._ts = this._rts;
        this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, this.progress() === 1 && Math.abs(this._zTime) !== _tinyNum && (this._tTime -= _tinyNum));
      }
    }
    return this;
  };
  _proto.startTime = function startTime(value) {
    if (arguments.length) {
      this._start = value;
      var parent = this.parent || this._dp;
      parent && (parent._sort || !this.parent) && _addToTimeline(parent, this, value - this._delay);
      return this;
    }
    return this._start;
  };
  _proto.endTime = function endTime(includeRepeats) {
    return this._start + (_isNotFalse(includeRepeats) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1);
  };
  _proto.rawTime = function rawTime(wrapRepeats) {
    var parent = this.parent || this._dp;
    return !parent ? this._tTime : wrapRepeats && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : !this._ts ? this._tTime : _parentToChildTotalTime(parent.rawTime(wrapRepeats), this);
  };
  _proto.revert = function revert(config3) {
    if (config3 === void 0) {
      config3 = _revertConfig;
    }
    var prevIsReverting = _reverting;
    _reverting = config3;
    if (this._initted || this._startAt) {
      this.timeline && this.timeline.revert(config3);
      this.totalTime(-0.01, config3.suppressEvents);
    }
    this.data !== "nested" && config3.kill !== false && this.kill();
    _reverting = prevIsReverting;
    return this;
  };
  _proto.globalTime = function globalTime(rawTime) {
    var animation = this, time = arguments.length ? rawTime : animation.rawTime();
    while (animation) {
      time = animation._start + time / (animation._ts || 1);
      animation = animation._dp;
    }
    return !this.parent && this._sat ? this._sat.vars.immediateRender ? -Infinity : this._sat.globalTime(rawTime) : time;
  };
  _proto.repeat = function repeat(value) {
    if (arguments.length) {
      this._repeat = value === Infinity ? -2 : value;
      return _onUpdateTotalDuration(this);
    }
    return this._repeat === -2 ? Infinity : this._repeat;
  };
  _proto.repeatDelay = function repeatDelay(value) {
    if (arguments.length) {
      var time = this._time;
      this._rDelay = value;
      _onUpdateTotalDuration(this);
      return time ? this.time(time) : this;
    }
    return this._rDelay;
  };
  _proto.yoyo = function yoyo(value) {
    if (arguments.length) {
      this._yoyo = value;
      return this;
    }
    return this._yoyo;
  };
  _proto.seek = function seek(position, suppressEvents) {
    return this.totalTime(_parsePosition(this, position), _isNotFalse(suppressEvents));
  };
  _proto.restart = function restart(includeDelay, suppressEvents) {
    return this.play().totalTime(includeDelay ? -this._delay : 0, _isNotFalse(suppressEvents));
  };
  _proto.play = function play(from, suppressEvents) {
    from != null && this.seek(from, suppressEvents);
    return this.reversed(false).paused(false);
  };
  _proto.reverse = function reverse(from, suppressEvents) {
    from != null && this.seek(from || this.totalDuration(), suppressEvents);
    return this.reversed(true).paused(false);
  };
  _proto.pause = function pause(atTime, suppressEvents) {
    atTime != null && this.seek(atTime, suppressEvents);
    return this.paused(true);
  };
  _proto.resume = function resume() {
    return this.paused(false);
  };
  _proto.reversed = function reversed(value) {
    if (arguments.length) {
      !!value !== this.reversed() && this.timeScale(-this._rts || (value ? -_tinyNum : 0));
      return this;
    }
    return this._rts < 0;
  };
  _proto.invalidate = function invalidate() {
    this._initted = this._act = 0;
    this._zTime = -_tinyNum;
    return this;
  };
  _proto.isActive = function isActive() {
    var parent = this.parent || this._dp, start = this._start, rawTime;
    return !!(!parent || this._ts && this._initted && parent.isActive() && (rawTime = parent.rawTime(true)) >= start && rawTime < this.endTime(true) - _tinyNum);
  };
  _proto.eventCallback = function eventCallback(type, callback, params) {
    var vars = this.vars;
    if (arguments.length > 1) {
      if (!callback) {
        delete vars[type];
      } else {
        vars[type] = callback;
        params && (vars[type + "Params"] = params);
        type === "onUpdate" && (this._onUpdate = callback);
      }
      return this;
    }
    return vars[type];
  };
  _proto.then = function then(onFulfilled) {
    var self2 = this;
    return new Promise(function(resolve) {
      var f = _isFunction(onFulfilled) ? onFulfilled : _passThrough, _resolve = function _resolve2() {
        var _then = self2.then;
        self2.then = null;
        _isFunction(f) && (f = f(self2)) && (f.then || f === self2) && (self2.then = _then);
        resolve(f);
        self2.then = _then;
      };
      if (self2._initted && self2.totalProgress() === 1 && self2._ts >= 0 || !self2._tTime && self2._ts < 0) {
        _resolve();
      } else {
        self2._prom = _resolve;
      }
    });
  };
  _proto.kill = function kill() {
    _interrupt(this);
  };
  return Animation2;
}();
_setDefaults(Animation.prototype, {
  _time: 0,
  _start: 0,
  _end: 0,
  _tTime: 0,
  _tDur: 0,
  _dirty: 0,
  _repeat: 0,
  _yoyo: false,
  parent: null,
  _initted: false,
  _rDelay: 0,
  _ts: 1,
  _dp: 0,
  ratio: 0,
  _zTime: -_tinyNum,
  _prom: 0,
  _ps: false,
  _rts: 1
});
var Timeline = function(_Animation) {
  _inheritsLoose(Timeline2, _Animation);
  function Timeline2(vars, position) {
    var _this;
    if (vars === void 0) {
      vars = {};
    }
    _this = _Animation.call(this, vars) || this;
    _this.labels = {};
    _this.smoothChildTiming = !!vars.smoothChildTiming;
    _this.autoRemoveChildren = !!vars.autoRemoveChildren;
    _this._sort = _isNotFalse(vars.sortChildren);
    _globalTimeline && _addToTimeline(vars.parent || _globalTimeline, _assertThisInitialized(_this), position);
    vars.reversed && _this.reverse();
    vars.paused && _this.paused(true);
    vars.scrollTrigger && _scrollTrigger(_assertThisInitialized(_this), vars.scrollTrigger);
    return _this;
  }
  var _proto2 = Timeline2.prototype;
  _proto2.to = function to(targets, vars, position) {
    _createTweenType(0, arguments, this);
    return this;
  };
  _proto2.from = function from(targets, vars, position) {
    _createTweenType(1, arguments, this);
    return this;
  };
  _proto2.fromTo = function fromTo(targets, fromVars, toVars, position) {
    _createTweenType(2, arguments, this);
    return this;
  };
  _proto2.set = function set(targets, vars, position) {
    vars.duration = 0;
    vars.parent = this;
    _inheritDefaults(vars).repeatDelay || (vars.repeat = 0);
    vars.immediateRender = !!vars.immediateRender;
    new Tween(targets, vars, _parsePosition(this, position), 1);
    return this;
  };
  _proto2.call = function call(callback, params, position) {
    return _addToTimeline(this, Tween.delayedCall(0, callback, params), position);
  };
  _proto2.staggerTo = function staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams) {
    vars.duration = duration;
    vars.stagger = vars.stagger || stagger;
    vars.onComplete = onCompleteAll;
    vars.onCompleteParams = onCompleteAllParams;
    vars.parent = this;
    new Tween(targets, vars, _parsePosition(this, position));
    return this;
  };
  _proto2.staggerFrom = function staggerFrom(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams) {
    vars.runBackwards = 1;
    _inheritDefaults(vars).immediateRender = _isNotFalse(vars.immediateRender);
    return this.staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams);
  };
  _proto2.staggerFromTo = function staggerFromTo(targets, duration, fromVars, toVars, stagger, position, onCompleteAll, onCompleteAllParams) {
    toVars.startAt = fromVars;
    _inheritDefaults(toVars).immediateRender = _isNotFalse(toVars.immediateRender);
    return this.staggerTo(targets, duration, toVars, stagger, position, onCompleteAll, onCompleteAllParams);
  };
  _proto2.render = function render3(totalTime, suppressEvents, force) {
    var prevTime = this._time, tDur = this._dirty ? this.totalDuration() : this._tDur, dur = this._dur, tTime = totalTime <= 0 ? 0 : _roundPrecise(totalTime), crossingStart = this._zTime < 0 !== totalTime < 0 && (this._initted || !dur), time, child, next, iteration, cycleDuration, prevPaused, pauseTween, timeScale, prevStart, prevIteration, yoyo, isYoyo;
    this !== _globalTimeline && tTime > tDur && totalTime >= 0 && (tTime = tDur);
    if (tTime !== this._tTime || force || crossingStart) {
      if (prevTime !== this._time && dur) {
        tTime += this._time - prevTime;
        totalTime += this._time - prevTime;
      }
      time = tTime;
      prevStart = this._start;
      timeScale = this._ts;
      prevPaused = !timeScale;
      if (crossingStart) {
        dur || (prevTime = this._zTime);
        (totalTime || !suppressEvents) && (this._zTime = totalTime);
      }
      if (this._repeat) {
        yoyo = this._yoyo;
        cycleDuration = dur + this._rDelay;
        if (this._repeat < -1 && totalTime < 0) {
          return this.totalTime(cycleDuration * 100 + totalTime, suppressEvents, force);
        }
        time = _roundPrecise(tTime % cycleDuration);
        if (tTime === tDur) {
          iteration = this._repeat;
          time = dur;
        } else {
          iteration = ~~(tTime / cycleDuration);
          if (iteration && iteration === tTime / cycleDuration) {
            time = dur;
            iteration--;
          }
          time > dur && (time = dur);
        }
        prevIteration = _animationCycle(this._tTime, cycleDuration);
        !prevTime && this._tTime && prevIteration !== iteration && this._tTime - prevIteration * cycleDuration - this._dur <= 0 && (prevIteration = iteration);
        if (yoyo && iteration & 1) {
          time = dur - time;
          isYoyo = 1;
        }
        if (iteration !== prevIteration && !this._lock) {
          var rewinding = yoyo && prevIteration & 1, doesWrap = rewinding === (yoyo && iteration & 1);
          iteration < prevIteration && (rewinding = !rewinding);
          prevTime = rewinding ? 0 : tTime % dur ? dur : tTime;
          this._lock = 1;
          this.render(prevTime || (isYoyo ? 0 : _roundPrecise(iteration * cycleDuration)), suppressEvents, !dur)._lock = 0;
          this._tTime = tTime;
          !suppressEvents && this.parent && _callback(this, "onRepeat");
          this.vars.repeatRefresh && !isYoyo && (this.invalidate()._lock = 1);
          if (prevTime && prevTime !== this._time || prevPaused !== !this._ts || this.vars.onRepeat && !this.parent && !this._act) {
            return this;
          }
          dur = this._dur;
          tDur = this._tDur;
          if (doesWrap) {
            this._lock = 2;
            prevTime = rewinding ? dur : -1e-4;
            this.render(prevTime, true);
            this.vars.repeatRefresh && !isYoyo && this.invalidate();
          }
          this._lock = 0;
          if (!this._ts && !prevPaused) {
            return this;
          }
          _propagateYoyoEase(this, isYoyo);
        }
      }
      if (this._hasPause && !this._forcing && this._lock < 2) {
        pauseTween = _findNextPauseTween(this, _roundPrecise(prevTime), _roundPrecise(time));
        if (pauseTween) {
          tTime -= time - (time = pauseTween._start);
        }
      }
      this._tTime = tTime;
      this._time = time;
      this._act = !timeScale;
      if (!this._initted) {
        this._onUpdate = this.vars.onUpdate;
        this._initted = 1;
        this._zTime = totalTime;
        prevTime = 0;
      }
      if (!prevTime && time && !suppressEvents && !iteration) {
        _callback(this, "onStart");
        if (this._tTime !== tTime) {
          return this;
        }
      }
      if (time >= prevTime && totalTime >= 0) {
        child = this._first;
        while (child) {
          next = child._next;
          if ((child._act || time >= child._start) && child._ts && pauseTween !== child) {
            if (child.parent !== this) {
              return this.render(totalTime, suppressEvents, force);
            }
            child.render(child._ts > 0 ? (time - child._start) * child._ts : (child._dirty ? child.totalDuration() : child._tDur) + (time - child._start) * child._ts, suppressEvents, force);
            if (time !== this._time || !this._ts && !prevPaused) {
              pauseTween = 0;
              next && (tTime += this._zTime = -_tinyNum);
              break;
            }
          }
          child = next;
        }
      } else {
        child = this._last;
        var adjustedTime = totalTime < 0 ? totalTime : time;
        while (child) {
          next = child._prev;
          if ((child._act || adjustedTime <= child._end) && child._ts && pauseTween !== child) {
            if (child.parent !== this) {
              return this.render(totalTime, suppressEvents, force);
            }
            child.render(child._ts > 0 ? (adjustedTime - child._start) * child._ts : (child._dirty ? child.totalDuration() : child._tDur) + (adjustedTime - child._start) * child._ts, suppressEvents, force || _reverting && (child._initted || child._startAt));
            if (time !== this._time || !this._ts && !prevPaused) {
              pauseTween = 0;
              next && (tTime += this._zTime = adjustedTime ? -_tinyNum : _tinyNum);
              break;
            }
          }
          child = next;
        }
      }
      if (pauseTween && !suppressEvents) {
        this.pause();
        pauseTween.render(time >= prevTime ? 0 : -_tinyNum)._zTime = time >= prevTime ? 1 : -1;
        if (this._ts) {
          this._start = prevStart;
          _setEnd(this);
          return this.render(totalTime, suppressEvents, force);
        }
      }
      this._onUpdate && !suppressEvents && _callback(this, "onUpdate", true);
      if (tTime === tDur && this._tTime >= this.totalDuration() || !tTime && prevTime) {
        if (prevStart === this._start || Math.abs(timeScale) !== Math.abs(this._ts)) {
          if (!this._lock) {
            (totalTime || !dur) && (tTime === tDur && this._ts > 0 || !tTime && this._ts < 0) && _removeFromParent(this, 1);
            if (!suppressEvents && !(totalTime < 0 && !prevTime) && (tTime || prevTime || !tDur)) {
              _callback(this, tTime === tDur && totalTime >= 0 ? "onComplete" : "onReverseComplete", true);
              this._prom && !(tTime < tDur && this.timeScale() > 0) && this._prom();
            }
          }
        }
      }
    }
    return this;
  };
  _proto2.add = function add(child, position) {
    var _this2 = this;
    _isNumber(position) || (position = _parsePosition(this, position, child));
    if (!(child instanceof Animation)) {
      if (_isArray(child)) {
        child.forEach(function(obj) {
          return _this2.add(obj, position);
        });
        return this;
      }
      if (_isString(child)) {
        return this.addLabel(child, position);
      }
      if (_isFunction(child)) {
        child = Tween.delayedCall(0, child);
      } else {
        return this;
      }
    }
    return this !== child ? _addToTimeline(this, child, position) : this;
  };
  _proto2.getChildren = function getChildren(nested, tweens, timelines, ignoreBeforeTime) {
    if (nested === void 0) {
      nested = true;
    }
    if (tweens === void 0) {
      tweens = true;
    }
    if (timelines === void 0) {
      timelines = true;
    }
    if (ignoreBeforeTime === void 0) {
      ignoreBeforeTime = -_bigNum;
    }
    var a4 = [], child = this._first;
    while (child) {
      if (child._start >= ignoreBeforeTime) {
        if (child instanceof Tween) {
          tweens && a4.push(child);
        } else {
          timelines && a4.push(child);
          nested && a4.push.apply(a4, child.getChildren(true, tweens, timelines));
        }
      }
      child = child._next;
    }
    return a4;
  };
  _proto2.getById = function getById2(id) {
    var animations = this.getChildren(1, 1, 1), i3 = animations.length;
    while (i3--) {
      if (animations[i3].vars.id === id) {
        return animations[i3];
      }
    }
  };
  _proto2.remove = function remove(child) {
    if (_isString(child)) {
      return this.removeLabel(child);
    }
    if (_isFunction(child)) {
      return this.killTweensOf(child);
    }
    _removeLinkedListItem(this, child);
    if (child === this._recent) {
      this._recent = this._last;
    }
    return _uncache(this);
  };
  _proto2.totalTime = function totalTime(_totalTime2, suppressEvents) {
    if (!arguments.length) {
      return this._tTime;
    }
    this._forcing = 1;
    if (!this._dp && this._ts) {
      this._start = _roundPrecise(_ticker.time - (this._ts > 0 ? _totalTime2 / this._ts : (this.totalDuration() - _totalTime2) / -this._ts));
    }
    _Animation.prototype.totalTime.call(this, _totalTime2, suppressEvents);
    this._forcing = 0;
    return this;
  };
  _proto2.addLabel = function addLabel(label, position) {
    this.labels[label] = _parsePosition(this, position);
    return this;
  };
  _proto2.removeLabel = function removeLabel(label) {
    delete this.labels[label];
    return this;
  };
  _proto2.addPause = function addPause(position, callback, params) {
    var t2 = Tween.delayedCall(0, callback || _emptyFunc, params);
    t2.data = "isPause";
    this._hasPause = 1;
    return _addToTimeline(this, t2, _parsePosition(this, position));
  };
  _proto2.removePause = function removePause(position) {
    var child = this._first;
    position = _parsePosition(this, position);
    while (child) {
      if (child._start === position && child.data === "isPause") {
        _removeFromParent(child);
      }
      child = child._next;
    }
  };
  _proto2.killTweensOf = function killTweensOf(targets, props, onlyActive) {
    var tweens = this.getTweensOf(targets, onlyActive), i3 = tweens.length;
    while (i3--) {
      _overwritingTween !== tweens[i3] && tweens[i3].kill(targets, props);
    }
    return this;
  };
  _proto2.getTweensOf = function getTweensOf2(targets, onlyActive) {
    var a4 = [], parsedTargets = toArray(targets), child = this._first, isGlobalTime = _isNumber(onlyActive), children;
    while (child) {
      if (child instanceof Tween) {
        if (_arrayContainsAny(child._targets, parsedTargets) && (isGlobalTime ? (!_overwritingTween || child._initted && child._ts) && child.globalTime(0) <= onlyActive && child.globalTime(child.totalDuration()) > onlyActive : !onlyActive || child.isActive())) {
          a4.push(child);
        }
      } else if ((children = child.getTweensOf(parsedTargets, onlyActive)).length) {
        a4.push.apply(a4, children);
      }
      child = child._next;
    }
    return a4;
  };
  _proto2.tweenTo = function tweenTo(position, vars) {
    vars = vars || {};
    var tl = this, endTime = _parsePosition(tl, position), _vars = vars, startAt = _vars.startAt, _onStart = _vars.onStart, onStartParams = _vars.onStartParams, immediateRender = _vars.immediateRender, initted, tween = Tween.to(tl, _setDefaults({
      ease: vars.ease || "none",
      lazy: false,
      immediateRender: false,
      time: endTime,
      overwrite: "auto",
      duration: vars.duration || Math.abs((endTime - (startAt && "time" in startAt ? startAt.time : tl._time)) / tl.timeScale()) || _tinyNum,
      onStart: function onStart() {
        tl.pause();
        if (!initted) {
          var duration = vars.duration || Math.abs((endTime - (startAt && "time" in startAt ? startAt.time : tl._time)) / tl.timeScale());
          tween._dur !== duration && _setDuration(tween, duration, 0, 1).render(tween._time, true, true);
          initted = 1;
        }
        _onStart && _onStart.apply(tween, onStartParams || []);
      }
    }, vars));
    return immediateRender ? tween.render(0) : tween;
  };
  _proto2.tweenFromTo = function tweenFromTo(fromPosition, toPosition, vars) {
    return this.tweenTo(toPosition, _setDefaults({
      startAt: {
        time: _parsePosition(this, fromPosition)
      }
    }, vars));
  };
  _proto2.recent = function recent() {
    return this._recent;
  };
  _proto2.nextLabel = function nextLabel(afterTime) {
    if (afterTime === void 0) {
      afterTime = this._time;
    }
    return _getLabelInDirection(this, _parsePosition(this, afterTime));
  };
  _proto2.previousLabel = function previousLabel(beforeTime) {
    if (beforeTime === void 0) {
      beforeTime = this._time;
    }
    return _getLabelInDirection(this, _parsePosition(this, beforeTime), 1);
  };
  _proto2.currentLabel = function currentLabel(value) {
    return arguments.length ? this.seek(value, true) : this.previousLabel(this._time + _tinyNum);
  };
  _proto2.shiftChildren = function shiftChildren(amount, adjustLabels, ignoreBeforeTime) {
    if (ignoreBeforeTime === void 0) {
      ignoreBeforeTime = 0;
    }
    var child = this._first, labels = this.labels, p;
    while (child) {
      if (child._start >= ignoreBeforeTime) {
        child._start += amount;
        child._end += amount;
      }
      child = child._next;
    }
    if (adjustLabels) {
      for (p in labels) {
        if (labels[p] >= ignoreBeforeTime) {
          labels[p] += amount;
        }
      }
    }
    return _uncache(this);
  };
  _proto2.invalidate = function invalidate(soft) {
    var child = this._first;
    this._lock = 0;
    while (child) {
      child.invalidate(soft);
      child = child._next;
    }
    return _Animation.prototype.invalidate.call(this, soft);
  };
  _proto2.clear = function clear(includeLabels) {
    if (includeLabels === void 0) {
      includeLabels = true;
    }
    var child = this._first, next;
    while (child) {
      next = child._next;
      this.remove(child);
      child = next;
    }
    this._dp && (this._time = this._tTime = this._pTime = 0);
    includeLabels && (this.labels = {});
    return _uncache(this);
  };
  _proto2.totalDuration = function totalDuration(value) {
    var max3 = 0, self2 = this, child = self2._last, prevStart = _bigNum, prev, start, parent;
    if (arguments.length) {
      return self2.timeScale((self2._repeat < 0 ? self2.duration() : self2.totalDuration()) / (self2.reversed() ? -value : value));
    }
    if (self2._dirty) {
      parent = self2.parent;
      while (child) {
        prev = child._prev;
        child._dirty && child.totalDuration();
        start = child._start;
        if (start > prevStart && self2._sort && child._ts && !self2._lock) {
          self2._lock = 1;
          _addToTimeline(self2, child, start - child._delay, 1)._lock = 0;
        } else {
          prevStart = start;
        }
        if (start < 0 && child._ts) {
          max3 -= start;
          if (!parent && !self2._dp || parent && parent.smoothChildTiming) {
            self2._start += start / self2._ts;
            self2._time -= start;
            self2._tTime -= start;
          }
          self2.shiftChildren(-start, false, -Infinity);
          prevStart = 0;
        }
        child._end > max3 && child._ts && (max3 = child._end);
        child = prev;
      }
      _setDuration(self2, self2 === _globalTimeline && self2._time > max3 ? self2._time : max3, 1, 1);
      self2._dirty = 0;
    }
    return self2._tDur;
  };
  Timeline2.updateRoot = function updateRoot(time) {
    if (_globalTimeline._ts) {
      _lazySafeRender(_globalTimeline, _parentToChildTotalTime(time, _globalTimeline));
      _lastRenderedFrame = _ticker.frame;
    }
    if (_ticker.frame >= _nextGCFrame) {
      _nextGCFrame += _config.autoSleep || 120;
      var child = _globalTimeline._first;
      if (!child || !child._ts) {
        if (_config.autoSleep && _ticker._listeners.length < 2) {
          while (child && !child._ts) {
            child = child._next;
          }
          child || _ticker.sleep();
        }
      }
    }
  };
  return Timeline2;
}(Animation);
_setDefaults(Timeline.prototype, {
  _lock: 0,
  _hasPause: 0,
  _forcing: 0
});
var _addComplexStringPropTween = function _addComplexStringPropTween2(target, prop, start, end, setter, stringFilter, funcParam) {
  var pt = new PropTween(this._pt, target, prop, 0, 1, _renderComplexString, null, setter), index = 0, matchIndex = 0, result, startNums, color, endNum, chunk, startNum, hasRandom, a4;
  pt.b = start;
  pt.e = end;
  start += "";
  end += "";
  if (hasRandom = ~end.indexOf("random(")) {
    end = _replaceRandom(end);
  }
  if (stringFilter) {
    a4 = [start, end];
    stringFilter(a4, target, prop);
    start = a4[0];
    end = a4[1];
  }
  startNums = start.match(_complexStringNumExp) || [];
  while (result = _complexStringNumExp.exec(end)) {
    endNum = result[0];
    chunk = end.substring(index, result.index);
    if (color) {
      color = (color + 1) % 5;
    } else if (chunk.substr(-5) === "rgba(") {
      color = 1;
    }
    if (endNum !== startNums[matchIndex++]) {
      startNum = parseFloat(startNums[matchIndex - 1]) || 0;
      pt._pt = {
        _next: pt._pt,
        p: chunk || matchIndex === 1 ? chunk : ",",
        //note: SVG spec allows omission of comma/space when a negative sign is wedged between two numbers, like 2.5-5.3 instead of 2.5,-5.3 but when tweening, the negative value may switch to positive, so we insert the comma just in case.
        s: startNum,
        c: endNum.charAt(1) === "=" ? _parseRelative(startNum, endNum) - startNum : parseFloat(endNum) - startNum,
        m: color && color < 4 ? Math.round : 0
      };
      index = _complexStringNumExp.lastIndex;
    }
  }
  pt.c = index < end.length ? end.substring(index, end.length) : "";
  pt.fp = funcParam;
  if (_relExp.test(end) || hasRandom) {
    pt.e = 0;
  }
  this._pt = pt;
  return pt;
};
var _addPropTween = function _addPropTween2(target, prop, start, end, index, targets, modifier, stringFilter, funcParam, optional) {
  _isFunction(end) && (end = end(index || 0, target, targets));
  var currentValue = target[prop], parsedStart = start !== "get" ? start : !_isFunction(currentValue) ? currentValue : funcParam ? target[prop.indexOf("set") || !_isFunction(target["get" + prop.substr(3)]) ? prop : "get" + prop.substr(3)](funcParam) : target[prop](), setter = !_isFunction(currentValue) ? _setterPlain : funcParam ? _setterFuncWithParam : _setterFunc, pt;
  if (_isString(end)) {
    if (~end.indexOf("random(")) {
      end = _replaceRandom(end);
    }
    if (end.charAt(1) === "=") {
      pt = _parseRelative(parsedStart, end) + (getUnit(parsedStart) || 0);
      if (pt || pt === 0) {
        end = pt;
      }
    }
  }
  if (!optional || parsedStart !== end || _forceAllPropTweens) {
    if (!isNaN(parsedStart * end) && end !== "") {
      pt = new PropTween(this._pt, target, prop, +parsedStart || 0, end - (parsedStart || 0), typeof currentValue === "boolean" ? _renderBoolean : _renderPlain, 0, setter);
      funcParam && (pt.fp = funcParam);
      modifier && pt.modifier(modifier, this, target);
      return this._pt = pt;
    }
    !currentValue && !(prop in target) && _missingPlugin(prop, end);
    return _addComplexStringPropTween.call(this, target, prop, parsedStart, end, setter, stringFilter || _config.stringFilter, funcParam);
  }
};
var _processVars = function _processVars2(vars, index, target, targets, tween) {
  _isFunction(vars) && (vars = _parseFuncOrString(vars, tween, index, target, targets));
  if (!_isObject(vars) || vars.style && vars.nodeType || _isArray(vars) || _isTypedArray(vars)) {
    return _isString(vars) ? _parseFuncOrString(vars, tween, index, target, targets) : vars;
  }
  var copy = {}, p;
  for (p in vars) {
    copy[p] = _parseFuncOrString(vars[p], tween, index, target, targets);
  }
  return copy;
};
var _checkPlugin = function _checkPlugin2(property, vars, tween, index, target, targets) {
  var plugin, pt, ptLookup, i3;
  if (_plugins[property] && (plugin = new _plugins[property]()).init(target, plugin.rawVars ? vars[property] : _processVars(vars[property], index, target, targets, tween), tween, index, targets) !== false) {
    tween._pt = pt = new PropTween(tween._pt, target, property, 0, 1, plugin.render, plugin, 0, plugin.priority);
    if (tween !== _quickTween) {
      ptLookup = tween._ptLookup[tween._targets.indexOf(target)];
      i3 = plugin._props.length;
      while (i3--) {
        ptLookup[plugin._props[i3]] = pt;
      }
    }
  }
  return plugin;
};
var _overwritingTween;
var _forceAllPropTweens;
var _initTween = function _initTween2(tween, time, tTime) {
  var vars = tween.vars, ease = vars.ease, startAt = vars.startAt, immediateRender = vars.immediateRender, lazy = vars.lazy, onUpdate = vars.onUpdate, onUpdateParams = vars.onUpdateParams, callbackScope = vars.callbackScope, runBackwards = vars.runBackwards, yoyoEase = vars.yoyoEase, keyframes = vars.keyframes, autoRevert = vars.autoRevert, dur = tween._dur, prevStartAt = tween._startAt, targets = tween._targets, parent = tween.parent, fullTargets = parent && parent.data === "nested" ? parent.vars.targets : targets, autoOverwrite = tween._overwrite === "auto" && !_suppressOverwrites, tl = tween.timeline, cleanVars, i3, p, pt, target, hasPriority, gsData, harness, plugin, ptLookup, index, harnessVars, overwritten;
  tl && (!keyframes || !ease) && (ease = "none");
  tween._ease = _parseEase(ease, _defaults.ease);
  tween._yEase = yoyoEase ? _invertEase(_parseEase(yoyoEase === true ? ease : yoyoEase, _defaults.ease)) : 0;
  if (yoyoEase && tween._yoyo && !tween._repeat) {
    yoyoEase = tween._yEase;
    tween._yEase = tween._ease;
    tween._ease = yoyoEase;
  }
  tween._from = !tl && !!vars.runBackwards;
  if (!tl || keyframes && !vars.stagger) {
    harness = targets[0] ? _getCache(targets[0]).harness : 0;
    harnessVars = harness && vars[harness.prop];
    cleanVars = _copyExcluding(vars, _reservedProps);
    if (prevStartAt) {
      prevStartAt._zTime < 0 && prevStartAt.progress(1);
      time < 0 && runBackwards && immediateRender && !autoRevert ? prevStartAt.render(-1, true) : prevStartAt.revert(runBackwards && dur ? _revertConfigNoKill : _startAtRevertConfig);
      prevStartAt._lazy = 0;
    }
    if (startAt) {
      _removeFromParent(tween._startAt = Tween.set(targets, _setDefaults({
        data: "isStart",
        overwrite: false,
        parent,
        immediateRender: true,
        lazy: !prevStartAt && _isNotFalse(lazy),
        startAt: null,
        delay: 0,
        onUpdate,
        onUpdateParams,
        callbackScope,
        stagger: 0
      }, startAt)));
      tween._startAt._dp = 0;
      tween._startAt._sat = tween;
      time < 0 && (_reverting || !immediateRender && !autoRevert) && tween._startAt.revert(_revertConfigNoKill);
      if (immediateRender) {
        if (dur && time <= 0 && tTime <= 0) {
          time && (tween._zTime = time);
          return;
        }
      }
    } else if (runBackwards && dur) {
      if (!prevStartAt) {
        time && (immediateRender = false);
        p = _setDefaults({
          overwrite: false,
          data: "isFromStart",
          //we tag the tween with as "isFromStart" so that if [inside a plugin] we need to only do something at the very END of a tween, we have a way of identifying this tween as merely the one that's setting the beginning values for a "from()" tween. For example, clearProps in CSSPlugin should only get applied at the very END of a tween and without this tag, from(...{height:100, clearProps:"height", delay:1}) would wipe the height at the beginning of the tween and after 1 second, it'd kick back in.
          lazy: immediateRender && !prevStartAt && _isNotFalse(lazy),
          immediateRender,
          //zero-duration tweens render immediately by default, but if we're not specifically instructed to render this tween immediately, we should skip this and merely _init() to record the starting values (rendering them immediately would push them to completion which is wasteful in that case - we'd have to render(-1) immediately after)
          stagger: 0,
          parent
          //ensures that nested tweens that had a stagger are handled properly, like gsap.from(".class", {y: gsap.utils.wrap([-100,100]), stagger: 0.5})
        }, cleanVars);
        harnessVars && (p[harness.prop] = harnessVars);
        _removeFromParent(tween._startAt = Tween.set(targets, p));
        tween._startAt._dp = 0;
        tween._startAt._sat = tween;
        time < 0 && (_reverting ? tween._startAt.revert(_revertConfigNoKill) : tween._startAt.render(-1, true));
        tween._zTime = time;
        if (!immediateRender) {
          _initTween2(tween._startAt, _tinyNum, _tinyNum);
        } else if (!time) {
          return;
        }
      }
    }
    tween._pt = tween._ptCache = 0;
    lazy = dur && _isNotFalse(lazy) || lazy && !dur;
    for (i3 = 0; i3 < targets.length; i3++) {
      target = targets[i3];
      gsData = target._gsap || _harness(targets)[i3]._gsap;
      tween._ptLookup[i3] = ptLookup = {};
      _lazyLookup[gsData.id] && _lazyTweens.length && _lazyRender();
      index = fullTargets === targets ? i3 : fullTargets.indexOf(target);
      if (harness && (plugin = new harness()).init(target, harnessVars || cleanVars, tween, index, fullTargets) !== false) {
        tween._pt = pt = new PropTween(tween._pt, target, plugin.name, 0, 1, plugin.render, plugin, 0, plugin.priority);
        plugin._props.forEach(function(name) {
          ptLookup[name] = pt;
        });
        plugin.priority && (hasPriority = 1);
      }
      if (!harness || harnessVars) {
        for (p in cleanVars) {
          if (_plugins[p] && (plugin = _checkPlugin(p, cleanVars, tween, index, target, fullTargets))) {
            plugin.priority && (hasPriority = 1);
          } else {
            ptLookup[p] = pt = _addPropTween.call(tween, target, p, "get", cleanVars[p], index, fullTargets, 0, vars.stringFilter);
          }
        }
      }
      tween._op && tween._op[i3] && tween.kill(target, tween._op[i3]);
      if (autoOverwrite && tween._pt) {
        _overwritingTween = tween;
        _globalTimeline.killTweensOf(target, ptLookup, tween.globalTime(time));
        overwritten = !tween.parent;
        _overwritingTween = 0;
      }
      tween._pt && lazy && (_lazyLookup[gsData.id] = 1);
    }
    hasPriority && _sortPropTweensByPriority(tween);
    tween._onInit && tween._onInit(tween);
  }
  tween._onUpdate = onUpdate;
  tween._initted = (!tween._op || tween._pt) && !overwritten;
  keyframes && time <= 0 && tl.render(_bigNum, true, true);
};
var _updatePropTweens = function _updatePropTweens2(tween, property, value, start, startIsRelative, ratio, time) {
  var ptCache = (tween._pt && tween._ptCache || (tween._ptCache = {}))[property], pt, rootPT, lookup, i3;
  if (!ptCache) {
    ptCache = tween._ptCache[property] = [];
    lookup = tween._ptLookup;
    i3 = tween._targets.length;
    while (i3--) {
      pt = lookup[i3][property];
      if (pt && pt.d && pt.d._pt) {
        pt = pt.d._pt;
        while (pt && pt.p !== property && pt.fp !== property) {
          pt = pt._next;
        }
      }
      if (!pt) {
        _forceAllPropTweens = 1;
        tween.vars[property] = "+=0";
        _initTween(tween, time);
        _forceAllPropTweens = 0;
        return 1;
      }
      ptCache.push(pt);
    }
  }
  i3 = ptCache.length;
  while (i3--) {
    rootPT = ptCache[i3];
    pt = rootPT._pt || rootPT;
    pt.s = (start || start === 0) && !startIsRelative ? start : pt.s + (start || 0) + ratio * pt.c;
    pt.c = value - pt.s;
    rootPT.e && (rootPT.e = _round(value) + getUnit(rootPT.e));
    rootPT.b && (rootPT.b = pt.s + getUnit(rootPT.b));
  }
};
var _addAliasesToVars = function _addAliasesToVars2(targets, vars) {
  var harness = targets[0] ? _getCache(targets[0]).harness : 0, propertyAliases = harness && harness.aliases, copy, p, i3, aliases;
  if (!propertyAliases) {
    return vars;
  }
  copy = _merge({}, vars);
  for (p in propertyAliases) {
    if (p in copy) {
      aliases = propertyAliases[p].split(",");
      i3 = aliases.length;
      while (i3--) {
        copy[aliases[i3]] = copy[p];
      }
    }
  }
  return copy;
};
var _parseKeyframe = function _parseKeyframe2(prop, obj, allProps, easeEach) {
  var ease = obj.ease || easeEach || "power1.inOut", p, a4;
  if (_isArray(obj)) {
    a4 = allProps[prop] || (allProps[prop] = []);
    obj.forEach(function(value, i3) {
      return a4.push({
        t: i3 / (obj.length - 1) * 100,
        v: value,
        e: ease
      });
    });
  } else {
    for (p in obj) {
      a4 = allProps[p] || (allProps[p] = []);
      p === "ease" || a4.push({
        t: parseFloat(prop),
        v: obj[p],
        e: ease
      });
    }
  }
};
var _parseFuncOrString = function _parseFuncOrString2(value, tween, i3, target, targets) {
  return _isFunction(value) ? value.call(tween, i3, target, targets) : _isString(value) && ~value.indexOf("random(") ? _replaceRandom(value) : value;
};
var _staggerTweenProps = _callbackNames + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert";
var _staggerPropsToSkip = {};
_forEachName(_staggerTweenProps + ",id,stagger,delay,duration,paused,scrollTrigger", function(name) {
  return _staggerPropsToSkip[name] = 1;
});
var Tween = function(_Animation2) {
  _inheritsLoose(Tween2, _Animation2);
  function Tween2(targets, vars, position, skipInherit) {
    var _this3;
    if (typeof vars === "number") {
      position.duration = vars;
      vars = position;
      position = null;
    }
    _this3 = _Animation2.call(this, skipInherit ? vars : _inheritDefaults(vars)) || this;
    var _this3$vars = _this3.vars, duration = _this3$vars.duration, delay = _this3$vars.delay, immediateRender = _this3$vars.immediateRender, stagger = _this3$vars.stagger, overwrite = _this3$vars.overwrite, keyframes = _this3$vars.keyframes, defaults2 = _this3$vars.defaults, scrollTrigger = _this3$vars.scrollTrigger, yoyoEase = _this3$vars.yoyoEase, parent = vars.parent || _globalTimeline, parsedTargets = (_isArray(targets) || _isTypedArray(targets) ? _isNumber(targets[0]) : "length" in vars) ? [targets] : toArray(targets), tl, i3, copy, l, p, curTarget, staggerFunc, staggerVarsToMerge;
    _this3._targets = parsedTargets.length ? _harness(parsedTargets) : _warn("GSAP target " + targets + " not found. https://greensock.com", !_config.nullTargetWarn) || [];
    _this3._ptLookup = [];
    _this3._overwrite = overwrite;
    if (keyframes || stagger || _isFuncOrString(duration) || _isFuncOrString(delay)) {
      vars = _this3.vars;
      tl = _this3.timeline = new Timeline({
        data: "nested",
        defaults: defaults2 || {},
        targets: parent && parent.data === "nested" ? parent.vars.targets : parsedTargets
      });
      tl.kill();
      tl.parent = tl._dp = _assertThisInitialized(_this3);
      tl._start = 0;
      if (stagger || _isFuncOrString(duration) || _isFuncOrString(delay)) {
        l = parsedTargets.length;
        staggerFunc = stagger && distribute(stagger);
        if (_isObject(stagger)) {
          for (p in stagger) {
            if (~_staggerTweenProps.indexOf(p)) {
              staggerVarsToMerge || (staggerVarsToMerge = {});
              staggerVarsToMerge[p] = stagger[p];
            }
          }
        }
        for (i3 = 0; i3 < l; i3++) {
          copy = _copyExcluding(vars, _staggerPropsToSkip);
          copy.stagger = 0;
          yoyoEase && (copy.yoyoEase = yoyoEase);
          staggerVarsToMerge && _merge(copy, staggerVarsToMerge);
          curTarget = parsedTargets[i3];
          copy.duration = +_parseFuncOrString(duration, _assertThisInitialized(_this3), i3, curTarget, parsedTargets);
          copy.delay = (+_parseFuncOrString(delay, _assertThisInitialized(_this3), i3, curTarget, parsedTargets) || 0) - _this3._delay;
          if (!stagger && l === 1 && copy.delay) {
            _this3._delay = delay = copy.delay;
            _this3._start += delay;
            copy.delay = 0;
          }
          tl.to(curTarget, copy, staggerFunc ? staggerFunc(i3, curTarget, parsedTargets) : 0);
          tl._ease = _easeMap.none;
        }
        tl.duration() ? duration = delay = 0 : _this3.timeline = 0;
      } else if (keyframes) {
        _inheritDefaults(_setDefaults(tl.vars.defaults, {
          ease: "none"
        }));
        tl._ease = _parseEase(keyframes.ease || vars.ease || "none");
        var time = 0, a4, kf, v;
        if (_isArray(keyframes)) {
          keyframes.forEach(function(frame) {
            return tl.to(parsedTargets, frame, ">");
          });
          tl.duration();
        } else {
          copy = {};
          for (p in keyframes) {
            p === "ease" || p === "easeEach" || _parseKeyframe(p, keyframes[p], copy, keyframes.easeEach);
          }
          for (p in copy) {
            a4 = copy[p].sort(function(a5, b5) {
              return a5.t - b5.t;
            });
            time = 0;
            for (i3 = 0; i3 < a4.length; i3++) {
              kf = a4[i3];
              v = {
                ease: kf.e,
                duration: (kf.t - (i3 ? a4[i3 - 1].t : 0)) / 100 * duration
              };
              v[p] = kf.v;
              tl.to(parsedTargets, v, time);
              time += v.duration;
            }
          }
          tl.duration() < duration && tl.to({}, {
            duration: duration - tl.duration()
          });
        }
      }
      duration || _this3.duration(duration = tl.duration());
    } else {
      _this3.timeline = 0;
    }
    if (overwrite === true && !_suppressOverwrites) {
      _overwritingTween = _assertThisInitialized(_this3);
      _globalTimeline.killTweensOf(parsedTargets);
      _overwritingTween = 0;
    }
    _addToTimeline(parent, _assertThisInitialized(_this3), position);
    vars.reversed && _this3.reverse();
    vars.paused && _this3.paused(true);
    if (immediateRender || !duration && !keyframes && _this3._start === _roundPrecise(parent._time) && _isNotFalse(immediateRender) && _hasNoPausedAncestors(_assertThisInitialized(_this3)) && parent.data !== "nested") {
      _this3._tTime = -_tinyNum;
      _this3.render(Math.max(0, -delay) || 0);
    }
    scrollTrigger && _scrollTrigger(_assertThisInitialized(_this3), scrollTrigger);
    return _this3;
  }
  var _proto3 = Tween2.prototype;
  _proto3.render = function render3(totalTime, suppressEvents, force) {
    var prevTime = this._time, tDur = this._tDur, dur = this._dur, isNegative = totalTime < 0, tTime = totalTime > tDur - _tinyNum && !isNegative ? tDur : totalTime < _tinyNum ? 0 : totalTime, time, pt, iteration, cycleDuration, prevIteration, isYoyo, ratio, timeline2, yoyoEase;
    if (!dur) {
      _renderZeroDurationTween(this, totalTime, suppressEvents, force);
    } else if (tTime !== this._tTime || !totalTime || force || !this._initted && this._tTime || this._startAt && this._zTime < 0 !== isNegative) {
      time = tTime;
      timeline2 = this.timeline;
      if (this._repeat) {
        cycleDuration = dur + this._rDelay;
        if (this._repeat < -1 && isNegative) {
          return this.totalTime(cycleDuration * 100 + totalTime, suppressEvents, force);
        }
        time = _roundPrecise(tTime % cycleDuration);
        if (tTime === tDur) {
          iteration = this._repeat;
          time = dur;
        } else {
          iteration = ~~(tTime / cycleDuration);
          if (iteration && iteration === tTime / cycleDuration) {
            time = dur;
            iteration--;
          }
          time > dur && (time = dur);
        }
        isYoyo = this._yoyo && iteration & 1;
        if (isYoyo) {
          yoyoEase = this._yEase;
          time = dur - time;
        }
        prevIteration = _animationCycle(this._tTime, cycleDuration);
        if (time === prevTime && !force && this._initted) {
          this._tTime = tTime;
          return this;
        }
        if (iteration !== prevIteration) {
          timeline2 && this._yEase && _propagateYoyoEase(timeline2, isYoyo);
          if (this.vars.repeatRefresh && !isYoyo && !this._lock) {
            this._lock = force = 1;
            this.render(_roundPrecise(cycleDuration * iteration), true).invalidate()._lock = 0;
          }
        }
      }
      if (!this._initted) {
        if (_attemptInitTween(this, isNegative ? totalTime : time, force, suppressEvents, tTime)) {
          this._tTime = 0;
          return this;
        }
        if (prevTime !== this._time) {
          return this;
        }
        if (dur !== this._dur) {
          return this.render(totalTime, suppressEvents, force);
        }
      }
      this._tTime = tTime;
      this._time = time;
      if (!this._act && this._ts) {
        this._act = 1;
        this._lazy = 0;
      }
      this.ratio = ratio = (yoyoEase || this._ease)(time / dur);
      if (this._from) {
        this.ratio = ratio = 1 - ratio;
      }
      if (time && !prevTime && !suppressEvents && !iteration) {
        _callback(this, "onStart");
        if (this._tTime !== tTime) {
          return this;
        }
      }
      pt = this._pt;
      while (pt) {
        pt.r(ratio, pt.d);
        pt = pt._next;
      }
      timeline2 && timeline2.render(totalTime < 0 ? totalTime : !time && isYoyo ? -_tinyNum : timeline2._dur * timeline2._ease(time / this._dur), suppressEvents, force) || this._startAt && (this._zTime = totalTime);
      if (this._onUpdate && !suppressEvents) {
        isNegative && _rewindStartAt(this, totalTime, suppressEvents, force);
        _callback(this, "onUpdate");
      }
      this._repeat && iteration !== prevIteration && this.vars.onRepeat && !suppressEvents && this.parent && _callback(this, "onRepeat");
      if ((tTime === this._tDur || !tTime) && this._tTime === tTime) {
        isNegative && !this._onUpdate && _rewindStartAt(this, totalTime, true, true);
        (totalTime || !dur) && (tTime === this._tDur && this._ts > 0 || !tTime && this._ts < 0) && _removeFromParent(this, 1);
        if (!suppressEvents && !(isNegative && !prevTime) && (tTime || prevTime || isYoyo)) {
          _callback(this, tTime === tDur ? "onComplete" : "onReverseComplete", true);
          this._prom && !(tTime < tDur && this.timeScale() > 0) && this._prom();
        }
      }
    }
    return this;
  };
  _proto3.targets = function targets() {
    return this._targets;
  };
  _proto3.invalidate = function invalidate(soft) {
    (!soft || !this.vars.runBackwards) && (this._startAt = 0);
    this._pt = this._op = this._onUpdate = this._lazy = this.ratio = 0;
    this._ptLookup = [];
    this.timeline && this.timeline.invalidate(soft);
    return _Animation2.prototype.invalidate.call(this, soft);
  };
  _proto3.resetTo = function resetTo(property, value, start, startIsRelative) {
    _tickerActive || _ticker.wake();
    this._ts || this.play();
    var time = Math.min(this._dur, (this._dp._time - this._start) * this._ts), ratio;
    this._initted || _initTween(this, time);
    ratio = this._ease(time / this._dur);
    if (_updatePropTweens(this, property, value, start, startIsRelative, ratio, time)) {
      return this.resetTo(property, value, start, startIsRelative);
    }
    _alignPlayhead(this, 0);
    this.parent || _addLinkedListItem(this._dp, this, "_first", "_last", this._dp._sort ? "_start" : 0);
    return this.render(0);
  };
  _proto3.kill = function kill(targets, vars) {
    if (vars === void 0) {
      vars = "all";
    }
    if (!targets && (!vars || vars === "all")) {
      this._lazy = this._pt = 0;
      return this.parent ? _interrupt(this) : this;
    }
    if (this.timeline) {
      var tDur = this.timeline.totalDuration();
      this.timeline.killTweensOf(targets, vars, _overwritingTween && _overwritingTween.vars.overwrite !== true)._first || _interrupt(this);
      this.parent && tDur !== this.timeline.totalDuration() && _setDuration(this, this._dur * this.timeline._tDur / tDur, 0, 1);
      return this;
    }
    var parsedTargets = this._targets, killingTargets = targets ? toArray(targets) : parsedTargets, propTweenLookup = this._ptLookup, firstPT = this._pt, overwrittenProps, curLookup, curOverwriteProps, props, p, pt, i3;
    if ((!vars || vars === "all") && _arraysMatch(parsedTargets, killingTargets)) {
      vars === "all" && (this._pt = 0);
      return _interrupt(this);
    }
    overwrittenProps = this._op = this._op || [];
    if (vars !== "all") {
      if (_isString(vars)) {
        p = {};
        _forEachName(vars, function(name) {
          return p[name] = 1;
        });
        vars = p;
      }
      vars = _addAliasesToVars(parsedTargets, vars);
    }
    i3 = parsedTargets.length;
    while (i3--) {
      if (~killingTargets.indexOf(parsedTargets[i3])) {
        curLookup = propTweenLookup[i3];
        if (vars === "all") {
          overwrittenProps[i3] = vars;
          props = curLookup;
          curOverwriteProps = {};
        } else {
          curOverwriteProps = overwrittenProps[i3] = overwrittenProps[i3] || {};
          props = vars;
        }
        for (p in props) {
          pt = curLookup && curLookup[p];
          if (pt) {
            if (!("kill" in pt.d) || pt.d.kill(p) === true) {
              _removeLinkedListItem(this, pt, "_pt");
            }
            delete curLookup[p];
          }
          if (curOverwriteProps !== "all") {
            curOverwriteProps[p] = 1;
          }
        }
      }
    }
    this._initted && !this._pt && firstPT && _interrupt(this);
    return this;
  };
  Tween2.to = function to(targets, vars) {
    return new Tween2(targets, vars, arguments[2]);
  };
  Tween2.from = function from(targets, vars) {
    return _createTweenType(1, arguments);
  };
  Tween2.delayedCall = function delayedCall(delay, callback, params, scope) {
    return new Tween2(callback, 0, {
      immediateRender: false,
      lazy: false,
      overwrite: false,
      delay,
      onComplete: callback,
      onReverseComplete: callback,
      onCompleteParams: params,
      onReverseCompleteParams: params,
      callbackScope: scope
    });
  };
  Tween2.fromTo = function fromTo(targets, fromVars, toVars) {
    return _createTweenType(2, arguments);
  };
  Tween2.set = function set(targets, vars) {
    vars.duration = 0;
    vars.repeatDelay || (vars.repeat = 0);
    return new Tween2(targets, vars);
  };
  Tween2.killTweensOf = function killTweensOf(targets, props, onlyActive) {
    return _globalTimeline.killTweensOf(targets, props, onlyActive);
  };
  return Tween2;
}(Animation);
_setDefaults(Tween.prototype, {
  _targets: [],
  _lazy: 0,
  _startAt: 0,
  _op: 0,
  _onInit: 0
});
_forEachName("staggerTo,staggerFrom,staggerFromTo", function(name) {
  Tween[name] = function() {
    var tl = new Timeline(), params = _slice.call(arguments, 0);
    params.splice(name === "staggerFromTo" ? 5 : 4, 0, 0);
    return tl[name].apply(tl, params);
  };
});
var _setterPlain = function _setterPlain2(target, property, value) {
  return target[property] = value;
};
var _setterFunc = function _setterFunc2(target, property, value) {
  return target[property](value);
};
var _setterFuncWithParam = function _setterFuncWithParam2(target, property, value, data) {
  return target[property](data.fp, value);
};
var _setterAttribute = function _setterAttribute2(target, property, value) {
  return target.setAttribute(property, value);
};
var _getSetter = function _getSetter2(target, property) {
  return _isFunction(target[property]) ? _setterFunc : _isUndefined(target[property]) && target.setAttribute ? _setterAttribute : _setterPlain;
};
var _renderPlain = function _renderPlain2(ratio, data) {
  return data.set(data.t, data.p, Math.round((data.s + data.c * ratio) * 1e6) / 1e6, data);
};
var _renderBoolean = function _renderBoolean2(ratio, data) {
  return data.set(data.t, data.p, !!(data.s + data.c * ratio), data);
};
var _renderComplexString = function _renderComplexString2(ratio, data) {
  var pt = data._pt, s = "";
  if (!ratio && data.b) {
    s = data.b;
  } else if (ratio === 1 && data.e) {
    s = data.e;
  } else {
    while (pt) {
      s = pt.p + (pt.m ? pt.m(pt.s + pt.c * ratio) : Math.round((pt.s + pt.c * ratio) * 1e4) / 1e4) + s;
      pt = pt._next;
    }
    s += data.c;
  }
  data.set(data.t, data.p, s, data);
};
var _renderPropTweens = function _renderPropTweens2(ratio, data) {
  var pt = data._pt;
  while (pt) {
    pt.r(ratio, pt.d);
    pt = pt._next;
  }
};
var _addPluginModifier = function _addPluginModifier2(modifier, tween, target, property) {
  var pt = this._pt, next;
  while (pt) {
    next = pt._next;
    pt.p === property && pt.modifier(modifier, tween, target);
    pt = next;
  }
};
var _killPropTweensOf = function _killPropTweensOf2(property) {
  var pt = this._pt, hasNonDependentRemaining, next;
  while (pt) {
    next = pt._next;
    if (pt.p === property && !pt.op || pt.op === property) {
      _removeLinkedListItem(this, pt, "_pt");
    } else if (!pt.dep) {
      hasNonDependentRemaining = 1;
    }
    pt = next;
  }
  return !hasNonDependentRemaining;
};
var _setterWithModifier = function _setterWithModifier2(target, property, value, data) {
  data.mSet(target, property, data.m.call(data.tween, value, data.mt), data);
};
var _sortPropTweensByPriority = function _sortPropTweensByPriority2(parent) {
  var pt = parent._pt, next, pt2, first2, last;
  while (pt) {
    next = pt._next;
    pt2 = first2;
    while (pt2 && pt2.pr > pt.pr) {
      pt2 = pt2._next;
    }
    if (pt._prev = pt2 ? pt2._prev : last) {
      pt._prev._next = pt;
    } else {
      first2 = pt;
    }
    if (pt._next = pt2) {
      pt2._prev = pt;
    } else {
      last = pt;
    }
    pt = next;
  }
  parent._pt = first2;
};
var PropTween = function() {
  function PropTween2(next, target, prop, start, change, renderer, data, setter, priority) {
    this.t = target;
    this.s = start;
    this.c = change;
    this.p = prop;
    this.r = renderer || _renderPlain;
    this.d = data || this;
    this.set = setter || _setterPlain;
    this.pr = priority || 0;
    this._next = next;
    if (next) {
      next._prev = this;
    }
  }
  var _proto4 = PropTween2.prototype;
  _proto4.modifier = function modifier(func, tween, target) {
    this.mSet = this.mSet || this.set;
    this.set = _setterWithModifier;
    this.m = func;
    this.mt = target;
    this.tween = tween;
  };
  return PropTween2;
}();
_forEachName(_callbackNames + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", function(name) {
  return _reservedProps[name] = 1;
});
_globals.TweenMax = _globals.TweenLite = Tween;
_globals.TimelineLite = _globals.TimelineMax = Timeline;
_globalTimeline = new Timeline({
  sortChildren: false,
  defaults: _defaults,
  autoRemoveChildren: true,
  id: "root",
  smoothChildTiming: true
});
_config.stringFilter = _colorStringFilter;
var _media = [];
var _listeners = {};
var _emptyArray = [];
var _lastMediaTime = 0;
var _contextID = 0;
var _dispatch = function _dispatch2(type) {
  return (_listeners[type] || _emptyArray).map(function(f) {
    return f();
  });
};
var _onMediaChange = function _onMediaChange2() {
  var time = Date.now(), matches = [];
  if (time - _lastMediaTime > 2) {
    _dispatch("matchMediaInit");
    _media.forEach(function(c3) {
      var queries = c3.queries, conditions = c3.conditions, match, p, anyMatch, toggled;
      for (p in queries) {
        match = _win.matchMedia(queries[p]).matches;
        match && (anyMatch = 1);
        if (match !== conditions[p]) {
          conditions[p] = match;
          toggled = 1;
        }
      }
      if (toggled) {
        c3.revert();
        anyMatch && matches.push(c3);
      }
    });
    _dispatch("matchMediaRevert");
    matches.forEach(function(c3) {
      return c3.onMatch(c3);
    });
    _lastMediaTime = time;
    _dispatch("matchMedia");
  }
};
var Context = function() {
  function Context2(func, scope) {
    this.selector = scope && selector(scope);
    this.data = [];
    this._r = [];
    this.isReverted = false;
    this.id = _contextID++;
    func && this.add(func);
  }
  var _proto5 = Context2.prototype;
  _proto5.add = function add(name, func, scope) {
    if (_isFunction(name)) {
      scope = func;
      func = name;
      name = _isFunction;
    }
    var self2 = this, f = function f2() {
      var prev = _context, prevSelector = self2.selector, result;
      prev && prev !== self2 && prev.data.push(self2);
      scope && (self2.selector = selector(scope));
      _context = self2;
      result = func.apply(self2, arguments);
      _isFunction(result) && self2._r.push(result);
      _context = prev;
      self2.selector = prevSelector;
      self2.isReverted = false;
      return result;
    };
    self2.last = f;
    return name === _isFunction ? f(self2) : name ? self2[name] = f : f;
  };
  _proto5.ignore = function ignore(func) {
    var prev = _context;
    _context = null;
    func(this);
    _context = prev;
  };
  _proto5.getTweens = function getTweens() {
    var a4 = [];
    this.data.forEach(function(e) {
      return e instanceof Context2 ? a4.push.apply(a4, e.getTweens()) : e instanceof Tween && !(e.parent && e.parent.data === "nested") && a4.push(e);
    });
    return a4;
  };
  _proto5.clear = function clear() {
    this._r.length = this.data.length = 0;
  };
  _proto5.kill = function kill(revert, matchMedia2) {
    var _this4 = this;
    if (revert) {
      var tweens = this.getTweens();
      this.data.forEach(function(t2) {
        if (t2.data === "isFlip") {
          t2.revert();
          t2.getChildren(true, true, false).forEach(function(tween) {
            return tweens.splice(tweens.indexOf(tween), 1);
          });
        }
      });
      tweens.map(function(t2) {
        return {
          g: t2.globalTime(0),
          t: t2
        };
      }).sort(function(a4, b5) {
        return b5.g - a4.g || -Infinity;
      }).forEach(function(o) {
        return o.t.revert(revert);
      });
      this.data.forEach(function(e) {
        return !(e instanceof Tween) && e.revert && e.revert(revert);
      });
      this._r.forEach(function(f) {
        return f(revert, _this4);
      });
      this.isReverted = true;
    } else {
      this.data.forEach(function(e) {
        return e.kill && e.kill();
      });
    }
    this.clear();
    if (matchMedia2) {
      var i3 = _media.length;
      while (i3--) {
        _media[i3].id === this.id && _media.splice(i3, 1);
      }
    }
  };
  _proto5.revert = function revert(config3) {
    this.kill(config3 || {});
  };
  return Context2;
}();
var MatchMedia = function() {
  function MatchMedia2(scope) {
    this.contexts = [];
    this.scope = scope;
  }
  var _proto6 = MatchMedia2.prototype;
  _proto6.add = function add(conditions, func, scope) {
    _isObject(conditions) || (conditions = {
      matches: conditions
    });
    var context3 = new Context(0, scope || this.scope), cond = context3.conditions = {}, mq, p, active;
    _context && !context3.selector && (context3.selector = _context.selector);
    this.contexts.push(context3);
    func = context3.add("onMatch", func);
    context3.queries = conditions;
    for (p in conditions) {
      if (p === "all") {
        active = 1;
      } else {
        mq = _win.matchMedia(conditions[p]);
        if (mq) {
          _media.indexOf(context3) < 0 && _media.push(context3);
          (cond[p] = mq.matches) && (active = 1);
          mq.addListener ? mq.addListener(_onMediaChange) : mq.addEventListener("change", _onMediaChange);
        }
      }
    }
    active && func(context3);
    return this;
  };
  _proto6.revert = function revert(config3) {
    this.kill(config3 || {});
  };
  _proto6.kill = function kill(revert) {
    this.contexts.forEach(function(c3) {
      return c3.kill(revert, true);
    });
  };
  return MatchMedia2;
}();
var _gsap = {
  registerPlugin: function registerPlugin() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    args.forEach(function(config3) {
      return _createPlugin(config3);
    });
  },
  timeline: function timeline(vars) {
    return new Timeline(vars);
  },
  getTweensOf: function getTweensOf(targets, onlyActive) {
    return _globalTimeline.getTweensOf(targets, onlyActive);
  },
  getProperty: function getProperty(target, property, unit, uncache) {
    _isString(target) && (target = toArray(target)[0]);
    var getter = _getCache(target || {}).get, format = unit ? _passThrough : _numericIfPossible;
    unit === "native" && (unit = "");
    return !target ? target : !property ? function(property2, unit2, uncache2) {
      return format((_plugins[property2] && _plugins[property2].get || getter)(target, property2, unit2, uncache2));
    } : format((_plugins[property] && _plugins[property].get || getter)(target, property, unit, uncache));
  },
  quickSetter: function quickSetter(target, property, unit) {
    target = toArray(target);
    if (target.length > 1) {
      var setters = target.map(function(t2) {
        return gsap.quickSetter(t2, property, unit);
      }), l = setters.length;
      return function(value) {
        var i3 = l;
        while (i3--) {
          setters[i3](value);
        }
      };
    }
    target = target[0] || {};
    var Plugin = _plugins[property], cache = _getCache(target), p = cache.harness && (cache.harness.aliases || {})[property] || property, setter = Plugin ? function(value) {
      var p2 = new Plugin();
      _quickTween._pt = 0;
      p2.init(target, unit ? value + unit : value, _quickTween, 0, [target]);
      p2.render(1, p2);
      _quickTween._pt && _renderPropTweens(1, _quickTween);
    } : cache.set(target, p);
    return Plugin ? setter : function(value) {
      return setter(target, p, unit ? value + unit : value, cache, 1);
    };
  },
  quickTo: function quickTo(target, property, vars) {
    var _merge22;
    var tween = gsap.to(target, _merge((_merge22 = {}, _merge22[property] = "+=0.1", _merge22.paused = true, _merge22), vars || {})), func = function func2(value, start, startIsRelative) {
      return tween.resetTo(property, value, start, startIsRelative);
    };
    func.tween = tween;
    return func;
  },
  isTweening: function isTweening(targets) {
    return _globalTimeline.getTweensOf(targets, true).length > 0;
  },
  defaults: function defaults(value) {
    value && value.ease && (value.ease = _parseEase(value.ease, _defaults.ease));
    return _mergeDeep(_defaults, value || {});
  },
  config: function config2(value) {
    return _mergeDeep(_config, value || {});
  },
  registerEffect: function registerEffect(_ref3) {
    var name = _ref3.name, effect = _ref3.effect, plugins = _ref3.plugins, defaults2 = _ref3.defaults, extendTimeline = _ref3.extendTimeline;
    (plugins || "").split(",").forEach(function(pluginName) {
      return pluginName && !_plugins[pluginName] && !_globals[pluginName] && _warn(name + " effect requires " + pluginName + " plugin.");
    });
    _effects[name] = function(targets, vars, tl) {
      return effect(toArray(targets), _setDefaults(vars || {}, defaults2), tl);
    };
    if (extendTimeline) {
      Timeline.prototype[name] = function(targets, vars, position) {
        return this.add(_effects[name](targets, _isObject(vars) ? vars : (position = vars) && {}, this), position);
      };
    }
  },
  registerEase: function registerEase(name, ease) {
    _easeMap[name] = _parseEase(ease);
  },
  parseEase: function parseEase(ease, defaultEase) {
    return arguments.length ? _parseEase(ease, defaultEase) : _easeMap;
  },
  getById: function getById(id) {
    return _globalTimeline.getById(id);
  },
  exportRoot: function exportRoot(vars, includeDelayedCalls) {
    if (vars === void 0) {
      vars = {};
    }
    var tl = new Timeline(vars), child, next;
    tl.smoothChildTiming = _isNotFalse(vars.smoothChildTiming);
    _globalTimeline.remove(tl);
    tl._dp = 0;
    tl._time = tl._tTime = _globalTimeline._time;
    child = _globalTimeline._first;
    while (child) {
      next = child._next;
      if (includeDelayedCalls || !(!child._dur && child instanceof Tween && child.vars.onComplete === child._targets[0])) {
        _addToTimeline(tl, child, child._start - child._delay);
      }
      child = next;
    }
    _addToTimeline(_globalTimeline, tl, 0);
    return tl;
  },
  context: function context(func, scope) {
    return func ? new Context(func, scope) : _context;
  },
  matchMedia: function matchMedia(scope) {
    return new MatchMedia(scope);
  },
  matchMediaRefresh: function matchMediaRefresh() {
    return _media.forEach(function(c3) {
      var cond = c3.conditions, found, p;
      for (p in cond) {
        if (cond[p]) {
          cond[p] = false;
          found = 1;
        }
      }
      found && c3.revert();
    }) || _onMediaChange();
  },
  addEventListener: function addEventListener(type, callback) {
    var a4 = _listeners[type] || (_listeners[type] = []);
    ~a4.indexOf(callback) || a4.push(callback);
  },
  removeEventListener: function removeEventListener(type, callback) {
    var a4 = _listeners[type], i3 = a4 && a4.indexOf(callback);
    i3 >= 0 && a4.splice(i3, 1);
  },
  utils: {
    wrap,
    wrapYoyo,
    distribute,
    random,
    snap,
    normalize,
    getUnit,
    clamp: clamp3,
    splitColor,
    toArray,
    selector,
    mapRange,
    pipe,
    unitize,
    interpolate,
    shuffle
  },
  install: _install,
  effects: _effects,
  ticker: _ticker,
  updateRoot: Timeline.updateRoot,
  plugins: _plugins,
  globalTimeline: _globalTimeline,
  core: {
    PropTween,
    globals: _addGlobal,
    Tween,
    Timeline,
    Animation,
    getCache: _getCache,
    _removeLinkedListItem,
    reverting: function reverting() {
      return _reverting;
    },
    context: function context2(toAdd) {
      if (toAdd && _context) {
        _context.data.push(toAdd);
        toAdd._ctx = _context;
      }
      return _context;
    },
    suppressOverwrites: function suppressOverwrites(value) {
      return _suppressOverwrites = value;
    }
  }
};
_forEachName("to,from,fromTo,delayedCall,set,killTweensOf", function(name) {
  return _gsap[name] = Tween[name];
});
_ticker.add(Timeline.updateRoot);
_quickTween = _gsap.to({}, {
  duration: 0
});
var _getPluginPropTween = function _getPluginPropTween2(plugin, prop) {
  var pt = plugin._pt;
  while (pt && pt.p !== prop && pt.op !== prop && pt.fp !== prop) {
    pt = pt._next;
  }
  return pt;
};
var _addModifiers = function _addModifiers2(tween, modifiers) {
  var targets = tween._targets, p, i3, pt;
  for (p in modifiers) {
    i3 = targets.length;
    while (i3--) {
      pt = tween._ptLookup[i3][p];
      if (pt && (pt = pt.d)) {
        if (pt._pt) {
          pt = _getPluginPropTween(pt, p);
        }
        pt && pt.modifier && pt.modifier(modifiers[p], tween, targets[i3], p);
      }
    }
  }
};
var _buildModifierPlugin = function _buildModifierPlugin2(name, modifier) {
  return {
    name,
    rawVars: 1,
    //don't pre-process function-based values or "random()" strings.
    init: function init5(target, vars, tween) {
      tween._onInit = function(tween2) {
        var temp, p;
        if (_isString(vars)) {
          temp = {};
          _forEachName(vars, function(name2) {
            return temp[name2] = 1;
          });
          vars = temp;
        }
        if (modifier) {
          temp = {};
          for (p in vars) {
            temp[p] = modifier(vars[p]);
          }
          vars = temp;
        }
        _addModifiers(tween2, vars);
      };
    }
  };
};
var gsap = _gsap.registerPlugin({
  name: "attr",
  init: function init2(target, vars, tween, index, targets) {
    var p, pt, v;
    this.tween = tween;
    for (p in vars) {
      v = target.getAttribute(p) || "";
      pt = this.add(target, "setAttribute", (v || 0) + "", vars[p], index, targets, 0, 0, p);
      pt.op = p;
      pt.b = v;
      this._props.push(p);
    }
  },
  render: function render(ratio, data) {
    var pt = data._pt;
    while (pt) {
      _reverting ? pt.set(pt.t, pt.p, pt.b, pt) : pt.r(ratio, pt.d);
      pt = pt._next;
    }
  }
}, {
  name: "endArray",
  init: function init3(target, value) {
    var i3 = value.length;
    while (i3--) {
      this.add(target, i3, target[i3] || 0, value[i3], 0, 0, 0, 0, 0, 1);
    }
  }
}, _buildModifierPlugin("roundProps", _roundModifier), _buildModifierPlugin("modifiers"), _buildModifierPlugin("snap", snap)) || _gsap;
Tween.version = Timeline.version = gsap.version = "3.12.2";
_coreReady = 1;
_windowExists() && _wake();
var Power0 = _easeMap.Power0;
var Power1 = _easeMap.Power1;
var Power2 = _easeMap.Power2;
var Power3 = _easeMap.Power3;
var Power4 = _easeMap.Power4;
var Linear = _easeMap.Linear;
var Quad = _easeMap.Quad;
var Cubic = _easeMap.Cubic;
var Quart = _easeMap.Quart;
var Quint = _easeMap.Quint;
var Strong = _easeMap.Strong;
var Elastic = _easeMap.Elastic;
var Back = _easeMap.Back;
var SteppedEase = _easeMap.SteppedEase;
var Bounce = _easeMap.Bounce;
var Sine = _easeMap.Sine;
var Expo = _easeMap.Expo;
var Circ = _easeMap.Circ;

// node_modules/gsap/CSSPlugin.js
var _win2;
var _doc2;
var _docElement;
var _pluginInitted;
var _tempDiv;
var _tempDivStyler;
var _recentSetterPlugin;
var _reverting2;
var _windowExists3 = function _windowExists4() {
  return typeof window !== "undefined";
};
var _transformProps = {};
var _RAD2DEG = 180 / Math.PI;
var _DEG2RAD = Math.PI / 180;
var _atan2 = Math.atan2;
var _bigNum2 = 1e8;
var _capsExp = /([A-Z])/g;
var _horizontalExp = /(left|right|width|margin|padding|x)/i;
var _complexExp = /[\s,\(]\S/;
var _propertyAliases = {
  autoAlpha: "opacity,visibility",
  scale: "scaleX,scaleY",
  alpha: "opacity"
};
var _renderCSSProp = function _renderCSSProp2(ratio, data) {
  return data.set(data.t, data.p, Math.round((data.s + data.c * ratio) * 1e4) / 1e4 + data.u, data);
};
var _renderPropWithEnd = function _renderPropWithEnd2(ratio, data) {
  return data.set(data.t, data.p, ratio === 1 ? data.e : Math.round((data.s + data.c * ratio) * 1e4) / 1e4 + data.u, data);
};
var _renderCSSPropWithBeginning = function _renderCSSPropWithBeginning2(ratio, data) {
  return data.set(data.t, data.p, ratio ? Math.round((data.s + data.c * ratio) * 1e4) / 1e4 + data.u : data.b, data);
};
var _renderRoundedCSSProp = function _renderRoundedCSSProp2(ratio, data) {
  var value = data.s + data.c * ratio;
  data.set(data.t, data.p, ~~(value + (value < 0 ? -0.5 : 0.5)) + data.u, data);
};
var _renderNonTweeningValue = function _renderNonTweeningValue2(ratio, data) {
  return data.set(data.t, data.p, ratio ? data.e : data.b, data);
};
var _renderNonTweeningValueOnlyAtEnd = function _renderNonTweeningValueOnlyAtEnd2(ratio, data) {
  return data.set(data.t, data.p, ratio !== 1 ? data.b : data.e, data);
};
var _setterCSSStyle = function _setterCSSStyle2(target, property, value) {
  return target.style[property] = value;
};
var _setterCSSProp = function _setterCSSProp2(target, property, value) {
  return target.style.setProperty(property, value);
};
var _setterTransform = function _setterTransform2(target, property, value) {
  return target._gsap[property] = value;
};
var _setterScale = function _setterScale2(target, property, value) {
  return target._gsap.scaleX = target._gsap.scaleY = value;
};
var _setterScaleWithRender = function _setterScaleWithRender2(target, property, value, data, ratio) {
  var cache = target._gsap;
  cache.scaleX = cache.scaleY = value;
  cache.renderTransform(ratio, cache);
};
var _setterTransformWithRender = function _setterTransformWithRender2(target, property, value, data, ratio) {
  var cache = target._gsap;
  cache[property] = value;
  cache.renderTransform(ratio, cache);
};
var _transformProp = "transform";
var _transformOriginProp = _transformProp + "Origin";
var _saveStyle = function _saveStyle2(property, isNotCSS) {
  var _this = this;
  var target = this.target, style = target.style;
  if (property in _transformProps && style) {
    this.tfm = this.tfm || {};
    if (property !== "transform") {
      property = _propertyAliases[property] || property;
      ~property.indexOf(",") ? property.split(",").forEach(function(a4) {
        return _this.tfm[a4] = _get(target, a4);
      }) : this.tfm[property] = target._gsap.x ? target._gsap[property] : _get(target, property);
    } else {
      return _propertyAliases.transform.split(",").forEach(function(p) {
        return _saveStyle2.call(_this, p, isNotCSS);
      });
    }
    if (this.props.indexOf(_transformProp) >= 0) {
      return;
    }
    if (target._gsap.svg) {
      this.svgo = target.getAttribute("data-svg-origin");
      this.props.push(_transformOriginProp, isNotCSS, "");
    }
    property = _transformProp;
  }
  (style || isNotCSS) && this.props.push(property, isNotCSS, style[property]);
};
var _removeIndependentTransforms = function _removeIndependentTransforms2(style) {
  if (style.translate) {
    style.removeProperty("translate");
    style.removeProperty("scale");
    style.removeProperty("rotate");
  }
};
var _revertStyle = function _revertStyle2() {
  var props = this.props, target = this.target, style = target.style, cache = target._gsap, i3, p;
  for (i3 = 0; i3 < props.length; i3 += 3) {
    props[i3 + 1] ? target[props[i3]] = props[i3 + 2] : props[i3 + 2] ? style[props[i3]] = props[i3 + 2] : style.removeProperty(props[i3].substr(0, 2) === "--" ? props[i3] : props[i3].replace(_capsExp, "-$1").toLowerCase());
  }
  if (this.tfm) {
    for (p in this.tfm) {
      cache[p] = this.tfm[p];
    }
    if (cache.svg) {
      cache.renderTransform();
      target.setAttribute("data-svg-origin", this.svgo || "");
    }
    i3 = _reverting2();
    if ((!i3 || !i3.isStart) && !style[_transformProp]) {
      _removeIndependentTransforms(style);
      cache.uncache = 1;
    }
  }
};
var _getStyleSaver = function _getStyleSaver2(target, properties) {
  var saver = {
    target,
    props: [],
    revert: _revertStyle,
    save: _saveStyle
  };
  target._gsap || gsap.core.getCache(target);
  properties && properties.split(",").forEach(function(p) {
    return saver.save(p);
  });
  return saver;
};
var _supports3D;
var _createElement = function _createElement2(type, ns) {
  var e = _doc2.createElementNS ? _doc2.createElementNS((ns || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), type) : _doc2.createElement(type);
  return e.style ? e : _doc2.createElement(type);
};
var _getComputedProperty = function _getComputedProperty2(target, property, skipPrefixFallback) {
  var cs = getComputedStyle(target);
  return cs[property] || cs.getPropertyValue(property.replace(_capsExp, "-$1").toLowerCase()) || cs.getPropertyValue(property) || !skipPrefixFallback && _getComputedProperty2(target, _checkPropPrefix(property) || property, 1) || "";
};
var _prefixes = "O,Moz,ms,Ms,Webkit".split(",");
var _checkPropPrefix = function _checkPropPrefix2(property, element, preferPrefix) {
  var e = element || _tempDiv, s = e.style, i3 = 5;
  if (property in s && !preferPrefix) {
    return property;
  }
  property = property.charAt(0).toUpperCase() + property.substr(1);
  while (i3-- && !(_prefixes[i3] + property in s)) {
  }
  return i3 < 0 ? null : (i3 === 3 ? "ms" : i3 >= 0 ? _prefixes[i3] : "") + property;
};
var _initCore = function _initCore2() {
  if (_windowExists3() && window.document) {
    _win2 = window;
    _doc2 = _win2.document;
    _docElement = _doc2.documentElement;
    _tempDiv = _createElement("div") || {
      style: {}
    };
    _tempDivStyler = _createElement("div");
    _transformProp = _checkPropPrefix(_transformProp);
    _transformOriginProp = _transformProp + "Origin";
    _tempDiv.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0";
    _supports3D = !!_checkPropPrefix("perspective");
    _reverting2 = gsap.core.reverting;
    _pluginInitted = 1;
  }
};
var _getBBoxHack = function _getBBoxHack2(swapIfPossible) {
  var svg = _createElement("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"), oldParent = this.parentNode, oldSibling = this.nextSibling, oldCSS = this.style.cssText, bbox;
  _docElement.appendChild(svg);
  svg.appendChild(this);
  this.style.display = "block";
  if (swapIfPossible) {
    try {
      bbox = this.getBBox();
      this._gsapBBox = this.getBBox;
      this.getBBox = _getBBoxHack2;
    } catch (e) {
    }
  } else if (this._gsapBBox) {
    bbox = this._gsapBBox();
  }
  if (oldParent) {
    if (oldSibling) {
      oldParent.insertBefore(this, oldSibling);
    } else {
      oldParent.appendChild(this);
    }
  }
  _docElement.removeChild(svg);
  this.style.cssText = oldCSS;
  return bbox;
};
var _getAttributeFallbacks = function _getAttributeFallbacks2(target, attributesArray) {
  var i3 = attributesArray.length;
  while (i3--) {
    if (target.hasAttribute(attributesArray[i3])) {
      return target.getAttribute(attributesArray[i3]);
    }
  }
};
var _getBBox = function _getBBox2(target) {
  var bounds;
  try {
    bounds = target.getBBox();
  } catch (error) {
    bounds = _getBBoxHack.call(target, true);
  }
  bounds && (bounds.width || bounds.height) || target.getBBox === _getBBoxHack || (bounds = _getBBoxHack.call(target, true));
  return bounds && !bounds.width && !bounds.x && !bounds.y ? {
    x: +_getAttributeFallbacks(target, ["x", "cx", "x1"]) || 0,
    y: +_getAttributeFallbacks(target, ["y", "cy", "y1"]) || 0,
    width: 0,
    height: 0
  } : bounds;
};
var _isSVG = function _isSVG2(e) {
  return !!(e.getCTM && (!e.parentNode || e.ownerSVGElement) && _getBBox(e));
};
var _removeProperty = function _removeProperty2(target, property) {
  if (property) {
    var style = target.style;
    if (property in _transformProps && property !== _transformOriginProp) {
      property = _transformProp;
    }
    if (style.removeProperty) {
      if (property.substr(0, 2) === "ms" || property.substr(0, 6) === "webkit") {
        property = "-" + property;
      }
      style.removeProperty(property.replace(_capsExp, "-$1").toLowerCase());
    } else {
      style.removeAttribute(property);
    }
  }
};
var _addNonTweeningPT = function _addNonTweeningPT2(plugin, target, property, beginning, end, onlySetAtEnd) {
  var pt = new PropTween(plugin._pt, target, property, 0, 1, onlySetAtEnd ? _renderNonTweeningValueOnlyAtEnd : _renderNonTweeningValue);
  plugin._pt = pt;
  pt.b = beginning;
  pt.e = end;
  plugin._props.push(property);
  return pt;
};
var _nonConvertibleUnits = {
  deg: 1,
  rad: 1,
  turn: 1
};
var _nonStandardLayouts = {
  grid: 1,
  flex: 1
};
var _convertToUnit = function _convertToUnit2(target, property, value, unit) {
  var curValue = parseFloat(value) || 0, curUnit = (value + "").trim().substr((curValue + "").length) || "px", style = _tempDiv.style, horizontal = _horizontalExp.test(property), isRootSVG = target.tagName.toLowerCase() === "svg", measureProperty = (isRootSVG ? "client" : "offset") + (horizontal ? "Width" : "Height"), amount = 100, toPixels = unit === "px", toPercent = unit === "%", px, parent, cache, isSVG;
  if (unit === curUnit || !curValue || _nonConvertibleUnits[unit] || _nonConvertibleUnits[curUnit]) {
    return curValue;
  }
  curUnit !== "px" && !toPixels && (curValue = _convertToUnit2(target, property, value, "px"));
  isSVG = target.getCTM && _isSVG(target);
  if ((toPercent || curUnit === "%") && (_transformProps[property] || ~property.indexOf("adius"))) {
    px = isSVG ? target.getBBox()[horizontal ? "width" : "height"] : target[measureProperty];
    return _round(toPercent ? curValue / px * amount : curValue / 100 * px);
  }
  style[horizontal ? "width" : "height"] = amount + (toPixels ? curUnit : unit);
  parent = ~property.indexOf("adius") || unit === "em" && target.appendChild && !isRootSVG ? target : target.parentNode;
  if (isSVG) {
    parent = (target.ownerSVGElement || {}).parentNode;
  }
  if (!parent || parent === _doc2 || !parent.appendChild) {
    parent = _doc2.body;
  }
  cache = parent._gsap;
  if (cache && toPercent && cache.width && horizontal && cache.time === _ticker.time && !cache.uncache) {
    return _round(curValue / cache.width * amount);
  } else {
    (toPercent || curUnit === "%") && !_nonStandardLayouts[_getComputedProperty(parent, "display")] && (style.position = _getComputedProperty(target, "position"));
    parent === target && (style.position = "static");
    parent.appendChild(_tempDiv);
    px = _tempDiv[measureProperty];
    parent.removeChild(_tempDiv);
    style.position = "absolute";
    if (horizontal && toPercent) {
      cache = _getCache(parent);
      cache.time = _ticker.time;
      cache.width = parent[measureProperty];
    }
  }
  return _round(toPixels ? px * curValue / amount : px && curValue ? amount / px * curValue : 0);
};
var _get = function _get2(target, property, unit, uncache) {
  var value;
  _pluginInitted || _initCore();
  if (property in _propertyAliases && property !== "transform") {
    property = _propertyAliases[property];
    if (~property.indexOf(",")) {
      property = property.split(",")[0];
    }
  }
  if (_transformProps[property] && property !== "transform") {
    value = _parseTransform(target, uncache);
    value = property !== "transformOrigin" ? value[property] : value.svg ? value.origin : _firstTwoOnly(_getComputedProperty(target, _transformOriginProp)) + " " + value.zOrigin + "px";
  } else {
    value = target.style[property];
    if (!value || value === "auto" || uncache || ~(value + "").indexOf("calc(")) {
      value = _specialProps[property] && _specialProps[property](target, property, unit) || _getComputedProperty(target, property) || _getProperty(target, property) || (property === "opacity" ? 1 : 0);
    }
  }
  return unit && !~(value + "").trim().indexOf(" ") ? _convertToUnit(target, property, value, unit) + unit : value;
};
var _tweenComplexCSSString = function _tweenComplexCSSString2(target, prop, start, end) {
  if (!start || start === "none") {
    var p = _checkPropPrefix(prop, target, 1), s = p && _getComputedProperty(target, p, 1);
    if (s && s !== start) {
      prop = p;
      start = s;
    } else if (prop === "borderColor") {
      start = _getComputedProperty(target, "borderTopColor");
    }
  }
  var pt = new PropTween(this._pt, target.style, prop, 0, 1, _renderComplexString), index = 0, matchIndex = 0, a4, result, startValues, startNum, color, startValue, endValue, endNum, chunk, endUnit, startUnit, endValues;
  pt.b = start;
  pt.e = end;
  start += "";
  end += "";
  if (end === "auto") {
    target.style[prop] = end;
    end = _getComputedProperty(target, prop) || end;
    target.style[prop] = start;
  }
  a4 = [start, end];
  _colorStringFilter(a4);
  start = a4[0];
  end = a4[1];
  startValues = start.match(_numWithUnitExp) || [];
  endValues = end.match(_numWithUnitExp) || [];
  if (endValues.length) {
    while (result = _numWithUnitExp.exec(end)) {
      endValue = result[0];
      chunk = end.substring(index, result.index);
      if (color) {
        color = (color + 1) % 5;
      } else if (chunk.substr(-5) === "rgba(" || chunk.substr(-5) === "hsla(") {
        color = 1;
      }
      if (endValue !== (startValue = startValues[matchIndex++] || "")) {
        startNum = parseFloat(startValue) || 0;
        startUnit = startValue.substr((startNum + "").length);
        endValue.charAt(1) === "=" && (endValue = _parseRelative(startNum, endValue) + startUnit);
        endNum = parseFloat(endValue);
        endUnit = endValue.substr((endNum + "").length);
        index = _numWithUnitExp.lastIndex - endUnit.length;
        if (!endUnit) {
          endUnit = endUnit || _config.units[prop] || startUnit;
          if (index === end.length) {
            end += endUnit;
            pt.e += endUnit;
          }
        }
        if (startUnit !== endUnit) {
          startNum = _convertToUnit(target, prop, startValue, endUnit) || 0;
        }
        pt._pt = {
          _next: pt._pt,
          p: chunk || matchIndex === 1 ? chunk : ",",
          //note: SVG spec allows omission of comma/space when a negative sign is wedged between two numbers, like 2.5-5.3 instead of 2.5,-5.3 but when tweening, the negative value may switch to positive, so we insert the comma just in case.
          s: startNum,
          c: endNum - startNum,
          m: color && color < 4 || prop === "zIndex" ? Math.round : 0
        };
      }
    }
    pt.c = index < end.length ? end.substring(index, end.length) : "";
  } else {
    pt.r = prop === "display" && end === "none" ? _renderNonTweeningValueOnlyAtEnd : _renderNonTweeningValue;
  }
  _relExp.test(end) && (pt.e = 0);
  this._pt = pt;
  return pt;
};
var _keywordToPercent = {
  top: "0%",
  bottom: "100%",
  left: "0%",
  right: "100%",
  center: "50%"
};
var _convertKeywordsToPercentages = function _convertKeywordsToPercentages2(value) {
  var split = value.split(" "), x = split[0], y = split[1] || "50%";
  if (x === "top" || x === "bottom" || y === "left" || y === "right") {
    value = x;
    x = y;
    y = value;
  }
  split[0] = _keywordToPercent[x] || x;
  split[1] = _keywordToPercent[y] || y;
  return split.join(" ");
};
var _renderClearProps = function _renderClearProps2(ratio, data) {
  if (data.tween && data.tween._time === data.tween._dur) {
    var target = data.t, style = target.style, props = data.u, cache = target._gsap, prop, clearTransforms, i3;
    if (props === "all" || props === true) {
      style.cssText = "";
      clearTransforms = 1;
    } else {
      props = props.split(",");
      i3 = props.length;
      while (--i3 > -1) {
        prop = props[i3];
        if (_transformProps[prop]) {
          clearTransforms = 1;
          prop = prop === "transformOrigin" ? _transformOriginProp : _transformProp;
        }
        _removeProperty(target, prop);
      }
    }
    if (clearTransforms) {
      _removeProperty(target, _transformProp);
      if (cache) {
        cache.svg && target.removeAttribute("transform");
        _parseTransform(target, 1);
        cache.uncache = 1;
        _removeIndependentTransforms(style);
      }
    }
  }
};
var _specialProps = {
  clearProps: function clearProps(plugin, target, property, endValue, tween) {
    if (tween.data !== "isFromStart") {
      var pt = plugin._pt = new PropTween(plugin._pt, target, property, 0, 0, _renderClearProps);
      pt.u = endValue;
      pt.pr = -10;
      pt.tween = tween;
      plugin._props.push(property);
      return 1;
    }
  }
  /* className feature (about 0.4kb gzipped).
  , className(plugin, target, property, endValue, tween) {
  	let _renderClassName = (ratio, data) => {
  			data.css.render(ratio, data.css);
  			if (!ratio || ratio === 1) {
  				let inline = data.rmv,
  					target = data.t,
  					p;
  				target.setAttribute("class", ratio ? data.e : data.b);
  				for (p in inline) {
  					_removeProperty(target, p);
  				}
  			}
  		},
  		_getAllStyles = (target) => {
  			let styles = {},
  				computed = getComputedStyle(target),
  				p;
  			for (p in computed) {
  				if (isNaN(p) && p !== "cssText" && p !== "length") {
  					styles[p] = computed[p];
  				}
  			}
  			_setDefaults(styles, _parseTransform(target, 1));
  			return styles;
  		},
  		startClassList = target.getAttribute("class"),
  		style = target.style,
  		cssText = style.cssText,
  		cache = target._gsap,
  		classPT = cache.classPT,
  		inlineToRemoveAtEnd = {},
  		data = {t:target, plugin:plugin, rmv:inlineToRemoveAtEnd, b:startClassList, e:(endValue.charAt(1) !== "=") ? endValue : startClassList.replace(new RegExp("(?:\\s|^)" + endValue.substr(2) + "(?![\\w-])"), "") + ((endValue.charAt(0) === "+") ? " " + endValue.substr(2) : "")},
  		changingVars = {},
  		startVars = _getAllStyles(target),
  		transformRelated = /(transform|perspective)/i,
  		endVars, p;
  	if (classPT) {
  		classPT.r(1, classPT.d);
  		_removeLinkedListItem(classPT.d.plugin, classPT, "_pt");
  	}
  	target.setAttribute("class", data.e);
  	endVars = _getAllStyles(target, true);
  	target.setAttribute("class", startClassList);
  	for (p in endVars) {
  		if (endVars[p] !== startVars[p] && !transformRelated.test(p)) {
  			changingVars[p] = endVars[p];
  			if (!style[p] && style[p] !== "0") {
  				inlineToRemoveAtEnd[p] = 1;
  			}
  		}
  	}
  	cache.classPT = plugin._pt = new PropTween(plugin._pt, target, "className", 0, 0, _renderClassName, data, 0, -11);
  	if (style.cssText !== cssText) { //only apply if things change. Otherwise, in cases like a background-image that's pulled dynamically, it could cause a refresh. See https://greensock.com/forums/topic/20368-possible-gsap-bug-switching-classnames-in-chrome/.
  		style.cssText = cssText; //we recorded cssText before we swapped classes and ran _getAllStyles() because in cases when a className tween is overwritten, we remove all the related tweening properties from that class change (otherwise class-specific stuff can't override properties we've directly set on the target's style object due to specificity).
  	}
  	_parseTransform(target, true); //to clear the caching of transforms
  	data.css = new gsap.plugins.css();
  	data.css.init(target, changingVars, tween);
  	plugin._props.push(...data.css._props);
  	return 1;
  }
  */
};
var _identity2DMatrix = [1, 0, 0, 1, 0, 0];
var _rotationalProperties = {};
var _isNullTransform = function _isNullTransform2(value) {
  return value === "matrix(1, 0, 0, 1, 0, 0)" || value === "none" || !value;
};
var _getComputedTransformMatrixAsArray = function _getComputedTransformMatrixAsArray2(target) {
  var matrixString = _getComputedProperty(target, _transformProp);
  return _isNullTransform(matrixString) ? _identity2DMatrix : matrixString.substr(7).match(_numExp).map(_round);
};
var _getMatrix = function _getMatrix2(target, force2D) {
  var cache = target._gsap || _getCache(target), style = target.style, matrix3 = _getComputedTransformMatrixAsArray(target), parent, nextSibling, temp, addedToDOM;
  if (cache.svg && target.getAttribute("transform")) {
    temp = target.transform.baseVal.consolidate().matrix;
    matrix3 = [temp.a, temp.b, temp.c, temp.d, temp.e, temp.f];
    return matrix3.join(",") === "1,0,0,1,0,0" ? _identity2DMatrix : matrix3;
  } else if (matrix3 === _identity2DMatrix && !target.offsetParent && target !== _docElement && !cache.svg) {
    temp = style.display;
    style.display = "block";
    parent = target.parentNode;
    if (!parent || !target.offsetParent) {
      addedToDOM = 1;
      nextSibling = target.nextElementSibling;
      _docElement.appendChild(target);
    }
    matrix3 = _getComputedTransformMatrixAsArray(target);
    temp ? style.display = temp : _removeProperty(target, "display");
    if (addedToDOM) {
      nextSibling ? parent.insertBefore(target, nextSibling) : parent ? parent.appendChild(target) : _docElement.removeChild(target);
    }
  }
  return force2D && matrix3.length > 6 ? [matrix3[0], matrix3[1], matrix3[4], matrix3[5], matrix3[12], matrix3[13]] : matrix3;
};
var _applySVGOrigin = function _applySVGOrigin2(target, origin2, originIsAbsolute, smooth, matrixArray, pluginToAddPropTweensTo) {
  var cache = target._gsap, matrix3 = matrixArray || _getMatrix(target, true), xOriginOld = cache.xOrigin || 0, yOriginOld = cache.yOrigin || 0, xOffsetOld = cache.xOffset || 0, yOffsetOld = cache.yOffset || 0, a4 = matrix3[0], b5 = matrix3[1], c3 = matrix3[2], d = matrix3[3], tx = matrix3[4], ty = matrix3[5], originSplit = origin2.split(" "), xOrigin = parseFloat(originSplit[0]) || 0, yOrigin = parseFloat(originSplit[1]) || 0, bounds, determinant, x, y;
  if (!originIsAbsolute) {
    bounds = _getBBox(target);
    xOrigin = bounds.x + (~originSplit[0].indexOf("%") ? xOrigin / 100 * bounds.width : xOrigin);
    yOrigin = bounds.y + (~(originSplit[1] || originSplit[0]).indexOf("%") ? yOrigin / 100 * bounds.height : yOrigin);
  } else if (matrix3 !== _identity2DMatrix && (determinant = a4 * d - b5 * c3)) {
    x = xOrigin * (d / determinant) + yOrigin * (-c3 / determinant) + (c3 * ty - d * tx) / determinant;
    y = xOrigin * (-b5 / determinant) + yOrigin * (a4 / determinant) - (a4 * ty - b5 * tx) / determinant;
    xOrigin = x;
    yOrigin = y;
  }
  if (smooth || smooth !== false && cache.smooth) {
    tx = xOrigin - xOriginOld;
    ty = yOrigin - yOriginOld;
    cache.xOffset = xOffsetOld + (tx * a4 + ty * c3) - tx;
    cache.yOffset = yOffsetOld + (tx * b5 + ty * d) - ty;
  } else {
    cache.xOffset = cache.yOffset = 0;
  }
  cache.xOrigin = xOrigin;
  cache.yOrigin = yOrigin;
  cache.smooth = !!smooth;
  cache.origin = origin2;
  cache.originIsAbsolute = !!originIsAbsolute;
  target.style[_transformOriginProp] = "0px 0px";
  if (pluginToAddPropTweensTo) {
    _addNonTweeningPT(pluginToAddPropTweensTo, cache, "xOrigin", xOriginOld, xOrigin);
    _addNonTweeningPT(pluginToAddPropTweensTo, cache, "yOrigin", yOriginOld, yOrigin);
    _addNonTweeningPT(pluginToAddPropTweensTo, cache, "xOffset", xOffsetOld, cache.xOffset);
    _addNonTweeningPT(pluginToAddPropTweensTo, cache, "yOffset", yOffsetOld, cache.yOffset);
  }
  target.setAttribute("data-svg-origin", xOrigin + " " + yOrigin);
};
var _parseTransform = function _parseTransform2(target, uncache) {
  var cache = target._gsap || new GSCache(target);
  if ("x" in cache && !uncache && !cache.uncache) {
    return cache;
  }
  var style = target.style, invertedScaleX = cache.scaleX < 0, px = "px", deg = "deg", cs = getComputedStyle(target), origin2 = _getComputedProperty(target, _transformOriginProp) || "0", x, y, z, scaleX, scaleY, rotation, rotationX, rotationY, skewX, skewY, perspective, xOrigin, yOrigin, matrix3, angle2, cos, sin, a4, b5, c3, d, a12, a22, t1, t2, t3, a13, a23, a33, a42, a43, a32;
  x = y = z = rotation = rotationX = rotationY = skewX = skewY = perspective = 0;
  scaleX = scaleY = 1;
  cache.svg = !!(target.getCTM && _isSVG(target));
  if (cs.translate) {
    if (cs.translate !== "none" || cs.scale !== "none" || cs.rotate !== "none") {
      style[_transformProp] = (cs.translate !== "none" ? "translate3d(" + (cs.translate + " 0 0").split(" ").slice(0, 3).join(", ") + ") " : "") + (cs.rotate !== "none" ? "rotate(" + cs.rotate + ") " : "") + (cs.scale !== "none" ? "scale(" + cs.scale.split(" ").join(",") + ") " : "") + (cs[_transformProp] !== "none" ? cs[_transformProp] : "");
    }
    style.scale = style.rotate = style.translate = "none";
  }
  matrix3 = _getMatrix(target, cache.svg);
  if (cache.svg) {
    if (cache.uncache) {
      t2 = target.getBBox();
      origin2 = cache.xOrigin - t2.x + "px " + (cache.yOrigin - t2.y) + "px";
      t1 = "";
    } else {
      t1 = !uncache && target.getAttribute("data-svg-origin");
    }
    _applySVGOrigin(target, t1 || origin2, !!t1 || cache.originIsAbsolute, cache.smooth !== false, matrix3);
  }
  xOrigin = cache.xOrigin || 0;
  yOrigin = cache.yOrigin || 0;
  if (matrix3 !== _identity2DMatrix) {
    a4 = matrix3[0];
    b5 = matrix3[1];
    c3 = matrix3[2];
    d = matrix3[3];
    x = a12 = matrix3[4];
    y = a22 = matrix3[5];
    if (matrix3.length === 6) {
      scaleX = Math.sqrt(a4 * a4 + b5 * b5);
      scaleY = Math.sqrt(d * d + c3 * c3);
      rotation = a4 || b5 ? _atan2(b5, a4) * _RAD2DEG : 0;
      skewX = c3 || d ? _atan2(c3, d) * _RAD2DEG + rotation : 0;
      skewX && (scaleY *= Math.abs(Math.cos(skewX * _DEG2RAD)));
      if (cache.svg) {
        x -= xOrigin - (xOrigin * a4 + yOrigin * c3);
        y -= yOrigin - (xOrigin * b5 + yOrigin * d);
      }
    } else {
      a32 = matrix3[6];
      a42 = matrix3[7];
      a13 = matrix3[8];
      a23 = matrix3[9];
      a33 = matrix3[10];
      a43 = matrix3[11];
      x = matrix3[12];
      y = matrix3[13];
      z = matrix3[14];
      angle2 = _atan2(a32, a33);
      rotationX = angle2 * _RAD2DEG;
      if (angle2) {
        cos = Math.cos(-angle2);
        sin = Math.sin(-angle2);
        t1 = a12 * cos + a13 * sin;
        t2 = a22 * cos + a23 * sin;
        t3 = a32 * cos + a33 * sin;
        a13 = a12 * -sin + a13 * cos;
        a23 = a22 * -sin + a23 * cos;
        a33 = a32 * -sin + a33 * cos;
        a43 = a42 * -sin + a43 * cos;
        a12 = t1;
        a22 = t2;
        a32 = t3;
      }
      angle2 = _atan2(-c3, a33);
      rotationY = angle2 * _RAD2DEG;
      if (angle2) {
        cos = Math.cos(-angle2);
        sin = Math.sin(-angle2);
        t1 = a4 * cos - a13 * sin;
        t2 = b5 * cos - a23 * sin;
        t3 = c3 * cos - a33 * sin;
        a43 = d * sin + a43 * cos;
        a4 = t1;
        b5 = t2;
        c3 = t3;
      }
      angle2 = _atan2(b5, a4);
      rotation = angle2 * _RAD2DEG;
      if (angle2) {
        cos = Math.cos(angle2);
        sin = Math.sin(angle2);
        t1 = a4 * cos + b5 * sin;
        t2 = a12 * cos + a22 * sin;
        b5 = b5 * cos - a4 * sin;
        a22 = a22 * cos - a12 * sin;
        a4 = t1;
        a12 = t2;
      }
      if (rotationX && Math.abs(rotationX) + Math.abs(rotation) > 359.9) {
        rotationX = rotation = 0;
        rotationY = 180 - rotationY;
      }
      scaleX = _round(Math.sqrt(a4 * a4 + b5 * b5 + c3 * c3));
      scaleY = _round(Math.sqrt(a22 * a22 + a32 * a32));
      angle2 = _atan2(a12, a22);
      skewX = Math.abs(angle2) > 2e-4 ? angle2 * _RAD2DEG : 0;
      perspective = a43 ? 1 / (a43 < 0 ? -a43 : a43) : 0;
    }
    if (cache.svg) {
      t1 = target.getAttribute("transform");
      cache.forceCSS = target.setAttribute("transform", "") || !_isNullTransform(_getComputedProperty(target, _transformProp));
      t1 && target.setAttribute("transform", t1);
    }
  }
  if (Math.abs(skewX) > 90 && Math.abs(skewX) < 270) {
    if (invertedScaleX) {
      scaleX *= -1;
      skewX += rotation <= 0 ? 180 : -180;
      rotation += rotation <= 0 ? 180 : -180;
    } else {
      scaleY *= -1;
      skewX += skewX <= 0 ? 180 : -180;
    }
  }
  uncache = uncache || cache.uncache;
  cache.x = x - ((cache.xPercent = x && (!uncache && cache.xPercent || (Math.round(target.offsetWidth / 2) === Math.round(-x) ? -50 : 0))) ? target.offsetWidth * cache.xPercent / 100 : 0) + px;
  cache.y = y - ((cache.yPercent = y && (!uncache && cache.yPercent || (Math.round(target.offsetHeight / 2) === Math.round(-y) ? -50 : 0))) ? target.offsetHeight * cache.yPercent / 100 : 0) + px;
  cache.z = z + px;
  cache.scaleX = _round(scaleX);
  cache.scaleY = _round(scaleY);
  cache.rotation = _round(rotation) + deg;
  cache.rotationX = _round(rotationX) + deg;
  cache.rotationY = _round(rotationY) + deg;
  cache.skewX = skewX + deg;
  cache.skewY = skewY + deg;
  cache.transformPerspective = perspective + px;
  if (cache.zOrigin = parseFloat(origin2.split(" ")[2]) || 0) {
    style[_transformOriginProp] = _firstTwoOnly(origin2);
  }
  cache.xOffset = cache.yOffset = 0;
  cache.force3D = _config.force3D;
  cache.renderTransform = cache.svg ? _renderSVGTransforms : _supports3D ? _renderCSSTransforms : _renderNon3DTransforms;
  cache.uncache = 0;
  return cache;
};
var _firstTwoOnly = function _firstTwoOnly2(value) {
  return (value = value.split(" "))[0] + " " + value[1];
};
var _addPxTranslate = function _addPxTranslate2(target, start, value) {
  var unit = getUnit(start);
  return _round(parseFloat(start) + parseFloat(_convertToUnit(target, "x", value + "px", unit))) + unit;
};
var _renderNon3DTransforms = function _renderNon3DTransforms2(ratio, cache) {
  cache.z = "0px";
  cache.rotationY = cache.rotationX = "0deg";
  cache.force3D = 0;
  _renderCSSTransforms(ratio, cache);
};
var _zeroDeg = "0deg";
var _zeroPx = "0px";
var _endParenthesis = ") ";
var _renderCSSTransforms = function _renderCSSTransforms2(ratio, cache) {
  var _ref = cache || this, xPercent = _ref.xPercent, yPercent = _ref.yPercent, x = _ref.x, y = _ref.y, z = _ref.z, rotation = _ref.rotation, rotationY = _ref.rotationY, rotationX = _ref.rotationX, skewX = _ref.skewX, skewY = _ref.skewY, scaleX = _ref.scaleX, scaleY = _ref.scaleY, transformPerspective = _ref.transformPerspective, force3D = _ref.force3D, target = _ref.target, zOrigin = _ref.zOrigin, transforms = "", use3D = force3D === "auto" && ratio && ratio !== 1 || force3D === true;
  if (zOrigin && (rotationX !== _zeroDeg || rotationY !== _zeroDeg)) {
    var angle2 = parseFloat(rotationY) * _DEG2RAD, a13 = Math.sin(angle2), a33 = Math.cos(angle2), cos;
    angle2 = parseFloat(rotationX) * _DEG2RAD;
    cos = Math.cos(angle2);
    x = _addPxTranslate(target, x, a13 * cos * -zOrigin);
    y = _addPxTranslate(target, y, -Math.sin(angle2) * -zOrigin);
    z = _addPxTranslate(target, z, a33 * cos * -zOrigin + zOrigin);
  }
  if (transformPerspective !== _zeroPx) {
    transforms += "perspective(" + transformPerspective + _endParenthesis;
  }
  if (xPercent || yPercent) {
    transforms += "translate(" + xPercent + "%, " + yPercent + "%) ";
  }
  if (use3D || x !== _zeroPx || y !== _zeroPx || z !== _zeroPx) {
    transforms += z !== _zeroPx || use3D ? "translate3d(" + x + ", " + y + ", " + z + ") " : "translate(" + x + ", " + y + _endParenthesis;
  }
  if (rotation !== _zeroDeg) {
    transforms += "rotate(" + rotation + _endParenthesis;
  }
  if (rotationY !== _zeroDeg) {
    transforms += "rotateY(" + rotationY + _endParenthesis;
  }
  if (rotationX !== _zeroDeg) {
    transforms += "rotateX(" + rotationX + _endParenthesis;
  }
  if (skewX !== _zeroDeg || skewY !== _zeroDeg) {
    transforms += "skew(" + skewX + ", " + skewY + _endParenthesis;
  }
  if (scaleX !== 1 || scaleY !== 1) {
    transforms += "scale(" + scaleX + ", " + scaleY + _endParenthesis;
  }
  target.style[_transformProp] = transforms || "translate(0, 0)";
};
var _renderSVGTransforms = function _renderSVGTransforms2(ratio, cache) {
  var _ref2 = cache || this, xPercent = _ref2.xPercent, yPercent = _ref2.yPercent, x = _ref2.x, y = _ref2.y, rotation = _ref2.rotation, skewX = _ref2.skewX, skewY = _ref2.skewY, scaleX = _ref2.scaleX, scaleY = _ref2.scaleY, target = _ref2.target, xOrigin = _ref2.xOrigin, yOrigin = _ref2.yOrigin, xOffset = _ref2.xOffset, yOffset = _ref2.yOffset, forceCSS = _ref2.forceCSS, tx = parseFloat(x), ty = parseFloat(y), a11, a21, a12, a22, temp;
  rotation = parseFloat(rotation);
  skewX = parseFloat(skewX);
  skewY = parseFloat(skewY);
  if (skewY) {
    skewY = parseFloat(skewY);
    skewX += skewY;
    rotation += skewY;
  }
  if (rotation || skewX) {
    rotation *= _DEG2RAD;
    skewX *= _DEG2RAD;
    a11 = Math.cos(rotation) * scaleX;
    a21 = Math.sin(rotation) * scaleX;
    a12 = Math.sin(rotation - skewX) * -scaleY;
    a22 = Math.cos(rotation - skewX) * scaleY;
    if (skewX) {
      skewY *= _DEG2RAD;
      temp = Math.tan(skewX - skewY);
      temp = Math.sqrt(1 + temp * temp);
      a12 *= temp;
      a22 *= temp;
      if (skewY) {
        temp = Math.tan(skewY);
        temp = Math.sqrt(1 + temp * temp);
        a11 *= temp;
        a21 *= temp;
      }
    }
    a11 = _round(a11);
    a21 = _round(a21);
    a12 = _round(a12);
    a22 = _round(a22);
  } else {
    a11 = scaleX;
    a22 = scaleY;
    a21 = a12 = 0;
  }
  if (tx && !~(x + "").indexOf("px") || ty && !~(y + "").indexOf("px")) {
    tx = _convertToUnit(target, "x", x, "px");
    ty = _convertToUnit(target, "y", y, "px");
  }
  if (xOrigin || yOrigin || xOffset || yOffset) {
    tx = _round(tx + xOrigin - (xOrigin * a11 + yOrigin * a12) + xOffset);
    ty = _round(ty + yOrigin - (xOrigin * a21 + yOrigin * a22) + yOffset);
  }
  if (xPercent || yPercent) {
    temp = target.getBBox();
    tx = _round(tx + xPercent / 100 * temp.width);
    ty = _round(ty + yPercent / 100 * temp.height);
  }
  temp = "matrix(" + a11 + "," + a21 + "," + a12 + "," + a22 + "," + tx + "," + ty + ")";
  target.setAttribute("transform", temp);
  forceCSS && (target.style[_transformProp] = temp);
};
var _addRotationalPropTween = function _addRotationalPropTween2(plugin, target, property, startNum, endValue) {
  var cap = 360, isString = _isString(endValue), endNum = parseFloat(endValue) * (isString && ~endValue.indexOf("rad") ? _RAD2DEG : 1), change = endNum - startNum, finalValue = startNum + change + "deg", direction, pt;
  if (isString) {
    direction = endValue.split("_")[1];
    if (direction === "short") {
      change %= cap;
      if (change !== change % (cap / 2)) {
        change += change < 0 ? cap : -cap;
      }
    }
    if (direction === "cw" && change < 0) {
      change = (change + cap * _bigNum2) % cap - ~~(change / cap) * cap;
    } else if (direction === "ccw" && change > 0) {
      change = (change - cap * _bigNum2) % cap - ~~(change / cap) * cap;
    }
  }
  plugin._pt = pt = new PropTween(plugin._pt, target, property, startNum, change, _renderPropWithEnd);
  pt.e = finalValue;
  pt.u = "deg";
  plugin._props.push(property);
  return pt;
};
var _assign = function _assign2(target, source) {
  for (var p in source) {
    target[p] = source[p];
  }
  return target;
};
var _addRawTransformPTs = function _addRawTransformPTs2(plugin, transforms, target) {
  var startCache = _assign({}, target._gsap), exclude = "perspective,force3D,transformOrigin,svgOrigin", style = target.style, endCache, p, startValue, endValue, startNum, endNum, startUnit, endUnit;
  if (startCache.svg) {
    startValue = target.getAttribute("transform");
    target.setAttribute("transform", "");
    style[_transformProp] = transforms;
    endCache = _parseTransform(target, 1);
    _removeProperty(target, _transformProp);
    target.setAttribute("transform", startValue);
  } else {
    startValue = getComputedStyle(target)[_transformProp];
    style[_transformProp] = transforms;
    endCache = _parseTransform(target, 1);
    style[_transformProp] = startValue;
  }
  for (p in _transformProps) {
    startValue = startCache[p];
    endValue = endCache[p];
    if (startValue !== endValue && exclude.indexOf(p) < 0) {
      startUnit = getUnit(startValue);
      endUnit = getUnit(endValue);
      startNum = startUnit !== endUnit ? _convertToUnit(target, p, startValue, endUnit) : parseFloat(startValue);
      endNum = parseFloat(endValue);
      plugin._pt = new PropTween(plugin._pt, endCache, p, startNum, endNum - startNum, _renderCSSProp);
      plugin._pt.u = endUnit || 0;
      plugin._props.push(p);
    }
  }
  _assign(endCache, startCache);
};
_forEachName("padding,margin,Width,Radius", function(name, index) {
  var t2 = "Top", r = "Right", b5 = "Bottom", l = "Left", props = (index < 3 ? [t2, r, b5, l] : [t2 + l, t2 + r, b5 + r, b5 + l]).map(function(side) {
    return index < 2 ? name + side : "border" + side + name;
  });
  _specialProps[index > 1 ? "border" + name : name] = function(plugin, target, property, endValue, tween) {
    var a4, vars;
    if (arguments.length < 4) {
      a4 = props.map(function(prop) {
        return _get(plugin, prop, property);
      });
      vars = a4.join(" ");
      return vars.split(a4[0]).length === 5 ? a4[0] : vars;
    }
    a4 = (endValue + "").split(" ");
    vars = {};
    props.forEach(function(prop, i3) {
      return vars[prop] = a4[i3] = a4[i3] || a4[(i3 - 1) / 2 | 0];
    });
    plugin.init(target, vars, tween);
  };
});
var CSSPlugin = {
  name: "css",
  register: _initCore,
  targetTest: function targetTest(target) {
    return target.style && target.nodeType;
  },
  init: function init4(target, vars, tween, index, targets) {
    var props = this._props, style = target.style, startAt = tween.vars.startAt, startValue, endValue, endNum, startNum, type, specialProp, p, startUnit, endUnit, relative, isTransformRelated, transformPropTween, cache, smooth, hasPriority, inlineProps;
    _pluginInitted || _initCore();
    this.styles = this.styles || _getStyleSaver(target);
    inlineProps = this.styles.props;
    this.tween = tween;
    for (p in vars) {
      if (p === "autoRound") {
        continue;
      }
      endValue = vars[p];
      if (_plugins[p] && _checkPlugin(p, vars, tween, index, target, targets)) {
        continue;
      }
      type = typeof endValue;
      specialProp = _specialProps[p];
      if (type === "function") {
        endValue = endValue.call(tween, index, target, targets);
        type = typeof endValue;
      }
      if (type === "string" && ~endValue.indexOf("random(")) {
        endValue = _replaceRandom(endValue);
      }
      if (specialProp) {
        specialProp(this, target, p, endValue, tween) && (hasPriority = 1);
      } else if (p.substr(0, 2) === "--") {
        startValue = (getComputedStyle(target).getPropertyValue(p) + "").trim();
        endValue += "";
        _colorExp.lastIndex = 0;
        if (!_colorExp.test(startValue)) {
          startUnit = getUnit(startValue);
          endUnit = getUnit(endValue);
        }
        endUnit ? startUnit !== endUnit && (startValue = _convertToUnit(target, p, startValue, endUnit) + endUnit) : startUnit && (endValue += startUnit);
        this.add(style, "setProperty", startValue, endValue, index, targets, 0, 0, p);
        props.push(p);
        inlineProps.push(p, 0, style[p]);
      } else if (type !== "undefined") {
        if (startAt && p in startAt) {
          startValue = typeof startAt[p] === "function" ? startAt[p].call(tween, index, target, targets) : startAt[p];
          _isString(startValue) && ~startValue.indexOf("random(") && (startValue = _replaceRandom(startValue));
          getUnit(startValue + "") || (startValue += _config.units[p] || getUnit(_get(target, p)) || "");
          (startValue + "").charAt(1) === "=" && (startValue = _get(target, p));
        } else {
          startValue = _get(target, p);
        }
        startNum = parseFloat(startValue);
        relative = type === "string" && endValue.charAt(1) === "=" && endValue.substr(0, 2);
        relative && (endValue = endValue.substr(2));
        endNum = parseFloat(endValue);
        if (p in _propertyAliases) {
          if (p === "autoAlpha") {
            if (startNum === 1 && _get(target, "visibility") === "hidden" && endNum) {
              startNum = 0;
            }
            inlineProps.push("visibility", 0, style.visibility);
            _addNonTweeningPT(this, style, "visibility", startNum ? "inherit" : "hidden", endNum ? "inherit" : "hidden", !endNum);
          }
          if (p !== "scale" && p !== "transform") {
            p = _propertyAliases[p];
            ~p.indexOf(",") && (p = p.split(",")[0]);
          }
        }
        isTransformRelated = p in _transformProps;
        if (isTransformRelated) {
          this.styles.save(p);
          if (!transformPropTween) {
            cache = target._gsap;
            cache.renderTransform && !vars.parseTransform || _parseTransform(target, vars.parseTransform);
            smooth = vars.smoothOrigin !== false && cache.smooth;
            transformPropTween = this._pt = new PropTween(this._pt, style, _transformProp, 0, 1, cache.renderTransform, cache, 0, -1);
            transformPropTween.dep = 1;
          }
          if (p === "scale") {
            this._pt = new PropTween(this._pt, cache, "scaleY", cache.scaleY, (relative ? _parseRelative(cache.scaleY, relative + endNum) : endNum) - cache.scaleY || 0, _renderCSSProp);
            this._pt.u = 0;
            props.push("scaleY", p);
            p += "X";
          } else if (p === "transformOrigin") {
            inlineProps.push(_transformOriginProp, 0, style[_transformOriginProp]);
            endValue = _convertKeywordsToPercentages(endValue);
            if (cache.svg) {
              _applySVGOrigin(target, endValue, 0, smooth, 0, this);
            } else {
              endUnit = parseFloat(endValue.split(" ")[2]) || 0;
              endUnit !== cache.zOrigin && _addNonTweeningPT(this, cache, "zOrigin", cache.zOrigin, endUnit);
              _addNonTweeningPT(this, style, p, _firstTwoOnly(startValue), _firstTwoOnly(endValue));
            }
            continue;
          } else if (p === "svgOrigin") {
            _applySVGOrigin(target, endValue, 1, smooth, 0, this);
            continue;
          } else if (p in _rotationalProperties) {
            _addRotationalPropTween(this, cache, p, startNum, relative ? _parseRelative(startNum, relative + endValue) : endValue);
            continue;
          } else if (p === "smoothOrigin") {
            _addNonTweeningPT(this, cache, "smooth", cache.smooth, endValue);
            continue;
          } else if (p === "force3D") {
            cache[p] = endValue;
            continue;
          } else if (p === "transform") {
            _addRawTransformPTs(this, endValue, target);
            continue;
          }
        } else if (!(p in style)) {
          p = _checkPropPrefix(p) || p;
        }
        if (isTransformRelated || (endNum || endNum === 0) && (startNum || startNum === 0) && !_complexExp.test(endValue) && p in style) {
          startUnit = (startValue + "").substr((startNum + "").length);
          endNum || (endNum = 0);
          endUnit = getUnit(endValue) || (p in _config.units ? _config.units[p] : startUnit);
          startUnit !== endUnit && (startNum = _convertToUnit(target, p, startValue, endUnit));
          this._pt = new PropTween(this._pt, isTransformRelated ? cache : style, p, startNum, (relative ? _parseRelative(startNum, relative + endNum) : endNum) - startNum, !isTransformRelated && (endUnit === "px" || p === "zIndex") && vars.autoRound !== false ? _renderRoundedCSSProp : _renderCSSProp);
          this._pt.u = endUnit || 0;
          if (startUnit !== endUnit && endUnit !== "%") {
            this._pt.b = startValue;
            this._pt.r = _renderCSSPropWithBeginning;
          }
        } else if (!(p in style)) {
          if (p in target) {
            this.add(target, p, startValue || target[p], relative ? relative + endValue : endValue, index, targets);
          } else if (p !== "parseTransform") {
            _missingPlugin(p, endValue);
            continue;
          }
        } else {
          _tweenComplexCSSString.call(this, target, p, startValue, relative ? relative + endValue : endValue);
        }
        isTransformRelated || (p in style ? inlineProps.push(p, 0, style[p]) : inlineProps.push(p, 1, startValue || target[p]));
        props.push(p);
      }
    }
    hasPriority && _sortPropTweensByPriority(this);
  },
  render: function render2(ratio, data) {
    if (data.tween._time || !_reverting2()) {
      var pt = data._pt;
      while (pt) {
        pt.r(ratio, pt.d);
        pt = pt._next;
      }
    } else {
      data.styles.revert();
    }
  },
  get: _get,
  aliases: _propertyAliases,
  getSetter: function getSetter(target, property, plugin) {
    var p = _propertyAliases[property];
    p && p.indexOf(",") < 0 && (property = p);
    return property in _transformProps && property !== _transformOriginProp && (target._gsap.x || _get(target, "x")) ? plugin && _recentSetterPlugin === plugin ? property === "scale" ? _setterScale : _setterTransform : (_recentSetterPlugin = plugin || {}) && (property === "scale" ? _setterScaleWithRender : _setterTransformWithRender) : target.style && !_isUndefined(target.style[property]) ? _setterCSSStyle : ~property.indexOf("-") ? _setterCSSProp : _getSetter(target, property);
  },
  core: {
    _removeProperty,
    _getMatrix
  }
};
gsap.utils.checkPrefix = _checkPropPrefix;
gsap.core.getStyleSaver = _getStyleSaver;
(function(positionAndScale, rotation, others, aliases) {
  var all = _forEachName(positionAndScale + "," + rotation + "," + others, function(name) {
    _transformProps[name] = 1;
  });
  _forEachName(rotation, function(name) {
    _config.units[name] = "deg";
    _rotationalProperties[name] = 1;
  });
  _propertyAliases[all[13]] = positionAndScale + "," + rotation;
  _forEachName(aliases, function(name) {
    var split = name.split(":");
    _propertyAliases[split[1]] = all[split[0]];
  });
})("x,y,z,scale,scaleX,scaleY,xPercent,yPercent", "rotation,rotationX,rotationY,skewX,skewY", "transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", "0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY");
_forEachName("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", function(name) {
  _config.units[name] = "px";
});
gsap.registerPlugin(CSSPlugin);

// node_modules/gsap/index.js
var gsapWithCSS = gsap.registerPlugin(CSSPlugin) || gsap;
var TweenMaxWithCSS = gsapWithCSS.core.Tween;

// node_modules/kokomi.js/dist/panorama/basicPanorama.js
var BasicPanorama = class extends Component {
  constructor(base, config3 = {}) {
    super(base);
    __publicField(this, "id");
    __publicField(this, "material");
    __publicField(this, "mesh");
    __publicField(this, "infospots");
    __publicField(this, "isInfospotVisible");
    __publicField(this, "active");
    const { id = "", radius = 5e3 } = config3;
    this.id = id;
    const geometry2 = new SphereGeometry(radius, 60, 40);
    const material2 = new MeshBasicMaterial({
      side: BackSide,
      transparent: true,
      opacity: 1
    });
    this.material = material2;
    const mesh = new Mesh(geometry2, material2);
    this.mesh = mesh;
    this.infospots = [];
    this.isInfospotVisible = false;
    this.active = false;
  }
  addExisting() {
    this.container.add(this.mesh);
  }
  outputPosition() {
    const container = this.base.container || window;
    container.addEventListener("click", (event) => {
      const intersects = this.base.interactionManager.raycaster.intersectObject(this.mesh, true);
      const point = intersects[0].point.clone();
      const position = {
        x: point.x.toFixed(2),
        y: point.y.toFixed(2),
        z: point.z.toFixed(2)
      };
      const message = `${position.x}, ${position.y}, ${position.z}`;
      console.log(message);
      this.emit("click", point);
    });
  }
  show() {
    this.material.opacity = 1;
  }
  hide() {
    this.material.opacity = 0;
  }
  fadeIn(duration = 0.5) {
    return new Promise((resolve) => {
      gsapWithCSS.fromTo(this.material, {
        opacity: 0
      }, {
        opacity: 1,
        duration,
        onComplete() {
          resolve(true);
        }
      });
    });
  }
  fadeOut(duration = 0.5) {
    return new Promise((resolve) => {
      gsapWithCSS.fromTo(this.material, {
        opacity: 1
      }, {
        opacity: 0,
        duration,
        onComplete() {
          resolve(true);
        }
      });
    });
  }
  add(infospot) {
    this.infospots.push(infospot);
  }
  addGroup(infospots) {
    for (const infospot of infospots) {
      this.add(infospot);
    }
  }
  update(time) {
    for (const infospot of this.infospots) {
      if (!this.active) {
        infospot.makeInvisible();
      } else {
        if (this.isInfospotVisible) {
          infospot.makeVisible();
        } else {
          infospot.makeInvisible();
        }
      }
    }
  }
  toggleInfospotVisibility(isVisible = void 0) {
    const visible = isVisible ? isVisible : this.isInfospotVisible ? false : true;
    this.isInfospotVisible = visible;
  }
  onEnter(duration = 0.5) {
    this.active = true;
    this.toggleInfospotVisibility(true);
    this.fadeIn(duration);
  }
  onLeave(duration = 0.5) {
    this.active = false;
    this.toggleInfospotVisibility(false);
    this.fadeOut(duration);
  }
};

// node_modules/kokomi.js/dist/panorama/imagePanorama.js
var ImagePanorama = class extends BasicPanorama {
  constructor(base, texture, config3 = {}) {
    super(base);
    const { id = "", radius = 5e3 } = config3;
    this.id = id;
    const geometry2 = new SphereGeometry(radius, 60, 40);
    const material2 = new MeshBasicMaterial({
      map: texture,
      side: BackSide,
      transparent: true,
      opacity: 1
    });
    this.material = material2;
    const mesh = new Mesh(geometry2, material2);
    this.mesh = mesh;
  }
};

// node_modules/kokomi.js/dist/panorama/viewer.js
var Viewer = class extends Component {
  constructor(base, config3 = {}) {
    super(base);
    __publicField(this, "camera");
    __publicField(this, "orbitControls");
    __publicField(this, "panoramas");
    __publicField(this, "currentPanorama");
    const { fov = 60 } = config3;
    const camera = new PerspectiveCamera(fov, window.innerWidth / window.innerHeight, 1, 1e4);
    camera.position.set(0, 0, 1);
    base.camera = camera;
    base.interactionManager.camera = camera;
    this.camera = camera;
    const orbitControls = new OrbitControls2(base);
    this.orbitControls = orbitControls;
    this.panoramas = [];
    this.currentPanorama = null;
  }
  add(panorama) {
    panorama.addExisting();
    this.panoramas.push(panorama);
    panorama.onEnter(0);
    this.currentPanorama = panorama;
  }
  setPanorama(panorama, duration = 0.5) {
    var _a4;
    if (panorama === this.currentPanorama) {
      return;
    }
    (_a4 = this.currentPanorama) == null ? void 0 : _a4.onLeave(duration);
    panorama == null ? void 0 : panorama.onEnter(duration);
    this.currentPanorama = panorama;
  }
};

// node_modules/kokomi.js/dist/web/html.js
var Html = class extends Component {
  constructor(base, el, position = new Vector3(0, 0, 0), config3 = {}) {
    super(base);
    __publicField(this, "el");
    __publicField(this, "position");
    __publicField(this, "visibleClassName");
    __publicField(this, "xPropertyName");
    __publicField(this, "yPropertyName");
    __publicField(this, "zIndexPropertyName");
    __publicField(this, "scalePropertyName");
    __publicField(this, "viewportWidthName");
    __publicField(this, "viewportHeightName");
    __publicField(this, "perspectiveName");
    __publicField(this, "transformOuterName");
    __publicField(this, "transformInnerName");
    __publicField(this, "raycaster");
    __publicField(this, "occlude");
    __publicField(this, "transform");
    __publicField(this, "distanceFactor");
    __publicField(this, "parentGroup");
    __publicField(this, "group");
    __publicField(this, "visibleToggle");
    this.el = el;
    this.position = position;
    const { visibleClassName = "visible", xPropertyName = "--x", yPropertyName = "--y", zIndexPropertyName = "--z-index", scalePropertyName = "--scale", viewportWidthName = "--viewport-width", viewportHeightName = "--viewport-height", perspectiveName = "--perspective", transformOuterName = "--transform-outer", transformInnerName = "--transform-inner", occlude = [], transform = false, distanceFactor = 0, group = null } = config3;
    this.visibleClassName = visibleClassName;
    this.xPropertyName = xPropertyName;
    this.yPropertyName = yPropertyName;
    this.zIndexPropertyName = zIndexPropertyName;
    this.scalePropertyName = scalePropertyName;
    this.viewportWidthName = viewportWidthName;
    this.viewportHeightName = viewportHeightName;
    this.perspectiveName = perspectiveName;
    this.transformOuterName = transformOuterName;
    this.transformInnerName = transformInnerName;
    this.raycaster = new Raycaster();
    this.occlude = occlude;
    this.transform = transform;
    this.distanceFactor = distanceFactor;
    this.parentGroup = group;
    this.group = new Group();
    this.group.position.copy(this.position);
    this.visibleToggle = true;
  }
  get domPosition() {
    return calcObjectPosition(this.group, this.base.camera);
  }
  get zIndex() {
    return objectZIndex(this.group, this.base.camera);
  }
  get scale() {
    return !this.distanceFactor ? 1 : objectScale(this.group, this.base.camera) * this.distanceFactor;
  }
  get isBehindCamera() {
    return isObjectBehindCamera(this.group, this.base.camera);
  }
  get isVisible() {
    return isObjectVisible(this.group, this.base.camera, this.raycaster, this.occlude);
  }
  get visible() {
    if (!this.visibleToggle) {
      return false;
    }
    if (this.occlude.length === 0) {
      return !this.isBehindCamera;
    } else {
      return !this.isBehindCamera && this.isVisible;
    }
  }
  get viewportSize() {
    return {
      width: window.innerWidth,
      height: window.innerHeight
    };
  }
  get fov() {
    return calcTransformFov(this.base.camera);
  }
  get perspective() {
    return this.base.camera.isOrthographicCamera ? "" : this.fov;
  }
  get transformOuter() {
    const camera = this.base.camera;
    const { isOrthographicCamera: isOrthographicCamera2, top, left, bottom, right } = camera;
    const { fov } = this;
    const widthHalf = window.innerWidth / 2;
    const heightHalf = window.innerHeight / 2;
    const cameraMatrix = getCameraCSSMatrix(camera.matrixWorldInverse);
    const cameraTransform = isOrthographicCamera2 ? `scale(${fov})translate(${epsilon(-(right + left) / 2)}px,${epsilon((top + bottom) / 2)}px)` : `translateZ(${fov}px)`;
    return `${cameraTransform}${cameraMatrix}translate(${widthHalf}px,${heightHalf}px)`;
  }
  get transformInner() {
    const matrix3 = this.group.matrixWorld;
    return getObjectCSSMatrix(matrix3, 1 / ((this.distanceFactor || 10) / 400));
  }
  addExisting() {
    if (this.parentGroup) {
      this.parentGroup.add(this.group);
    } else {
      this.container.add(this.group);
    }
  }
  show() {
    var _a4;
    (_a4 = this.el) == null ? void 0 : _a4.classList.add(this.visibleClassName);
  }
  hide() {
    var _a4;
    (_a4 = this.el) == null ? void 0 : _a4.classList.remove(this.visibleClassName);
  }
  translate({ x = 0, y = 0 }) {
    var _a4, _b4;
    (_a4 = this.el) == null ? void 0 : _a4.style.setProperty(this.xPropertyName, `${x}px`);
    (_b4 = this.el) == null ? void 0 : _b4.style.setProperty(this.yPropertyName, `${y}px`);
  }
  setZIndex(zIndex = 0) {
    var _a4;
    (_a4 = this.el) == null ? void 0 : _a4.style.setProperty(this.zIndexPropertyName, `${zIndex}`);
  }
  setScale(scale = 1) {
    var _a4;
    (_a4 = this.el) == null ? void 0 : _a4.style.setProperty(this.scalePropertyName, `${scale}`);
  }
  syncPosition() {
    this.translate(this.domPosition);
    this.setScale(this.scale);
    if (this.zIndex) {
      this.setZIndex(this.zIndex);
    }
    if (this.transform) {
      this.setTransformProperty();
    }
  }
  makeVisible() {
    this.visibleToggle = true;
  }
  makeInvisible() {
    this.visibleToggle = false;
  }
  update(time) {
    this.syncPosition();
    if (this.visible) {
      this.show();
    } else {
      this.hide();
    }
  }
  setTransformProperty() {
    var _a4, _b4, _c, _d, _e;
    (_a4 = this.el) == null ? void 0 : _a4.style.setProperty(this.viewportWidthName, `${this.viewportSize.width}px`);
    (_b4 = this.el) == null ? void 0 : _b4.style.setProperty(this.viewportHeightName, `${this.viewportSize.height}px`);
    (_c = this.el) == null ? void 0 : _c.style.setProperty(this.perspectiveName, `${this.perspective}px`);
    (_d = this.el) == null ? void 0 : _d.style.setProperty(this.transformOuterName, this.transformOuter);
    (_e = this.el) == null ? void 0 : _e.style.setProperty(this.transformInnerName, this.transformInner);
  }
};

// node_modules/kokomi.js/dist/panorama/panoramaGenerator.js
var PanoramaGenerator = class extends Component {
  constructor(base, config3 = null) {
    super(base);
    __publicField(this, "config");
    __publicField(this, "assetManager");
    __publicField(this, "viewer");
    __publicField(this, "panoramas");
    __publicField(this, "isSceneJumpEnabled");
    this.config = null;
    this.assetManager = null;
    this.viewer = null;
    this.panoramas = [];
    this.isSceneJumpEnabled = true;
    if (config3) {
      this.setConfig(config3);
    }
  }
  // 设置配置
  setConfig(config3) {
    this.config = config3;
  }
  // 通过配置获取信息点元素
  getInfospotElByConfig(config3) {
    const className = config3.className || `point-${config3.id}`;
    const el = document.querySelector(`.${className}`);
    return el;
  }
  // 加载素材并生成全景图
  generate() {
    const { config: config3 } = this;
    if (!config3) {
      return;
    }
    const resourceList = config3.map((item) => ({
      name: item.name,
      type: "texture",
      path: item.url
    }));
    const assetManager = new AssetManager(this.base, resourceList);
    this.assetManager = assetManager;
    this.assetManager.on("ready", () => {
      const viewer = new Viewer(this.base);
      this.viewer = viewer;
      this.generatePanoramas();
      viewer.setPanorama(this.panoramas[0], 0);
      this.emit("generate", this);
    });
  }
  // 根据配置生成所有全景图
  generateByConfig(config3) {
    this.setConfig(config3);
    this.generate();
  }
  // 生成全景图
  generatePanoramas() {
    const { config: config3 } = this;
    if (!config3) {
      return;
    }
    const panoramas = config3.map((item) => {
      var _a4;
      const image = (_a4 = this.assetManager) == null ? void 0 : _a4.items[item.name];
      const panorama = new ImagePanorama(this.base, image);
      panorama.id = item.id;
      const { viewer } = this;
      viewer == null ? void 0 : viewer.add(panorama);
      return panorama;
    });
    this.panoramas = panoramas;
    return panoramas;
  }
  // 生成信息点
  generateInfospots() {
    const { config: config3 } = this;
    if (!config3) {
      return;
    }
    config3.forEach((item) => {
      if (item.infospots) {
        const points = item.infospots.map((infospot) => {
          const el = this.getInfospotElByConfig(infospot);
          const html = new Html(this.base, el, new Vector3(infospot.point.x, infospot.point.y, infospot.point.z));
          html.addExisting();
          return html;
        });
        const { panoramas } = this;
        const targetPanorama = panoramas.find((pa) => pa.id === item.id);
        if (targetPanorama) {
          targetPanorama.infospots = [];
          targetPanorama.addGroup(points);
        }
      }
    });
  }
  // 生成场景跳转
  generateSceneJump() {
    const { config: config3 } = this;
    if (!config3) {
      return;
    }
    config3.forEach((item) => {
      if (item.infospots) {
        item.infospots.forEach((infospot) => {
          if (infospot.jump) {
            const { panoramas, viewer } = this;
            const targetPanorama = panoramas.find((pa) => pa.id === infospot.jump);
            if (targetPanorama) {
              const el = this.getInfospotElByConfig(infospot);
              el.onclick = () => {
                if (!this.isSceneJumpEnabled) {
                  return;
                }
                viewer == null ? void 0 : viewer.setPanorama(targetPanorama);
              };
            }
          } else {
            const el = this.getInfospotElByConfig(infospot);
            el.onclick = () => {
              if (!this.isSceneJumpEnabled) {
                return;
              }
            };
          }
        });
      }
    });
  }
  // 生成带跳转的信息点
  generateInfospotsWithSceneJump() {
    this.generateInfospots();
    this.generateSceneJump();
  }
  // 所有点的配置
  get allInfospotConfig() {
    if (!this.config) {
      return [];
    }
    return this.config.map((scene) => {
      var _a4;
      if (!scene.infospots) {
        return [];
      }
      const infospots = (_a4 = scene.infospots) == null ? void 0 : _a4.map((infospot) => {
        return {
          id: infospot.id,
          name: infospot.name || infospot.id,
          point: infospot.point,
          jump: infospot.jump,
          className: infospot.className
        };
      });
      return infospots;
    }).flat().filter((item) => item);
  }
  // 输出当前场景的信息
  outputCurrentScenePosition() {
    var _a4, _b4, _c, _d;
    (_b4 = (_a4 = this.viewer) == null ? void 0 : _a4.currentPanorama) == null ? void 0 : _b4.outputPosition();
    (_d = (_c = this.viewer) == null ? void 0 : _c.currentPanorama) == null ? void 0 : _d.on("click", (point) => {
      this.emit("click-scene", point);
    });
  }
  // 允许跳转场景
  enableSceneJump() {
    this.isSceneJumpEnabled = true;
  }
  // 禁止跳转场景
  disableSceneJump() {
    this.isSceneJumpEnabled = false;
  }
};

// node_modules/kokomi.js/dist/postprocessing/customEffect.js
var defaultVertexShader = (
  /* glsl */
  `
uniform float iTime;
uniform vec2 iResolution;
uniform vec2 iMouse;

varying vec2 vUv;

void main(){
    vec3 p=position;
    gl_Position=projectionMatrix*modelViewMatrix*vec4(p,1.);
    
    vUv=uv;
}
`
);
var defaultFragmentShader = (
  /* glsl */
  `
uniform float iTime;
uniform vec2 iResolution;
uniform vec2 iMouse;

uniform sampler2D tDiffuse;

varying vec2 vUv;

void main(){
    vec2 p=vUv;
    vec4 color=texture(tDiffuse,p);
    gl_FragColor=color;
}
`
);
var CustomEffect = class extends Component {
  constructor(base, config3 = {}) {
    super(base);
    __publicField(this, "composer");
    __publicField(this, "customPass");
    __publicField(this, "uniformInjector");
    const { vertexShader = defaultVertexShader, fragmentShader = defaultFragmentShader, uniforms = {} } = config3;
    const composer = new EffectComposer(base.renderer);
    this.composer = composer;
    const renderPass = new RenderPass(base.scene, base.camera);
    composer.addPass(renderPass);
    const uniformInjector = new UniformInjector(base);
    this.uniformInjector = uniformInjector;
    const customPass = new ShaderPass({
      vertexShader,
      fragmentShader,
      uniforms: {
        ...{
          tDiffuse: {
            value: null
          }
        },
        ...uniformInjector.shadertoyUniforms,
        ...uniforms
      }
    });
    this.customPass = customPass;
    customPass.renderToScreen = true;
    composer.addPass(customPass);
  }
  addExisting() {
    this.base.composer = this.composer;
  }
  update(time) {
    const uniforms = this.customPass.uniforms;
    this.uniformInjector.injectShadertoyUniforms(uniforms);
  }
};

// node_modules/kokomi.js/dist/shapes/box.js
var Box4 = class extends Component {
  constructor(base, config3 = {}) {
    super(base);
    __publicField(this, "mesh");
    const { width = 0.2, height = 0.2, depth = 0.2, position = new Vector3(0, 0, 0), material: material2 = new MeshBasicMaterial({
      color: new Color("#ffffff")
    }) } = config3;
    const geometry2 = new BoxGeometry(width, height, depth);
    const mesh = new Mesh(geometry2, material2);
    mesh.position.copy(position);
    this.mesh = mesh;
  }
  addExisting() {
    this.container.add(this.mesh);
  }
  spin(time, axis = "y", speed = 1) {
    const mesh = this.mesh;
    mesh.rotation[axis] = time / 1e3 * speed;
  }
};

// node_modules/kokomi.js/dist/shapes/screenQuad.js
var defaultVertexShader2 = (
  /* glsl */
  `
varying vec2 vUv;

void main(){
    vec3 p=position;
    gl_Position=vec4(p,1.);
    
    vUv=uv;
}
`
);
var defaultFragmentShader2 = (
  /* glsl */
  `
uniform float iTime;
uniform vec3 iResolution;
uniform vec4 iMouse;

varying vec2 vUv;

void main(){
    vec2 p=vUv;
    vec3 color=vec3(p,0.);
    gl_FragColor=vec4(color,1.);
}
`
);
var shadertoyPrepend = (
  /* glsl */
  `
uniform float iGlobalTime;
uniform float iTime;
uniform float iTimeDelta;
uniform vec3 iResolution;
uniform vec4 iMouse;
uniform int iFrame;
uniform vec4 iDate;
uniform float iSampleRate;

uniform sampler2D iChannel0;
uniform sampler2D iChannel1;
uniform sampler2D iChannel2;
uniform sampler2D iChannel3;
uniform samplerCube iChannel0Cube;
uniform samplerCube iChannel1Cube;
uniform samplerCube iChannel2Cube;
uniform samplerCube iChannel3Cube;

uniform float iChannelTime[4];
`
);
var shadertoyAppend = (
  /* glsl */
  `
varying vec2 vUv;

void main(){
    mainImage(gl_FragColor,vUv*iResolution.xy);
}
`
);
var ScreenQuad = class extends Component {
  constructor(base, config3 = {}) {
    super(base);
    __publicField(this, "material");
    __publicField(this, "mesh");
    __publicField(this, "uniformInjector");
    const { vertexShader = defaultVertexShader2, fragmentShader = defaultFragmentShader2, uniforms = {}, shadertoyMode = false } = config3;
    const finalFragmentShader = shadertoyMode ? `
    ${shadertoyPrepend}

    ${fragmentShader}

    ${shadertoyAppend}
    ` : fragmentShader;
    const uniformInjector = new UniformInjector(base);
    this.uniformInjector = uniformInjector;
    const geometry2 = new PlaneGeometry(2, 2);
    const material2 = new ShaderMaterial({
      vertexShader,
      fragmentShader: finalFragmentShader,
      uniforms: {
        ...uniformInjector.shadertoyUniforms,
        ...uniforms
      },
      side: DoubleSide
    });
    this.material = material2;
    const mesh = new Mesh(geometry2, material2);
    this.mesh = mesh;
  }
  addExisting() {
    this.container.add(this.mesh);
  }
  update(time) {
    const uniforms = this.material.uniforms;
    this.uniformInjector.injectShadertoyUniforms(uniforms);
  }
};

// node_modules/kokomi.js/dist/shapes/cubemapQuad.js
var cubemapShaderUniforms = (
  /* glsl */
  `
uniform vec2 unViewport;
uniform vec3 unCorners[5];
`
);
var cubemapShaderMain = (
  /* glsl */
  `
void main()
{
    vec4 color=vec4(0.,0.,0.,1.);
    vec3 ro=vec3(0.);
    vec2 uv=gl_FragCoord.xy/unViewport.xy;
    vec3 rd=normalize(mix(mix(unCorners[0],unCorners[1],uv.x),mix(unCorners[3],unCorners[2],uv.x),uv.y)-ro);
    mainCubemap(color,gl_FragCoord.xy,ro,rd);
    gl_FragColor=color;
}
`
);
var CubemapQuad = class extends ScreenQuad {
  constructor(base, config3 = {}) {
    super(base, {
      ...config3,
      fragmentShader: `
      ${cubemapShaderUniforms}

      ${config3.fragmentShader}

      ${cubemapShaderMain}
      `,
      uniforms: {
        unViewport: {
          value: new Vector2(window.innerHeight, window.innerHeight)
        },
        unCorners: {
          value: [1, 1, 1, 1, 1, -1, 1, -1, -1, 1, -1, 1, 0, 0, 0]
          // X
        }
      }
    });
  }
};

// node_modules/kokomi.js/dist/shapes/customMesh.js
var defaultVertexShader3 = (
  /* glsl */
  `
uniform float iTime;
uniform vec2 iResolution;
uniform vec2 iMouse;

varying vec2 vUv;

void main(){
    vec3 p=position;
    csm_Position=p;
    
    vUv=uv;
}
`
);
var defaultFragmentShader3 = (
  /* glsl */
  `
uniform float iTime;
uniform vec2 iResolution;
uniform vec2 iMouse;

varying vec2 vUv;

void main(){
    vec2 p=vUv;
    vec3 col=vec3(p,0.);
    
    csm_DiffuseColor=vec4(col,1.);
}

`
);
var CustomMesh = class extends Component {
  constructor(base, config3 = {}) {
    super(base);
    __publicField(this, "material");
    __publicField(this, "mesh");
    __publicField(this, "uniformInjector");
    const { geometry: geometry2 = new PlaneGeometry(1, 1, 16, 16), baseMaterial = new ShaderMaterial(), vertexShader = defaultVertexShader3, fragmentShader = defaultFragmentShader3, uniforms = {}, patchMap = {}, materialParams = {} } = config3;
    const uniformInjector = new UniformInjector(base);
    this.uniformInjector = uniformInjector;
    const material2 = new CustomShaderMaterial({
      baseMaterial,
      vertexShader,
      fragmentShader,
      uniforms: {
        ...uniformInjector.shadertoyUniforms,
        ...uniforms
      },
      patchMap,
      ...materialParams
    });
    this.material = material2;
    const mesh = new Mesh(geometry2, material2);
    this.mesh = mesh;
  }
  addExisting() {
    this.container.add(this.mesh);
  }
  update(time) {
    const uniforms = this.material.uniforms;
    this.uniformInjector.injectShadertoyUniforms(uniforms);
  }
};

// node_modules/kokomi.js/dist/shapes/customPoints.js
var defaultVertexShader4 = (
  /* glsl */
  `
uniform float iTime;
uniform vec2 iResolution;
uniform vec2 iMouse;

varying vec2 vUv;

uniform float uPointSize;

void main(){
    vec3 p=position;
    csm_Position=p;

    gl_PointSize=uPointSize;
    
    vUv=uv;
}
`
);
var defaultFragmentShader4 = (
  /* glsl */
  `
uniform float iTime;
uniform vec2 iResolution;
uniform vec2 iMouse;

varying vec2 vUv;

void main(){
    vec2 p=vUv;
    vec3 col=vec3(p,0.);
    
    csm_DiffuseColor=vec4(col,1.);
}

`
);
var CustomPoints = class extends Component {
  constructor(base, config3 = {}) {
    super(base);
    __publicField(this, "material");
    __publicField(this, "points");
    __publicField(this, "uniformInjector");
    const { geometry: geometry2 = new PlaneGeometry(1, 1, 16, 16), baseMaterial = new ShaderMaterial(), vertexShader = defaultVertexShader4, fragmentShader = defaultFragmentShader4, uniforms = {}, patchMap = {}, materialParams = {} } = config3;
    const uniformInjector = new UniformInjector(base);
    this.uniformInjector = uniformInjector;
    const material2 = new CustomShaderMaterial({
      baseMaterial,
      vertexShader,
      fragmentShader,
      uniforms: {
        ...uniformInjector.shadertoyUniforms,
        ...{
          uPointSize: {
            value: 10
          }
        },
        ...uniforms
      },
      patchMap,
      ...materialParams
    });
    this.material = material2;
    const points = new Points(geometry2, material2);
    this.points = points;
  }
  addExisting() {
    this.container.add(this.points);
  }
  update(time) {
    const uniforms = this.material.uniforms;
    this.uniformInjector.injectShadertoyUniforms(uniforms);
  }
};

// node_modules/kokomi.js/dist/shapes/rayMarchingQuad.js
var RayMarchingQuad = class extends Component {
  constructor(base, marcher) {
    super(base);
    __publicField(this, "screenQuad");
    __publicField(this, "marcher");
    this.screenQuad = null;
    this.marcher = marcher;
  }
  render() {
    if (this.screenQuad) {
      this.container.remove(this.screenQuad.mesh);
    }
    const screenQuad = new ScreenQuad(this.base, {
      fragmentShader: this.marcher.fragmentShader,
      shadertoyMode: true
    });
    screenQuad.addExisting();
    this.screenQuad = screenQuad;
  }
};

// node_modules/kokomi.js/dist/shapes/renderQuad.js
var RenderQuad = class extends CustomMesh {
  constructor(base, map2, config3 = {}) {
    super(base, {
      vertexShader: "",
      fragmentShader: "",
      baseMaterial: new MeshBasicMaterial(),
      geometry: config3.geometry || new PlaneGeometry(window.innerWidth, window.innerHeight),
      materialParams: {
        map: map2,
        transparent: true,
        ...config3.materialParams
      }
    });
  }
};

// node_modules/kokomi.js/dist/shapes/sparkles.js
var sparklesVertexShader = (
  /* glsl */
  `
uniform float iTime;
uniform vec2 iResolution;
uniform vec2 iMouse;

varying vec2 vUv;

uniform float uPixelRatio;

attribute float size;
attribute float speed;
attribute float opacity;
attribute vec3 noise;
attribute vec3 color;

varying vec3 vColor;
varying float vOpacity;

vec3 distort(vec3 p){
    float t=iTime;
    p.y+=sin(t*speed+p.x*noise.x*100.)*.2;
    p.z+=cos(t*speed+p.x*noise.y*100.)*.2;
    p.x+=cos(t*speed+p.x*noise.z*100.)*.2;
    return p;
}

void main(){
    vec3 p=position;
    
    p=distort(p);
    
    vec4 mvPosition=modelViewMatrix*vec4(p,1.);
    
    gl_Position=projectionMatrix*mvPosition;
    
    vUv=uv;
    
    gl_PointSize=size*uPixelRatio*25.;
    gl_PointSize*=(1./-mvPosition.z);
    
    vColor=color;
    vOpacity=opacity;
}
`
);
var sparklesFragmentShader = (
  /* glsl */
  `
uniform float iTime;
uniform vec2 iResolution;
uniform vec2 iMouse;

varying vec2 vUv;

varying vec3 vColor;
varying float vOpacity;

float spot(vec2 p,float r,float offset){
    float center=distance(p,vec2(.5));
    float strength=r/center-offset;
    return strength;
}

void main(){
    vec2 p=vUv;
    
    vec3 col=vColor;
    
    float alpha=spot(gl_PointCoord,.05,.1)*vOpacity;
    
    gl_FragColor=vec4(col,alpha);
}
`
);
var Sparkles = class extends Component {
  constructor(base, config3 = {}) {
    super(base);
    __publicField(this, "uj");
    __publicField(this, "sparkles");
    const { count = 100, speed = 1, opacity = 1, color = void 0, size: size2 = void 0, scale = 1, noise = 1, blending = NormalBlending } = config3;
    const geo = new BufferGeometry();
    const positions = Float32Array.from(Array.from({ length: count }, () => normalizeVector(scale).map(MathUtils.randFloatSpread)).flat());
    geo.setAttribute("position", new BufferAttribute(positions, 3));
    const sizes = usePropAsIsOrAsAttribute(count, size2, Math.random);
    const opacities = usePropAsIsOrAsAttribute(count, opacity);
    const speeds = usePropAsIsOrAsAttribute(count, speed);
    const noises = usePropAsIsOrAsAttribute(count * 3, noise);
    const colors = usePropAsIsOrAsAttribute(color === void 0 ? count * 3 : count, !isFloat32Array(color) ? new Color(color) : color, () => 1);
    geo.setAttribute("size", new BufferAttribute(sizes, 1));
    geo.setAttribute("opacity", new BufferAttribute(opacities, 1));
    geo.setAttribute("speed", new BufferAttribute(speeds, 1));
    geo.setAttribute("noise", new BufferAttribute(noises, 3));
    geo.setAttribute("color", new BufferAttribute(colors, 3));
    const uj = new UniformInjector(this.base);
    this.uj = uj;
    const sparklesMat = new ShaderMaterial({
      vertexShader: sparklesVertexShader,
      fragmentShader: sparklesFragmentShader,
      uniforms: {
        ...uj.shadertoyUniforms,
        ...{
          uPixelRatio: {
            value: Math.min(window.devicePixelRatio, 2)
          }
        }
      },
      transparent: true,
      blending,
      depthWrite: false
    });
    const sparkles = new Points(geo, sparklesMat);
    this.sparkles = sparkles;
    this.base.resizer.on("resize", () => {
      sparkles.material.uniforms.uPixelRatio.value = Math.min(window.devicePixelRatio, 2);
    });
  }
  addExisting() {
    this.container.add(this.sparkles);
  }
  update(time) {
    if (this.sparkles) {
      const mat = this.sparkles.material;
      this.uj.injectShadertoyUniforms(mat.uniforms);
    }
  }
};

// node_modules/kokomi.js/dist/shapes/text3D.js
var defaultFontUrl = "https://unpkg.com/three@0.77.0/examples/fonts/helvetiker_regular.typeface.json";
var loadFont = (url = defaultFontUrl) => {
  return new Promise((resolve) => {
    new FontLoader().load(url, (font) => {
      resolve(font);
    });
  });
};
var Text3D = class extends CustomMesh {
  constructor(base, text, font, textParams = {
    size: 0.5,
    height: 0.2,
    curveSegments: 12,
    bevelEnabled: true,
    bevelThickness: 0.03,
    bevelSize: 0.02,
    bevelOffset: 0,
    // @ts-ignore
    bevelSegments: 5
  }, config3 = {}) {
    super(base, {
      geometry: new TextGeometry(text, { ...textParams, font }),
      ...config3
    });
  }
};

// node_modules/troika-worker-utils/dist/troika-worker-utils.esm.js
function workerBootstrap() {
  var modules = /* @__PURE__ */ Object.create(null);
  function registerModule(ref, callback) {
    var id = ref.id;
    var name = ref.name;
    var dependencies = ref.dependencies;
    if (dependencies === void 0)
      dependencies = [];
    var init5 = ref.init;
    if (init5 === void 0)
      init5 = function() {
      };
    var getTransferables = ref.getTransferables;
    if (getTransferables === void 0)
      getTransferables = null;
    if (modules[id]) {
      return;
    }
    try {
      dependencies = dependencies.map(function(dep) {
        if (dep && dep.isWorkerModule) {
          registerModule(dep, function(depResult) {
            if (depResult instanceof Error) {
              throw depResult;
            }
          });
          dep = modules[dep.id].value;
        }
        return dep;
      });
      init5 = rehydrate("<" + name + ">.init", init5);
      if (getTransferables) {
        getTransferables = rehydrate("<" + name + ">.getTransferables", getTransferables);
      }
      var value = null;
      if (typeof init5 === "function") {
        value = init5.apply(void 0, dependencies);
      } else {
        console.error("worker module init function failed to rehydrate");
      }
      modules[id] = {
        id,
        value,
        getTransferables
      };
      callback(value);
    } catch (err) {
      if (!(err && err.noLog)) {
        console.error(err);
      }
      callback(err);
    }
  }
  function callModule(ref, callback) {
    var ref$1;
    var id = ref.id;
    var args = ref.args;
    if (!modules[id] || typeof modules[id].value !== "function") {
      callback(new Error("Worker module " + id + ": not found or its 'init' did not return a function"));
    }
    try {
      var result = (ref$1 = modules[id]).value.apply(ref$1, args);
      if (result && typeof result.then === "function") {
        result.then(handleResult, function(rej) {
          return callback(rej instanceof Error ? rej : new Error("" + rej));
        });
      } else {
        handleResult(result);
      }
    } catch (err) {
      callback(err);
    }
    function handleResult(result2) {
      try {
        var tx = modules[id].getTransferables && modules[id].getTransferables(result2);
        if (!tx || !Array.isArray(tx) || !tx.length) {
          tx = void 0;
        }
        callback(result2, tx);
      } catch (err) {
        console.error(err);
        callback(err);
      }
    }
  }
  function rehydrate(name, str) {
    var result = void 0;
    self.troikaDefine = function(r) {
      return result = r;
    };
    var url = URL.createObjectURL(
      new Blob(
        ["/** " + name.replace(/\*/g, "") + " **/\n\ntroikaDefine(\n" + str + "\n)"],
        { type: "application/javascript" }
      )
    );
    try {
      importScripts(url);
    } catch (err) {
      console.error(err);
    }
    URL.revokeObjectURL(url);
    delete self.troikaDefine;
    return result;
  }
  self.addEventListener("message", function(e) {
    var ref = e.data;
    var messageId = ref.messageId;
    var action = ref.action;
    var data = ref.data;
    try {
      if (action === "registerModule") {
        registerModule(data, function(result) {
          if (result instanceof Error) {
            postMessage({
              messageId,
              success: false,
              error: result.message
            });
          } else {
            postMessage({
              messageId,
              success: true,
              result: { isCallable: typeof result === "function" }
            });
          }
        });
      }
      if (action === "callModule") {
        callModule(data, function(result, transferables) {
          if (result instanceof Error) {
            postMessage({
              messageId,
              success: false,
              error: result.message
            });
          } else {
            postMessage({
              messageId,
              success: true,
              result
            }, transferables || void 0);
          }
        });
      }
    } catch (err) {
      postMessage({
        messageId,
        success: false,
        error: err.stack
      });
    }
  });
}
function defineMainThreadModule(options) {
  var moduleFunc = function() {
    var args = [], len = arguments.length;
    while (len--)
      args[len] = arguments[len];
    return moduleFunc._getInitResult().then(function(initResult) {
      if (typeof initResult === "function") {
        return initResult.apply(void 0, args);
      } else {
        throw new Error("Worker module function was called but `init` did not return a callable function");
      }
    });
  };
  moduleFunc._getInitResult = function() {
    var dependencies = options.dependencies;
    var init5 = options.init;
    dependencies = Array.isArray(dependencies) ? dependencies.map(
      function(dep) {
        return dep && dep._getInitResult ? dep._getInitResult() : dep;
      }
    ) : [];
    var initPromise = Promise.all(dependencies).then(function(deps) {
      return init5.apply(null, deps);
    });
    moduleFunc._getInitResult = function() {
      return initPromise;
    };
    return initPromise;
  };
  return moduleFunc;
}
var supportsWorkers = function() {
  var supported = false;
  if (typeof window !== "undefined" && typeof window.document !== "undefined") {
    try {
      var worker = new Worker(
        URL.createObjectURL(new Blob([""], { type: "application/javascript" }))
      );
      worker.terminate();
      supported = true;
    } catch (err) {
      if (typeof process !== "undefined" && false)
        ;
      else {
        console.log(
          "Troika createWorkerModule: web workers not allowed; falling back to main thread execution. Cause: [" + err.message + "]"
        );
      }
    }
  }
  supportsWorkers = function() {
    return supported;
  };
  return supported;
};
var _workerModuleId = 0;
var _messageId = 0;
var _allowInitAsString = false;
var workers = /* @__PURE__ */ Object.create(null);
var registeredModules = /* @__PURE__ */ Object.create(null);
var openRequests = /* @__PURE__ */ Object.create(null);
function defineWorkerModule(options) {
  if ((!options || typeof options.init !== "function") && !_allowInitAsString) {
    throw new Error("requires `options.init` function");
  }
  var dependencies = options.dependencies;
  var init5 = options.init;
  var getTransferables = options.getTransferables;
  var workerId = options.workerId;
  if (!supportsWorkers()) {
    return defineMainThreadModule(options);
  }
  if (workerId == null) {
    workerId = "#default";
  }
  var id = "workerModule" + ++_workerModuleId;
  var name = options.name || id;
  var registrationPromise = null;
  dependencies = dependencies && dependencies.map(function(dep) {
    if (typeof dep === "function" && !dep.workerModuleData) {
      _allowInitAsString = true;
      dep = defineWorkerModule({
        workerId,
        name: "<" + name + "> function dependency: " + dep.name,
        init: "function(){return (\n" + stringifyFunction(dep) + "\n)}"
      });
      _allowInitAsString = false;
    }
    if (dep && dep.workerModuleData) {
      dep = dep.workerModuleData;
    }
    return dep;
  });
  function moduleFunc() {
    var args = [], len = arguments.length;
    while (len--)
      args[len] = arguments[len];
    if (!registrationPromise) {
      registrationPromise = callWorker(workerId, "registerModule", moduleFunc.workerModuleData);
      var unregister = function() {
        registrationPromise = null;
        registeredModules[workerId].delete(unregister);
      };
      (registeredModules[workerId] || (registeredModules[workerId] = /* @__PURE__ */ new Set())).add(unregister);
    }
    return registrationPromise.then(function(ref) {
      var isCallable = ref.isCallable;
      if (isCallable) {
        return callWorker(workerId, "callModule", { id, args });
      } else {
        throw new Error("Worker module function was called but `init` did not return a callable function");
      }
    });
  }
  moduleFunc.workerModuleData = {
    isWorkerModule: true,
    id,
    name,
    dependencies,
    init: stringifyFunction(init5),
    getTransferables: getTransferables && stringifyFunction(getTransferables)
  };
  return moduleFunc;
}
function terminateWorker(workerId) {
  if (registeredModules[workerId]) {
    registeredModules[workerId].forEach(function(unregister) {
      unregister();
    });
  }
  if (workers[workerId]) {
    workers[workerId].terminate();
    delete workers[workerId];
  }
}
function stringifyFunction(fn) {
  var str = fn.toString();
  if (!/^function/.test(str) && /^\w+\s*\(/.test(str)) {
    str = "function " + str;
  }
  return str;
}
function getWorker(workerId) {
  var worker = workers[workerId];
  if (!worker) {
    var bootstrap = stringifyFunction(workerBootstrap);
    worker = workers[workerId] = new Worker(
      URL.createObjectURL(
        new Blob(
          ["/** Worker Module Bootstrap: " + workerId.replace(/\*/g, "") + " **/\n\n;(" + bootstrap + ")()"],
          { type: "application/javascript" }
        )
      )
    );
    worker.onmessage = function(e) {
      var response = e.data;
      var msgId = response.messageId;
      var callback = openRequests[msgId];
      if (!callback) {
        throw new Error("WorkerModule response with empty or unknown messageId");
      }
      delete openRequests[msgId];
      callback(response);
    };
  }
  return worker;
}
function callWorker(workerId, action, data) {
  return new Promise(function(resolve, reject) {
    var messageId = ++_messageId;
    openRequests[messageId] = function(response) {
      if (response.success) {
        resolve(response.result);
      } else {
        reject(new Error("Error in worker " + action + " call: " + response.error));
      }
    };
    getWorker(workerId).postMessage({
      messageId,
      action,
      data
    });
  });
}

// node_modules/webgl-sdf-generator/dist/webgl-sdf-generator.mjs
function SDFGenerator() {
  var exports2 = function(exports3) {
    function pointOnQuadraticBezier(x0, y0, x1, y1, x2, y2, t2, pointOut) {
      var t22 = 1 - t2;
      pointOut.x = t22 * t22 * x0 + 2 * t22 * t2 * x1 + t2 * t2 * x2;
      pointOut.y = t22 * t22 * y0 + 2 * t22 * t2 * y1 + t2 * t2 * y2;
    }
    function pointOnCubicBezier(x0, y0, x1, y1, x2, y2, x3, y3, t2, pointOut) {
      var t22 = 1 - t2;
      pointOut.x = t22 * t22 * t22 * x0 + 3 * t22 * t22 * t2 * x1 + 3 * t22 * t2 * t2 * x2 + t2 * t2 * t2 * x3;
      pointOut.y = t22 * t22 * t22 * y0 + 3 * t22 * t22 * t2 * y1 + 3 * t22 * t2 * t2 * y2 + t2 * t2 * t2 * y3;
    }
    function forEachPathCommand(pathString, commandCallback) {
      var segmentRE = /([MLQCZ])([^MLQCZ]*)/g;
      var match, firstX, firstY, prevX, prevY;
      while (match = segmentRE.exec(pathString)) {
        var args = match[2].replace(/^\s*|\s*$/g, "").split(/[,\s]+/).map(function(v) {
          return parseFloat(v);
        });
        switch (match[1]) {
          case "M":
            prevX = firstX = args[0];
            prevY = firstY = args[1];
            break;
          case "L":
            if (args[0] !== prevX || args[1] !== prevY) {
              commandCallback("L", prevX, prevY, prevX = args[0], prevY = args[1]);
            }
            break;
          case "Q": {
            commandCallback("Q", prevX, prevY, prevX = args[2], prevY = args[3], args[0], args[1]);
            break;
          }
          case "C": {
            commandCallback("C", prevX, prevY, prevX = args[4], prevY = args[5], args[0], args[1], args[2], args[3]);
            break;
          }
          case "Z":
            if (prevX !== firstX || prevY !== firstY) {
              commandCallback("L", prevX, prevY, firstX, firstY);
            }
            break;
        }
      }
    }
    function pathToLineSegments(pathString, segmentCallback, curvePoints) {
      if (curvePoints === void 0)
        curvePoints = 16;
      var tempPoint = { x: 0, y: 0 };
      forEachPathCommand(pathString, function(command, startX, startY, endX, endY, ctrl1X, ctrl1Y, ctrl2X, ctrl2Y) {
        switch (command) {
          case "L":
            segmentCallback(startX, startY, endX, endY);
            break;
          case "Q": {
            var prevCurveX = startX;
            var prevCurveY = startY;
            for (var i3 = 1; i3 < curvePoints; i3++) {
              pointOnQuadraticBezier(
                startX,
                startY,
                ctrl1X,
                ctrl1Y,
                endX,
                endY,
                i3 / (curvePoints - 1),
                tempPoint
              );
              segmentCallback(prevCurveX, prevCurveY, tempPoint.x, tempPoint.y);
              prevCurveX = tempPoint.x;
              prevCurveY = tempPoint.y;
            }
            break;
          }
          case "C": {
            var prevCurveX$1 = startX;
            var prevCurveY$1 = startY;
            for (var i$1 = 1; i$1 < curvePoints; i$1++) {
              pointOnCubicBezier(
                startX,
                startY,
                ctrl1X,
                ctrl1Y,
                ctrl2X,
                ctrl2Y,
                endX,
                endY,
                i$1 / (curvePoints - 1),
                tempPoint
              );
              segmentCallback(prevCurveX$1, prevCurveY$1, tempPoint.x, tempPoint.y);
              prevCurveX$1 = tempPoint.x;
              prevCurveY$1 = tempPoint.y;
            }
            break;
          }
        }
      });
    }
    var viewportQuadVertex = "precision highp float;attribute vec2 aUV;varying vec2 vUV;void main(){vUV=aUV;gl_Position=vec4(mix(vec2(-1.0),vec2(1.0),aUV),0.0,1.0);}";
    var copyTexFragment = "precision highp float;uniform sampler2D tex;varying vec2 vUV;void main(){gl_FragColor=texture2D(tex,vUV);}";
    var cache = /* @__PURE__ */ new WeakMap();
    var glContextParams = {
      premultipliedAlpha: false,
      preserveDrawingBuffer: true,
      antialias: false,
      depth: false
    };
    function withWebGLContext(glOrCanvas, callback) {
      var gl = glOrCanvas.getContext ? glOrCanvas.getContext("webgl", glContextParams) : glOrCanvas;
      var wrapper = cache.get(gl);
      if (!wrapper) {
        let getExtension = function(name) {
          var ext = extensions[name];
          if (!ext) {
            ext = extensions[name] = gl.getExtension(name);
            if (!ext) {
              throw new Error(name + " not supported");
            }
          }
          return ext;
        }, compileShader = function(src, type) {
          var shader = gl.createShader(type);
          gl.shaderSource(shader, src);
          gl.compileShader(shader);
          return shader;
        }, withProgram = function(name, vert, frag, func) {
          if (!programs[name]) {
            var attributes = {};
            var uniforms = {};
            var program = gl.createProgram();
            gl.attachShader(program, compileShader(vert, gl.VERTEX_SHADER));
            gl.attachShader(program, compileShader(frag, gl.FRAGMENT_SHADER));
            gl.linkProgram(program);
            programs[name] = {
              program,
              transaction: function transaction(func2) {
                gl.useProgram(program);
                func2({
                  setUniform: function setUniform(type, name2) {
                    var values = [], len = arguments.length - 2;
                    while (len-- > 0)
                      values[len] = arguments[len + 2];
                    var uniformLoc = uniforms[name2] || (uniforms[name2] = gl.getUniformLocation(program, name2));
                    gl["uniform" + type].apply(gl, [uniformLoc].concat(values));
                  },
                  setAttribute: function setAttribute(name2, size2, usage, instancingDivisor, data) {
                    var attr = attributes[name2];
                    if (!attr) {
                      attr = attributes[name2] = {
                        buf: gl.createBuffer(),
                        // TODO should we destroy our buffers?
                        loc: gl.getAttribLocation(program, name2),
                        data: null
                      };
                    }
                    gl.bindBuffer(gl.ARRAY_BUFFER, attr.buf);
                    gl.vertexAttribPointer(attr.loc, size2, gl.FLOAT, false, 0, 0);
                    gl.enableVertexAttribArray(attr.loc);
                    if (isWebGL2) {
                      gl.vertexAttribDivisor(attr.loc, instancingDivisor);
                    } else {
                      getExtension("ANGLE_instanced_arrays").vertexAttribDivisorANGLE(attr.loc, instancingDivisor);
                    }
                    if (data !== attr.data) {
                      gl.bufferData(gl.ARRAY_BUFFER, data, usage);
                      attr.data = data;
                    }
                  }
                });
              }
            };
          }
          programs[name].transaction(func);
        }, withTexture = function(name, func) {
          textureUnit++;
          try {
            gl.activeTexture(gl.TEXTURE0 + textureUnit);
            var texture = textures[name];
            if (!texture) {
              texture = textures[name] = gl.createTexture();
              gl.bindTexture(gl.TEXTURE_2D, texture);
              gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
              gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
            }
            gl.bindTexture(gl.TEXTURE_2D, texture);
            func(texture, textureUnit);
          } finally {
            textureUnit--;
          }
        }, withTextureFramebuffer = function(texture, textureUnit2, func) {
          var framebuffer = gl.createFramebuffer();
          framebufferStack.push(framebuffer);
          gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
          gl.activeTexture(gl.TEXTURE0 + textureUnit2);
          gl.bindTexture(gl.TEXTURE_2D, texture);
          gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
          try {
            func(framebuffer);
          } finally {
            gl.deleteFramebuffer(framebuffer);
            gl.bindFramebuffer(gl.FRAMEBUFFER, framebufferStack[--framebufferStack.length - 1] || null);
          }
        }, handleContextLoss = function() {
          extensions = {};
          programs = {};
          textures = {};
          textureUnit = -1;
          framebufferStack.length = 0;
        };
        var isWebGL2 = typeof WebGL2RenderingContext !== "undefined" && gl instanceof WebGL2RenderingContext;
        var extensions = {};
        var programs = {};
        var textures = {};
        var textureUnit = -1;
        var framebufferStack = [];
        gl.canvas.addEventListener("webglcontextlost", function(e) {
          handleContextLoss();
          e.preventDefault();
        }, false);
        cache.set(gl, wrapper = {
          gl,
          isWebGL2,
          getExtension,
          withProgram,
          withTexture,
          withTextureFramebuffer,
          handleContextLoss
        });
      }
      callback(wrapper);
    }
    function renderImageData(glOrCanvas, imageData, x, y, width, height, channels, framebuffer) {
      if (channels === void 0)
        channels = 15;
      if (framebuffer === void 0)
        framebuffer = null;
      withWebGLContext(glOrCanvas, function(ref) {
        var gl = ref.gl;
        var withProgram = ref.withProgram;
        var withTexture = ref.withTexture;
        withTexture("copy", function(tex, texUnit) {
          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, imageData);
          withProgram("copy", viewportQuadVertex, copyTexFragment, function(ref2) {
            var setUniform = ref2.setUniform;
            var setAttribute = ref2.setAttribute;
            setAttribute("aUV", 2, gl.STATIC_DRAW, 0, new Float32Array([0, 0, 2, 0, 0, 2]));
            setUniform("1i", "image", texUnit);
            gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer || null);
            gl.disable(gl.BLEND);
            gl.colorMask(channels & 8, channels & 4, channels & 2, channels & 1);
            gl.viewport(x, y, width, height);
            gl.scissor(x, y, width, height);
            gl.drawArrays(gl.TRIANGLES, 0, 3);
          });
        });
      });
    }
    function resizeWebGLCanvasWithoutClearing2(canvas, newWidth, newHeight) {
      var width = canvas.width;
      var height = canvas.height;
      withWebGLContext(canvas, function(ref) {
        var gl = ref.gl;
        var data = new Uint8Array(width * height * 4);
        gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, data);
        canvas.width = newWidth;
        canvas.height = newHeight;
        renderImageData(gl, data, 0, 0, width, height);
      });
    }
    var webglUtils = Object.freeze({
      __proto__: null,
      withWebGLContext,
      renderImageData,
      resizeWebGLCanvasWithoutClearing: resizeWebGLCanvasWithoutClearing2
    });
    function generate$2(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent) {
      if (sdfExponent === void 0)
        sdfExponent = 1;
      var textureData = new Uint8Array(sdfWidth * sdfHeight);
      var viewBoxWidth = viewBox[2] - viewBox[0];
      var viewBoxHeight = viewBox[3] - viewBox[1];
      var segments = [];
      pathToLineSegments(path, function(x1, y1, x2, y2) {
        segments.push({
          x1,
          y1,
          x2,
          y2,
          minX: Math.min(x1, x2),
          minY: Math.min(y1, y2),
          maxX: Math.max(x1, x2),
          maxY: Math.max(y1, y2)
        });
      });
      segments.sort(function(a4, b5) {
        return a4.maxX - b5.maxX;
      });
      for (var sdfX = 0; sdfX < sdfWidth; sdfX++) {
        for (var sdfY = 0; sdfY < sdfHeight; sdfY++) {
          var signedDist = findNearestSignedDistance(
            viewBox[0] + viewBoxWidth * (sdfX + 0.5) / sdfWidth,
            viewBox[1] + viewBoxHeight * (sdfY + 0.5) / sdfHeight
          );
          var alpha = Math.pow(1 - Math.abs(signedDist) / maxDistance, sdfExponent) / 2;
          if (signedDist < 0) {
            alpha = 1 - alpha;
          }
          alpha = Math.max(0, Math.min(255, Math.round(alpha * 255)));
          textureData[sdfY * sdfWidth + sdfX] = alpha;
        }
      }
      return textureData;
      function findNearestSignedDistance(x, y) {
        var closestDistSq = Infinity;
        var closestDist = Infinity;
        for (var i3 = segments.length; i3--; ) {
          var seg = segments[i3];
          if (seg.maxX + closestDist <= x) {
            break;
          }
          if (x + closestDist > seg.minX && y - closestDist < seg.maxY && y + closestDist > seg.minY) {
            var distSq = absSquareDistanceToLineSegment(x, y, seg.x1, seg.y1, seg.x2, seg.y2);
            if (distSq < closestDistSq) {
              closestDistSq = distSq;
              closestDist = Math.sqrt(closestDistSq);
            }
          }
        }
        if (isPointInPoly(x, y)) {
          closestDist = -closestDist;
        }
        return closestDist;
      }
      function isPointInPoly(x, y) {
        var winding = 0;
        for (var i3 = segments.length; i3--; ) {
          var seg = segments[i3];
          if (seg.maxX <= x) {
            break;
          }
          var intersects = seg.y1 > y !== seg.y2 > y && x < (seg.x2 - seg.x1) * (y - seg.y1) / (seg.y2 - seg.y1) + seg.x1;
          if (intersects) {
            winding += seg.y1 < seg.y2 ? 1 : -1;
          }
        }
        return winding !== 0;
      }
    }
    function generateIntoCanvas$2(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, canvas, x, y, channel) {
      if (sdfExponent === void 0)
        sdfExponent = 1;
      if (x === void 0)
        x = 0;
      if (y === void 0)
        y = 0;
      if (channel === void 0)
        channel = 0;
      generateIntoFramebuffer$1(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, canvas, null, x, y, channel);
    }
    function generateIntoFramebuffer$1(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, glOrCanvas, framebuffer, x, y, channel) {
      if (sdfExponent === void 0)
        sdfExponent = 1;
      if (x === void 0)
        x = 0;
      if (y === void 0)
        y = 0;
      if (channel === void 0)
        channel = 0;
      var data = generate$2(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent);
      var rgbaData = new Uint8Array(data.length * 4);
      for (var i3 = 0; i3 < data.length; i3++) {
        rgbaData[i3 * 4 + channel] = data[i3];
      }
      renderImageData(glOrCanvas, rgbaData, x, y, sdfWidth, sdfHeight, 1 << 3 - channel, framebuffer);
    }
    function absSquareDistanceToLineSegment(x, y, lineX0, lineY0, lineX1, lineY1) {
      var ldx = lineX1 - lineX0;
      var ldy = lineY1 - lineY0;
      var lengthSq = ldx * ldx + ldy * ldy;
      var t2 = lengthSq ? Math.max(0, Math.min(1, ((x - lineX0) * ldx + (y - lineY0) * ldy) / lengthSq)) : 0;
      var dx = x - (lineX0 + t2 * ldx);
      var dy = y - (lineY0 + t2 * ldy);
      return dx * dx + dy * dy;
    }
    var javascript = Object.freeze({
      __proto__: null,
      generate: generate$2,
      generateIntoCanvas: generateIntoCanvas$2,
      generateIntoFramebuffer: generateIntoFramebuffer$1
    });
    var mainVertex = "precision highp float;uniform vec4 uGlyphBounds;attribute vec2 aUV;attribute vec4 aLineSegment;varying vec4 vLineSegment;varying vec2 vGlyphXY;void main(){vLineSegment=aLineSegment;vGlyphXY=mix(uGlyphBounds.xy,uGlyphBounds.zw,aUV);gl_Position=vec4(mix(vec2(-1.0),vec2(1.0),aUV),0.0,1.0);}";
    var mainFragment = "precision highp float;uniform vec4 uGlyphBounds;uniform float uMaxDistance;uniform float uExponent;varying vec4 vLineSegment;varying vec2 vGlyphXY;float absDistToSegment(vec2 point,vec2 lineA,vec2 lineB){vec2 lineDir=lineB-lineA;float lenSq=dot(lineDir,lineDir);float t=lenSq==0.0 ? 0.0 : clamp(dot(point-lineA,lineDir)/lenSq,0.0,1.0);vec2 linePt=lineA+t*lineDir;return distance(point,linePt);}void main(){vec4 seg=vLineSegment;vec2 p=vGlyphXY;float dist=absDistToSegment(p,seg.xy,seg.zw);float val=pow(1.0-clamp(dist/uMaxDistance,0.0,1.0),uExponent)*0.5;bool crossing=(seg.y>p.y!=seg.w>p.y)&&(p.x<(seg.z-seg.x)*(p.y-seg.y)/(seg.w-seg.y)+seg.x);bool crossingUp=crossing&&vLineSegment.y<vLineSegment.w;gl_FragColor=vec4(crossingUp ? 1.0/255.0 : 0.0,crossing&&!crossingUp ? 1.0/255.0 : 0.0,0.0,val);}";
    var postFragment = "precision highp float;uniform sampler2D tex;varying vec2 vUV;void main(){vec4 color=texture2D(tex,vUV);bool inside=color.r!=color.g;float val=inside ? 1.0-color.a : color.a;gl_FragColor=vec4(val);}";
    var viewportUVs = new Float32Array([0, 0, 2, 0, 0, 2]);
    var implicitContext = null;
    var isTestingSupport = false;
    var NULL_OBJECT = {};
    var supportByCanvas = /* @__PURE__ */ new WeakMap();
    function validateSupport(glOrCanvas) {
      if (!isTestingSupport && !isSupported(glOrCanvas)) {
        throw new Error("WebGL generation not supported");
      }
    }
    function generate$1(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, glOrCanvas) {
      if (sdfExponent === void 0)
        sdfExponent = 1;
      if (glOrCanvas === void 0)
        glOrCanvas = null;
      if (!glOrCanvas) {
        glOrCanvas = implicitContext;
        if (!glOrCanvas) {
          var canvas = typeof OffscreenCanvas === "function" ? new OffscreenCanvas(1, 1) : typeof document !== "undefined" ? document.createElement("canvas") : null;
          if (!canvas) {
            throw new Error("OffscreenCanvas or DOM canvas not supported");
          }
          glOrCanvas = implicitContext = canvas.getContext("webgl", { depth: false });
        }
      }
      validateSupport(glOrCanvas);
      var rgbaData = new Uint8Array(sdfWidth * sdfHeight * 4);
      withWebGLContext(glOrCanvas, function(ref) {
        var gl = ref.gl;
        var withTexture = ref.withTexture;
        var withTextureFramebuffer = ref.withTextureFramebuffer;
        withTexture("readable", function(texture, textureUnit) {
          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, sdfWidth, sdfHeight, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
          withTextureFramebuffer(texture, textureUnit, function(framebuffer) {
            generateIntoFramebuffer(
              sdfWidth,
              sdfHeight,
              path,
              viewBox,
              maxDistance,
              sdfExponent,
              gl,
              framebuffer,
              0,
              0,
              0
              // red channel
            );
            gl.readPixels(0, 0, sdfWidth, sdfHeight, gl.RGBA, gl.UNSIGNED_BYTE, rgbaData);
          });
        });
      });
      var data = new Uint8Array(sdfWidth * sdfHeight);
      for (var i3 = 0, j = 0; i3 < rgbaData.length; i3 += 4) {
        data[j++] = rgbaData[i3];
      }
      return data;
    }
    function generateIntoCanvas$1(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, canvas, x, y, channel) {
      if (sdfExponent === void 0)
        sdfExponent = 1;
      if (x === void 0)
        x = 0;
      if (y === void 0)
        y = 0;
      if (channel === void 0)
        channel = 0;
      generateIntoFramebuffer(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, canvas, null, x, y, channel);
    }
    function generateIntoFramebuffer(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, glOrCanvas, framebuffer, x, y, channel) {
      if (sdfExponent === void 0)
        sdfExponent = 1;
      if (x === void 0)
        x = 0;
      if (y === void 0)
        y = 0;
      if (channel === void 0)
        channel = 0;
      validateSupport(glOrCanvas);
      var lineSegmentCoords = [];
      pathToLineSegments(path, function(x1, y1, x2, y2) {
        lineSegmentCoords.push(x1, y1, x2, y2);
      });
      lineSegmentCoords = new Float32Array(lineSegmentCoords);
      withWebGLContext(glOrCanvas, function(ref) {
        var gl = ref.gl;
        var isWebGL2 = ref.isWebGL2;
        var getExtension = ref.getExtension;
        var withProgram = ref.withProgram;
        var withTexture = ref.withTexture;
        var withTextureFramebuffer = ref.withTextureFramebuffer;
        var handleContextLoss = ref.handleContextLoss;
        withTexture("rawDistances", function(intermediateTexture, intermediateTextureUnit) {
          if (sdfWidth !== intermediateTexture._lastWidth || sdfHeight !== intermediateTexture._lastHeight) {
            gl.texImage2D(
              gl.TEXTURE_2D,
              0,
              gl.RGBA,
              intermediateTexture._lastWidth = sdfWidth,
              intermediateTexture._lastHeight = sdfHeight,
              0,
              gl.RGBA,
              gl.UNSIGNED_BYTE,
              null
            );
          }
          withProgram("main", mainVertex, mainFragment, function(ref2) {
            var setAttribute = ref2.setAttribute;
            var setUniform = ref2.setUniform;
            var instancingExtension = !isWebGL2 && getExtension("ANGLE_instanced_arrays");
            var blendMinMaxExtension = !isWebGL2 && getExtension("EXT_blend_minmax");
            setAttribute("aUV", 2, gl.STATIC_DRAW, 0, viewportUVs);
            setAttribute("aLineSegment", 4, gl.DYNAMIC_DRAW, 1, lineSegmentCoords);
            setUniform.apply(void 0, ["4f", "uGlyphBounds"].concat(viewBox));
            setUniform("1f", "uMaxDistance", maxDistance);
            setUniform("1f", "uExponent", sdfExponent);
            withTextureFramebuffer(intermediateTexture, intermediateTextureUnit, function(framebuffer2) {
              gl.enable(gl.BLEND);
              gl.colorMask(true, true, true, true);
              gl.viewport(0, 0, sdfWidth, sdfHeight);
              gl.scissor(0, 0, sdfWidth, sdfHeight);
              gl.blendFunc(gl.ONE, gl.ONE);
              gl.blendEquationSeparate(gl.FUNC_ADD, isWebGL2 ? gl.MAX : blendMinMaxExtension.MAX_EXT);
              gl.clear(gl.COLOR_BUFFER_BIT);
              if (isWebGL2) {
                gl.drawArraysInstanced(gl.TRIANGLES, 0, 3, lineSegmentCoords.length / 4);
              } else {
                instancingExtension.drawArraysInstancedANGLE(gl.TRIANGLES, 0, 3, lineSegmentCoords.length / 4);
              }
            });
          });
          withProgram("post", viewportQuadVertex, postFragment, function(program) {
            program.setAttribute("aUV", 2, gl.STATIC_DRAW, 0, viewportUVs);
            program.setUniform("1i", "tex", intermediateTextureUnit);
            gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
            gl.disable(gl.BLEND);
            gl.colorMask(channel === 0, channel === 1, channel === 2, channel === 3);
            gl.viewport(x, y, sdfWidth, sdfHeight);
            gl.scissor(x, y, sdfWidth, sdfHeight);
            gl.drawArrays(gl.TRIANGLES, 0, 3);
          });
        });
        if (gl.isContextLost()) {
          handleContextLoss();
          throw new Error("webgl context lost");
        }
      });
    }
    function isSupported(glOrCanvas) {
      var key = !glOrCanvas || glOrCanvas === implicitContext ? NULL_OBJECT : glOrCanvas.canvas || glOrCanvas;
      var supported = supportByCanvas.get(key);
      if (supported === void 0) {
        isTestingSupport = true;
        var failReason = null;
        try {
          var expectedResult = [
            97,
            106,
            97,
            61,
            99,
            137,
            118,
            80,
            80,
            118,
            137,
            99,
            61,
            97,
            106,
            97
          ];
          var testResult = generate$1(
            4,
            4,
            "M8,8L16,8L24,24L16,24Z",
            [0, 0, 32, 32],
            24,
            1,
            glOrCanvas
          );
          supported = testResult && expectedResult.length === testResult.length && testResult.every(function(val, i3) {
            return val === expectedResult[i3];
          });
          if (!supported) {
            failReason = "bad trial run results";
            console.info(expectedResult, testResult);
          }
        } catch (err) {
          supported = false;
          failReason = err.message;
        }
        if (failReason) {
          console.warn("WebGL SDF generation not supported:", failReason);
        }
        isTestingSupport = false;
        supportByCanvas.set(key, supported);
      }
      return supported;
    }
    var webgl = Object.freeze({
      __proto__: null,
      generate: generate$1,
      generateIntoCanvas: generateIntoCanvas$1,
      generateIntoFramebuffer,
      isSupported
    });
    function generate(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent) {
      if (maxDistance === void 0)
        maxDistance = Math.max(viewBox[2] - viewBox[0], viewBox[3] - viewBox[1]) / 2;
      if (sdfExponent === void 0)
        sdfExponent = 1;
      try {
        return generate$1.apply(webgl, arguments);
      } catch (e) {
        console.info("WebGL SDF generation failed, falling back to JS", e);
        return generate$2.apply(javascript, arguments);
      }
    }
    function generateIntoCanvas(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, canvas, x, y, channel) {
      if (maxDistance === void 0)
        maxDistance = Math.max(viewBox[2] - viewBox[0], viewBox[3] - viewBox[1]) / 2;
      if (sdfExponent === void 0)
        sdfExponent = 1;
      if (x === void 0)
        x = 0;
      if (y === void 0)
        y = 0;
      if (channel === void 0)
        channel = 0;
      try {
        return generateIntoCanvas$1.apply(webgl, arguments);
      } catch (e) {
        console.info("WebGL SDF generation failed, falling back to JS", e);
        return generateIntoCanvas$2.apply(javascript, arguments);
      }
    }
    exports3.forEachPathCommand = forEachPathCommand;
    exports3.generate = generate;
    exports3.generateIntoCanvas = generateIntoCanvas;
    exports3.javascript = javascript;
    exports3.pathToLineSegments = pathToLineSegments;
    exports3.webgl = webgl;
    exports3.webglUtils = webglUtils;
    Object.defineProperty(exports3, "__esModule", { value: true });
    return exports3;
  }({});
  return exports2;
}

// node_modules/bidi-js/dist/bidi.mjs
function bidiFactory() {
  var bidi = function(exports2) {
    var DATA = {
      "R": "13k,1a,2,3,3,2+1j,ch+16,a+1,5+2,2+n,5,a,4,6+16,4+3,h+1b,4mo,179q,2+9,2+11,2i9+7y,2+68,4,3+4,5+13,4+3,2+4k,3+29,8+cf,1t+7z,w+17,3+3m,1t+3z,16o1+5r,8+30,8+mc,29+1r,29+4v,75+73",
      "EN": "1c+9,3d+1,6,187+9,513,4+5,7+9,sf+j,175h+9,qw+q,161f+1d,4xt+a,25i+9",
      "ES": "17,2,6dp+1,f+1,av,16vr,mx+1,4o,2",
      "ET": "z+2,3h+3,b+1,ym,3e+1,2o,p4+1,8,6u,7c,g6,1wc,1n9+4,30+1b,2n,6d,qhx+1,h0m,a+1,49+2,63+1,4+1,6bb+3,12jj",
      "AN": "16o+5,2j+9,2+1,35,ed,1ff2+9,87+u",
      "CS": "18,2+1,b,2u,12k,55v,l,17v0,2,3,53,2+1,b",
      "B": "a,3,f+2,2v,690",
      "S": "9,2,k",
      "WS": "c,k,4f4,1vk+a,u,1j,335",
      "ON": "x+1,4+4,h+5,r+5,r+3,z,5+3,2+1,2+1,5,2+2,3+4,o,w,ci+1,8+d,3+d,6+8,2+g,39+1,9,6+1,2,33,b8,3+1,3c+1,7+1,5r,b,7h+3,sa+5,2,3i+6,jg+3,ur+9,2v,ij+1,9g+9,7+a,8m,4+1,49+x,14u,2+2,c+2,e+2,e+2,e+1,i+n,e+e,2+p,u+2,e+2,36+1,2+3,2+1,b,2+2,6+5,2,2,2,h+1,5+4,6+3,3+f,16+2,5+3l,3+81,1y+p,2+40,q+a,m+13,2r+ch,2+9e,75+hf,3+v,2+2w,6e+5,f+6,75+2a,1a+p,2+2g,d+5x,r+b,6+3,4+o,g,6+1,6+2,2k+1,4,2j,5h+z,1m+1,1e+f,t+2,1f+e,d+3,4o+3,2s+1,w,535+1r,h3l+1i,93+2,2s,b+1,3l+x,2v,4g+3,21+3,kz+1,g5v+1,5a,j+9,n+v,2,3,2+8,2+1,3+2,2,3,46+1,4+4,h+5,r+5,r+a,3h+2,4+6,b+4,78,1r+24,4+c,4,1hb,ey+6,103+j,16j+c,1ux+7,5+g,fsh,jdq+1t,4,57+2e,p1,1m,1m,1m,1m,4kt+1,7j+17,5+2r,d+e,3+e,2+e,2+10,m+4,w,1n+5,1q,4z+5,4b+rb,9+c,4+c,4+37,d+2g,8+b,l+b,5+1j,9+9,7+13,9+t,3+1,27+3c,2+29,2+3q,d+d,3+4,4+2,6+6,a+o,8+6,a+2,e+6,16+42,2+1i",
      "BN": "0+8,6+d,2s+5,2+p,e,4m9,1kt+2,2b+5,5+5,17q9+v,7k,6p+8,6+1,119d+3,440+7,96s+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+75,6p+2rz,1ben+1,1ekf+1,1ekf+1",
      "NSM": "lc+33,7o+6,7c+18,2,2+1,2+1,2,21+a,1d+k,h,2u+6,3+5,3+1,2+3,10,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,g+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+g,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,k1+w,2db+2,3y,2p+v,ff+3,30+1,n9x+3,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,r2,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+5,3+1,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2d+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,f0c+4,1o+6,t5,1s+3,2a,f5l+1,43t+2,i+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,gzhy+6n",
      "AL": "16w,3,2,e+1b,z+2,2+2s,g+1,8+1,b+m,2+t,s+2i,c+e,4h+f,1d+1e,1bwe+dp,3+3z,x+c,2+1,35+3y,2rm+z,5+7,b+5,dt+l,c+u,17nl+27,1t+27,4x+6n,3+d",
      "LRO": "6ct",
      "RLO": "6cu",
      "LRE": "6cq",
      "RLE": "6cr",
      "PDF": "6cs",
      "LRI": "6ee",
      "RLI": "6ef",
      "FSI": "6eg",
      "PDI": "6eh"
    };
    var TYPES = {};
    var TYPES_TO_NAMES = {};
    TYPES.L = 1;
    TYPES_TO_NAMES[1] = "L";
    Object.keys(DATA).forEach(function(type, i3) {
      TYPES[type] = 1 << i3 + 1;
      TYPES_TO_NAMES[TYPES[type]] = type;
    });
    Object.freeze(TYPES);
    var ISOLATE_INIT_TYPES = TYPES.LRI | TYPES.RLI | TYPES.FSI;
    var STRONG_TYPES = TYPES.L | TYPES.R | TYPES.AL;
    var NEUTRAL_ISOLATE_TYPES = TYPES.B | TYPES.S | TYPES.WS | TYPES.ON | TYPES.FSI | TYPES.LRI | TYPES.RLI | TYPES.PDI;
    var BN_LIKE_TYPES = TYPES.BN | TYPES.RLE | TYPES.LRE | TYPES.RLO | TYPES.LRO | TYPES.PDF;
    var TRAILING_TYPES = TYPES.S | TYPES.WS | TYPES.B | ISOLATE_INIT_TYPES | TYPES.PDI | BN_LIKE_TYPES;
    var map2 = null;
    function parseData() {
      if (!map2) {
        map2 = /* @__PURE__ */ new Map();
        var loop = function(type2) {
          if (DATA.hasOwnProperty(type2)) {
            var lastCode = 0;
            DATA[type2].split(",").forEach(function(range2) {
              var ref = range2.split("+");
              var skip2 = ref[0];
              var step = ref[1];
              skip2 = parseInt(skip2, 36);
              step = step ? parseInt(step, 36) : 0;
              map2.set(lastCode += skip2, TYPES[type2]);
              for (var i3 = 0; i3 < step; i3++) {
                map2.set(++lastCode, TYPES[type2]);
              }
            });
          }
        };
        for (var type in DATA)
          loop(type);
      }
    }
    function getBidiCharType(char) {
      parseData();
      return map2.get(char.codePointAt(0)) || TYPES.L;
    }
    function getBidiCharTypeName(char) {
      return TYPES_TO_NAMES[getBidiCharType(char)];
    }
    var data$1 = {
      "pairs": "14>1,1e>2,u>2,2wt>1,1>1,1ge>1,1wp>1,1j>1,f>1,hm>1,1>1,u>1,u6>1,1>1,+5,28>1,w>1,1>1,+3,b8>1,1>1,+3,1>3,-1>-1,3>1,1>1,+2,1s>1,1>1,x>1,th>1,1>1,+2,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,4q>1,1e>2,u>2,2>1,+1",
      "canonical": "6f1>-6dx,6dy>-6dx,6ec>-6ed,6ee>-6ed,6ww>2jj,-2ji>2jj,14r4>-1e7l,1e7m>-1e7l,1e7m>-1e5c,1e5d>-1e5b,1e5c>-14qx,14qy>-14qx,14vn>-1ecg,1ech>-1ecg,1edu>-1ecg,1eci>-1ecg,1eda>-1ecg,1eci>-1ecg,1eci>-168q,168r>-168q,168s>-14ye,14yf>-14ye"
    };
    function parseCharacterMap(encodedString, includeReverse) {
      var radix = 36;
      var lastCode = 0;
      var map3 = /* @__PURE__ */ new Map();
      var reverseMap = includeReverse && /* @__PURE__ */ new Map();
      var prevPair;
      encodedString.split(",").forEach(function visit(entry) {
        if (entry.indexOf("+") !== -1) {
          for (var i3 = +entry; i3--; ) {
            visit(prevPair);
          }
        } else {
          prevPair = entry;
          var ref = entry.split(">");
          var a4 = ref[0];
          var b5 = ref[1];
          a4 = String.fromCodePoint(lastCode += parseInt(a4, radix));
          b5 = String.fromCodePoint(lastCode += parseInt(b5, radix));
          map3.set(a4, b5);
          includeReverse && reverseMap.set(b5, a4);
        }
      });
      return { map: map3, reverseMap };
    }
    var openToClose, closeToOpen, canonical;
    function parse$1() {
      if (!openToClose) {
        var ref = parseCharacterMap(data$1.pairs, true);
        var map3 = ref.map;
        var reverseMap = ref.reverseMap;
        openToClose = map3;
        closeToOpen = reverseMap;
        canonical = parseCharacterMap(data$1.canonical, false).map;
      }
    }
    function openingToClosingBracket(char) {
      parse$1();
      return openToClose.get(char) || null;
    }
    function closingToOpeningBracket(char) {
      parse$1();
      return closeToOpen.get(char) || null;
    }
    function getCanonicalBracket(char) {
      parse$1();
      return canonical.get(char) || null;
    }
    var TYPE_L = TYPES.L;
    var TYPE_R = TYPES.R;
    var TYPE_EN = TYPES.EN;
    var TYPE_ES = TYPES.ES;
    var TYPE_ET = TYPES.ET;
    var TYPE_AN = TYPES.AN;
    var TYPE_CS = TYPES.CS;
    var TYPE_B = TYPES.B;
    var TYPE_S = TYPES.S;
    var TYPE_ON = TYPES.ON;
    var TYPE_BN = TYPES.BN;
    var TYPE_NSM = TYPES.NSM;
    var TYPE_AL = TYPES.AL;
    var TYPE_LRO = TYPES.LRO;
    var TYPE_RLO = TYPES.RLO;
    var TYPE_LRE = TYPES.LRE;
    var TYPE_RLE = TYPES.RLE;
    var TYPE_PDF = TYPES.PDF;
    var TYPE_LRI = TYPES.LRI;
    var TYPE_RLI = TYPES.RLI;
    var TYPE_FSI = TYPES.FSI;
    var TYPE_PDI = TYPES.PDI;
    function getEmbeddingLevels(string, baseDirection) {
      var MAX_DEPTH = 125;
      var charTypes = new Uint32Array(string.length);
      for (var i3 = 0; i3 < string.length; i3++) {
        charTypes[i3] = getBidiCharType(string[i3]);
      }
      var charTypeCounts = /* @__PURE__ */ new Map();
      function changeCharType(i4, type2) {
        var oldType = charTypes[i4];
        charTypes[i4] = type2;
        charTypeCounts.set(oldType, charTypeCounts.get(oldType) - 1);
        if (oldType & NEUTRAL_ISOLATE_TYPES) {
          charTypeCounts.set(NEUTRAL_ISOLATE_TYPES, charTypeCounts.get(NEUTRAL_ISOLATE_TYPES) - 1);
        }
        charTypeCounts.set(type2, (charTypeCounts.get(type2) || 0) + 1);
        if (type2 & NEUTRAL_ISOLATE_TYPES) {
          charTypeCounts.set(NEUTRAL_ISOLATE_TYPES, (charTypeCounts.get(NEUTRAL_ISOLATE_TYPES) || 0) + 1);
        }
      }
      var embedLevels = new Uint8Array(string.length);
      var isolationPairs = /* @__PURE__ */ new Map();
      var paragraphs = [];
      var paragraph = null;
      for (var i$1 = 0; i$1 < string.length; i$1++) {
        if (!paragraph) {
          paragraphs.push(paragraph = {
            start: i$1,
            end: string.length - 1,
            // 3.3.1 P2-P3: Determine the paragraph level
            level: baseDirection === "rtl" ? 1 : baseDirection === "ltr" ? 0 : determineAutoEmbedLevel(i$1, false)
          });
        }
        if (charTypes[i$1] & TYPE_B) {
          paragraph.end = i$1;
          paragraph = null;
        }
      }
      var FORMATTING_TYPES = TYPE_RLE | TYPE_LRE | TYPE_RLO | TYPE_LRO | ISOLATE_INIT_TYPES | TYPE_PDI | TYPE_PDF | TYPE_B;
      var nextEven = function(n) {
        return n + (n & 1 ? 1 : 2);
      };
      var nextOdd = function(n) {
        return n + (n & 1 ? 2 : 1);
      };
      for (var paraIdx = 0; paraIdx < paragraphs.length; paraIdx++) {
        paragraph = paragraphs[paraIdx];
        var statusStack = [{
          _level: paragraph.level,
          _override: 0,
          //0=neutral, 1=L, 2=R
          _isolate: 0
          //bool
        }];
        var stackTop = void 0;
        var overflowIsolateCount = 0;
        var overflowEmbeddingCount = 0;
        var validIsolateCount = 0;
        charTypeCounts.clear();
        for (var i$2 = paragraph.start; i$2 <= paragraph.end; i$2++) {
          var charType = charTypes[i$2];
          stackTop = statusStack[statusStack.length - 1];
          charTypeCounts.set(charType, (charTypeCounts.get(charType) || 0) + 1);
          if (charType & NEUTRAL_ISOLATE_TYPES) {
            charTypeCounts.set(NEUTRAL_ISOLATE_TYPES, (charTypeCounts.get(NEUTRAL_ISOLATE_TYPES) || 0) + 1);
          }
          if (charType & FORMATTING_TYPES) {
            if (charType & (TYPE_RLE | TYPE_LRE)) {
              embedLevels[i$2] = stackTop._level;
              var level = (charType === TYPE_RLE ? nextOdd : nextEven)(stackTop._level);
              if (level <= MAX_DEPTH && !overflowIsolateCount && !overflowEmbeddingCount) {
                statusStack.push({
                  _level: level,
                  _override: 0,
                  _isolate: 0
                });
              } else if (!overflowIsolateCount) {
                overflowEmbeddingCount++;
              }
            } else if (charType & (TYPE_RLO | TYPE_LRO)) {
              embedLevels[i$2] = stackTop._level;
              var level$1 = (charType === TYPE_RLO ? nextOdd : nextEven)(stackTop._level);
              if (level$1 <= MAX_DEPTH && !overflowIsolateCount && !overflowEmbeddingCount) {
                statusStack.push({
                  _level: level$1,
                  _override: charType & TYPE_RLO ? TYPE_R : TYPE_L,
                  _isolate: 0
                });
              } else if (!overflowIsolateCount) {
                overflowEmbeddingCount++;
              }
            } else if (charType & ISOLATE_INIT_TYPES) {
              if (charType & TYPE_FSI) {
                charType = determineAutoEmbedLevel(i$2 + 1, true) === 1 ? TYPE_RLI : TYPE_LRI;
              }
              embedLevels[i$2] = stackTop._level;
              if (stackTop._override) {
                changeCharType(i$2, stackTop._override);
              }
              var level$2 = (charType === TYPE_RLI ? nextOdd : nextEven)(stackTop._level);
              if (level$2 <= MAX_DEPTH && overflowIsolateCount === 0 && overflowEmbeddingCount === 0) {
                validIsolateCount++;
                statusStack.push({
                  _level: level$2,
                  _override: 0,
                  _isolate: 1,
                  _isolInitIndex: i$2
                });
              } else {
                overflowIsolateCount++;
              }
            } else if (charType & TYPE_PDI) {
              if (overflowIsolateCount > 0) {
                overflowIsolateCount--;
              } else if (validIsolateCount > 0) {
                overflowEmbeddingCount = 0;
                while (!statusStack[statusStack.length - 1]._isolate) {
                  statusStack.pop();
                }
                var isolInitIndex = statusStack[statusStack.length - 1]._isolInitIndex;
                if (isolInitIndex != null) {
                  isolationPairs.set(isolInitIndex, i$2);
                  isolationPairs.set(i$2, isolInitIndex);
                }
                statusStack.pop();
                validIsolateCount--;
              }
              stackTop = statusStack[statusStack.length - 1];
              embedLevels[i$2] = stackTop._level;
              if (stackTop._override) {
                changeCharType(i$2, stackTop._override);
              }
            } else if (charType & TYPE_PDF) {
              if (overflowIsolateCount === 0) {
                if (overflowEmbeddingCount > 0) {
                  overflowEmbeddingCount--;
                } else if (!stackTop._isolate && statusStack.length > 1) {
                  statusStack.pop();
                  stackTop = statusStack[statusStack.length - 1];
                }
              }
              embedLevels[i$2] = stackTop._level;
            } else if (charType & TYPE_B) {
              embedLevels[i$2] = paragraph.level;
            }
          } else {
            embedLevels[i$2] = stackTop._level;
            if (stackTop._override && charType !== TYPE_BN) {
              changeCharType(i$2, stackTop._override);
            }
          }
        }
        var levelRuns = [];
        var currentRun = null;
        for (var i$3 = paragraph.start; i$3 <= paragraph.end; i$3++) {
          var charType$1 = charTypes[i$3];
          if (!(charType$1 & BN_LIKE_TYPES)) {
            var lvl = embedLevels[i$3];
            var isIsolInit = charType$1 & ISOLATE_INIT_TYPES;
            var isPDI = charType$1 === TYPE_PDI;
            if (currentRun && lvl === currentRun._level) {
              currentRun._end = i$3;
              currentRun._endsWithIsolInit = isIsolInit;
            } else {
              levelRuns.push(currentRun = {
                _start: i$3,
                _end: i$3,
                _level: lvl,
                _startsWithPDI: isPDI,
                _endsWithIsolInit: isIsolInit
              });
            }
          }
        }
        var isolatingRunSeqs = [];
        for (var runIdx = 0; runIdx < levelRuns.length; runIdx++) {
          var run = levelRuns[runIdx];
          if (!run._startsWithPDI || run._startsWithPDI && !isolationPairs.has(run._start)) {
            var seqRuns = [currentRun = run];
            for (var pdiIndex = void 0; currentRun && currentRun._endsWithIsolInit && (pdiIndex = isolationPairs.get(currentRun._end)) != null; ) {
              for (var i$4 = runIdx + 1; i$4 < levelRuns.length; i$4++) {
                if (levelRuns[i$4]._start === pdiIndex) {
                  seqRuns.push(currentRun = levelRuns[i$4]);
                  break;
                }
              }
            }
            var seqIndices = [];
            for (var i$5 = 0; i$5 < seqRuns.length; i$5++) {
              var run$1 = seqRuns[i$5];
              for (var j = run$1._start; j <= run$1._end; j++) {
                seqIndices.push(j);
              }
            }
            var firstLevel = embedLevels[seqIndices[0]];
            var prevLevel = paragraph.level;
            for (var i$6 = seqIndices[0] - 1; i$6 >= 0; i$6--) {
              if (!(charTypes[i$6] & BN_LIKE_TYPES)) {
                prevLevel = embedLevels[i$6];
                break;
              }
            }
            var lastIndex = seqIndices[seqIndices.length - 1];
            var lastLevel = embedLevels[lastIndex];
            var nextLevel = paragraph.level;
            if (!(charTypes[lastIndex] & ISOLATE_INIT_TYPES)) {
              for (var i$7 = lastIndex + 1; i$7 <= paragraph.end; i$7++) {
                if (!(charTypes[i$7] & BN_LIKE_TYPES)) {
                  nextLevel = embedLevels[i$7];
                  break;
                }
              }
            }
            isolatingRunSeqs.push({
              _seqIndices: seqIndices,
              _sosType: Math.max(prevLevel, firstLevel) % 2 ? TYPE_R : TYPE_L,
              _eosType: Math.max(nextLevel, lastLevel) % 2 ? TYPE_R : TYPE_L
            });
          }
        }
        for (var seqIdx = 0; seqIdx < isolatingRunSeqs.length; seqIdx++) {
          var ref = isolatingRunSeqs[seqIdx];
          var seqIndices$1 = ref._seqIndices;
          var sosType = ref._sosType;
          var eosType = ref._eosType;
          if (charTypeCounts.get(TYPE_NSM)) {
            for (var si = 0; si < seqIndices$1.length; si++) {
              var i$8 = seqIndices$1[si];
              if (charTypes[i$8] & TYPE_NSM) {
                var prevType = sosType;
                for (var sj = si - 1; sj >= 0; sj--) {
                  if (!(charTypes[seqIndices$1[sj]] & BN_LIKE_TYPES)) {
                    prevType = charTypes[seqIndices$1[sj]];
                    break;
                  }
                }
                changeCharType(i$8, prevType & (ISOLATE_INIT_TYPES | TYPE_PDI) ? TYPE_ON : prevType);
              }
            }
          }
          if (charTypeCounts.get(TYPE_EN)) {
            for (var si$1 = 0; si$1 < seqIndices$1.length; si$1++) {
              var i$9 = seqIndices$1[si$1];
              if (charTypes[i$9] & TYPE_EN) {
                for (var sj$1 = si$1 - 1; sj$1 >= -1; sj$1--) {
                  var prevCharType = sj$1 === -1 ? sosType : charTypes[seqIndices$1[sj$1]];
                  if (prevCharType & STRONG_TYPES) {
                    if (prevCharType === TYPE_AL) {
                      changeCharType(i$9, TYPE_AN);
                    }
                    break;
                  }
                }
              }
            }
          }
          if (charTypeCounts.get(TYPE_AL)) {
            for (var si$2 = 0; si$2 < seqIndices$1.length; si$2++) {
              var i$10 = seqIndices$1[si$2];
              if (charTypes[i$10] & TYPE_AL) {
                changeCharType(i$10, TYPE_R);
              }
            }
          }
          if (charTypeCounts.get(TYPE_ES) || charTypeCounts.get(TYPE_CS)) {
            for (var si$3 = 1; si$3 < seqIndices$1.length - 1; si$3++) {
              var i$11 = seqIndices$1[si$3];
              if (charTypes[i$11] & (TYPE_ES | TYPE_CS)) {
                var prevType$1 = 0, nextType = 0;
                for (var sj$2 = si$3 - 1; sj$2 >= 0; sj$2--) {
                  prevType$1 = charTypes[seqIndices$1[sj$2]];
                  if (!(prevType$1 & BN_LIKE_TYPES)) {
                    break;
                  }
                }
                for (var sj$3 = si$3 + 1; sj$3 < seqIndices$1.length; sj$3++) {
                  nextType = charTypes[seqIndices$1[sj$3]];
                  if (!(nextType & BN_LIKE_TYPES)) {
                    break;
                  }
                }
                if (prevType$1 === nextType && (charTypes[i$11] === TYPE_ES ? prevType$1 === TYPE_EN : prevType$1 & (TYPE_EN | TYPE_AN))) {
                  changeCharType(i$11, prevType$1);
                }
              }
            }
          }
          if (charTypeCounts.get(TYPE_EN)) {
            for (var si$4 = 0; si$4 < seqIndices$1.length; si$4++) {
              var i$12 = seqIndices$1[si$4];
              if (charTypes[i$12] & TYPE_EN) {
                for (var sj$4 = si$4 - 1; sj$4 >= 0 && charTypes[seqIndices$1[sj$4]] & (TYPE_ET | BN_LIKE_TYPES); sj$4--) {
                  changeCharType(seqIndices$1[sj$4], TYPE_EN);
                }
                for (var sj$5 = si$4 + 1; sj$5 < seqIndices$1.length && charTypes[seqIndices$1[sj$5]] & (TYPE_ET | BN_LIKE_TYPES); sj$5++) {
                  changeCharType(seqIndices$1[sj$5], TYPE_EN);
                }
              }
            }
          }
          if (charTypeCounts.get(TYPE_ET) || charTypeCounts.get(TYPE_ES) || charTypeCounts.get(TYPE_CS)) {
            for (var si$5 = 0; si$5 < seqIndices$1.length; si$5++) {
              var i$13 = seqIndices$1[si$5];
              if (charTypes[i$13] & (TYPE_ET | TYPE_ES | TYPE_CS)) {
                changeCharType(i$13, TYPE_ON);
                for (var sj$6 = si$5 - 1; sj$6 >= 0 && charTypes[seqIndices$1[sj$6]] & BN_LIKE_TYPES; sj$6--) {
                  changeCharType(seqIndices$1[sj$6], TYPE_ON);
                }
                for (var sj$7 = si$5 + 1; sj$7 < seqIndices$1.length && charTypes[seqIndices$1[sj$7]] & BN_LIKE_TYPES; sj$7++) {
                  changeCharType(seqIndices$1[sj$7], TYPE_ON);
                }
              }
            }
          }
          if (charTypeCounts.get(TYPE_EN)) {
            for (var si$6 = 0, prevStrongType = sosType; si$6 < seqIndices$1.length; si$6++) {
              var i$14 = seqIndices$1[si$6];
              var type = charTypes[i$14];
              if (type & TYPE_EN) {
                if (prevStrongType === TYPE_L) {
                  changeCharType(i$14, TYPE_L);
                }
              } else if (type & STRONG_TYPES) {
                prevStrongType = type;
              }
            }
          }
          if (charTypeCounts.get(NEUTRAL_ISOLATE_TYPES)) {
            var R_TYPES_FOR_N_STEPS = TYPE_R | TYPE_EN | TYPE_AN;
            var STRONG_TYPES_FOR_N_STEPS = R_TYPES_FOR_N_STEPS | TYPE_L;
            var bracketPairs = [];
            {
              var openerStack = [];
              for (var si$7 = 0; si$7 < seqIndices$1.length; si$7++) {
                if (charTypes[seqIndices$1[si$7]] & NEUTRAL_ISOLATE_TYPES) {
                  var char = string[seqIndices$1[si$7]];
                  var oppositeBracket = void 0;
                  if (openingToClosingBracket(char) !== null) {
                    if (openerStack.length < 63) {
                      openerStack.push({ char, seqIndex: si$7 });
                    } else {
                      break;
                    }
                  } else if ((oppositeBracket = closingToOpeningBracket(char)) !== null) {
                    for (var stackIdx = openerStack.length - 1; stackIdx >= 0; stackIdx--) {
                      var stackChar = openerStack[stackIdx].char;
                      if (stackChar === oppositeBracket || stackChar === closingToOpeningBracket(getCanonicalBracket(char)) || openingToClosingBracket(getCanonicalBracket(stackChar)) === char) {
                        bracketPairs.push([openerStack[stackIdx].seqIndex, si$7]);
                        openerStack.length = stackIdx;
                        break;
                      }
                    }
                  }
                }
              }
              bracketPairs.sort(function(a4, b5) {
                return a4[0] - b5[0];
              });
            }
            for (var pairIdx = 0; pairIdx < bracketPairs.length; pairIdx++) {
              var ref$1 = bracketPairs[pairIdx];
              var openSeqIdx = ref$1[0];
              var closeSeqIdx = ref$1[1];
              var foundStrongType = false;
              var useStrongType = 0;
              for (var si$8 = openSeqIdx + 1; si$8 < closeSeqIdx; si$8++) {
                var i$15 = seqIndices$1[si$8];
                if (charTypes[i$15] & STRONG_TYPES_FOR_N_STEPS) {
                  foundStrongType = true;
                  var lr = charTypes[i$15] & R_TYPES_FOR_N_STEPS ? TYPE_R : TYPE_L;
                  if (lr === getEmbedDirection(i$15)) {
                    useStrongType = lr;
                    break;
                  }
                }
              }
              if (foundStrongType && !useStrongType) {
                useStrongType = sosType;
                for (var si$9 = openSeqIdx - 1; si$9 >= 0; si$9--) {
                  var i$16 = seqIndices$1[si$9];
                  if (charTypes[i$16] & STRONG_TYPES_FOR_N_STEPS) {
                    var lr$1 = charTypes[i$16] & R_TYPES_FOR_N_STEPS ? TYPE_R : TYPE_L;
                    if (lr$1 !== getEmbedDirection(i$16)) {
                      useStrongType = lr$1;
                    } else {
                      useStrongType = getEmbedDirection(i$16);
                    }
                    break;
                  }
                }
              }
              if (useStrongType) {
                charTypes[seqIndices$1[openSeqIdx]] = charTypes[seqIndices$1[closeSeqIdx]] = useStrongType;
                if (useStrongType !== getEmbedDirection(seqIndices$1[openSeqIdx])) {
                  for (var si$10 = openSeqIdx + 1; si$10 < seqIndices$1.length; si$10++) {
                    if (!(charTypes[seqIndices$1[si$10]] & BN_LIKE_TYPES)) {
                      if (getBidiCharType(string[seqIndices$1[si$10]]) & TYPE_NSM) {
                        charTypes[seqIndices$1[si$10]] = useStrongType;
                      }
                      break;
                    }
                  }
                }
                if (useStrongType !== getEmbedDirection(seqIndices$1[closeSeqIdx])) {
                  for (var si$11 = closeSeqIdx + 1; si$11 < seqIndices$1.length; si$11++) {
                    if (!(charTypes[seqIndices$1[si$11]] & BN_LIKE_TYPES)) {
                      if (getBidiCharType(string[seqIndices$1[si$11]]) & TYPE_NSM) {
                        charTypes[seqIndices$1[si$11]] = useStrongType;
                      }
                      break;
                    }
                  }
                }
              }
            }
            for (var si$12 = 0; si$12 < seqIndices$1.length; si$12++) {
              if (charTypes[seqIndices$1[si$12]] & NEUTRAL_ISOLATE_TYPES) {
                var niRunStart = si$12, niRunEnd = si$12;
                var prevType$2 = sosType;
                for (var si2 = si$12 - 1; si2 >= 0; si2--) {
                  if (charTypes[seqIndices$1[si2]] & BN_LIKE_TYPES) {
                    niRunStart = si2;
                  } else {
                    prevType$2 = charTypes[seqIndices$1[si2]] & R_TYPES_FOR_N_STEPS ? TYPE_R : TYPE_L;
                    break;
                  }
                }
                var nextType$1 = eosType;
                for (var si2$1 = si$12 + 1; si2$1 < seqIndices$1.length; si2$1++) {
                  if (charTypes[seqIndices$1[si2$1]] & (NEUTRAL_ISOLATE_TYPES | BN_LIKE_TYPES)) {
                    niRunEnd = si2$1;
                  } else {
                    nextType$1 = charTypes[seqIndices$1[si2$1]] & R_TYPES_FOR_N_STEPS ? TYPE_R : TYPE_L;
                    break;
                  }
                }
                for (var sj$8 = niRunStart; sj$8 <= niRunEnd; sj$8++) {
                  charTypes[seqIndices$1[sj$8]] = prevType$2 === nextType$1 ? prevType$2 : getEmbedDirection(seqIndices$1[sj$8]);
                }
                si$12 = niRunEnd;
              }
            }
          }
        }
        for (var i$17 = paragraph.start; i$17 <= paragraph.end; i$17++) {
          var level$3 = embedLevels[i$17];
          var type$1 = charTypes[i$17];
          if (level$3 & 1) {
            if (type$1 & (TYPE_L | TYPE_EN | TYPE_AN)) {
              embedLevels[i$17]++;
            }
          } else {
            if (type$1 & TYPE_R) {
              embedLevels[i$17]++;
            } else if (type$1 & (TYPE_AN | TYPE_EN)) {
              embedLevels[i$17] += 2;
            }
          }
          if (type$1 & BN_LIKE_TYPES) {
            embedLevels[i$17] = i$17 === 0 ? paragraph.level : embedLevels[i$17 - 1];
          }
          if (i$17 === paragraph.end || getBidiCharType(string[i$17]) & (TYPE_S | TYPE_B)) {
            for (var j$1 = i$17; j$1 >= 0 && getBidiCharType(string[j$1]) & TRAILING_TYPES; j$1--) {
              embedLevels[j$1] = paragraph.level;
            }
          }
        }
      }
      return {
        levels: embedLevels,
        paragraphs
      };
      function determineAutoEmbedLevel(start, isFSI) {
        for (var i4 = start; i4 < string.length; i4++) {
          var charType2 = charTypes[i4];
          if (charType2 & (TYPE_R | TYPE_AL)) {
            return 1;
          }
          if (charType2 & (TYPE_B | TYPE_L) || isFSI && charType2 === TYPE_PDI) {
            return 0;
          }
          if (charType2 & ISOLATE_INIT_TYPES) {
            var pdi = indexOfMatchingPDI(i4);
            i4 = pdi === -1 ? string.length : pdi;
          }
        }
        return 0;
      }
      function indexOfMatchingPDI(isolateStart) {
        var isolationLevel = 1;
        for (var i4 = isolateStart + 1; i4 < string.length; i4++) {
          var charType2 = charTypes[i4];
          if (charType2 & TYPE_B) {
            break;
          }
          if (charType2 & TYPE_PDI) {
            if (--isolationLevel === 0) {
              return i4;
            }
          } else if (charType2 & ISOLATE_INIT_TYPES) {
            isolationLevel++;
          }
        }
        return -1;
      }
      function getEmbedDirection(i4) {
        return embedLevels[i4] & 1 ? TYPE_R : TYPE_L;
      }
    }
    var data = "14>1,j>2,t>2,u>2,1a>g,2v3>1,1>1,1ge>1,1wd>1,b>1,1j>1,f>1,ai>3,-2>3,+1,8>1k0,-1jq>1y7,-1y6>1hf,-1he>1h6,-1h5>1ha,-1h8>1qi,-1pu>1,6>3u,-3s>7,6>1,1>1,f>1,1>1,+2,3>1,1>1,+13,4>1,1>1,6>1eo,-1ee>1,3>1mg,-1me>1mk,-1mj>1mi,-1mg>1mi,-1md>1,1>1,+2,1>10k,-103>1,1>1,4>1,5>1,1>1,+10,3>1,1>8,-7>8,+1,-6>7,+1,a>1,1>1,u>1,u6>1,1>1,+5,26>1,1>1,2>1,2>2,8>1,7>1,4>1,1>1,+5,b8>1,1>1,+3,1>3,-2>1,2>1,1>1,+2,c>1,3>1,1>1,+2,h>1,3>1,a>1,1>1,2>1,3>1,1>1,d>1,f>1,3>1,1a>1,1>1,6>1,7>1,13>1,k>1,1>1,+19,4>1,1>1,+2,2>1,1>1,+18,m>1,a>1,1>1,lk>1,1>1,4>1,2>1,f>1,3>1,1>1,+3,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,6>1,4j>1,j>2,t>2,u>2,2>1,+1";
    var mirrorMap;
    function parse2() {
      if (!mirrorMap) {
        var ref = parseCharacterMap(data, true);
        var map3 = ref.map;
        var reverseMap = ref.reverseMap;
        reverseMap.forEach(function(value, key) {
          map3.set(key, value);
        });
        mirrorMap = map3;
      }
    }
    function getMirroredCharacter(char) {
      parse2();
      return mirrorMap.get(char) || null;
    }
    function getMirroredCharactersMap(string, embeddingLevels, start, end) {
      var strLen = string.length;
      start = Math.max(0, start == null ? 0 : +start);
      end = Math.min(strLen - 1, end == null ? strLen - 1 : +end);
      var map3 = /* @__PURE__ */ new Map();
      for (var i3 = start; i3 <= end; i3++) {
        if (embeddingLevels[i3] & 1) {
          var mirror = getMirroredCharacter(string[i3]);
          if (mirror !== null) {
            map3.set(i3, mirror);
          }
        }
      }
      return map3;
    }
    function getReorderSegments(string, embeddingLevelsResult, start, end) {
      var strLen = string.length;
      start = Math.max(0, start == null ? 0 : +start);
      end = Math.min(strLen - 1, end == null ? strLen - 1 : +end);
      var segments = [];
      embeddingLevelsResult.paragraphs.forEach(function(paragraph) {
        var lineStart = Math.max(start, paragraph.start);
        var lineEnd = Math.min(end, paragraph.end);
        if (lineStart < lineEnd) {
          var lineLevels = embeddingLevelsResult.levels.slice(lineStart, lineEnd + 1);
          for (var i3 = lineEnd; i3 >= lineStart && getBidiCharType(string[i3]) & TRAILING_TYPES; i3--) {
            lineLevels[i3] = paragraph.level;
          }
          var maxLevel = paragraph.level;
          var minOddLevel = Infinity;
          for (var i$1 = 0; i$1 < lineLevels.length; i$1++) {
            var level = lineLevels[i$1];
            if (level > maxLevel) {
              maxLevel = level;
            }
            if (level < minOddLevel) {
              minOddLevel = level | 1;
            }
          }
          for (var lvl = maxLevel; lvl >= minOddLevel; lvl--) {
            for (var i$2 = 0; i$2 < lineLevels.length; i$2++) {
              if (lineLevels[i$2] >= lvl) {
                var segStart = i$2;
                while (i$2 + 1 < lineLevels.length && lineLevels[i$2 + 1] >= lvl) {
                  i$2++;
                }
                if (i$2 > segStart) {
                  segments.push([segStart + start, i$2 + start]);
                }
              }
            }
          }
        }
      });
      return segments;
    }
    function getReorderedString(string, embedLevelsResult, start, end) {
      var indices = getReorderedIndices(string, embedLevelsResult, start, end);
      var chars = [].concat(string);
      indices.forEach(function(charIndex, i3) {
        chars[i3] = (embedLevelsResult.levels[charIndex] & 1 ? getMirroredCharacter(string[charIndex]) : null) || string[charIndex];
      });
      return chars.join("");
    }
    function getReorderedIndices(string, embedLevelsResult, start, end) {
      var segments = getReorderSegments(string, embedLevelsResult, start, end);
      var indices = [];
      for (var i3 = 0; i3 < string.length; i3++) {
        indices[i3] = i3;
      }
      segments.forEach(function(ref) {
        var start2 = ref[0];
        var end2 = ref[1];
        var slice3 = indices.slice(start2, end2 + 1);
        for (var i4 = slice3.length; i4--; ) {
          indices[end2 - i4] = slice3[i4];
        }
      });
      return indices;
    }
    exports2.closingToOpeningBracket = closingToOpeningBracket;
    exports2.getBidiCharType = getBidiCharType;
    exports2.getBidiCharTypeName = getBidiCharTypeName;
    exports2.getCanonicalBracket = getCanonicalBracket;
    exports2.getEmbeddingLevels = getEmbeddingLevels;
    exports2.getMirroredCharacter = getMirroredCharacter;
    exports2.getMirroredCharactersMap = getMirroredCharactersMap;
    exports2.getReorderSegments = getReorderSegments;
    exports2.getReorderedIndices = getReorderedIndices;
    exports2.getReorderedString = getReorderedString;
    exports2.openingToClosingBracket = openingToClosingBracket;
    Object.defineProperty(exports2, "__esModule", { value: true });
    return exports2;
  }({});
  return bidi;
}
var bidi_default = bidiFactory;

// node_modules/troika-three-utils/dist/troika-three-utils.esm.js
var voidMainRegExp = /\bvoid\s+main\s*\(\s*\)\s*{/g;
function expandShaderIncludes(source) {
  const pattern = /^[ \t]*#include +<([\w\d./]+)>/gm;
  function replace(match, include) {
    let chunk = ShaderChunk[include];
    return chunk ? expandShaderIncludes(chunk) : match;
  }
  return source.replace(pattern, replace);
}
var _lut = [];
for (let i3 = 0; i3 < 256; i3++) {
  _lut[i3] = (i3 < 16 ? "0" : "") + i3.toString(16);
}
function generateUUID() {
  const d0 = Math.random() * 4294967295 | 0;
  const d1 = Math.random() * 4294967295 | 0;
  const d2 = Math.random() * 4294967295 | 0;
  const d3 = Math.random() * 4294967295 | 0;
  const uuid = _lut[d0 & 255] + _lut[d0 >> 8 & 255] + _lut[d0 >> 16 & 255] + _lut[d0 >> 24 & 255] + "-" + _lut[d1 & 255] + _lut[d1 >> 8 & 255] + "-" + _lut[d1 >> 16 & 15 | 64] + _lut[d1 >> 24 & 255] + "-" + _lut[d2 & 63 | 128] + _lut[d2 >> 8 & 255] + "-" + _lut[d2 >> 16 & 255] + _lut[d2 >> 24 & 255] + _lut[d3 & 255] + _lut[d3 >> 8 & 255] + _lut[d3 >> 16 & 255] + _lut[d3 >> 24 & 255];
  return uuid.toUpperCase();
}
var assign = Object.assign || function() {
  let target = arguments[0];
  for (let i3 = 1, len = arguments.length; i3 < len; i3++) {
    let source = arguments[i3];
    if (source) {
      for (let prop in source) {
        if (Object.prototype.hasOwnProperty.call(source, prop)) {
          target[prop] = source[prop];
        }
      }
    }
  }
  return target;
};
var epoch = Date.now();
var CONSTRUCTOR_CACHE = /* @__PURE__ */ new WeakMap();
var SHADER_UPGRADE_CACHE = /* @__PURE__ */ new Map();
var materialInstanceId = 1e10;
function createDerivedMaterial(baseMaterial, options) {
  const optionsKey = getKeyForOptions(options);
  let ctorsByDerivation = CONSTRUCTOR_CACHE.get(baseMaterial);
  if (!ctorsByDerivation) {
    CONSTRUCTOR_CACHE.set(baseMaterial, ctorsByDerivation = /* @__PURE__ */ Object.create(null));
  }
  if (ctorsByDerivation[optionsKey]) {
    return new ctorsByDerivation[optionsKey]();
  }
  const privateBeforeCompileProp = `_onBeforeCompile${optionsKey}`;
  const onBeforeCompile = function(shaderInfo, renderer) {
    baseMaterial.onBeforeCompile.call(this, shaderInfo, renderer);
    const cacheKey = this.customProgramCacheKey() + "|" + shaderInfo.vertexShader + "|" + shaderInfo.fragmentShader;
    let upgradedShaders = SHADER_UPGRADE_CACHE[cacheKey];
    if (!upgradedShaders) {
      const upgraded = upgradeShaders(this, shaderInfo, options, optionsKey);
      upgradedShaders = SHADER_UPGRADE_CACHE[cacheKey] = upgraded;
    }
    shaderInfo.vertexShader = upgradedShaders.vertexShader;
    shaderInfo.fragmentShader = upgradedShaders.fragmentShader;
    assign(shaderInfo.uniforms, this.uniforms);
    if (options.timeUniform) {
      shaderInfo.uniforms[options.timeUniform] = {
        get value() {
          return Date.now() - epoch;
        }
      };
    }
    if (this[privateBeforeCompileProp]) {
      this[privateBeforeCompileProp](shaderInfo);
    }
  };
  const DerivedMaterial = function DerivedMaterial2() {
    return derive2(options.chained ? baseMaterial : baseMaterial.clone());
  };
  const derive2 = function(base) {
    const derived = Object.create(base, descriptor);
    Object.defineProperty(derived, "baseMaterial", { value: baseMaterial });
    Object.defineProperty(derived, "id", { value: materialInstanceId++ });
    derived.uuid = generateUUID();
    derived.uniforms = assign({}, base.uniforms, options.uniforms);
    derived.defines = assign({}, base.defines, options.defines);
    derived.defines[`TROIKA_DERIVED_MATERIAL_${optionsKey}`] = "";
    derived.extensions = assign({}, base.extensions, options.extensions);
    derived._listeners = void 0;
    return derived;
  };
  const descriptor = {
    constructor: { value: DerivedMaterial },
    isDerivedMaterial: { value: true },
    customProgramCacheKey: {
      writable: true,
      configurable: true,
      value: function() {
        return baseMaterial.customProgramCacheKey() + "|" + optionsKey;
      }
    },
    onBeforeCompile: {
      get() {
        return onBeforeCompile;
      },
      set(fn) {
        this[privateBeforeCompileProp] = fn;
      }
    },
    copy: {
      writable: true,
      configurable: true,
      value: function(source) {
        baseMaterial.copy.call(this, source);
        if (!baseMaterial.isShaderMaterial && !baseMaterial.isDerivedMaterial) {
          assign(this.extensions, source.extensions);
          assign(this.defines, source.defines);
          assign(this.uniforms, UniformsUtils.clone(source.uniforms));
        }
        return this;
      }
    },
    clone: {
      writable: true,
      configurable: true,
      value: function() {
        const newBase = new baseMaterial.constructor();
        return derive2(newBase).copy(this);
      }
    },
    /**
     * Utility to get a MeshDepthMaterial that will honor this derived material's vertex
     * transformations and discarded fragments.
     */
    getDepthMaterial: {
      writable: true,
      configurable: true,
      value: function() {
        let depthMaterial = this._depthMaterial;
        if (!depthMaterial) {
          depthMaterial = this._depthMaterial = createDerivedMaterial(
            baseMaterial.isDerivedMaterial ? baseMaterial.getDepthMaterial() : new MeshDepthMaterial({ depthPacking: RGBADepthPacking }),
            options
          );
          depthMaterial.defines.IS_DEPTH_MATERIAL = "";
          depthMaterial.uniforms = this.uniforms;
        }
        return depthMaterial;
      }
    },
    /**
     * Utility to get a MeshDistanceMaterial that will honor this derived material's vertex
     * transformations and discarded fragments.
     */
    getDistanceMaterial: {
      writable: true,
      configurable: true,
      value: function() {
        let distanceMaterial = this._distanceMaterial;
        if (!distanceMaterial) {
          distanceMaterial = this._distanceMaterial = createDerivedMaterial(
            baseMaterial.isDerivedMaterial ? baseMaterial.getDistanceMaterial() : new MeshDistanceMaterial(),
            options
          );
          distanceMaterial.defines.IS_DISTANCE_MATERIAL = "";
          distanceMaterial.uniforms = this.uniforms;
        }
        return distanceMaterial;
      }
    },
    dispose: {
      writable: true,
      configurable: true,
      value() {
        const { _depthMaterial, _distanceMaterial } = this;
        if (_depthMaterial)
          _depthMaterial.dispose();
        if (_distanceMaterial)
          _distanceMaterial.dispose();
        baseMaterial.dispose.call(this);
      }
    }
  };
  ctorsByDerivation[optionsKey] = DerivedMaterial;
  return new DerivedMaterial();
}
function upgradeShaders(material2, { vertexShader, fragmentShader }, options, key) {
  let {
    vertexDefs,
    vertexMainIntro,
    vertexMainOutro,
    vertexTransform,
    fragmentDefs,
    fragmentMainIntro,
    fragmentMainOutro,
    fragmentColorTransform,
    customRewriter,
    timeUniform
  } = options;
  vertexDefs = vertexDefs || "";
  vertexMainIntro = vertexMainIntro || "";
  vertexMainOutro = vertexMainOutro || "";
  fragmentDefs = fragmentDefs || "";
  fragmentMainIntro = fragmentMainIntro || "";
  fragmentMainOutro = fragmentMainOutro || "";
  if (vertexTransform || customRewriter) {
    vertexShader = expandShaderIncludes(vertexShader);
  }
  if (fragmentColorTransform || customRewriter) {
    fragmentShader = fragmentShader.replace(
      /^[ \t]*#include <((?:tonemapping|encodings|fog|premultiplied_alpha|dithering)_fragment)>/gm,
      "\n//!BEGIN_POST_CHUNK $1\n$&\n//!END_POST_CHUNK\n"
    );
    fragmentShader = expandShaderIncludes(fragmentShader);
  }
  if (customRewriter) {
    let res = customRewriter({ vertexShader, fragmentShader });
    vertexShader = res.vertexShader;
    fragmentShader = res.fragmentShader;
  }
  if (fragmentColorTransform) {
    let postChunks = [];
    fragmentShader = fragmentShader.replace(
      /^\/\/!BEGIN_POST_CHUNK[^]+?^\/\/!END_POST_CHUNK/gm,
      // [^]+? = non-greedy match of any chars including newlines
      (match) => {
        postChunks.push(match);
        return "";
      }
    );
    fragmentMainOutro = `${fragmentColorTransform}
${postChunks.join("\n")}
${fragmentMainOutro}`;
  }
  if (timeUniform) {
    const code = `
uniform float ${timeUniform};
`;
    vertexDefs = code + vertexDefs;
    fragmentDefs = code + fragmentDefs;
  }
  if (vertexTransform) {
    vertexShader = `vec3 troika_position_${key};
vec3 troika_normal_${key};
vec2 troika_uv_${key};
${vertexShader}
`;
    vertexDefs = `${vertexDefs}
void troikaVertexTransform${key}(inout vec3 position, inout vec3 normal, inout vec2 uv) {
  ${vertexTransform}
}
`;
    vertexMainIntro = `
troika_position_${key} = vec3(position);
troika_normal_${key} = vec3(normal);
troika_uv_${key} = vec2(uv);
troikaVertexTransform${key}(troika_position_${key}, troika_normal_${key}, troika_uv_${key});
${vertexMainIntro}
`;
    vertexShader = vertexShader.replace(/\b(position|normal|uv)\b/g, (match, match1, index, fullStr) => {
      return /\battribute\s+vec[23]\s+$/.test(fullStr.substr(0, index)) ? match1 : `troika_${match1}_${key}`;
    });
    if (!(material2.map && material2.map.channel > 0)) {
      vertexShader = vertexShader.replace(/\bMAP_UV\b/g, `troika_uv_${key}`);
    }
  }
  vertexShader = injectIntoShaderCode(vertexShader, key, vertexDefs, vertexMainIntro, vertexMainOutro);
  fragmentShader = injectIntoShaderCode(fragmentShader, key, fragmentDefs, fragmentMainIntro, fragmentMainOutro);
  return {
    vertexShader,
    fragmentShader
  };
}
function injectIntoShaderCode(shaderCode, id, defs, intro, outro) {
  if (intro || outro || defs) {
    shaderCode = shaderCode.replace(
      voidMainRegExp,
      `
${defs}
void troikaOrigMain${id}() {`
    );
    shaderCode += `
void main() {
  ${intro}
  troikaOrigMain${id}();
  ${outro}
}`;
  }
  return shaderCode;
}
function optionsJsonReplacer(key, value) {
  return key === "uniforms" ? void 0 : typeof value === "function" ? value.toString() : value;
}
var _idCtr = 0;
var optionsHashesToIds = /* @__PURE__ */ new Map();
function getKeyForOptions(options) {
  const optionsHash = JSON.stringify(options, optionsJsonReplacer);
  let id = optionsHashesToIds.get(optionsHash);
  if (id == null) {
    optionsHashesToIds.set(optionsHash, id = ++_idCtr);
  }
  return id;
}
var defaultBaseMaterial = new MeshStandardMaterial({ color: 16777215, side: DoubleSide });

// node_modules/troika-three-text/dist/troika-three-text.esm.js
function createTypesetter(fontParser, bidi, config3) {
  const {
    defaultFontURL
  } = config3;
  const fonts = /* @__PURE__ */ Object.create(null);
  const INF = Infinity;
  const DEFAULT_IGNORABLE_CHARS = /[\u00AD\u034F\u061C\u115F-\u1160\u17B4-\u17B5\u180B-\u180E\u200B-\u200F\u202A-\u202E\u2060-\u206F\u3164\uFE00-\uFE0F\uFEFF\uFFA0\uFFF0-\uFFF8]/;
  const lineBreakingWhiteSpace = `[^\\S\\u00A0]`;
  const BREAK_AFTER_CHARS = new RegExp(`${lineBreakingWhiteSpace}|[\\-\\u007C\\u00AD\\u2010\\u2012-\\u2014\\u2027\\u2056\\u2E17\\u2E40]`);
  function doLoadFont(url, callback) {
    function tryLoad() {
      const onError = (err) => {
        console.error(`Failure loading font ${url}${url === defaultFontURL ? "" : "; trying fallback"}`, err);
        if (url !== defaultFontURL) {
          url = defaultFontURL;
          tryLoad();
        }
      };
      try {
        const request = new XMLHttpRequest();
        request.open("get", url, true);
        request.responseType = "arraybuffer";
        request.onload = function() {
          if (request.status >= 400) {
            onError(new Error(request.statusText));
          } else if (request.status > 0) {
            try {
              const fontObj = fontParser(request.response);
              callback(fontObj);
            } catch (e) {
              onError(e);
            }
          }
        };
        request.onerror = onError;
        request.send();
      } catch (err) {
        onError(err);
      }
    }
    tryLoad();
  }
  function loadFont2(fontUrl, callback) {
    if (!fontUrl)
      fontUrl = defaultFontURL;
    let font = fonts[fontUrl];
    if (font) {
      if (font.pending) {
        font.pending.push(callback);
      } else {
        callback(font);
      }
    } else {
      fonts[fontUrl] = { pending: [callback] };
      doLoadFont(fontUrl, (fontObj) => {
        let callbacks = fonts[fontUrl].pending;
        fonts[fontUrl] = fontObj;
        callbacks.forEach((cb3) => cb3(fontObj));
      });
    }
  }
  function typeset({
    text = "",
    font = defaultFontURL,
    sdfGlyphSize = 64,
    fontSize = 1,
    letterSpacing = 0,
    lineHeight = "normal",
    maxWidth = INF,
    direction,
    textAlign = "left",
    textIndent = 0,
    whiteSpace = "normal",
    overflowWrap = "normal",
    anchorX = 0,
    anchorY = 0,
    includeCaretPositions = false,
    chunkedBoundsSize = 8192,
    colorRanges = null
  }, callback, metricsOnly = false) {
    const mainStart = now2();
    const timings = { fontLoad: 0, typesetting: 0 };
    if (text.indexOf("\r") > -1) {
      console.info("Typesetter: got text with \\r chars; normalizing to \\n");
      text = text.replace(/\r\n/g, "\n").replace(/\r/g, "\n");
    }
    fontSize = +fontSize;
    letterSpacing = +letterSpacing;
    maxWidth = +maxWidth;
    lineHeight = lineHeight || "normal";
    textIndent = +textIndent;
    loadFont2(font, (fontObj) => {
      const hasMaxWidth = isFinite(maxWidth);
      let glyphIds = null;
      let glyphPositions = null;
      let glyphData = null;
      let glyphColors = null;
      let caretPositions = null;
      let visibleBounds = null;
      let chunkedBounds = null;
      let maxLineWidth = 0;
      let renderableGlyphCount = 0;
      let canWrap = whiteSpace !== "nowrap";
      const { ascender, descender, unitsPerEm, lineGap, capHeight, xHeight } = fontObj;
      timings.fontLoad = now2() - mainStart;
      const typesetStart = now2();
      const fontSizeMult = fontSize / unitsPerEm;
      if (lineHeight === "normal") {
        lineHeight = (ascender - descender + lineGap) / unitsPerEm;
      }
      lineHeight = lineHeight * fontSize;
      const halfLeading = (lineHeight - (ascender - descender) * fontSizeMult) / 2;
      const topBaseline = -(ascender * fontSizeMult + halfLeading);
      const caretHeight = Math.min(lineHeight, (ascender - descender) * fontSizeMult);
      const caretBottomOffset = (ascender + descender) / 2 * fontSizeMult - caretHeight / 2;
      let lineXOffset = textIndent;
      let currentLine = new TextLine();
      const lines = [currentLine];
      fontObj.forEachGlyph(text, fontSize, letterSpacing, (glyphObj, glyphX, charIndex) => {
        const char = text.charAt(charIndex);
        const glyphWidth = glyphObj.advanceWidth * fontSizeMult;
        const curLineCount = currentLine.count;
        let nextLine;
        if (!("isEmpty" in glyphObj)) {
          glyphObj.isWhitespace = !!char && new RegExp(lineBreakingWhiteSpace).test(char);
          glyphObj.canBreakAfter = !!char && BREAK_AFTER_CHARS.test(char);
          glyphObj.isEmpty = glyphObj.xMin === glyphObj.xMax || glyphObj.yMin === glyphObj.yMax || DEFAULT_IGNORABLE_CHARS.test(char);
        }
        if (!glyphObj.isWhitespace && !glyphObj.isEmpty) {
          renderableGlyphCount++;
        }
        if (canWrap && hasMaxWidth && !glyphObj.isWhitespace && glyphX + glyphWidth + lineXOffset > maxWidth && curLineCount) {
          if (currentLine.glyphAt(curLineCount - 1).glyphObj.canBreakAfter) {
            nextLine = new TextLine();
            lineXOffset = -glyphX;
          } else {
            for (let i3 = curLineCount; i3--; ) {
              if (i3 === 0 && overflowWrap === "break-word") {
                nextLine = new TextLine();
                lineXOffset = -glyphX;
                break;
              } else if (currentLine.glyphAt(i3).glyphObj.canBreakAfter) {
                nextLine = currentLine.splitAt(i3 + 1);
                const adjustX = nextLine.glyphAt(0).x;
                lineXOffset -= adjustX;
                for (let j = nextLine.count; j--; ) {
                  nextLine.glyphAt(j).x -= adjustX;
                }
                break;
              }
            }
          }
          if (nextLine) {
            currentLine.isSoftWrapped = true;
            currentLine = nextLine;
            lines.push(currentLine);
            maxLineWidth = maxWidth;
          }
        }
        let fly = currentLine.glyphAt(currentLine.count);
        fly.glyphObj = glyphObj;
        fly.x = glyphX + lineXOffset;
        fly.width = glyphWidth;
        fly.charIndex = charIndex;
        if (char === "\n") {
          currentLine = new TextLine();
          lines.push(currentLine);
          lineXOffset = -(glyphX + glyphWidth + letterSpacing * fontSize) + textIndent;
        }
      });
      lines.forEach((line2) => {
        for (let i3 = line2.count; i3--; ) {
          let { glyphObj, x, width } = line2.glyphAt(i3);
          if (!glyphObj.isWhitespace) {
            line2.width = x + width;
            if (line2.width > maxLineWidth) {
              maxLineWidth = line2.width;
            }
            return;
          }
        }
      });
      let anchorXOffset = 0;
      let anchorYOffset = 0;
      if (anchorX) {
        if (typeof anchorX === "number") {
          anchorXOffset = -anchorX;
        } else if (typeof anchorX === "string") {
          anchorXOffset = -maxLineWidth * (anchorX === "left" ? 0 : anchorX === "center" ? 0.5 : anchorX === "right" ? 1 : parsePercent(anchorX));
        }
      }
      if (anchorY) {
        if (typeof anchorY === "number") {
          anchorYOffset = -anchorY;
        } else if (typeof anchorY === "string") {
          let height = lines.length * lineHeight;
          anchorYOffset = anchorY === "top" ? 0 : anchorY === "top-baseline" ? -topBaseline : anchorY === "top-cap" ? -topBaseline - capHeight * fontSizeMult : anchorY === "top-ex" ? -topBaseline - xHeight * fontSizeMult : anchorY === "middle" ? height / 2 : anchorY === "bottom" ? height : anchorY === "bottom-baseline" ? height - halfLeading + descender * fontSizeMult : parsePercent(anchorY) * height;
        }
      }
      if (!metricsOnly) {
        const bidiLevelsResult = bidi.getEmbeddingLevels(text, direction);
        glyphIds = new Uint16Array(renderableGlyphCount);
        glyphPositions = new Float32Array(renderableGlyphCount * 2);
        glyphData = {};
        visibleBounds = [INF, INF, -INF, -INF];
        chunkedBounds = [];
        let lineYOffset = topBaseline;
        if (includeCaretPositions) {
          caretPositions = new Float32Array(text.length * 3);
        }
        if (colorRanges) {
          glyphColors = new Uint8Array(renderableGlyphCount * 3);
        }
        let renderableGlyphIndex = 0;
        let prevCharIndex = -1;
        let colorCharIndex = -1;
        let chunk;
        let currentColor;
        lines.forEach((line2, lineIndex) => {
          let { count: lineGlyphCount, width: lineWidth } = line2;
          if (lineGlyphCount > 0) {
            let trailingWhitespaceCount = 0;
            for (let i3 = lineGlyphCount; i3-- && line2.glyphAt(i3).glyphObj.isWhitespace; ) {
              trailingWhitespaceCount++;
            }
            let lineXOffset2 = 0;
            let justifyAdjust = 0;
            if (textAlign === "center") {
              lineXOffset2 = (maxLineWidth - lineWidth) / 2;
            } else if (textAlign === "right") {
              lineXOffset2 = maxLineWidth - lineWidth;
            } else if (textAlign === "justify" && line2.isSoftWrapped) {
              let whitespaceCount = 0;
              for (let i3 = lineGlyphCount - trailingWhitespaceCount; i3--; ) {
                if (line2.glyphAt(i3).glyphObj.isWhitespace) {
                  whitespaceCount++;
                }
              }
              justifyAdjust = (maxLineWidth - lineWidth) / whitespaceCount;
            }
            if (justifyAdjust || lineXOffset2) {
              let justifyOffset = 0;
              for (let i3 = 0; i3 < lineGlyphCount; i3++) {
                let glyphInfo = line2.glyphAt(i3);
                const glyphObj2 = glyphInfo.glyphObj;
                glyphInfo.x += lineXOffset2 + justifyOffset;
                if (justifyAdjust !== 0 && glyphObj2.isWhitespace && i3 < lineGlyphCount - trailingWhitespaceCount) {
                  justifyOffset += justifyAdjust;
                  glyphInfo.width += justifyAdjust;
                }
              }
            }
            const flips = bidi.getReorderSegments(
              text,
              bidiLevelsResult,
              line2.glyphAt(0).charIndex,
              line2.glyphAt(line2.count - 1).charIndex
            );
            for (let fi = 0; fi < flips.length; fi++) {
              const [start, end] = flips[fi];
              let left = Infinity, right = -Infinity;
              for (let i3 = 0; i3 < lineGlyphCount; i3++) {
                if (line2.glyphAt(i3).charIndex >= start) {
                  let startInLine = i3, endInLine = i3;
                  for (; endInLine < lineGlyphCount; endInLine++) {
                    let info = line2.glyphAt(endInLine);
                    if (info.charIndex > end) {
                      break;
                    }
                    if (endInLine < lineGlyphCount - trailingWhitespaceCount) {
                      left = Math.min(left, info.x);
                      right = Math.max(right, info.x + info.width);
                    }
                  }
                  for (let j = startInLine; j < endInLine; j++) {
                    const glyphInfo = line2.glyphAt(j);
                    glyphInfo.x = right - (glyphInfo.x + glyphInfo.width - left);
                  }
                  break;
                }
              }
            }
            let glyphObj;
            const setGlyphObj = (g2) => glyphObj = g2;
            for (let i3 = 0; i3 < lineGlyphCount; i3++) {
              let glyphInfo = line2.glyphAt(i3);
              glyphObj = glyphInfo.glyphObj;
              const glyphId = glyphObj.index;
              const rtl = bidiLevelsResult.levels[glyphInfo.charIndex] & 1;
              if (rtl) {
                const mirrored = bidi.getMirroredCharacter(text[glyphInfo.charIndex]);
                if (mirrored) {
                  fontObj.forEachGlyph(mirrored, 0, 0, setGlyphObj);
                }
              }
              if (includeCaretPositions) {
                const { charIndex } = glyphInfo;
                const caretLeft = glyphInfo.x + anchorXOffset;
                const caretRight = glyphInfo.x + glyphInfo.width + anchorXOffset;
                caretPositions[charIndex * 3] = rtl ? caretRight : caretLeft;
                caretPositions[charIndex * 3 + 1] = rtl ? caretLeft : caretRight;
                caretPositions[charIndex * 3 + 2] = lineYOffset + caretBottomOffset + anchorYOffset;
                const ligCount = charIndex - prevCharIndex;
                if (ligCount > 1) {
                  fillLigatureCaretPositions(caretPositions, prevCharIndex, ligCount);
                }
                prevCharIndex = charIndex;
              }
              if (colorRanges) {
                const { charIndex } = glyphInfo;
                while (charIndex > colorCharIndex) {
                  colorCharIndex++;
                  if (colorRanges.hasOwnProperty(colorCharIndex)) {
                    currentColor = colorRanges[colorCharIndex];
                  }
                }
              }
              if (!glyphObj.isWhitespace && !glyphObj.isEmpty) {
                const idx = renderableGlyphIndex++;
                if (!glyphData[glyphId]) {
                  glyphData[glyphId] = {
                    path: glyphObj.path,
                    pathBounds: [glyphObj.xMin, glyphObj.yMin, glyphObj.xMax, glyphObj.yMax]
                  };
                }
                const glyphX = glyphInfo.x + anchorXOffset;
                const glyphY = lineYOffset + anchorYOffset;
                glyphPositions[idx * 2] = glyphX;
                glyphPositions[idx * 2 + 1] = glyphY;
                const visX0 = glyphX + glyphObj.xMin * fontSizeMult;
                const visY0 = glyphY + glyphObj.yMin * fontSizeMult;
                const visX1 = glyphX + glyphObj.xMax * fontSizeMult;
                const visY1 = glyphY + glyphObj.yMax * fontSizeMult;
                if (visX0 < visibleBounds[0])
                  visibleBounds[0] = visX0;
                if (visY0 < visibleBounds[1])
                  visibleBounds[1] = visY0;
                if (visX1 > visibleBounds[2])
                  visibleBounds[2] = visX1;
                if (visY1 > visibleBounds[3])
                  visibleBounds[3] = visY1;
                if (idx % chunkedBoundsSize === 0) {
                  chunk = { start: idx, end: idx, rect: [INF, INF, -INF, -INF] };
                  chunkedBounds.push(chunk);
                }
                chunk.end++;
                const chunkRect = chunk.rect;
                if (visX0 < chunkRect[0])
                  chunkRect[0] = visX0;
                if (visY0 < chunkRect[1])
                  chunkRect[1] = visY0;
                if (visX1 > chunkRect[2])
                  chunkRect[2] = visX1;
                if (visY1 > chunkRect[3])
                  chunkRect[3] = visY1;
                glyphIds[idx] = glyphId;
                if (colorRanges) {
                  const start = idx * 3;
                  glyphColors[start] = currentColor >> 16 & 255;
                  glyphColors[start + 1] = currentColor >> 8 & 255;
                  glyphColors[start + 2] = currentColor & 255;
                }
              }
            }
          }
          lineYOffset -= lineHeight;
        });
        if (caretPositions) {
          const ligCount = text.length - prevCharIndex;
          if (ligCount > 1) {
            fillLigatureCaretPositions(caretPositions, prevCharIndex, ligCount);
          }
        }
      }
      timings.typesetting = now2() - typesetStart;
      callback({
        glyphIds,
        //font indices for each glyph
        glyphPositions,
        //x,y of each glyph's origin in layout
        glyphData,
        //dict holding data about each glyph appearing in the text
        caretPositions,
        //startX,endX,bottomY caret positions for each char
        caretHeight,
        //height of cursor from bottom to top
        glyphColors,
        //color for each glyph, if color ranges supplied
        chunkedBounds,
        //total rects per (n=chunkedBoundsSize) consecutive glyphs
        fontSize,
        //calculated em height
        unitsPerEm,
        //font units per em
        ascender: ascender * fontSizeMult,
        //font ascender
        descender: descender * fontSizeMult,
        //font descender
        capHeight: capHeight * fontSizeMult,
        //font cap-height
        xHeight: xHeight * fontSizeMult,
        //font x-height
        lineHeight,
        //computed line height
        topBaseline,
        //y coordinate of the top line's baseline
        blockBounds: [
          //bounds for the whole block of text, including vertical padding for lineHeight
          anchorXOffset,
          anchorYOffset - lines.length * lineHeight,
          anchorXOffset + maxLineWidth,
          anchorYOffset
        ],
        visibleBounds,
        //total bounds of visible text paths, may be larger or smaller than blockBounds
        timings
      });
    });
  }
  function measure(args, callback) {
    typeset(args, (result) => {
      const [x0, y0, x1, y1] = result.blockBounds;
      callback({
        width: x1 - x0,
        height: y1 - y0
      });
    }, { metricsOnly: true });
  }
  function parsePercent(str) {
    let match = str.match(/^([\d.]+)%$/);
    let pct = match ? parseFloat(match[1]) : NaN;
    return isNaN(pct) ? 0 : pct / 100;
  }
  function fillLigatureCaretPositions(caretPositions, ligStartIndex, ligCount) {
    const ligStartX = caretPositions[ligStartIndex * 3];
    const ligEndX = caretPositions[ligStartIndex * 3 + 1];
    const ligY = caretPositions[ligStartIndex * 3 + 2];
    const guessedAdvanceX = (ligEndX - ligStartX) / ligCount;
    for (let i3 = 0; i3 < ligCount; i3++) {
      const startIndex = (ligStartIndex + i3) * 3;
      caretPositions[startIndex] = ligStartX + guessedAdvanceX * i3;
      caretPositions[startIndex + 1] = ligStartX + guessedAdvanceX * (i3 + 1);
      caretPositions[startIndex + 2] = ligY;
    }
  }
  function now2() {
    return (self.performance || Date).now();
  }
  function TextLine() {
    this.data = [];
  }
  const textLineProps = ["glyphObj", "x", "width", "charIndex"];
  TextLine.prototype = {
    width: 0,
    isSoftWrapped: false,
    get count() {
      return Math.ceil(this.data.length / textLineProps.length);
    },
    glyphAt(i3) {
      let fly = TextLine.flyweight;
      fly.data = this.data;
      fly.index = i3;
      return fly;
    },
    splitAt(i3) {
      let newLine = new TextLine();
      newLine.data = this.data.splice(i3 * textLineProps.length);
      return newLine;
    }
  };
  TextLine.flyweight = textLineProps.reduce((obj, prop, i3, all) => {
    Object.defineProperty(obj, prop, {
      get() {
        return this.data[this.index * textLineProps.length + i3];
      },
      set(val) {
        this.data[this.index * textLineProps.length + i3] = val;
      }
    });
    return obj;
  }, { data: null, index: 0 });
  return {
    typeset,
    measure,
    loadFont: loadFont2
  };
}
var now = () => (self.performance || Date).now();
var mainThreadGenerator = SDFGenerator();
var warned;
function generateSDF(width, height, path, viewBox, distance2, exponent, canvas, x, y, channel, useWebGL = true) {
  if (!useWebGL) {
    return generateSDF_JS_Worker(width, height, path, viewBox, distance2, exponent, canvas, x, y, channel);
  }
  return generateSDF_GL(width, height, path, viewBox, distance2, exponent, canvas, x, y, channel).then(
    null,
    (err) => {
      if (!warned) {
        console.warn(`WebGL SDF generation failed, falling back to JS`, err);
        warned = true;
      }
      return generateSDF_JS_Worker(width, height, path, viewBox, distance2, exponent, canvas, x, y, channel);
    }
  );
}
var queue = [];
var chunkTimeBudget = 5;
var timer = 0;
function nextChunk() {
  const start = now();
  while (queue.length && now() - start < chunkTimeBudget) {
    queue.shift()();
  }
  timer = queue.length ? setTimeout(nextChunk, 0) : 0;
}
var generateSDF_GL = (...args) => {
  return new Promise((resolve, reject) => {
    queue.push(() => {
      const start = now();
      try {
        mainThreadGenerator.webgl.generateIntoCanvas(...args);
        resolve({ timing: now() - start });
      } catch (err) {
        reject(err);
      }
    });
    if (!timer) {
      timer = setTimeout(nextChunk, 0);
    }
  });
};
var threadCount = 4;
var idleTimeout = 2e3;
var threads = {};
var callNum = 0;
function generateSDF_JS_Worker(width, height, path, viewBox, distance2, exponent, canvas, x, y, channel) {
  const workerId = "TroikaTextSDFGenerator_JS_" + callNum++ % threadCount;
  let thread = threads[workerId];
  if (!thread) {
    thread = threads[workerId] = {
      workerModule: defineWorkerModule({
        name: workerId,
        workerId,
        dependencies: [
          SDFGenerator,
          now
        ],
        init(_createSDFGenerator, now2) {
          const generate = _createSDFGenerator().javascript.generate;
          return function(...args) {
            const start = now2();
            const textureData = generate(...args);
            return {
              textureData,
              timing: now2() - start
            };
          };
        },
        getTransferables(result) {
          return [result.textureData.buffer];
        }
      }),
      requests: 0,
      idleTimer: null
    };
  }
  thread.requests++;
  clearTimeout(thread.idleTimer);
  return thread.workerModule(width, height, path, viewBox, distance2, exponent).then(({ textureData, timing }) => {
    const start = now();
    const imageData = new Uint8Array(textureData.length * 4);
    for (let i3 = 0; i3 < textureData.length; i3++) {
      imageData[i3 * 4 + channel] = textureData[i3];
    }
    mainThreadGenerator.webglUtils.renderImageData(canvas, imageData, x, y, width, height, 1 << 3 - channel);
    timing += now() - start;
    if (--thread.requests === 0) {
      thread.idleTimer = setTimeout(() => {
        terminateWorker(workerId);
      }, idleTimeout);
    }
    return { timing };
  });
}
function warmUpSDFCanvas(canvas) {
  if (!canvas._warm) {
    mainThreadGenerator.webgl.isSupported(canvas);
    canvas._warm = true;
  }
}
var resizeWebGLCanvasWithoutClearing = mainThreadGenerator.webglUtils.resizeWebGLCanvasWithoutClearing;
function typrFactory() {
  return "undefined" == typeof window && (self.window = self), function(r) {
    var e = { parse: function(r2) {
      var t3 = e._bin, a5 = new Uint8Array(r2);
      if ("ttcf" == t3.readASCII(a5, 0, 4)) {
        var n = 4;
        t3.readUshort(a5, n), n += 2, t3.readUshort(a5, n), n += 2;
        var o = t3.readUint(a5, n);
        n += 4;
        for (var s = [], i3 = 0; i3 < o; i3++) {
          var h = t3.readUint(a5, n);
          n += 4, s.push(e._readFont(a5, h));
        }
        return s;
      }
      return [e._readFont(a5, 0)];
    }, _readFont: function(r2, t3) {
      var a5 = e._bin, n = t3;
      a5.readFixed(r2, t3), t3 += 4;
      var o = a5.readUshort(r2, t3);
      t3 += 2, a5.readUshort(r2, t3), t3 += 2, a5.readUshort(r2, t3), t3 += 2, a5.readUshort(r2, t3), t3 += 2;
      for (var s = ["cmap", "head", "hhea", "maxp", "hmtx", "name", "OS/2", "post", "loca", "glyf", "kern", "CFF ", "GPOS", "GSUB", "SVG "], i3 = { _data: r2, _offset: n }, h = {}, f = 0; f < o; f++) {
        var d = a5.readASCII(r2, t3, 4);
        t3 += 4, a5.readUint(r2, t3), t3 += 4;
        var u = a5.readUint(r2, t3);
        t3 += 4;
        var l = a5.readUint(r2, t3);
        t3 += 4, h[d] = { offset: u, length: l };
      }
      for (f = 0; f < s.length; f++) {
        var v = s[f];
        h[v] && (i3[v.trim()] = e[v.trim()].parse(r2, h[v].offset, h[v].length, i3));
      }
      return i3;
    }, _tabOffset: function(r2, t3, a5) {
      for (var n = e._bin, o = n.readUshort(r2, a5 + 4), s = a5 + 12, i3 = 0; i3 < o; i3++) {
        var h = n.readASCII(r2, s, 4);
        s += 4, n.readUint(r2, s), s += 4;
        var f = n.readUint(r2, s);
        if (s += 4, n.readUint(r2, s), s += 4, h == t3)
          return f;
      }
      return 0;
    } };
    e._bin = { readFixed: function(r2, e2) {
      return (r2[e2] << 8 | r2[e2 + 1]) + (r2[e2 + 2] << 8 | r2[e2 + 3]) / 65540;
    }, readF2dot14: function(r2, t3) {
      return e._bin.readShort(r2, t3) / 16384;
    }, readInt: function(r2, t3) {
      return e._bin._view(r2).getInt32(t3);
    }, readInt8: function(r2, t3) {
      return e._bin._view(r2).getInt8(t3);
    }, readShort: function(r2, t3) {
      return e._bin._view(r2).getInt16(t3);
    }, readUshort: function(r2, t3) {
      return e._bin._view(r2).getUint16(t3);
    }, readUshorts: function(r2, t3, a5) {
      for (var n = [], o = 0; o < a5; o++)
        n.push(e._bin.readUshort(r2, t3 + 2 * o));
      return n;
    }, readUint: function(r2, t3) {
      return e._bin._view(r2).getUint32(t3);
    }, readUint64: function(r2, t3) {
      return 4294967296 * e._bin.readUint(r2, t3) + e._bin.readUint(r2, t3 + 4);
    }, readASCII: function(r2, e2, t3) {
      for (var a5 = "", n = 0; n < t3; n++)
        a5 += String.fromCharCode(r2[e2 + n]);
      return a5;
    }, readUnicode: function(r2, e2, t3) {
      for (var a5 = "", n = 0; n < t3; n++) {
        var o = r2[e2++] << 8 | r2[e2++];
        a5 += String.fromCharCode(o);
      }
      return a5;
    }, _tdec: "undefined" != typeof window && window.TextDecoder ? new window.TextDecoder() : null, readUTF8: function(r2, t3, a5) {
      var n = e._bin._tdec;
      return n && 0 == t3 && a5 == r2.length ? n.decode(r2) : e._bin.readASCII(r2, t3, a5);
    }, readBytes: function(r2, e2, t3) {
      for (var a5 = [], n = 0; n < t3; n++)
        a5.push(r2[e2 + n]);
      return a5;
    }, readASCIIArray: function(r2, e2, t3) {
      for (var a5 = [], n = 0; n < t3; n++)
        a5.push(String.fromCharCode(r2[e2 + n]));
      return a5;
    }, _view: function(r2) {
      return r2._dataView || (r2._dataView = r2.buffer ? new DataView(r2.buffer, r2.byteOffset, r2.byteLength) : new DataView(new Uint8Array(r2).buffer));
    } }, e._lctf = {}, e._lctf.parse = function(r2, t3, a5, n, o) {
      var s = e._bin, i3 = {}, h = t3;
      s.readFixed(r2, t3), t3 += 4;
      var f = s.readUshort(r2, t3);
      t3 += 2;
      var d = s.readUshort(r2, t3);
      t3 += 2;
      var u = s.readUshort(r2, t3);
      return t3 += 2, i3.scriptList = e._lctf.readScriptList(r2, h + f), i3.featureList = e._lctf.readFeatureList(r2, h + d), i3.lookupList = e._lctf.readLookupList(r2, h + u, o), i3;
    }, e._lctf.readLookupList = function(r2, t3, a5) {
      var n = e._bin, o = t3, s = [], i3 = n.readUshort(r2, t3);
      t3 += 2;
      for (var h = 0; h < i3; h++) {
        var f = n.readUshort(r2, t3);
        t3 += 2;
        var d = e._lctf.readLookupTable(r2, o + f, a5);
        s.push(d);
      }
      return s;
    }, e._lctf.readLookupTable = function(r2, t3, a5) {
      var n = e._bin, o = t3, s = { tabs: [] };
      s.ltype = n.readUshort(r2, t3), t3 += 2, s.flag = n.readUshort(r2, t3), t3 += 2;
      var i3 = n.readUshort(r2, t3);
      t3 += 2;
      for (var h = s.ltype, f = 0; f < i3; f++) {
        var d = n.readUshort(r2, t3);
        t3 += 2;
        var u = a5(r2, h, o + d, s);
        s.tabs.push(u);
      }
      return s;
    }, e._lctf.numOfOnes = function(r2) {
      for (var e2 = 0, t3 = 0; t3 < 32; t3++)
        0 != (r2 >>> t3 & 1) && e2++;
      return e2;
    }, e._lctf.readClassDef = function(r2, t3) {
      var a5 = e._bin, n = [], o = a5.readUshort(r2, t3);
      if (t3 += 2, 1 == o) {
        var s = a5.readUshort(r2, t3);
        t3 += 2;
        var i3 = a5.readUshort(r2, t3);
        t3 += 2;
        for (var h = 0; h < i3; h++)
          n.push(s + h), n.push(s + h), n.push(a5.readUshort(r2, t3)), t3 += 2;
      }
      if (2 == o) {
        var f = a5.readUshort(r2, t3);
        t3 += 2;
        for (h = 0; h < f; h++)
          n.push(a5.readUshort(r2, t3)), t3 += 2, n.push(a5.readUshort(r2, t3)), t3 += 2, n.push(a5.readUshort(r2, t3)), t3 += 2;
      }
      return n;
    }, e._lctf.getInterval = function(r2, e2) {
      for (var t3 = 0; t3 < r2.length; t3 += 3) {
        var a5 = r2[t3], n = r2[t3 + 1];
        if (r2[t3 + 2], a5 <= e2 && e2 <= n)
          return t3;
      }
      return -1;
    }, e._lctf.readCoverage = function(r2, t3) {
      var a5 = e._bin, n = {};
      n.fmt = a5.readUshort(r2, t3), t3 += 2;
      var o = a5.readUshort(r2, t3);
      return t3 += 2, 1 == n.fmt && (n.tab = a5.readUshorts(r2, t3, o)), 2 == n.fmt && (n.tab = a5.readUshorts(r2, t3, 3 * o)), n;
    }, e._lctf.coverageIndex = function(r2, t3) {
      var a5 = r2.tab;
      if (1 == r2.fmt)
        return a5.indexOf(t3);
      if (2 == r2.fmt) {
        var n = e._lctf.getInterval(a5, t3);
        if (-1 != n)
          return a5[n + 2] + (t3 - a5[n]);
      }
      return -1;
    }, e._lctf.readFeatureList = function(r2, t3) {
      var a5 = e._bin, n = t3, o = [], s = a5.readUshort(r2, t3);
      t3 += 2;
      for (var i3 = 0; i3 < s; i3++) {
        var h = a5.readASCII(r2, t3, 4);
        t3 += 4;
        var f = a5.readUshort(r2, t3);
        t3 += 2;
        var d = e._lctf.readFeatureTable(r2, n + f);
        d.tag = h.trim(), o.push(d);
      }
      return o;
    }, e._lctf.readFeatureTable = function(r2, t3) {
      var a5 = e._bin, n = t3, o = {}, s = a5.readUshort(r2, t3);
      t3 += 2, s > 0 && (o.featureParams = n + s);
      var i3 = a5.readUshort(r2, t3);
      t3 += 2, o.tab = [];
      for (var h = 0; h < i3; h++)
        o.tab.push(a5.readUshort(r2, t3 + 2 * h));
      return o;
    }, e._lctf.readScriptList = function(r2, t3) {
      var a5 = e._bin, n = t3, o = {}, s = a5.readUshort(r2, t3);
      t3 += 2;
      for (var i3 = 0; i3 < s; i3++) {
        var h = a5.readASCII(r2, t3, 4);
        t3 += 4;
        var f = a5.readUshort(r2, t3);
        t3 += 2, o[h.trim()] = e._lctf.readScriptTable(r2, n + f);
      }
      return o;
    }, e._lctf.readScriptTable = function(r2, t3) {
      var a5 = e._bin, n = t3, o = {}, s = a5.readUshort(r2, t3);
      t3 += 2, o.default = e._lctf.readLangSysTable(r2, n + s);
      var i3 = a5.readUshort(r2, t3);
      t3 += 2;
      for (var h = 0; h < i3; h++) {
        var f = a5.readASCII(r2, t3, 4);
        t3 += 4;
        var d = a5.readUshort(r2, t3);
        t3 += 2, o[f.trim()] = e._lctf.readLangSysTable(r2, n + d);
      }
      return o;
    }, e._lctf.readLangSysTable = function(r2, t3) {
      var a5 = e._bin, n = {};
      a5.readUshort(r2, t3), t3 += 2, n.reqFeature = a5.readUshort(r2, t3), t3 += 2;
      var o = a5.readUshort(r2, t3);
      return t3 += 2, n.features = a5.readUshorts(r2, t3, o), n;
    }, e.CFF = {}, e.CFF.parse = function(r2, t3, a5) {
      var n = e._bin;
      (r2 = new Uint8Array(r2.buffer, t3, a5))[t3 = 0], r2[++t3], r2[++t3], r2[++t3], t3++;
      var o = [];
      t3 = e.CFF.readIndex(r2, t3, o);
      for (var s = [], i3 = 0; i3 < o.length - 1; i3++)
        s.push(n.readASCII(r2, t3 + o[i3], o[i3 + 1] - o[i3]));
      t3 += o[o.length - 1];
      var h = [];
      t3 = e.CFF.readIndex(r2, t3, h);
      var f = [];
      for (i3 = 0; i3 < h.length - 1; i3++)
        f.push(e.CFF.readDict(r2, t3 + h[i3], t3 + h[i3 + 1]));
      t3 += h[h.length - 1];
      var d = f[0], u = [];
      t3 = e.CFF.readIndex(r2, t3, u);
      var l = [];
      for (i3 = 0; i3 < u.length - 1; i3++)
        l.push(n.readASCII(r2, t3 + u[i3], u[i3 + 1] - u[i3]));
      if (t3 += u[u.length - 1], e.CFF.readSubrs(r2, t3, d), d.CharStrings) {
        t3 = d.CharStrings;
        u = [];
        t3 = e.CFF.readIndex(r2, t3, u);
        var v = [];
        for (i3 = 0; i3 < u.length - 1; i3++)
          v.push(n.readBytes(r2, t3 + u[i3], u[i3 + 1] - u[i3]));
        d.CharStrings = v;
      }
      if (d.ROS) {
        t3 = d.FDArray;
        var c3 = [];
        t3 = e.CFF.readIndex(r2, t3, c3), d.FDArray = [];
        for (i3 = 0; i3 < c3.length - 1; i3++) {
          var p = e.CFF.readDict(r2, t3 + c3[i3], t3 + c3[i3 + 1]);
          e.CFF._readFDict(r2, p, l), d.FDArray.push(p);
        }
        t3 += c3[c3.length - 1], t3 = d.FDSelect, d.FDSelect = [];
        var U = r2[t3];
        if (t3++, 3 != U)
          throw U;
        var g2 = n.readUshort(r2, t3);
        t3 += 2;
        for (i3 = 0; i3 < g2 + 1; i3++)
          d.FDSelect.push(n.readUshort(r2, t3), r2[t3 + 2]), t3 += 3;
      }
      return d.Encoding && (d.Encoding = e.CFF.readEncoding(r2, d.Encoding, d.CharStrings.length)), d.charset && (d.charset = e.CFF.readCharset(r2, d.charset, d.CharStrings.length)), e.CFF._readFDict(r2, d, l), d;
    }, e.CFF._readFDict = function(r2, t3, a5) {
      var n;
      for (var o in t3.Private && (n = t3.Private[1], t3.Private = e.CFF.readDict(r2, n, n + t3.Private[0]), t3.Private.Subrs && e.CFF.readSubrs(r2, n + t3.Private.Subrs, t3.Private)), t3)
        -1 != ["FamilyName", "FontName", "FullName", "Notice", "version", "Copyright"].indexOf(o) && (t3[o] = a5[t3[o] - 426 + 35]);
    }, e.CFF.readSubrs = function(r2, t3, a5) {
      var n = e._bin, o = [];
      t3 = e.CFF.readIndex(r2, t3, o);
      var s, i3 = o.length;
      s = i3 < 1240 ? 107 : i3 < 33900 ? 1131 : 32768, a5.Bias = s, a5.Subrs = [];
      for (var h = 0; h < o.length - 1; h++)
        a5.Subrs.push(n.readBytes(r2, t3 + o[h], o[h + 1] - o[h]));
    }, e.CFF.tableSE = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 0, 111, 112, 113, 114, 0, 115, 116, 117, 118, 119, 120, 121, 122, 0, 123, 0, 124, 125, 126, 127, 128, 129, 130, 131, 0, 132, 133, 0, 134, 135, 136, 137, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 138, 0, 139, 0, 0, 0, 0, 140, 141, 142, 143, 0, 0, 0, 0, 0, 144, 0, 0, 0, 145, 0, 0, 146, 147, 148, 149, 0, 0, 0, 0], e.CFF.glyphByUnicode = function(r2, e2) {
      for (var t3 = 0; t3 < r2.charset.length; t3++)
        if (r2.charset[t3] == e2)
          return t3;
      return -1;
    }, e.CFF.glyphBySE = function(r2, t3) {
      return t3 < 0 || t3 > 255 ? -1 : e.CFF.glyphByUnicode(r2, e.CFF.tableSE[t3]);
    }, e.CFF.readEncoding = function(r2, t3, a5) {
      e._bin;
      var n = [".notdef"], o = r2[t3];
      if (t3++, 0 != o)
        throw "error: unknown encoding format: " + o;
      var s = r2[t3];
      t3++;
      for (var i3 = 0; i3 < s; i3++)
        n.push(r2[t3 + i3]);
      return n;
    }, e.CFF.readCharset = function(r2, t3, a5) {
      var n = e._bin, o = [".notdef"], s = r2[t3];
      if (t3++, 0 == s)
        for (var i3 = 0; i3 < a5; i3++) {
          var h = n.readUshort(r2, t3);
          t3 += 2, o.push(h);
        }
      else {
        if (1 != s && 2 != s)
          throw "error: format: " + s;
        for (; o.length < a5; ) {
          h = n.readUshort(r2, t3);
          t3 += 2;
          var f = 0;
          1 == s ? (f = r2[t3], t3++) : (f = n.readUshort(r2, t3), t3 += 2);
          for (i3 = 0; i3 <= f; i3++)
            o.push(h), h++;
        }
      }
      return o;
    }, e.CFF.readIndex = function(r2, t3, a5) {
      var n = e._bin, o = n.readUshort(r2, t3) + 1, s = r2[t3 += 2];
      if (t3++, 1 == s)
        for (var i3 = 0; i3 < o; i3++)
          a5.push(r2[t3 + i3]);
      else if (2 == s)
        for (i3 = 0; i3 < o; i3++)
          a5.push(n.readUshort(r2, t3 + 2 * i3));
      else if (3 == s)
        for (i3 = 0; i3 < o; i3++)
          a5.push(16777215 & n.readUint(r2, t3 + 3 * i3 - 1));
      else if (1 != o)
        throw "unsupported offset size: " + s + ", count: " + o;
      return (t3 += o * s) - 1;
    }, e.CFF.getCharString = function(r2, t3, a5) {
      var n = e._bin, o = r2[t3], s = r2[t3 + 1];
      r2[t3 + 2], r2[t3 + 3], r2[t3 + 4];
      var i3 = 1, h = null, f = null;
      o <= 20 && (h = o, i3 = 1), 12 == o && (h = 100 * o + s, i3 = 2), 21 <= o && o <= 27 && (h = o, i3 = 1), 28 == o && (f = n.readShort(r2, t3 + 1), i3 = 3), 29 <= o && o <= 31 && (h = o, i3 = 1), 32 <= o && o <= 246 && (f = o - 139, i3 = 1), 247 <= o && o <= 250 && (f = 256 * (o - 247) + s + 108, i3 = 2), 251 <= o && o <= 254 && (f = 256 * -(o - 251) - s - 108, i3 = 2), 255 == o && (f = n.readInt(r2, t3 + 1) / 65535, i3 = 5), a5.val = null != f ? f : "o" + h, a5.size = i3;
    }, e.CFF.readCharString = function(r2, t3, a5) {
      for (var n = t3 + a5, o = e._bin, s = []; t3 < n; ) {
        var i3 = r2[t3], h = r2[t3 + 1];
        r2[t3 + 2], r2[t3 + 3], r2[t3 + 4];
        var f = 1, d = null, u = null;
        i3 <= 20 && (d = i3, f = 1), 12 == i3 && (d = 100 * i3 + h, f = 2), 19 != i3 && 20 != i3 || (d = i3, f = 2), 21 <= i3 && i3 <= 27 && (d = i3, f = 1), 28 == i3 && (u = o.readShort(r2, t3 + 1), f = 3), 29 <= i3 && i3 <= 31 && (d = i3, f = 1), 32 <= i3 && i3 <= 246 && (u = i3 - 139, f = 1), 247 <= i3 && i3 <= 250 && (u = 256 * (i3 - 247) + h + 108, f = 2), 251 <= i3 && i3 <= 254 && (u = 256 * -(i3 - 251) - h - 108, f = 2), 255 == i3 && (u = o.readInt(r2, t3 + 1) / 65535, f = 5), s.push(null != u ? u : "o" + d), t3 += f;
      }
      return s;
    }, e.CFF.readDict = function(r2, t3, a5) {
      for (var n = e._bin, o = {}, s = []; t3 < a5; ) {
        var i3 = r2[t3], h = r2[t3 + 1];
        r2[t3 + 2], r2[t3 + 3], r2[t3 + 4];
        var f = 1, d = null, u = null;
        if (28 == i3 && (u = n.readShort(r2, t3 + 1), f = 3), 29 == i3 && (u = n.readInt(r2, t3 + 1), f = 5), 32 <= i3 && i3 <= 246 && (u = i3 - 139, f = 1), 247 <= i3 && i3 <= 250 && (u = 256 * (i3 - 247) + h + 108, f = 2), 251 <= i3 && i3 <= 254 && (u = 256 * -(i3 - 251) - h - 108, f = 2), 255 == i3)
          throw u = n.readInt(r2, t3 + 1) / 65535, f = 5, "unknown number";
        if (30 == i3) {
          var l = [];
          for (f = 1; ; ) {
            var v = r2[t3 + f];
            f++;
            var c3 = v >> 4, p = 15 & v;
            if (15 != c3 && l.push(c3), 15 != p && l.push(p), 15 == p)
              break;
          }
          for (var U = "", g2 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, ".", "e", "e-", "reserved", "-", "endOfNumber"], S = 0; S < l.length; S++)
            U += g2[l[S]];
          u = parseFloat(U);
        }
        if (i3 <= 21) {
          if (d = ["version", "Notice", "FullName", "FamilyName", "Weight", "FontBBox", "BlueValues", "OtherBlues", "FamilyBlues", "FamilyOtherBlues", "StdHW", "StdVW", "escape", "UniqueID", "XUID", "charset", "Encoding", "CharStrings", "Private", "Subrs", "defaultWidthX", "nominalWidthX"][i3], f = 1, 12 == i3)
            d = ["Copyright", "isFixedPitch", "ItalicAngle", "UnderlinePosition", "UnderlineThickness", "PaintType", "CharstringType", "FontMatrix", "StrokeWidth", "BlueScale", "BlueShift", "BlueFuzz", "StemSnapH", "StemSnapV", "ForceBold", 0, 0, "LanguageGroup", "ExpansionFactor", "initialRandomSeed", "SyntheticBase", "PostScript", "BaseFontName", "BaseFontBlend", 0, 0, 0, 0, 0, 0, "ROS", "CIDFontVersion", "CIDFontRevision", "CIDFontType", "CIDCount", "UIDBase", "FDArray", "FDSelect", "FontName"][h], f = 2;
        }
        null != d ? (o[d] = 1 == s.length ? s[0] : s, s = []) : s.push(u), t3 += f;
      }
      return o;
    }, e.cmap = {}, e.cmap.parse = function(r2, t3, a5) {
      r2 = new Uint8Array(r2.buffer, t3, a5), t3 = 0;
      var n = e._bin, o = {};
      n.readUshort(r2, t3), t3 += 2;
      var s = n.readUshort(r2, t3);
      t3 += 2;
      var i3 = [];
      o.tables = [];
      for (var h = 0; h < s; h++) {
        var f = n.readUshort(r2, t3);
        t3 += 2;
        var d = n.readUshort(r2, t3);
        t3 += 2;
        var u = n.readUint(r2, t3);
        t3 += 4;
        var l = "p" + f + "e" + d, v = i3.indexOf(u);
        if (-1 == v) {
          var c3;
          v = o.tables.length, i3.push(u);
          var p = n.readUshort(r2, u);
          0 == p ? c3 = e.cmap.parse0(r2, u) : 4 == p ? c3 = e.cmap.parse4(r2, u) : 6 == p ? c3 = e.cmap.parse6(r2, u) : 12 == p ? c3 = e.cmap.parse12(r2, u) : console.debug("unknown format: " + p, f, d, u), o.tables.push(c3);
        }
        if (null != o[l])
          throw "multiple tables for one platform+encoding";
        o[l] = v;
      }
      return o;
    }, e.cmap.parse0 = function(r2, t3) {
      var a5 = e._bin, n = {};
      n.format = a5.readUshort(r2, t3), t3 += 2;
      var o = a5.readUshort(r2, t3);
      t3 += 2, a5.readUshort(r2, t3), t3 += 2, n.map = [];
      for (var s = 0; s < o - 6; s++)
        n.map.push(r2[t3 + s]);
      return n;
    }, e.cmap.parse4 = function(r2, t3) {
      var a5 = e._bin, n = t3, o = {};
      o.format = a5.readUshort(r2, t3), t3 += 2;
      var s = a5.readUshort(r2, t3);
      t3 += 2, a5.readUshort(r2, t3), t3 += 2;
      var i3 = a5.readUshort(r2, t3);
      t3 += 2;
      var h = i3 / 2;
      o.searchRange = a5.readUshort(r2, t3), t3 += 2, o.entrySelector = a5.readUshort(r2, t3), t3 += 2, o.rangeShift = a5.readUshort(r2, t3), t3 += 2, o.endCount = a5.readUshorts(r2, t3, h), t3 += 2 * h, t3 += 2, o.startCount = a5.readUshorts(r2, t3, h), t3 += 2 * h, o.idDelta = [];
      for (var f = 0; f < h; f++)
        o.idDelta.push(a5.readShort(r2, t3)), t3 += 2;
      for (o.idRangeOffset = a5.readUshorts(r2, t3, h), t3 += 2 * h, o.glyphIdArray = []; t3 < n + s; )
        o.glyphIdArray.push(a5.readUshort(r2, t3)), t3 += 2;
      return o;
    }, e.cmap.parse6 = function(r2, t3) {
      var a5 = e._bin, n = {};
      n.format = a5.readUshort(r2, t3), t3 += 2, a5.readUshort(r2, t3), t3 += 2, a5.readUshort(r2, t3), t3 += 2, n.firstCode = a5.readUshort(r2, t3), t3 += 2;
      var o = a5.readUshort(r2, t3);
      t3 += 2, n.glyphIdArray = [];
      for (var s = 0; s < o; s++)
        n.glyphIdArray.push(a5.readUshort(r2, t3)), t3 += 2;
      return n;
    }, e.cmap.parse12 = function(r2, t3) {
      var a5 = e._bin, n = {};
      n.format = a5.readUshort(r2, t3), t3 += 2, t3 += 2, a5.readUint(r2, t3), t3 += 4, a5.readUint(r2, t3), t3 += 4;
      var o = a5.readUint(r2, t3);
      t3 += 4, n.groups = [];
      for (var s = 0; s < o; s++) {
        var i3 = t3 + 12 * s, h = a5.readUint(r2, i3 + 0), f = a5.readUint(r2, i3 + 4), d = a5.readUint(r2, i3 + 8);
        n.groups.push([h, f, d]);
      }
      return n;
    }, e.glyf = {}, e.glyf.parse = function(r2, e2, t3, a5) {
      for (var n = [], o = 0; o < a5.maxp.numGlyphs; o++)
        n.push(null);
      return n;
    }, e.glyf._parseGlyf = function(r2, t3) {
      var a5 = e._bin, n = r2._data, o = e._tabOffset(n, "glyf", r2._offset) + r2.loca[t3];
      if (r2.loca[t3] == r2.loca[t3 + 1])
        return null;
      var s = {};
      if (s.noc = a5.readShort(n, o), o += 2, s.xMin = a5.readShort(n, o), o += 2, s.yMin = a5.readShort(n, o), o += 2, s.xMax = a5.readShort(n, o), o += 2, s.yMax = a5.readShort(n, o), o += 2, s.xMin >= s.xMax || s.yMin >= s.yMax)
        return null;
      if (s.noc > 0) {
        s.endPts = [];
        for (var i3 = 0; i3 < s.noc; i3++)
          s.endPts.push(a5.readUshort(n, o)), o += 2;
        var h = a5.readUshort(n, o);
        if (o += 2, n.length - o < h)
          return null;
        s.instructions = a5.readBytes(n, o, h), o += h;
        var f = s.endPts[s.noc - 1] + 1;
        s.flags = [];
        for (i3 = 0; i3 < f; i3++) {
          var d = n[o];
          if (o++, s.flags.push(d), 0 != (8 & d)) {
            var u = n[o];
            o++;
            for (var l = 0; l < u; l++)
              s.flags.push(d), i3++;
          }
        }
        s.xs = [];
        for (i3 = 0; i3 < f; i3++) {
          var v = 0 != (2 & s.flags[i3]), c3 = 0 != (16 & s.flags[i3]);
          v ? (s.xs.push(c3 ? n[o] : -n[o]), o++) : c3 ? s.xs.push(0) : (s.xs.push(a5.readShort(n, o)), o += 2);
        }
        s.ys = [];
        for (i3 = 0; i3 < f; i3++) {
          v = 0 != (4 & s.flags[i3]), c3 = 0 != (32 & s.flags[i3]);
          v ? (s.ys.push(c3 ? n[o] : -n[o]), o++) : c3 ? s.ys.push(0) : (s.ys.push(a5.readShort(n, o)), o += 2);
        }
        var p = 0, U = 0;
        for (i3 = 0; i3 < f; i3++)
          p += s.xs[i3], U += s.ys[i3], s.xs[i3] = p, s.ys[i3] = U;
      } else {
        var g2;
        s.parts = [];
        do {
          g2 = a5.readUshort(n, o), o += 2;
          var S = { m: { a: 1, b: 0, c: 0, d: 1, tx: 0, ty: 0 }, p1: -1, p2: -1 };
          if (s.parts.push(S), S.glyphIndex = a5.readUshort(n, o), o += 2, 1 & g2) {
            var m = a5.readShort(n, o);
            o += 2;
            var b5 = a5.readShort(n, o);
            o += 2;
          } else {
            m = a5.readInt8(n, o);
            o++;
            b5 = a5.readInt8(n, o);
            o++;
          }
          2 & g2 ? (S.m.tx = m, S.m.ty = b5) : (S.p1 = m, S.p2 = b5), 8 & g2 ? (S.m.a = S.m.d = a5.readF2dot14(n, o), o += 2) : 64 & g2 ? (S.m.a = a5.readF2dot14(n, o), o += 2, S.m.d = a5.readF2dot14(n, o), o += 2) : 128 & g2 && (S.m.a = a5.readF2dot14(n, o), o += 2, S.m.b = a5.readF2dot14(n, o), o += 2, S.m.c = a5.readF2dot14(n, o), o += 2, S.m.d = a5.readF2dot14(n, o), o += 2);
        } while (32 & g2);
        if (256 & g2) {
          var y = a5.readUshort(n, o);
          o += 2, s.instr = [];
          for (i3 = 0; i3 < y; i3++)
            s.instr.push(n[o]), o++;
        }
      }
      return s;
    }, e.GPOS = {}, e.GPOS.parse = function(r2, t3, a5, n) {
      return e._lctf.parse(r2, t3, a5, n, e.GPOS.subt);
    }, e.GPOS.subt = function(r2, t3, a5, n) {
      var o = e._bin, s = a5, i3 = {};
      if (i3.fmt = o.readUshort(r2, a5), a5 += 2, 1 == t3 || 2 == t3 || 3 == t3 || 7 == t3 || 8 == t3 && i3.fmt <= 2) {
        var h = o.readUshort(r2, a5);
        a5 += 2, i3.coverage = e._lctf.readCoverage(r2, h + s);
      }
      if (1 == t3 && 1 == i3.fmt) {
        var f = o.readUshort(r2, a5);
        a5 += 2;
        var d = e._lctf.numOfOnes(f);
        0 != f && (i3.pos = e.GPOS.readValueRecord(r2, a5, f));
      } else if (2 == t3 && i3.fmt >= 1 && i3.fmt <= 2) {
        f = o.readUshort(r2, a5);
        a5 += 2;
        var u = o.readUshort(r2, a5);
        a5 += 2;
        d = e._lctf.numOfOnes(f);
        var l = e._lctf.numOfOnes(u);
        if (1 == i3.fmt) {
          i3.pairsets = [];
          var v = o.readUshort(r2, a5);
          a5 += 2;
          for (var c3 = 0; c3 < v; c3++) {
            var p = s + o.readUshort(r2, a5);
            a5 += 2;
            var U = o.readUshort(r2, p);
            p += 2;
            for (var g2 = [], S = 0; S < U; S++) {
              var m = o.readUshort(r2, p);
              p += 2, 0 != f && (x = e.GPOS.readValueRecord(r2, p, f), p += 2 * d), 0 != u && (P = e.GPOS.readValueRecord(r2, p, u), p += 2 * l), g2.push({ gid2: m, val1: x, val2: P });
            }
            i3.pairsets.push(g2);
          }
        }
        if (2 == i3.fmt) {
          var b5 = o.readUshort(r2, a5);
          a5 += 2;
          var y = o.readUshort(r2, a5);
          a5 += 2;
          var F = o.readUshort(r2, a5);
          a5 += 2;
          var _ = o.readUshort(r2, a5);
          a5 += 2, i3.classDef1 = e._lctf.readClassDef(r2, s + b5), i3.classDef2 = e._lctf.readClassDef(r2, s + y), i3.matrix = [];
          for (c3 = 0; c3 < F; c3++) {
            var C2 = [];
            for (S = 0; S < _; S++) {
              var x = null, P = null;
              0 != f && (x = e.GPOS.readValueRecord(r2, a5, f), a5 += 2 * d), 0 != u && (P = e.GPOS.readValueRecord(r2, a5, u), a5 += 2 * l), C2.push({ val1: x, val2: P });
            }
            i3.matrix.push(C2);
          }
        }
      } else {
        if (9 == t3 && 1 == i3.fmt) {
          var I2 = o.readUshort(r2, a5);
          a5 += 2;
          var w = o.readUint(r2, a5);
          if (a5 += 4, 9 == n.ltype)
            n.ltype = I2;
          else if (n.ltype != I2)
            throw "invalid extension substitution";
          return e.GPOS.subt(r2, n.ltype, s + w);
        }
        console.debug("unsupported GPOS table LookupType", t3, "format", i3.fmt);
      }
      return i3;
    }, e.GPOS.readValueRecord = function(r2, t3, a5) {
      var n = e._bin, o = [];
      return o.push(1 & a5 ? n.readShort(r2, t3) : 0), t3 += 1 & a5 ? 2 : 0, o.push(2 & a5 ? n.readShort(r2, t3) : 0), t3 += 2 & a5 ? 2 : 0, o.push(4 & a5 ? n.readShort(r2, t3) : 0), t3 += 4 & a5 ? 2 : 0, o.push(8 & a5 ? n.readShort(r2, t3) : 0), t3 += 8 & a5 ? 2 : 0, o;
    }, e.GSUB = {}, e.GSUB.parse = function(r2, t3, a5, n) {
      return e._lctf.parse(r2, t3, a5, n, e.GSUB.subt);
    }, e.GSUB.subt = function(r2, t3, a5, n) {
      var o = e._bin, s = a5, i3 = {};
      if (i3.fmt = o.readUshort(r2, a5), a5 += 2, 1 != t3 && 4 != t3 && 5 != t3 && 6 != t3)
        return null;
      if (1 == t3 || 4 == t3 || 5 == t3 && i3.fmt <= 2 || 6 == t3 && i3.fmt <= 2) {
        var h = o.readUshort(r2, a5);
        a5 += 2, i3.coverage = e._lctf.readCoverage(r2, s + h);
      }
      if (1 == t3 && i3.fmt >= 1 && i3.fmt <= 2) {
        if (1 == i3.fmt)
          i3.delta = o.readShort(r2, a5), a5 += 2;
        else if (2 == i3.fmt) {
          var f = o.readUshort(r2, a5);
          a5 += 2, i3.newg = o.readUshorts(r2, a5, f), a5 += 2 * i3.newg.length;
        }
      } else if (4 == t3) {
        i3.vals = [];
        f = o.readUshort(r2, a5);
        a5 += 2;
        for (var d = 0; d < f; d++) {
          var u = o.readUshort(r2, a5);
          a5 += 2, i3.vals.push(e.GSUB.readLigatureSet(r2, s + u));
        }
      } else if (5 == t3 && 2 == i3.fmt) {
        if (2 == i3.fmt) {
          var l = o.readUshort(r2, a5);
          a5 += 2, i3.cDef = e._lctf.readClassDef(r2, s + l), i3.scset = [];
          var v = o.readUshort(r2, a5);
          a5 += 2;
          for (d = 0; d < v; d++) {
            var c3 = o.readUshort(r2, a5);
            a5 += 2, i3.scset.push(0 == c3 ? null : e.GSUB.readSubClassSet(r2, s + c3));
          }
        }
      } else if (6 == t3 && 3 == i3.fmt) {
        if (3 == i3.fmt) {
          for (d = 0; d < 3; d++) {
            f = o.readUshort(r2, a5);
            a5 += 2;
            for (var p = [], U = 0; U < f; U++)
              p.push(e._lctf.readCoverage(r2, s + o.readUshort(r2, a5 + 2 * U)));
            a5 += 2 * f, 0 == d && (i3.backCvg = p), 1 == d && (i3.inptCvg = p), 2 == d && (i3.ahedCvg = p);
          }
          f = o.readUshort(r2, a5);
          a5 += 2, i3.lookupRec = e.GSUB.readSubstLookupRecords(r2, a5, f);
        }
      } else {
        if (7 == t3 && 1 == i3.fmt) {
          var g2 = o.readUshort(r2, a5);
          a5 += 2;
          var S = o.readUint(r2, a5);
          if (a5 += 4, 9 == n.ltype)
            n.ltype = g2;
          else if (n.ltype != g2)
            throw "invalid extension substitution";
          return e.GSUB.subt(r2, n.ltype, s + S);
        }
        console.debug("unsupported GSUB table LookupType", t3, "format", i3.fmt);
      }
      return i3;
    }, e.GSUB.readSubClassSet = function(r2, t3) {
      var a5 = e._bin.readUshort, n = t3, o = [], s = a5(r2, t3);
      t3 += 2;
      for (var i3 = 0; i3 < s; i3++) {
        var h = a5(r2, t3);
        t3 += 2, o.push(e.GSUB.readSubClassRule(r2, n + h));
      }
      return o;
    }, e.GSUB.readSubClassRule = function(r2, t3) {
      var a5 = e._bin.readUshort, n = {}, o = a5(r2, t3), s = a5(r2, t3 += 2);
      t3 += 2, n.input = [];
      for (var i3 = 0; i3 < o - 1; i3++)
        n.input.push(a5(r2, t3)), t3 += 2;
      return n.substLookupRecords = e.GSUB.readSubstLookupRecords(r2, t3, s), n;
    }, e.GSUB.readSubstLookupRecords = function(r2, t3, a5) {
      for (var n = e._bin.readUshort, o = [], s = 0; s < a5; s++)
        o.push(n(r2, t3), n(r2, t3 + 2)), t3 += 4;
      return o;
    }, e.GSUB.readChainSubClassSet = function(r2, t3) {
      var a5 = e._bin, n = t3, o = [], s = a5.readUshort(r2, t3);
      t3 += 2;
      for (var i3 = 0; i3 < s; i3++) {
        var h = a5.readUshort(r2, t3);
        t3 += 2, o.push(e.GSUB.readChainSubClassRule(r2, n + h));
      }
      return o;
    }, e.GSUB.readChainSubClassRule = function(r2, t3) {
      for (var a5 = e._bin, n = {}, o = ["backtrack", "input", "lookahead"], s = 0; s < o.length; s++) {
        var i3 = a5.readUshort(r2, t3);
        t3 += 2, 1 == s && i3--, n[o[s]] = a5.readUshorts(r2, t3, i3), t3 += 2 * n[o[s]].length;
      }
      i3 = a5.readUshort(r2, t3);
      return t3 += 2, n.subst = a5.readUshorts(r2, t3, 2 * i3), t3 += 2 * n.subst.length, n;
    }, e.GSUB.readLigatureSet = function(r2, t3) {
      var a5 = e._bin, n = t3, o = [], s = a5.readUshort(r2, t3);
      t3 += 2;
      for (var i3 = 0; i3 < s; i3++) {
        var h = a5.readUshort(r2, t3);
        t3 += 2, o.push(e.GSUB.readLigature(r2, n + h));
      }
      return o;
    }, e.GSUB.readLigature = function(r2, t3) {
      var a5 = e._bin, n = { chain: [] };
      n.nglyph = a5.readUshort(r2, t3), t3 += 2;
      var o = a5.readUshort(r2, t3);
      t3 += 2;
      for (var s = 0; s < o - 1; s++)
        n.chain.push(a5.readUshort(r2, t3)), t3 += 2;
      return n;
    }, e.head = {}, e.head.parse = function(r2, t3, a5) {
      var n = e._bin, o = {};
      return n.readFixed(r2, t3), t3 += 4, o.fontRevision = n.readFixed(r2, t3), t3 += 4, n.readUint(r2, t3), t3 += 4, n.readUint(r2, t3), t3 += 4, o.flags = n.readUshort(r2, t3), t3 += 2, o.unitsPerEm = n.readUshort(r2, t3), t3 += 2, o.created = n.readUint64(r2, t3), t3 += 8, o.modified = n.readUint64(r2, t3), t3 += 8, o.xMin = n.readShort(r2, t3), t3 += 2, o.yMin = n.readShort(r2, t3), t3 += 2, o.xMax = n.readShort(r2, t3), t3 += 2, o.yMax = n.readShort(r2, t3), t3 += 2, o.macStyle = n.readUshort(r2, t3), t3 += 2, o.lowestRecPPEM = n.readUshort(r2, t3), t3 += 2, o.fontDirectionHint = n.readShort(r2, t3), t3 += 2, o.indexToLocFormat = n.readShort(r2, t3), t3 += 2, o.glyphDataFormat = n.readShort(r2, t3), t3 += 2, o;
    }, e.hhea = {}, e.hhea.parse = function(r2, t3, a5) {
      var n = e._bin, o = {};
      return n.readFixed(r2, t3), t3 += 4, o.ascender = n.readShort(r2, t3), t3 += 2, o.descender = n.readShort(r2, t3), t3 += 2, o.lineGap = n.readShort(r2, t3), t3 += 2, o.advanceWidthMax = n.readUshort(r2, t3), t3 += 2, o.minLeftSideBearing = n.readShort(r2, t3), t3 += 2, o.minRightSideBearing = n.readShort(r2, t3), t3 += 2, o.xMaxExtent = n.readShort(r2, t3), t3 += 2, o.caretSlopeRise = n.readShort(r2, t3), t3 += 2, o.caretSlopeRun = n.readShort(r2, t3), t3 += 2, o.caretOffset = n.readShort(r2, t3), t3 += 2, t3 += 8, o.metricDataFormat = n.readShort(r2, t3), t3 += 2, o.numberOfHMetrics = n.readUshort(r2, t3), t3 += 2, o;
    }, e.hmtx = {}, e.hmtx.parse = function(r2, t3, a5, n) {
      for (var o = e._bin, s = { aWidth: [], lsBearing: [] }, i3 = 0, h = 0, f = 0; f < n.maxp.numGlyphs; f++)
        f < n.hhea.numberOfHMetrics && (i3 = o.readUshort(r2, t3), t3 += 2, h = o.readShort(r2, t3), t3 += 2), s.aWidth.push(i3), s.lsBearing.push(h);
      return s;
    }, e.kern = {}, e.kern.parse = function(r2, t3, a5, n) {
      var o = e._bin, s = o.readUshort(r2, t3);
      if (t3 += 2, 1 == s)
        return e.kern.parseV1(r2, t3 - 2, a5, n);
      var i3 = o.readUshort(r2, t3);
      t3 += 2;
      for (var h = { glyph1: [], rval: [] }, f = 0; f < i3; f++) {
        t3 += 2;
        a5 = o.readUshort(r2, t3);
        t3 += 2;
        var d = o.readUshort(r2, t3);
        t3 += 2;
        var u = d >>> 8;
        if (0 != (u &= 15))
          throw "unknown kern table format: " + u;
        t3 = e.kern.readFormat0(r2, t3, h);
      }
      return h;
    }, e.kern.parseV1 = function(r2, t3, a5, n) {
      var o = e._bin;
      o.readFixed(r2, t3), t3 += 4;
      var s = o.readUint(r2, t3);
      t3 += 4;
      for (var i3 = { glyph1: [], rval: [] }, h = 0; h < s; h++) {
        o.readUint(r2, t3), t3 += 4;
        var f = o.readUshort(r2, t3);
        t3 += 2, o.readUshort(r2, t3), t3 += 2;
        var d = f >>> 8;
        if (0 != (d &= 15))
          throw "unknown kern table format: " + d;
        t3 = e.kern.readFormat0(r2, t3, i3);
      }
      return i3;
    }, e.kern.readFormat0 = function(r2, t3, a5) {
      var n = e._bin, o = -1, s = n.readUshort(r2, t3);
      t3 += 2, n.readUshort(r2, t3), t3 += 2, n.readUshort(r2, t3), t3 += 2, n.readUshort(r2, t3), t3 += 2;
      for (var i3 = 0; i3 < s; i3++) {
        var h = n.readUshort(r2, t3);
        t3 += 2;
        var f = n.readUshort(r2, t3);
        t3 += 2;
        var d = n.readShort(r2, t3);
        t3 += 2, h != o && (a5.glyph1.push(h), a5.rval.push({ glyph2: [], vals: [] }));
        var u = a5.rval[a5.rval.length - 1];
        u.glyph2.push(f), u.vals.push(d), o = h;
      }
      return t3;
    }, e.loca = {}, e.loca.parse = function(r2, t3, a5, n) {
      var o = e._bin, s = [], i3 = n.head.indexToLocFormat, h = n.maxp.numGlyphs + 1;
      if (0 == i3)
        for (var f = 0; f < h; f++)
          s.push(o.readUshort(r2, t3 + (f << 1)) << 1);
      if (1 == i3)
        for (f = 0; f < h; f++)
          s.push(o.readUint(r2, t3 + (f << 2)));
      return s;
    }, e.maxp = {}, e.maxp.parse = function(r2, t3, a5) {
      var n = e._bin, o = {}, s = n.readUint(r2, t3);
      return t3 += 4, o.numGlyphs = n.readUshort(r2, t3), t3 += 2, 65536 == s && (o.maxPoints = n.readUshort(r2, t3), t3 += 2, o.maxContours = n.readUshort(r2, t3), t3 += 2, o.maxCompositePoints = n.readUshort(r2, t3), t3 += 2, o.maxCompositeContours = n.readUshort(r2, t3), t3 += 2, o.maxZones = n.readUshort(r2, t3), t3 += 2, o.maxTwilightPoints = n.readUshort(r2, t3), t3 += 2, o.maxStorage = n.readUshort(r2, t3), t3 += 2, o.maxFunctionDefs = n.readUshort(r2, t3), t3 += 2, o.maxInstructionDefs = n.readUshort(r2, t3), t3 += 2, o.maxStackElements = n.readUshort(r2, t3), t3 += 2, o.maxSizeOfInstructions = n.readUshort(r2, t3), t3 += 2, o.maxComponentElements = n.readUshort(r2, t3), t3 += 2, o.maxComponentDepth = n.readUshort(r2, t3), t3 += 2), o;
    }, e.name = {}, e.name.parse = function(r2, t3, a5) {
      var n = e._bin, o = {};
      n.readUshort(r2, t3), t3 += 2;
      var s = n.readUshort(r2, t3);
      t3 += 2, n.readUshort(r2, t3);
      for (var i3, h = ["copyright", "fontFamily", "fontSubfamily", "ID", "fullName", "version", "postScriptName", "trademark", "manufacturer", "designer", "description", "urlVendor", "urlDesigner", "licence", "licenceURL", "---", "typoFamilyName", "typoSubfamilyName", "compatibleFull", "sampleText", "postScriptCID", "wwsFamilyName", "wwsSubfamilyName", "lightPalette", "darkPalette"], f = t3 += 2, d = 0; d < s; d++) {
        var u = n.readUshort(r2, t3);
        t3 += 2;
        var l = n.readUshort(r2, t3);
        t3 += 2;
        var v = n.readUshort(r2, t3);
        t3 += 2;
        var c3 = n.readUshort(r2, t3);
        t3 += 2;
        var p = n.readUshort(r2, t3);
        t3 += 2;
        var U = n.readUshort(r2, t3);
        t3 += 2;
        var g2, S = h[c3], m = f + 12 * s + U;
        if (0 == u)
          g2 = n.readUnicode(r2, m, p / 2);
        else if (3 == u && 0 == l)
          g2 = n.readUnicode(r2, m, p / 2);
        else if (0 == l)
          g2 = n.readASCII(r2, m, p);
        else if (1 == l)
          g2 = n.readUnicode(r2, m, p / 2);
        else if (3 == l)
          g2 = n.readUnicode(r2, m, p / 2);
        else {
          if (1 != u)
            throw "unknown encoding " + l + ", platformID: " + u;
          g2 = n.readASCII(r2, m, p), console.debug("reading unknown MAC encoding " + l + " as ASCII");
        }
        var b5 = "p" + u + "," + v.toString(16);
        null == o[b5] && (o[b5] = {}), o[b5][void 0 !== S ? S : c3] = g2, o[b5]._lang = v;
      }
      for (var y in o)
        if (null != o[y].postScriptName && 1033 == o[y]._lang)
          return o[y];
      for (var y in o)
        if (null != o[y].postScriptName && 0 == o[y]._lang)
          return o[y];
      for (var y in o)
        if (null != o[y].postScriptName && 3084 == o[y]._lang)
          return o[y];
      for (var y in o)
        if (null != o[y].postScriptName)
          return o[y];
      for (var y in o) {
        i3 = y;
        break;
      }
      return console.debug("returning name table with languageID " + o[i3]._lang), o[i3];
    }, e["OS/2"] = {}, e["OS/2"].parse = function(r2, t3, a5) {
      var n = e._bin.readUshort(r2, t3);
      t3 += 2;
      var o = {};
      if (0 == n)
        e["OS/2"].version0(r2, t3, o);
      else if (1 == n)
        e["OS/2"].version1(r2, t3, o);
      else if (2 == n || 3 == n || 4 == n)
        e["OS/2"].version2(r2, t3, o);
      else {
        if (5 != n)
          throw "unknown OS/2 table version: " + n;
        e["OS/2"].version5(r2, t3, o);
      }
      return o;
    }, e["OS/2"].version0 = function(r2, t3, a5) {
      var n = e._bin;
      return a5.xAvgCharWidth = n.readShort(r2, t3), t3 += 2, a5.usWeightClass = n.readUshort(r2, t3), t3 += 2, a5.usWidthClass = n.readUshort(r2, t3), t3 += 2, a5.fsType = n.readUshort(r2, t3), t3 += 2, a5.ySubscriptXSize = n.readShort(r2, t3), t3 += 2, a5.ySubscriptYSize = n.readShort(r2, t3), t3 += 2, a5.ySubscriptXOffset = n.readShort(r2, t3), t3 += 2, a5.ySubscriptYOffset = n.readShort(r2, t3), t3 += 2, a5.ySuperscriptXSize = n.readShort(r2, t3), t3 += 2, a5.ySuperscriptYSize = n.readShort(r2, t3), t3 += 2, a5.ySuperscriptXOffset = n.readShort(r2, t3), t3 += 2, a5.ySuperscriptYOffset = n.readShort(r2, t3), t3 += 2, a5.yStrikeoutSize = n.readShort(r2, t3), t3 += 2, a5.yStrikeoutPosition = n.readShort(r2, t3), t3 += 2, a5.sFamilyClass = n.readShort(r2, t3), t3 += 2, a5.panose = n.readBytes(r2, t3, 10), t3 += 10, a5.ulUnicodeRange1 = n.readUint(r2, t3), t3 += 4, a5.ulUnicodeRange2 = n.readUint(r2, t3), t3 += 4, a5.ulUnicodeRange3 = n.readUint(r2, t3), t3 += 4, a5.ulUnicodeRange4 = n.readUint(r2, t3), t3 += 4, a5.achVendID = [n.readInt8(r2, t3), n.readInt8(r2, t3 + 1), n.readInt8(r2, t3 + 2), n.readInt8(r2, t3 + 3)], t3 += 4, a5.fsSelection = n.readUshort(r2, t3), t3 += 2, a5.usFirstCharIndex = n.readUshort(r2, t3), t3 += 2, a5.usLastCharIndex = n.readUshort(r2, t3), t3 += 2, a5.sTypoAscender = n.readShort(r2, t3), t3 += 2, a5.sTypoDescender = n.readShort(r2, t3), t3 += 2, a5.sTypoLineGap = n.readShort(r2, t3), t3 += 2, a5.usWinAscent = n.readUshort(r2, t3), t3 += 2, a5.usWinDescent = n.readUshort(r2, t3), t3 += 2;
    }, e["OS/2"].version1 = function(r2, t3, a5) {
      var n = e._bin;
      return t3 = e["OS/2"].version0(r2, t3, a5), a5.ulCodePageRange1 = n.readUint(r2, t3), t3 += 4, a5.ulCodePageRange2 = n.readUint(r2, t3), t3 += 4;
    }, e["OS/2"].version2 = function(r2, t3, a5) {
      var n = e._bin;
      return t3 = e["OS/2"].version1(r2, t3, a5), a5.sxHeight = n.readShort(r2, t3), t3 += 2, a5.sCapHeight = n.readShort(r2, t3), t3 += 2, a5.usDefault = n.readUshort(r2, t3), t3 += 2, a5.usBreak = n.readUshort(r2, t3), t3 += 2, a5.usMaxContext = n.readUshort(r2, t3), t3 += 2;
    }, e["OS/2"].version5 = function(r2, t3, a5) {
      var n = e._bin;
      return t3 = e["OS/2"].version2(r2, t3, a5), a5.usLowerOpticalPointSize = n.readUshort(r2, t3), t3 += 2, a5.usUpperOpticalPointSize = n.readUshort(r2, t3), t3 += 2;
    }, e.post = {}, e.post.parse = function(r2, t3, a5) {
      var n = e._bin, o = {};
      return o.version = n.readFixed(r2, t3), t3 += 4, o.italicAngle = n.readFixed(r2, t3), t3 += 4, o.underlinePosition = n.readShort(r2, t3), t3 += 2, o.underlineThickness = n.readShort(r2, t3), t3 += 2, o;
    }, null == e && (e = {}), null == e.U && (e.U = {}), e.U.codeToGlyph = function(r2, e2) {
      var t3 = r2.cmap, a5 = -1;
      if (null != t3.p0e4 ? a5 = t3.p0e4 : null != t3.p3e1 ? a5 = t3.p3e1 : null != t3.p1e0 ? a5 = t3.p1e0 : null != t3.p0e3 && (a5 = t3.p0e3), -1 == a5)
        throw "no familiar platform and encoding!";
      var n = t3.tables[a5];
      if (0 == n.format)
        return e2 >= n.map.length ? 0 : n.map[e2];
      if (4 == n.format) {
        for (var o = -1, s = 0; s < n.endCount.length; s++)
          if (e2 <= n.endCount[s]) {
            o = s;
            break;
          }
        if (-1 == o)
          return 0;
        if (n.startCount[o] > e2)
          return 0;
        return 65535 & (0 != n.idRangeOffset[o] ? n.glyphIdArray[e2 - n.startCount[o] + (n.idRangeOffset[o] >> 1) - (n.idRangeOffset.length - o)] : e2 + n.idDelta[o]);
      }
      if (12 == n.format) {
        if (e2 > n.groups[n.groups.length - 1][1])
          return 0;
        for (s = 0; s < n.groups.length; s++) {
          var i3 = n.groups[s];
          if (i3[0] <= e2 && e2 <= i3[1])
            return i3[2] + (e2 - i3[0]);
        }
        return 0;
      }
      throw "unknown cmap table format " + n.format;
    }, e.U.glyphToPath = function(r2, t3) {
      var a5 = { cmds: [], crds: [] };
      if (r2.SVG && r2.SVG.entries[t3]) {
        var n = r2.SVG.entries[t3];
        return null == n ? a5 : ("string" == typeof n && (n = e.SVG.toPath(n), r2.SVG.entries[t3] = n), n);
      }
      if (r2.CFF) {
        var o = { x: 0, y: 0, stack: [], nStems: 0, haveWidth: false, width: r2.CFF.Private ? r2.CFF.Private.defaultWidthX : 0, open: false }, s = r2.CFF, i3 = r2.CFF.Private;
        if (s.ROS) {
          for (var h = 0; s.FDSelect[h + 2] <= t3; )
            h += 2;
          i3 = s.FDArray[s.FDSelect[h + 1]].Private;
        }
        e.U._drawCFF(r2.CFF.CharStrings[t3], o, s, i3, a5);
      } else
        r2.glyf && e.U._drawGlyf(t3, r2, a5);
      return a5;
    }, e.U._drawGlyf = function(r2, t3, a5) {
      var n = t3.glyf[r2];
      null == n && (n = t3.glyf[r2] = e.glyf._parseGlyf(t3, r2)), null != n && (n.noc > -1 ? e.U._simpleGlyph(n, a5) : e.U._compoGlyph(n, t3, a5));
    }, e.U._simpleGlyph = function(r2, t3) {
      for (var a5 = 0; a5 < r2.noc; a5++) {
        for (var n = 0 == a5 ? 0 : r2.endPts[a5 - 1] + 1, o = r2.endPts[a5], s = n; s <= o; s++) {
          var i3 = s == n ? o : s - 1, h = s == o ? n : s + 1, f = 1 & r2.flags[s], d = 1 & r2.flags[i3], u = 1 & r2.flags[h], l = r2.xs[s], v = r2.ys[s];
          if (s == n)
            if (f) {
              if (!d) {
                e.U.P.moveTo(t3, l, v);
                continue;
              }
              e.U.P.moveTo(t3, r2.xs[i3], r2.ys[i3]);
            } else
              d ? e.U.P.moveTo(t3, r2.xs[i3], r2.ys[i3]) : e.U.P.moveTo(t3, (r2.xs[i3] + l) / 2, (r2.ys[i3] + v) / 2);
          f ? d && e.U.P.lineTo(t3, l, v) : u ? e.U.P.qcurveTo(t3, l, v, r2.xs[h], r2.ys[h]) : e.U.P.qcurveTo(t3, l, v, (l + r2.xs[h]) / 2, (v + r2.ys[h]) / 2);
        }
        e.U.P.closePath(t3);
      }
    }, e.U._compoGlyph = function(r2, t3, a5) {
      for (var n = 0; n < r2.parts.length; n++) {
        var o = { cmds: [], crds: [] }, s = r2.parts[n];
        e.U._drawGlyf(s.glyphIndex, t3, o);
        for (var i3 = s.m, h = 0; h < o.crds.length; h += 2) {
          var f = o.crds[h], d = o.crds[h + 1];
          a5.crds.push(f * i3.a + d * i3.b + i3.tx), a5.crds.push(f * i3.c + d * i3.d + i3.ty);
        }
        for (h = 0; h < o.cmds.length; h++)
          a5.cmds.push(o.cmds[h]);
      }
    }, e.U._getGlyphClass = function(r2, t3) {
      var a5 = e._lctf.getInterval(t3, r2);
      return -1 == a5 ? 0 : t3[a5 + 2];
    }, e.U.getPairAdjustment = function(r2, t3, a5) {
      var n = false;
      if (r2.GPOS)
        for (var o = r2.GPOS, s = o.lookupList, i3 = o.featureList, h = [], f = 0; f < i3.length; f++) {
          var d = i3[f];
          if ("kern" == d.tag) {
            n = true;
            for (var u = 0; u < d.tab.length; u++)
              if (!h[d.tab[u]]) {
                h[d.tab[u]] = true;
                for (var l = s[d.tab[u]], v = 0; v < l.tabs.length; v++)
                  if (null != l.tabs[v]) {
                    var c3, p = l.tabs[v];
                    if (!p.coverage || -1 != (c3 = e._lctf.coverageIndex(p.coverage, t3))) {
                      if (1 == l.ltype)
                        ;
                      else if (2 == l.ltype) {
                        var U = null;
                        if (1 == p.fmt) {
                          var g2 = p.pairsets[c3];
                          for (f = 0; f < g2.length; f++)
                            g2[f].gid2 == a5 && (U = g2[f]);
                        } else if (2 == p.fmt) {
                          var S = e.U._getGlyphClass(t3, p.classDef1), m = e.U._getGlyphClass(a5, p.classDef2);
                          U = p.matrix[S][m];
                        }
                        if (U) {
                          var b5 = 0;
                          return U.val1 && U.val1[2] && (b5 += U.val1[2]), U.val2 && U.val2[0] && (b5 += U.val2[0]), b5;
                        }
                      }
                    }
                  }
              }
          }
        }
      if (r2.kern && !n) {
        var y = r2.kern.glyph1.indexOf(t3);
        if (-1 != y) {
          var F = r2.kern.rval[y].glyph2.indexOf(a5);
          if (-1 != F)
            return r2.kern.rval[y].vals[F];
        }
      }
      return 0;
    }, e.U._applySubs = function(r2, t3, a5, n) {
      for (var o = r2.length - t3 - 1, s = 0; s < a5.tabs.length; s++)
        if (null != a5.tabs[s]) {
          var i3, h = a5.tabs[s];
          if (!h.coverage || -1 != (i3 = e._lctf.coverageIndex(h.coverage, r2[t3]))) {
            if (1 == a5.ltype)
              r2[t3], 1 == h.fmt ? r2[t3] = r2[t3] + h.delta : r2[t3] = h.newg[i3];
            else if (4 == a5.ltype)
              for (var f = h.vals[i3], d = 0; d < f.length; d++) {
                var u = f[d], l = u.chain.length;
                if (!(l > o)) {
                  for (var v = true, c3 = 0, p = 0; p < l; p++) {
                    for (; -1 == r2[t3 + c3 + (1 + p)]; )
                      c3++;
                    u.chain[p] != r2[t3 + c3 + (1 + p)] && (v = false);
                  }
                  if (v) {
                    r2[t3] = u.nglyph;
                    for (p = 0; p < l + c3; p++)
                      r2[t3 + p + 1] = -1;
                    break;
                  }
                }
              }
            else if (5 == a5.ltype && 2 == h.fmt)
              for (var U = e._lctf.getInterval(h.cDef, r2[t3]), g2 = h.cDef[U + 2], S = h.scset[g2], m = 0; m < S.length; m++) {
                var b5 = S[m], y = b5.input;
                if (!(y.length > o)) {
                  for (v = true, p = 0; p < y.length; p++) {
                    var F = e._lctf.getInterval(h.cDef, r2[t3 + 1 + p]);
                    if (-1 == U && h.cDef[F + 2] != y[p]) {
                      v = false;
                      break;
                    }
                  }
                  if (v) {
                    var _ = b5.substLookupRecords;
                    for (d = 0; d < _.length; d += 2)
                      _[d], _[d + 1];
                  }
                }
              }
            else if (6 == a5.ltype && 3 == h.fmt) {
              if (!e.U._glsCovered(r2, h.backCvg, t3 - h.backCvg.length))
                continue;
              if (!e.U._glsCovered(r2, h.inptCvg, t3))
                continue;
              if (!e.U._glsCovered(r2, h.ahedCvg, t3 + h.inptCvg.length))
                continue;
              var C2 = h.lookupRec;
              for (m = 0; m < C2.length; m += 2) {
                U = C2[m];
                var x = n[C2[m + 1]];
                e.U._applySubs(r2, t3 + U, x, n);
              }
            }
          }
        }
    }, e.U._glsCovered = function(r2, t3, a5) {
      for (var n = 0; n < t3.length; n++) {
        if (-1 == e._lctf.coverageIndex(t3[n], r2[a5 + n]))
          return false;
      }
      return true;
    }, e.U.glyphsToPath = function(r2, t3, a5) {
      for (var n = { cmds: [], crds: [] }, o = 0, s = 0; s < t3.length; s++) {
        var i3 = t3[s];
        if (-1 != i3) {
          for (var h = s < t3.length - 1 && -1 != t3[s + 1] ? t3[s + 1] : 0, f = e.U.glyphToPath(r2, i3), d = 0; d < f.crds.length; d += 2)
            n.crds.push(f.crds[d] + o), n.crds.push(f.crds[d + 1]);
          a5 && n.cmds.push(a5);
          for (d = 0; d < f.cmds.length; d++)
            n.cmds.push(f.cmds[d]);
          a5 && n.cmds.push("X"), o += r2.hmtx.aWidth[i3], s < t3.length - 1 && (o += e.U.getPairAdjustment(r2, i3, h));
        }
      }
      return n;
    }, e.U.P = {}, e.U.P.moveTo = function(r2, e2, t3) {
      r2.cmds.push("M"), r2.crds.push(e2, t3);
    }, e.U.P.lineTo = function(r2, e2, t3) {
      r2.cmds.push("L"), r2.crds.push(e2, t3);
    }, e.U.P.curveTo = function(r2, e2, t3, a5, n, o, s) {
      r2.cmds.push("C"), r2.crds.push(e2, t3, a5, n, o, s);
    }, e.U.P.qcurveTo = function(r2, e2, t3, a5, n) {
      r2.cmds.push("Q"), r2.crds.push(e2, t3, a5, n);
    }, e.U.P.closePath = function(r2) {
      r2.cmds.push("Z");
    }, e.U._drawCFF = function(r2, t3, a5, n, o) {
      for (var s = t3.stack, i3 = t3.nStems, h = t3.haveWidth, f = t3.width, d = t3.open, u = 0, l = t3.x, v = t3.y, c3 = 0, p = 0, U = 0, g2 = 0, S = 0, m = 0, b5 = 0, y = 0, F = 0, _ = 0, C2 = { val: 0, size: 0 }; u < r2.length; ) {
        e.CFF.getCharString(r2, u, C2);
        var x = C2.val;
        if (u += C2.size, "o1" == x || "o18" == x)
          s.length % 2 != 0 && !h && (f = s.shift() + n.nominalWidthX), i3 += s.length >> 1, s.length = 0, h = true;
        else if ("o3" == x || "o23" == x) {
          s.length % 2 != 0 && !h && (f = s.shift() + n.nominalWidthX), i3 += s.length >> 1, s.length = 0, h = true;
        } else if ("o4" == x)
          s.length > 1 && !h && (f = s.shift() + n.nominalWidthX, h = true), d && e.U.P.closePath(o), v += s.pop(), e.U.P.moveTo(o, l, v), d = true;
        else if ("o5" == x)
          for (; s.length > 0; )
            l += s.shift(), v += s.shift(), e.U.P.lineTo(o, l, v);
        else if ("o6" == x || "o7" == x)
          for (var P = s.length, I2 = "o6" == x, w = 0; w < P; w++) {
            var O = s.shift();
            I2 ? l += O : v += O, I2 = !I2, e.U.P.lineTo(o, l, v);
          }
        else if ("o8" == x || "o24" == x) {
          P = s.length;
          for (var T = 0; T + 6 <= P; )
            c3 = l + s.shift(), p = v + s.shift(), U = c3 + s.shift(), g2 = p + s.shift(), l = U + s.shift(), v = g2 + s.shift(), e.U.P.curveTo(o, c3, p, U, g2, l, v), T += 6;
          "o24" == x && (l += s.shift(), v += s.shift(), e.U.P.lineTo(o, l, v));
        } else {
          if ("o11" == x)
            break;
          if ("o1234" == x || "o1235" == x || "o1236" == x || "o1237" == x)
            "o1234" == x && (p = v, U = (c3 = l + s.shift()) + s.shift(), _ = g2 = p + s.shift(), m = g2, y = v, l = (b5 = (S = (F = U + s.shift()) + s.shift()) + s.shift()) + s.shift(), e.U.P.curveTo(o, c3, p, U, g2, F, _), e.U.P.curveTo(o, S, m, b5, y, l, v)), "o1235" == x && (c3 = l + s.shift(), p = v + s.shift(), U = c3 + s.shift(), g2 = p + s.shift(), F = U + s.shift(), _ = g2 + s.shift(), S = F + s.shift(), m = _ + s.shift(), b5 = S + s.shift(), y = m + s.shift(), l = b5 + s.shift(), v = y + s.shift(), s.shift(), e.U.P.curveTo(o, c3, p, U, g2, F, _), e.U.P.curveTo(o, S, m, b5, y, l, v)), "o1236" == x && (c3 = l + s.shift(), p = v + s.shift(), U = c3 + s.shift(), _ = g2 = p + s.shift(), m = g2, b5 = (S = (F = U + s.shift()) + s.shift()) + s.shift(), y = m + s.shift(), l = b5 + s.shift(), e.U.P.curveTo(o, c3, p, U, g2, F, _), e.U.P.curveTo(o, S, m, b5, y, l, v)), "o1237" == x && (c3 = l + s.shift(), p = v + s.shift(), U = c3 + s.shift(), g2 = p + s.shift(), F = U + s.shift(), _ = g2 + s.shift(), S = F + s.shift(), m = _ + s.shift(), b5 = S + s.shift(), y = m + s.shift(), Math.abs(b5 - l) > Math.abs(y - v) ? l = b5 + s.shift() : v = y + s.shift(), e.U.P.curveTo(o, c3, p, U, g2, F, _), e.U.P.curveTo(o, S, m, b5, y, l, v));
          else if ("o14" == x) {
            if (s.length > 0 && !h && (f = s.shift() + a5.nominalWidthX, h = true), 4 == s.length) {
              var k = s.shift(), G = s.shift(), D = s.shift(), B2 = s.shift(), L = e.CFF.glyphBySE(a5, D), R2 = e.CFF.glyphBySE(a5, B2);
              e.U._drawCFF(a5.CharStrings[L], t3, a5, n, o), t3.x = k, t3.y = G, e.U._drawCFF(a5.CharStrings[R2], t3, a5, n, o);
            }
            d && (e.U.P.closePath(o), d = false);
          } else if ("o19" == x || "o20" == x) {
            s.length % 2 != 0 && !h && (f = s.shift() + n.nominalWidthX), i3 += s.length >> 1, s.length = 0, h = true, u += i3 + 7 >> 3;
          } else if ("o21" == x)
            s.length > 2 && !h && (f = s.shift() + n.nominalWidthX, h = true), v += s.pop(), l += s.pop(), d && e.U.P.closePath(o), e.U.P.moveTo(o, l, v), d = true;
          else if ("o22" == x)
            s.length > 1 && !h && (f = s.shift() + n.nominalWidthX, h = true), l += s.pop(), d && e.U.P.closePath(o), e.U.P.moveTo(o, l, v), d = true;
          else if ("o25" == x) {
            for (; s.length > 6; )
              l += s.shift(), v += s.shift(), e.U.P.lineTo(o, l, v);
            c3 = l + s.shift(), p = v + s.shift(), U = c3 + s.shift(), g2 = p + s.shift(), l = U + s.shift(), v = g2 + s.shift(), e.U.P.curveTo(o, c3, p, U, g2, l, v);
          } else if ("o26" == x)
            for (s.length % 2 && (l += s.shift()); s.length > 0; )
              c3 = l, p = v + s.shift(), l = U = c3 + s.shift(), v = (g2 = p + s.shift()) + s.shift(), e.U.P.curveTo(o, c3, p, U, g2, l, v);
          else if ("o27" == x)
            for (s.length % 2 && (v += s.shift()); s.length > 0; )
              p = v, U = (c3 = l + s.shift()) + s.shift(), g2 = p + s.shift(), l = U + s.shift(), v = g2, e.U.P.curveTo(o, c3, p, U, g2, l, v);
          else if ("o10" == x || "o29" == x) {
            var A2 = "o10" == x ? n : a5;
            if (0 == s.length)
              console.debug("error: empty stack");
            else {
              var W = s.pop(), M = A2.Subrs[W + A2.Bias];
              t3.x = l, t3.y = v, t3.nStems = i3, t3.haveWidth = h, t3.width = f, t3.open = d, e.U._drawCFF(M, t3, a5, n, o), l = t3.x, v = t3.y, i3 = t3.nStems, h = t3.haveWidth, f = t3.width, d = t3.open;
            }
          } else if ("o30" == x || "o31" == x) {
            var V = s.length, N = (T = 0, "o31" == x);
            for (T += V - (P = -3 & V); T < P; )
              N ? (p = v, U = (c3 = l + s.shift()) + s.shift(), v = (g2 = p + s.shift()) + s.shift(), P - T == 5 ? (l = U + s.shift(), T++) : l = U, N = false) : (c3 = l, p = v + s.shift(), U = c3 + s.shift(), g2 = p + s.shift(), l = U + s.shift(), P - T == 5 ? (v = g2 + s.shift(), T++) : v = g2, N = true), e.U.P.curveTo(o, c3, p, U, g2, l, v), T += 4;
          } else {
            if ("o" == (x + "").charAt(0))
              throw console.debug("Unknown operation: " + x, r2), x;
            s.push(x);
          }
        }
      }
      t3.x = l, t3.y = v, t3.nStems = i3, t3.haveWidth = h, t3.width = f, t3.open = d;
    };
    var t2 = e, a4 = { Typr: t2 };
    return r.Typr = t2, r.default = a4, Object.defineProperty(r, "__esModule", { value: true }), r;
  }({}).Typr;
}
function woff2otfFactory() {
  return function(r) {
    var e = Uint8Array, n = Uint16Array, t2 = Uint32Array, a4 = new e([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]), i3 = new e([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]), o = new e([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), f = function(r2, e2) {
      for (var a5 = new n(31), i4 = 0; i4 < 31; ++i4)
        a5[i4] = e2 += 1 << r2[i4 - 1];
      var o2 = new t2(a5[30]);
      for (i4 = 1; i4 < 30; ++i4)
        for (var f2 = a5[i4]; f2 < a5[i4 + 1]; ++f2)
          o2[f2] = f2 - a5[i4] << 5 | i4;
      return [a5, o2];
    }, u = f(a4, 2), v = u[0], s = u[1];
    v[28] = 258, s[258] = 28;
    for (var l = f(i3, 0)[0], c3 = new n(32768), g2 = 0; g2 < 32768; ++g2) {
      var h = (43690 & g2) >>> 1 | (21845 & g2) << 1;
      h = (61680 & (h = (52428 & h) >>> 2 | (13107 & h) << 2)) >>> 4 | (3855 & h) << 4, c3[g2] = ((65280 & h) >>> 8 | (255 & h) << 8) >>> 1;
    }
    var w = function(r2, e2, t3) {
      for (var a5 = r2.length, i4 = 0, o2 = new n(e2); i4 < a5; ++i4)
        ++o2[r2[i4] - 1];
      var f2, u2 = new n(e2);
      for (i4 = 0; i4 < e2; ++i4)
        u2[i4] = u2[i4 - 1] + o2[i4 - 1] << 1;
      if (t3) {
        f2 = new n(1 << e2);
        var v4 = 15 - e2;
        for (i4 = 0; i4 < a5; ++i4)
          if (r2[i4])
            for (var s2 = i4 << 4 | r2[i4], l2 = e2 - r2[i4], g3 = u2[r2[i4] - 1]++ << l2, h2 = g3 | (1 << l2) - 1; g3 <= h2; ++g3)
              f2[c3[g3] >>> v4] = s2;
      } else
        for (f2 = new n(a5), i4 = 0; i4 < a5; ++i4)
          r2[i4] && (f2[i4] = c3[u2[r2[i4] - 1]++] >>> 15 - r2[i4]);
      return f2;
    }, d = new e(288);
    for (g2 = 0; g2 < 144; ++g2)
      d[g2] = 8;
    for (g2 = 144; g2 < 256; ++g2)
      d[g2] = 9;
    for (g2 = 256; g2 < 280; ++g2)
      d[g2] = 7;
    for (g2 = 280; g2 < 288; ++g2)
      d[g2] = 8;
    var m = new e(32);
    for (g2 = 0; g2 < 32; ++g2)
      m[g2] = 5;
    var b5 = w(d, 9, 1), p = w(m, 5, 1), y = function(r2) {
      for (var e2 = r2[0], n2 = 1; n2 < r2.length; ++n2)
        r2[n2] > e2 && (e2 = r2[n2]);
      return e2;
    }, L = function(r2, e2, n2) {
      var t3 = e2 / 8 | 0;
      return (r2[t3] | r2[t3 + 1] << 8) >> (7 & e2) & n2;
    }, U = function(r2, e2) {
      var n2 = e2 / 8 | 0;
      return (r2[n2] | r2[n2 + 1] << 8 | r2[n2 + 2] << 16) >> (7 & e2);
    }, k = ["unexpected EOF", "invalid block type", "invalid length/literal", "invalid distance", "stream finished", "no stream handler", , "no callback", "invalid UTF-8 data", "extra field too long", "date not in range 1980-2099", "filename too long", "stream finishing", "invalid zip data"], T = function(r2, e2, n2) {
      var t3 = new Error(e2 || k[r2]);
      if (t3.code = r2, Error.captureStackTrace && Error.captureStackTrace(t3, T), !n2)
        throw t3;
      return t3;
    }, O = function(r2, f2, u2) {
      var s2 = r2.length;
      if (!s2 || u2 && !u2.l && s2 < 5)
        return f2 || new e(0);
      var c4 = !f2 || u2, g3 = !u2 || u2.i;
      u2 || (u2 = {}), f2 || (f2 = new e(3 * s2));
      var h2, d2 = function(r3) {
        var n2 = f2.length;
        if (r3 > n2) {
          var t3 = new e(Math.max(2 * n2, r3));
          t3.set(f2), f2 = t3;
        }
      }, m2 = u2.f || 0, k2 = u2.p || 0, O2 = u2.b || 0, A3 = u2.l, x2 = u2.d, E = u2.m, D = u2.n, M = 8 * s2;
      do {
        if (!A3) {
          u2.f = m2 = L(r2, k2, 1);
          var S = L(r2, k2 + 1, 3);
          if (k2 += 3, !S) {
            var V = r2[(I2 = ((h2 = k2) / 8 | 0) + (7 & h2 && 1) + 4) - 4] | r2[I2 - 3] << 8, _ = I2 + V;
            if (_ > s2) {
              g3 && T(0);
              break;
            }
            c4 && d2(O2 + V), f2.set(r2.subarray(I2, _), O2), u2.b = O2 += V, u2.p = k2 = 8 * _;
            continue;
          }
          if (1 == S)
            A3 = b5, x2 = p, E = 9, D = 5;
          else if (2 == S) {
            var j = L(r2, k2, 31) + 257, z = L(r2, k2 + 10, 15) + 4, C2 = j + L(r2, k2 + 5, 31) + 1;
            k2 += 14;
            for (var F = new e(C2), P = new e(19), q = 0; q < z; ++q)
              P[o[q]] = L(r2, k2 + 3 * q, 7);
            k2 += 3 * z;
            var B2 = y(P), G = (1 << B2) - 1, H = w(P, B2, 1);
            for (q = 0; q < C2; ) {
              var I2, J = H[L(r2, k2, G)];
              if (k2 += 15 & J, (I2 = J >>> 4) < 16)
                F[q++] = I2;
              else {
                var K = 0, N = 0;
                for (16 == I2 ? (N = 3 + L(r2, k2, 3), k2 += 2, K = F[q - 1]) : 17 == I2 ? (N = 3 + L(r2, k2, 7), k2 += 3) : 18 == I2 && (N = 11 + L(r2, k2, 127), k2 += 7); N--; )
                  F[q++] = K;
              }
            }
            var Q2 = F.subarray(0, j), R2 = F.subarray(j);
            E = y(Q2), D = y(R2), A3 = w(Q2, E, 1), x2 = w(R2, D, 1);
          } else
            T(1);
          if (k2 > M) {
            g3 && T(0);
            break;
          }
        }
        c4 && d2(O2 + 131072);
        for (var W = (1 << E) - 1, X = (1 << D) - 1, Y = k2; ; Y = k2) {
          var Z = (K = A3[U(r2, k2) & W]) >>> 4;
          if ((k2 += 15 & K) > M) {
            g3 && T(0);
            break;
          }
          if (K || T(2), Z < 256)
            f2[O2++] = Z;
          else {
            if (256 == Z) {
              Y = k2, A3 = null;
              break;
            }
            var $ = Z - 254;
            if (Z > 264) {
              var rr = a4[q = Z - 257];
              $ = L(r2, k2, (1 << rr) - 1) + v[q], k2 += rr;
            }
            var er = x2[U(r2, k2) & X], nr = er >>> 4;
            er || T(3), k2 += 15 & er;
            R2 = l[nr];
            if (nr > 3) {
              rr = i3[nr];
              R2 += U(r2, k2) & (1 << rr) - 1, k2 += rr;
            }
            if (k2 > M) {
              g3 && T(0);
              break;
            }
            c4 && d2(O2 + 131072);
            for (var tr = O2 + $; O2 < tr; O2 += 4)
              f2[O2] = f2[O2 - R2], f2[O2 + 1] = f2[O2 + 1 - R2], f2[O2 + 2] = f2[O2 + 2 - R2], f2[O2 + 3] = f2[O2 + 3 - R2];
            O2 = tr;
          }
        }
        u2.l = A3, u2.p = Y, u2.b = O2, A3 && (m2 = 1, u2.m = E, u2.d = x2, u2.n = D);
      } while (!m2);
      return O2 == f2.length ? f2 : function(r3, a5, i4) {
        (null == a5 || a5 < 0) && (a5 = 0), (null == i4 || i4 > r3.length) && (i4 = r3.length);
        var o2 = new (r3 instanceof n ? n : r3 instanceof t2 ? t2 : e)(i4 - a5);
        return o2.set(r3.subarray(a5, i4)), o2;
      }(f2, 0, O2);
    }, A2 = new e(0);
    var x = "undefined" != typeof TextDecoder && new TextDecoder();
    try {
      x.decode(A2, { stream: true }), 1;
    } catch (r2) {
    }
    return r.convert_streams = function(r2) {
      var e2 = new DataView(r2), n2 = 0;
      function t3() {
        var r3 = e2.getUint16(n2);
        return n2 += 2, r3;
      }
      function a5() {
        var r3 = e2.getUint32(n2);
        return n2 += 4, r3;
      }
      function i4(r3) {
        m2.setUint16(b6, r3), b6 += 2;
      }
      function o2(r3) {
        m2.setUint32(b6, r3), b6 += 4;
      }
      for (var f2 = { signature: a5(), flavor: a5(), length: a5(), numTables: t3(), reserved: t3(), totalSfntSize: a5(), majorVersion: t3(), minorVersion: t3(), metaOffset: a5(), metaLength: a5(), metaOrigLength: a5(), privOffset: a5(), privLength: a5() }, u2 = 0; Math.pow(2, u2) <= f2.numTables; )
        u2++;
      u2--;
      for (var v4 = 16 * Math.pow(2, u2), s2 = 16 * f2.numTables - v4, l2 = 12, c4 = [], g3 = 0; g3 < f2.numTables; g3++)
        c4.push({ tag: a5(), offset: a5(), compLength: a5(), origLength: a5(), origChecksum: a5() }), l2 += 16;
      var h2, w2 = new Uint8Array(12 + 16 * c4.length + c4.reduce(function(r3, e3) {
        return r3 + e3.origLength + 4;
      }, 0)), d2 = w2.buffer, m2 = new DataView(d2), b6 = 0;
      return o2(f2.flavor), i4(f2.numTables), i4(v4), i4(u2), i4(s2), c4.forEach(function(r3) {
        o2(r3.tag), o2(r3.origChecksum), o2(l2), o2(r3.origLength), r3.outOffset = l2, (l2 += r3.origLength) % 4 != 0 && (l2 += 4 - l2 % 4);
      }), c4.forEach(function(e3) {
        var n3, t4 = r2.slice(e3.offset, e3.offset + e3.compLength);
        if (e3.compLength != e3.origLength) {
          var a6 = new Uint8Array(e3.origLength);
          n3 = new Uint8Array(t4, 2), O(n3, a6);
        } else
          a6 = new Uint8Array(t4);
        w2.set(a6, e3.outOffset);
        var i5 = 0;
        (l2 = e3.outOffset + e3.origLength) % 4 != 0 && (i5 = 4 - l2 % 4), w2.set(new Uint8Array(i5).buffer, e3.outOffset + e3.origLength), h2 = l2 + i5;
      }), d2.slice(0, h2);
    }, Object.defineProperty(r, "__esModule", { value: true }), r;
  }({}).convert_streams;
}
function parserFactory(Typr, woff2otf) {
  const cmdArgLengths = {
    M: 2,
    L: 2,
    Q: 4,
    C: 6,
    Z: 0
  };
  const joiningTypeRawData = { "C": "18g,ca,368,1kz", "D": "17k,6,2,2+4,5+c,2+6,2+1,10+1,9+f,j+11,2+1,a,2,2+1,15+2,3,j+2,6+3,2+8,2,2,2+1,w+a,4+e,3+3,2,3+2,3+5,23+w,2f+4,3,2+9,2,b,2+3,3,1k+9,6+1,3+1,2+2,2+d,30g,p+y,1,1+1g,f+x,2,sd2+1d,jf3+4,f+3,2+4,2+2,b+3,42,2,4+2,2+1,2,3,t+1,9f+w,2,el+2,2+g,d+2,2l,2+1,5,3+1,2+1,2,3,6,16wm+1v", "R": "17m+3,2,2,6+3,m,15+2,2+2,h+h,13,3+8,2,2,3+1,2,p+1,x,5+4,5,a,2,2,3,u,c+2,g+1,5,2+1,4+1,5j,6+1,2,b,2+2,f,2+1,1s+2,2,3+1,7,1ez0,2,2+1,4+4,b,4,3,b,42,2+2,4,3,2+1,2,o+3,ae,ep,x,2o+2,3+1,3,5+1,6", "L": "x9u,jff,a,fd,jv", "T": "4t,gj+33,7o+4,1+1,7c+18,2,2+1,2+1,2,21+a,2,1b+k,h,2u+6,3+5,3+1,2+3,y,2,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,3,7,6+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+d,1,1+1,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,ek,3+1,r+4,1e+4,6+5,2p+c,1+3,1,1+2,1+b,2db+2,3y,2p+v,ff+3,30+1,n9x,1+2,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,5s,6y+2,ea,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+9,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2,2b+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,470+8,at4+4,1o+6,t5,1s+3,2a,f5l+1,2+3,43o+2,a+7,1+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,1,gzau,v+2n,3l+6n" };
  const JT_LEFT = 1, JT_RIGHT = 2, JT_DUAL = 4, JT_TRANSPARENT = 8, JT_JOIN_CAUSING = 16, JT_NON_JOINING = 32;
  let joiningTypeMap;
  function getCharJoiningType(ch4) {
    if (!joiningTypeMap) {
      const m = {
        R: JT_RIGHT,
        L: JT_LEFT,
        D: JT_DUAL,
        C: JT_JOIN_CAUSING,
        U: JT_NON_JOINING,
        T: JT_TRANSPARENT
      };
      joiningTypeMap = /* @__PURE__ */ new Map();
      for (let type in joiningTypeRawData) {
        let lastCode = 0;
        joiningTypeRawData[type].split(",").forEach((range2) => {
          let [skip2, step] = range2.split("+");
          skip2 = parseInt(skip2, 36);
          step = step ? parseInt(step, 36) : 0;
          joiningTypeMap.set(lastCode += skip2, m[type]);
          for (let i3 = step; i3--; ) {
            joiningTypeMap.set(++lastCode, m[type]);
          }
        });
      }
    }
    return joiningTypeMap.get(ch4) || JT_NON_JOINING;
  }
  const ISOL = 1, INIT = 2, FINA = 3, MEDI = 4;
  const formsToFeatures = [null, "isol", "init", "fina", "medi"];
  function detectJoiningForms(str) {
    const joiningForms = new Uint8Array(str.length);
    let prevJoiningType = JT_NON_JOINING;
    let prevForm = ISOL;
    let prevIndex = -1;
    for (let i3 = 0; i3 < str.length; i3++) {
      const code = str.codePointAt(i3);
      let joiningType = getCharJoiningType(code) | 0;
      let form = ISOL;
      if (joiningType & JT_TRANSPARENT) {
        continue;
      }
      if (prevJoiningType & (JT_LEFT | JT_DUAL | JT_JOIN_CAUSING)) {
        if (joiningType & (JT_RIGHT | JT_DUAL | JT_JOIN_CAUSING)) {
          form = FINA;
          if (prevForm === ISOL || prevForm === FINA) {
            joiningForms[prevIndex]++;
          }
        } else if (joiningType & (JT_LEFT | JT_NON_JOINING)) {
          if (prevForm === INIT || prevForm === MEDI) {
            joiningForms[prevIndex]--;
          }
        }
      } else if (prevJoiningType & (JT_RIGHT | JT_NON_JOINING)) {
        if (prevForm === INIT || prevForm === MEDI) {
          joiningForms[prevIndex]--;
        }
      }
      prevForm = joiningForms[i3] = form;
      prevJoiningType = joiningType;
      prevIndex = i3;
      if (code > 65535)
        i3++;
    }
    return joiningForms;
  }
  function stringToGlyphs(font, str) {
    const glyphIds = [];
    for (let i3 = 0; i3 < str.length; i3++) {
      const cc = str.codePointAt(i3);
      if (cc > 65535)
        i3++;
      glyphIds.push(Typr.U.codeToGlyph(font, cc));
    }
    const gsub2 = font["GSUB"];
    if (gsub2) {
      const { lookupList, featureList } = gsub2;
      let joiningForms;
      const supportedFeatures = /^(rlig|liga|mset|isol|init|fina|medi|half|pres|blws)$/;
      const usedLookups = [];
      featureList.forEach((feature) => {
        if (supportedFeatures.test(feature.tag)) {
          for (let ti = 0; ti < feature.tab.length; ti++) {
            if (usedLookups[feature.tab[ti]])
              continue;
            usedLookups[feature.tab[ti]] = true;
            const tab = lookupList[feature.tab[ti]];
            const isJoiningFeature = /^(isol|init|fina|medi)$/.test(feature.tag);
            if (isJoiningFeature && !joiningForms) {
              joiningForms = detectJoiningForms(str);
            }
            for (let ci = 0; ci < glyphIds.length; ci++) {
              if (!joiningForms || !isJoiningFeature || formsToFeatures[joiningForms[ci]] === feature.tag) {
                Typr.U._applySubs(glyphIds, ci, tab, lookupList);
              }
            }
          }
        }
      });
    }
    return glyphIds;
  }
  function firstNum(...args) {
    for (let i3 = 0; i3 < args.length; i3++) {
      if (typeof args[i3] === "number") {
        return args[i3];
      }
    }
  }
  function wrapFontObj(typrFont) {
    const glyphMap = /* @__PURE__ */ Object.create(null);
    const os22 = typrFont["OS/2"];
    const hhea2 = typrFont.hhea;
    const unitsPerEm = typrFont.head.unitsPerEm;
    const ascender = firstNum(os22 && os22.sTypoAscender, hhea2 && hhea2.ascender, unitsPerEm);
    const fontObj = {
      unitsPerEm,
      ascender,
      descender: firstNum(os22 && os22.sTypoDescender, hhea2 && hhea2.descender, 0),
      capHeight: firstNum(os22 && os22.sCapHeight, ascender),
      xHeight: firstNum(os22 && os22.sxHeight, ascender),
      lineGap: firstNum(os22 && os22.sTypoLineGap, hhea2 && hhea2.lineGap),
      forEachGlyph(text, fontSize, letterSpacing, callback) {
        let glyphX = 0;
        const fontScale = 1 / fontObj.unitsPerEm * fontSize;
        const glyphIndices = stringToGlyphs(typrFont, text);
        let charIndex = 0;
        let prevGlyphIndex = -1;
        glyphIndices.forEach((glyphIndex, i3) => {
          if (glyphIndex !== -1) {
            let glyphObj = glyphMap[glyphIndex];
            if (!glyphObj) {
              const { cmds, crds } = Typr.U.glyphToPath(typrFont, glyphIndex);
              let path = "";
              let crdsIdx = 0;
              for (let i4 = 0, len = cmds.length; i4 < len; i4++) {
                const numArgs = cmdArgLengths[cmds[i4]];
                path += cmds[i4];
                for (let j = 1; j <= numArgs; j++) {
                  path += (j > 1 ? "," : "") + crds[crdsIdx++];
                }
              }
              let xMin, yMin, xMax, yMax;
              if (crds.length) {
                xMin = yMin = Infinity;
                xMax = yMax = -Infinity;
                for (let i4 = 0, len = crds.length; i4 < len; i4 += 2) {
                  let x = crds[i4];
                  let y = crds[i4 + 1];
                  if (x < xMin)
                    xMin = x;
                  if (y < yMin)
                    yMin = y;
                  if (x > xMax)
                    xMax = x;
                  if (y > yMax)
                    yMax = y;
                }
              } else {
                xMin = xMax = yMin = yMax = 0;
              }
              glyphObj = glyphMap[glyphIndex] = {
                index: glyphIndex,
                advanceWidth: typrFont.hmtx.aWidth[glyphIndex],
                xMin,
                yMin,
                xMax,
                yMax,
                path,
                pathCommandCount: cmds.length
                // forEachPathCommand(callback) {
                //   let argsIndex = 0
                //   const argsArray = []
                //   for (let i = 0, len = cmds.length; i < len; i++) {
                //     const numArgs = cmdArgLengths[cmds[i]]
                //     argsArray.length = 1 + numArgs
                //     argsArray[0] = cmds[i]
                //     for (let j = 1; j <= numArgs; j++) {
                //       argsArray[j] = crds[argsIndex++]
                //     }
                //     callback.apply(null, argsArray)
                //   }
                // }
              };
            }
            if (prevGlyphIndex !== -1) {
              glyphX += Typr.U.getPairAdjustment(typrFont, prevGlyphIndex, glyphIndex) * fontScale;
            }
            callback.call(null, glyphObj, glyphX, charIndex);
            if (glyphObj.advanceWidth) {
              glyphX += glyphObj.advanceWidth * fontScale;
            }
            if (letterSpacing) {
              glyphX += letterSpacing * fontSize;
            }
            prevGlyphIndex = glyphIndex;
          }
          charIndex += text.codePointAt(charIndex) > 65535 ? 2 : 1;
        });
        return glyphX;
      }
    };
    return fontObj;
  }
  return function parse2(buffer) {
    const peek = new Uint8Array(buffer, 0, 4);
    const tag = Typr._bin.readASCII(peek, 0, 4);
    if (tag === "wOFF") {
      buffer = woff2otf(buffer);
    } else if (tag === "wOF2") {
      throw new Error("woff2 fonts not supported");
    }
    return wrapFontObj(Typr.parse(buffer)[0]);
  };
}
var workerModule = defineWorkerModule({
  name: "Typr Font Parser",
  dependencies: [typrFactory, woff2otfFactory, parserFactory],
  init(typrFactory2, woff2otfFactory2, parserFactory2) {
    const Typr = typrFactory2();
    const woff2otf = woff2otfFactory2();
    return parserFactory2(Typr, woff2otf);
  }
});
var CONFIG = {
  defaultFontURL: "https://fonts.gstatic.com/s/roboto/v18/KFOmCnqEu92Fr1Mu4mxM.woff",
  //Roboto Regular
  sdfGlyphSize: 64,
  sdfMargin: 1 / 16,
  sdfExponent: 9,
  textureWidth: 2048
};
var tempColor = new Color();
var hasRequested = false;
function now$1() {
  return (self.performance || Date).now();
}
var atlases = /* @__PURE__ */ Object.create(null);
function getTextRenderInfo(args, callback) {
  hasRequested = true;
  args = assign2({}, args);
  const totalStart = now$1();
  args.font = toAbsoluteURL(args.font || CONFIG.defaultFontURL);
  args.text = "" + args.text;
  args.sdfGlyphSize = args.sdfGlyphSize || CONFIG.sdfGlyphSize;
  if (args.colorRanges != null) {
    let colors = {};
    for (let key in args.colorRanges) {
      if (args.colorRanges.hasOwnProperty(key)) {
        let val = args.colorRanges[key];
        if (typeof val !== "number") {
          val = tempColor.set(val).getHex();
        }
        colors[key] = val;
      }
    }
    args.colorRanges = colors;
  }
  Object.freeze(args);
  const { textureWidth, sdfExponent } = CONFIG;
  const { sdfGlyphSize } = args;
  const glyphsPerRow = textureWidth / sdfGlyphSize * 4;
  let atlas = atlases[sdfGlyphSize];
  if (!atlas) {
    const canvas = document.createElement("canvas");
    canvas.width = textureWidth;
    canvas.height = sdfGlyphSize * 256 / glyphsPerRow;
    atlas = atlases[sdfGlyphSize] = {
      glyphCount: 0,
      sdfGlyphSize,
      sdfCanvas: canvas,
      sdfTexture: new Texture(
        canvas,
        void 0,
        void 0,
        void 0,
        LinearFilter,
        LinearFilter
      ),
      contextLost: false,
      glyphsByFont: /* @__PURE__ */ new Map()
    };
    atlas.sdfTexture.generateMipmaps = false;
    initContextLossHandling(atlas);
  }
  const { sdfTexture, sdfCanvas } = atlas;
  let fontGlyphs = atlas.glyphsByFont.get(args.font);
  if (!fontGlyphs) {
    atlas.glyphsByFont.set(args.font, fontGlyphs = /* @__PURE__ */ new Map());
  }
  typesetInWorker(args).then((result) => {
    const { glyphIds, glyphPositions, fontSize, unitsPerEm, timings } = result;
    const neededSDFs = [];
    const glyphBounds = new Float32Array(glyphIds.length * 4);
    const fontSizeMult = fontSize / unitsPerEm;
    let boundsIdx = 0;
    let positionsIdx = 0;
    const quadsStart = now$1();
    glyphIds.forEach((glyphId, i3) => {
      let glyphInfo = fontGlyphs.get(glyphId);
      if (!glyphInfo) {
        const { path, pathBounds } = result.glyphData[glyphId];
        const fontUnitsMargin = Math.max(pathBounds[2] - pathBounds[0], pathBounds[3] - pathBounds[1]) / sdfGlyphSize * (CONFIG.sdfMargin * sdfGlyphSize + 0.5);
        const atlasIndex = atlas.glyphCount++;
        const sdfViewBox2 = [
          pathBounds[0] - fontUnitsMargin,
          pathBounds[1] - fontUnitsMargin,
          pathBounds[2] + fontUnitsMargin,
          pathBounds[3] + fontUnitsMargin
        ];
        fontGlyphs.set(glyphId, glyphInfo = { path, atlasIndex, sdfViewBox: sdfViewBox2 });
        neededSDFs.push(glyphInfo);
      }
      const { sdfViewBox } = glyphInfo;
      const posX = glyphPositions[positionsIdx++];
      const posY = glyphPositions[positionsIdx++];
      glyphBounds[boundsIdx++] = posX + sdfViewBox[0] * fontSizeMult;
      glyphBounds[boundsIdx++] = posY + sdfViewBox[1] * fontSizeMult;
      glyphBounds[boundsIdx++] = posX + sdfViewBox[2] * fontSizeMult;
      glyphBounds[boundsIdx++] = posY + sdfViewBox[3] * fontSizeMult;
      glyphIds[i3] = glyphInfo.atlasIndex;
    });
    timings.quads = (timings.quads || 0) + (now$1() - quadsStart);
    const sdfStart = now$1();
    timings.sdf = {};
    const currentHeight = sdfCanvas.height;
    const neededRows = Math.ceil(atlas.glyphCount / glyphsPerRow);
    const neededHeight = Math.pow(2, Math.ceil(Math.log2(neededRows * sdfGlyphSize)));
    if (neededHeight > currentHeight) {
      console.info(`Increasing SDF texture size ${currentHeight}->${neededHeight}`);
      resizeWebGLCanvasWithoutClearing(sdfCanvas, textureWidth, neededHeight);
      sdfTexture.dispose();
    }
    Promise.all(neededSDFs.map(
      (glyphInfo) => generateGlyphSDF(glyphInfo, atlas, args.gpuAccelerateSDF).then(({ timing }) => {
        timings.sdf[glyphInfo.atlasIndex] = timing;
      })
    )).then(() => {
      if (neededSDFs.length && !atlas.contextLost) {
        safariPre15Workaround(atlas);
        sdfTexture.needsUpdate = true;
      }
      timings.sdfTotal = now$1() - sdfStart;
      timings.total = now$1() - totalStart;
      callback(Object.freeze({
        parameters: args,
        sdfTexture,
        sdfGlyphSize,
        sdfExponent,
        glyphBounds,
        glyphAtlasIndices: glyphIds,
        glyphColors: result.glyphColors,
        caretPositions: result.caretPositions,
        caretHeight: result.caretHeight,
        chunkedBounds: result.chunkedBounds,
        ascender: result.ascender,
        descender: result.descender,
        lineHeight: result.lineHeight,
        capHeight: result.capHeight,
        xHeight: result.xHeight,
        topBaseline: result.topBaseline,
        blockBounds: result.blockBounds,
        visibleBounds: result.visibleBounds,
        timings: result.timings
      }));
    });
  });
  Promise.resolve().then(() => {
    if (!atlas.contextLost) {
      warmUpSDFCanvas(sdfCanvas);
    }
  });
}
function generateGlyphSDF({ path, atlasIndex, sdfViewBox }, { sdfGlyphSize, sdfCanvas, contextLost }, useGPU) {
  if (contextLost) {
    return Promise.resolve({ timing: -1 });
  }
  const { textureWidth, sdfExponent } = CONFIG;
  const maxDist = Math.max(sdfViewBox[2] - sdfViewBox[0], sdfViewBox[3] - sdfViewBox[1]);
  const squareIndex = Math.floor(atlasIndex / 4);
  const x = squareIndex % (textureWidth / sdfGlyphSize) * sdfGlyphSize;
  const y = Math.floor(squareIndex / (textureWidth / sdfGlyphSize)) * sdfGlyphSize;
  const channel = atlasIndex % 4;
  return generateSDF(sdfGlyphSize, sdfGlyphSize, path, sdfViewBox, maxDist, sdfExponent, sdfCanvas, x, y, channel, useGPU);
}
function initContextLossHandling(atlas) {
  const canvas = atlas.sdfCanvas;
  canvas.addEventListener("webglcontextlost", (event) => {
    console.log("Context Lost", event);
    event.preventDefault();
    atlas.contextLost = true;
  });
  canvas.addEventListener("webglcontextrestored", (event) => {
    console.log("Context Restored", event);
    atlas.contextLost = false;
    const promises = [];
    atlas.glyphsByFont.forEach((glyphMap) => {
      glyphMap.forEach((glyph) => {
        promises.push(generateGlyphSDF(glyph, atlas, true));
      });
    });
    Promise.all(promises).then(() => {
      safariPre15Workaround(atlas);
      atlas.sdfTexture.needsUpdate = true;
    });
  });
}
function preloadFont({ font, characters, sdfGlyphSize }, callback) {
  let text = Array.isArray(characters) ? characters.join("\n") : "" + characters;
  getTextRenderInfo({ font, sdfGlyphSize, text }, callback);
}
function assign2(toObj, fromObj) {
  for (let key in fromObj) {
    if (fromObj.hasOwnProperty(key)) {
      toObj[key] = fromObj[key];
    }
  }
  return toObj;
}
var linkEl;
function toAbsoluteURL(path) {
  if (!linkEl) {
    linkEl = typeof document === "undefined" ? {} : document.createElement("a");
  }
  linkEl.href = path;
  return linkEl.href;
}
function safariPre15Workaround(atlas) {
  if (typeof createImageBitmap !== "function") {
    console.info("Safari<15: applying SDF canvas workaround");
    const { sdfCanvas, sdfTexture } = atlas;
    const { width, height } = sdfCanvas;
    const gl = atlas.sdfCanvas.getContext("webgl");
    let pixels = sdfTexture.image.data;
    if (!pixels || pixels.length !== width * height * 4) {
      pixels = new Uint8Array(width * height * 4);
      sdfTexture.image = { width, height, data: pixels };
      sdfTexture.flipY = false;
      sdfTexture.isDataTexture = true;
    }
    gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
  }
}
var typesetterWorkerModule = defineWorkerModule({
  name: "Typesetter",
  dependencies: [
    CONFIG,
    workerModule,
    createTypesetter,
    bidi_default
  ],
  init(config3, fontParser, createTypesetter2, bidiFactory2) {
    const { defaultFontURL } = config3;
    return createTypesetter2(fontParser, bidiFactory2(), { defaultFontURL });
  }
});
var typesetInWorker = defineWorkerModule({
  name: "Typesetter",
  dependencies: [
    typesetterWorkerModule
  ],
  init(typesetter) {
    return function(args) {
      return new Promise((resolve) => {
        typesetter.typeset(args, resolve);
      });
    };
  },
  getTransferables(result) {
    const transferables = [
      result.glyphPositions.buffer,
      result.glyphIds.buffer
    ];
    if (result.caretPositions) {
      transferables.push(result.caretPositions.buffer);
    }
    if (result.glyphColors) {
      transferables.push(result.glyphColors.buffer);
    }
    return transferables;
  }
});
var templateGeometries = {};
function getTemplateGeometry(detail) {
  let geom = templateGeometries[detail];
  if (!geom) {
    const front = new PlaneGeometry(1, 1, detail, detail);
    const back = front.clone();
    const frontAttrs = front.attributes;
    const backAttrs = back.attributes;
    const combined = new BufferGeometry();
    const vertCount = frontAttrs.uv.count;
    for (let i3 = 0; i3 < vertCount; i3++) {
      backAttrs.position.array[i3 * 3] *= -1;
      backAttrs.normal.array[i3 * 3 + 2] *= -1;
    }
    ["position", "normal", "uv"].forEach((name) => {
      combined.setAttribute(
        name,
        new Float32BufferAttribute(
          [...frontAttrs[name].array, ...backAttrs[name].array],
          frontAttrs[name].itemSize
        )
      );
    });
    combined.setIndex([...front.index.array, ...back.index.array.map((n) => n + vertCount)]);
    combined.translate(0.5, 0.5, 0);
    geom = templateGeometries[detail] = combined;
  }
  return geom;
}
var glyphBoundsAttrName = "aTroikaGlyphBounds";
var glyphIndexAttrName = "aTroikaGlyphIndex";
var glyphColorAttrName = "aTroikaGlyphColor";
var GlyphsGeometry = class extends InstancedBufferGeometry {
  constructor() {
    super();
    this.detail = 1;
    this.curveRadius = 0;
    this.groups = [
      { start: 0, count: Infinity, materialIndex: 0 },
      { start: 0, count: Infinity, materialIndex: 1 }
    ];
    this.boundingSphere = new Sphere();
    this.boundingBox = new Box3();
  }
  computeBoundingSphere() {
  }
  computeBoundingBox() {
  }
  // Since our base geometry contains triangles for both front and back sides, we can emulate
  // the "side" by restricting the draw range.
  setSide(side) {
    const verts = this.getIndex().count;
    this.setDrawRange(side === BackSide ? verts / 2 : 0, side === DoubleSide ? verts : verts / 2);
  }
  set detail(detail) {
    if (detail !== this._detail) {
      this._detail = detail;
      if (typeof detail !== "number" || detail < 1) {
        detail = 1;
      }
      let tpl = getTemplateGeometry(detail);
      ["position", "normal", "uv"].forEach((attr) => {
        this.attributes[attr] = tpl.attributes[attr].clone();
      });
      this.setIndex(tpl.getIndex().clone());
    }
  }
  get detail() {
    return this._detail;
  }
  set curveRadius(r) {
    if (r !== this._curveRadius) {
      this._curveRadius = r;
      this._updateBounds();
    }
  }
  get curveRadius() {
    return this._curveRadius;
  }
  /**
   * Update the geometry for a new set of glyphs.
   * @param {Float32Array} glyphBounds - An array holding the planar bounds for all glyphs
   *        to be rendered, 4 entries for each glyph: x1,x2,y1,y1
   * @param {Float32Array} glyphAtlasIndices - An array holding the index of each glyph within
   *        the SDF atlas texture.
   * @param {Array} blockBounds - An array holding the [minX, minY, maxX, maxY] across all glyphs
   * @param {Array} [chunkedBounds] - An array of objects describing bounds for each chunk of N
   *        consecutive glyphs: `{start:N, end:N, rect:[minX, minY, maxX, maxY]}`. This can be
   *        used with `applyClipRect` to choose an optimized `instanceCount`.
   * @param {Uint8Array} [glyphColors] - An array holding r,g,b values for each glyph.
   */
  updateGlyphs(glyphBounds, glyphAtlasIndices, blockBounds, chunkedBounds, glyphColors) {
    updateBufferAttr(this, glyphBoundsAttrName, glyphBounds, 4);
    updateBufferAttr(this, glyphIndexAttrName, glyphAtlasIndices, 1);
    updateBufferAttr(this, glyphColorAttrName, glyphColors, 3);
    this._blockBounds = blockBounds;
    this._chunkedBounds = chunkedBounds;
    this.instanceCount = glyphAtlasIndices.length;
    this._updateBounds();
  }
  _updateBounds() {
    const bounds = this._blockBounds;
    if (bounds) {
      const { curveRadius, boundingBox: bbox } = this;
      if (curveRadius) {
        const { PI, floor, min, max: max3, sin, cos } = Math;
        const halfPi = PI / 2;
        const twoPi = PI * 2;
        const absR = Math.abs(curveRadius);
        const leftAngle = bounds[0] / absR;
        const rightAngle = bounds[2] / absR;
        const minX = floor((leftAngle + halfPi) / twoPi) !== floor((rightAngle + halfPi) / twoPi) ? -absR : min(sin(leftAngle) * absR, sin(rightAngle) * absR);
        const maxX = floor((leftAngle - halfPi) / twoPi) !== floor((rightAngle - halfPi) / twoPi) ? absR : max3(sin(leftAngle) * absR, sin(rightAngle) * absR);
        const maxZ = floor((leftAngle + PI) / twoPi) !== floor((rightAngle + PI) / twoPi) ? absR * 2 : max3(absR - cos(leftAngle) * absR, absR - cos(rightAngle) * absR);
        bbox.min.set(minX, bounds[1], curveRadius < 0 ? -maxZ : 0);
        bbox.max.set(maxX, bounds[3], curveRadius < 0 ? 0 : maxZ);
      } else {
        bbox.min.set(bounds[0], bounds[1], 0);
        bbox.max.set(bounds[2], bounds[3], 0);
      }
      bbox.getBoundingSphere(this.boundingSphere);
    }
  }
  /**
   * Given a clipping rect, and the chunkedBounds from the last updateGlyphs call, choose the lowest
   * `instanceCount` that will show all glyphs within the clipped view. This is an optimization
   * for long blocks of text that are clipped, to skip vertex shader evaluation for glyphs that would
   * be clipped anyway.
   *
   * Note that since `drawElementsInstanced[ANGLE]` only accepts an instance count and not a starting
   * offset, this optimization becomes less effective as the clipRect moves closer to the end of the
   * text block. We could fix that by switching from instancing to a full geometry with a drawRange,
   * but at the expense of much larger attribute buffers (see classdoc above.)
   *
   * @param {Vector4} clipRect
   */
  applyClipRect(clipRect) {
    let count = this.getAttribute(glyphIndexAttrName).count;
    let chunks = this._chunkedBounds;
    if (chunks) {
      for (let i3 = chunks.length; i3--; ) {
        count = chunks[i3].end;
        let rect = chunks[i3].rect;
        if (rect[1] < clipRect.w && rect[3] > clipRect.y && rect[0] < clipRect.z && rect[2] > clipRect.x) {
          break;
        }
      }
    }
    this.instanceCount = count;
  }
};
function updateBufferAttr(geom, attrName, newArray, itemSize) {
  const attr = geom.getAttribute(attrName);
  if (newArray) {
    if (attr && attr.array.length === newArray.length) {
      attr.array.set(newArray);
      attr.needsUpdate = true;
    } else {
      geom.setAttribute(attrName, new InstancedBufferAttribute(newArray, itemSize));
      delete geom._maxInstanceCount;
      geom.dispose();
    }
  } else if (attr) {
    geom.deleteAttribute(attrName);
  }
}
var VERTEX_DEFS = `
uniform vec2 uTroikaSDFTextureSize;
uniform float uTroikaSDFGlyphSize;
uniform vec4 uTroikaTotalBounds;
uniform vec4 uTroikaClipRect;
uniform mat3 uTroikaOrient;
uniform bool uTroikaUseGlyphColors;
uniform float uTroikaDistanceOffset;
uniform float uTroikaBlurRadius;
uniform vec2 uTroikaPositionOffset;
uniform float uTroikaCurveRadius;
attribute vec4 aTroikaGlyphBounds;
attribute float aTroikaGlyphIndex;
attribute vec3 aTroikaGlyphColor;
varying vec2 vTroikaGlyphUV;
varying vec4 vTroikaTextureUVBounds;
varying float vTroikaTextureChannel;
varying vec3 vTroikaGlyphColor;
varying vec2 vTroikaGlyphDimensions;
`;
var VERTEX_TRANSFORM = `
vec4 bounds = aTroikaGlyphBounds;
bounds.xz += uTroikaPositionOffset.x;
bounds.yw -= uTroikaPositionOffset.y;

vec4 outlineBounds = vec4(
  bounds.xy - uTroikaDistanceOffset - uTroikaBlurRadius,
  bounds.zw + uTroikaDistanceOffset + uTroikaBlurRadius
);
vec4 clippedBounds = vec4(
  clamp(outlineBounds.xy, uTroikaClipRect.xy, uTroikaClipRect.zw),
  clamp(outlineBounds.zw, uTroikaClipRect.xy, uTroikaClipRect.zw)
);

vec2 clippedXY = (mix(clippedBounds.xy, clippedBounds.zw, position.xy) - bounds.xy) / (bounds.zw - bounds.xy);

position.xy = mix(bounds.xy, bounds.zw, clippedXY);

uv = (position.xy - uTroikaTotalBounds.xy) / (uTroikaTotalBounds.zw - uTroikaTotalBounds.xy);

float rad = uTroikaCurveRadius;
if (rad != 0.0) {
  float angle = position.x / rad;
  position.xz = vec2(sin(angle) * rad, rad - cos(angle) * rad);
  normal.xz = vec2(sin(angle), cos(angle));
}
  
position = uTroikaOrient * position;
normal = uTroikaOrient * normal;

vTroikaGlyphUV = clippedXY.xy;
vTroikaGlyphDimensions = vec2(bounds[2] - bounds[0], bounds[3] - bounds[1]);

${""}
float txCols = uTroikaSDFTextureSize.x / uTroikaSDFGlyphSize;
vec2 txUvPerSquare = uTroikaSDFGlyphSize / uTroikaSDFTextureSize;
vec2 txStartUV = txUvPerSquare * vec2(
  mod(floor(aTroikaGlyphIndex / 4.0), txCols),
  floor(floor(aTroikaGlyphIndex / 4.0) / txCols)
);
vTroikaTextureUVBounds = vec4(txStartUV, vec2(txStartUV) + txUvPerSquare);
vTroikaTextureChannel = mod(aTroikaGlyphIndex, 4.0);
`;
var FRAGMENT_DEFS = `
uniform sampler2D uTroikaSDFTexture;
uniform vec2 uTroikaSDFTextureSize;
uniform float uTroikaSDFGlyphSize;
uniform float uTroikaSDFExponent;
uniform float uTroikaDistanceOffset;
uniform float uTroikaFillOpacity;
uniform float uTroikaOutlineOpacity;
uniform float uTroikaBlurRadius;
uniform vec3 uTroikaStrokeColor;
uniform float uTroikaStrokeWidth;
uniform float uTroikaStrokeOpacity;
uniform bool uTroikaSDFDebug;
varying vec2 vTroikaGlyphUV;
varying vec4 vTroikaTextureUVBounds;
varying float vTroikaTextureChannel;
varying vec2 vTroikaGlyphDimensions;

float troikaSdfValueToSignedDistance(float alpha) {
  // Inverse of exponential encoding in webgl-sdf-generator
  ${""}
  float maxDimension = max(vTroikaGlyphDimensions.x, vTroikaGlyphDimensions.y);
  float absDist = (1.0 - pow(2.0 * (alpha > 0.5 ? 1.0 - alpha : alpha), 1.0 / uTroikaSDFExponent)) * maxDimension;
  float signedDist = absDist * (alpha > 0.5 ? -1.0 : 1.0);
  return signedDist;
}

float troikaGlyphUvToSdfValue(vec2 glyphUV) {
  vec2 textureUV = mix(vTroikaTextureUVBounds.xy, vTroikaTextureUVBounds.zw, glyphUV);
  vec4 rgba = texture2D(uTroikaSDFTexture, textureUV);
  float ch = floor(vTroikaTextureChannel + 0.5); //NOTE: can't use round() in WebGL1
  return ch == 0.0 ? rgba.r : ch == 1.0 ? rgba.g : ch == 2.0 ? rgba.b : rgba.a;
}

float troikaGlyphUvToDistance(vec2 uv) {
  return troikaSdfValueToSignedDistance(troikaGlyphUvToSdfValue(uv));
}

float troikaGetAADist() {
  ${""}
  #if defined(GL_OES_standard_derivatives) || __VERSION__ >= 300
  return length(fwidth(vTroikaGlyphUV * vTroikaGlyphDimensions)) * 0.5;
  #else
  return vTroikaGlyphDimensions.x / 64.0;
  #endif
}

float troikaGetFragDistValue() {
  vec2 clampedGlyphUV = clamp(vTroikaGlyphUV, 0.5 / uTroikaSDFGlyphSize, 1.0 - 0.5 / uTroikaSDFGlyphSize);
  float distance = troikaGlyphUvToDistance(clampedGlyphUV);
 
  // Extrapolate distance when outside bounds:
  distance += clampedGlyphUV == vTroikaGlyphUV ? 0.0 : 
    length((vTroikaGlyphUV - clampedGlyphUV) * vTroikaGlyphDimensions);

  ${""}

  return distance;
}

float troikaGetEdgeAlpha(float distance, float distanceOffset, float aaDist) {
  #if defined(IS_DEPTH_MATERIAL) || defined(IS_DISTANCE_MATERIAL)
  float alpha = step(-distanceOffset, -distance);
  #else

  float alpha = smoothstep(
    distanceOffset + aaDist,
    distanceOffset - aaDist,
    distance
  );
  #endif

  return alpha;
}
`;
var FRAGMENT_TRANSFORM = `
float aaDist = troikaGetAADist();
float fragDistance = troikaGetFragDistValue();
float edgeAlpha = uTroikaSDFDebug ?
  troikaGlyphUvToSdfValue(vTroikaGlyphUV) :
  troikaGetEdgeAlpha(fragDistance, uTroikaDistanceOffset, max(aaDist, uTroikaBlurRadius));

#if !defined(IS_DEPTH_MATERIAL) && !defined(IS_DISTANCE_MATERIAL)
vec4 fillRGBA = gl_FragColor;
fillRGBA.a *= uTroikaFillOpacity;
vec4 strokeRGBA = uTroikaStrokeWidth == 0.0 ? fillRGBA : vec4(uTroikaStrokeColor, uTroikaStrokeOpacity);
if (fillRGBA.a == 0.0) fillRGBA.rgb = strokeRGBA.rgb;
gl_FragColor = mix(fillRGBA, strokeRGBA, smoothstep(
  -uTroikaStrokeWidth - aaDist,
  -uTroikaStrokeWidth + aaDist,
  fragDistance
));
gl_FragColor.a *= edgeAlpha;
#endif

if (edgeAlpha == 0.0) {
  discard;
}
`;
function createTextDerivedMaterial(baseMaterial) {
  const textMaterial = createDerivedMaterial(baseMaterial, {
    chained: true,
    extensions: {
      derivatives: true
    },
    uniforms: {
      uTroikaSDFTexture: { value: null },
      uTroikaSDFTextureSize: { value: new Vector2() },
      uTroikaSDFGlyphSize: { value: 0 },
      uTroikaSDFExponent: { value: 0 },
      uTroikaTotalBounds: { value: new Vector4(0, 0, 0, 0) },
      uTroikaClipRect: { value: new Vector4(0, 0, 0, 0) },
      uTroikaDistanceOffset: { value: 0 },
      uTroikaOutlineOpacity: { value: 0 },
      uTroikaFillOpacity: { value: 1 },
      uTroikaPositionOffset: { value: new Vector2() },
      uTroikaCurveRadius: { value: 0 },
      uTroikaBlurRadius: { value: 0 },
      uTroikaStrokeWidth: { value: 0 },
      uTroikaStrokeColor: { value: new Color() },
      uTroikaStrokeOpacity: { value: 1 },
      uTroikaOrient: { value: new Matrix3() },
      uTroikaUseGlyphColors: { value: true },
      uTroikaSDFDebug: { value: false }
    },
    vertexDefs: VERTEX_DEFS,
    vertexTransform: VERTEX_TRANSFORM,
    fragmentDefs: FRAGMENT_DEFS,
    fragmentColorTransform: FRAGMENT_TRANSFORM,
    customRewriter({ vertexShader, fragmentShader }) {
      let uDiffuseRE = /\buniform\s+vec3\s+diffuse\b/;
      if (uDiffuseRE.test(fragmentShader)) {
        fragmentShader = fragmentShader.replace(uDiffuseRE, "varying vec3 vTroikaGlyphColor").replace(/\bdiffuse\b/g, "vTroikaGlyphColor");
        if (!uDiffuseRE.test(vertexShader)) {
          vertexShader = vertexShader.replace(
            voidMainRegExp,
            "uniform vec3 diffuse;\n$&\nvTroikaGlyphColor = uTroikaUseGlyphColors ? aTroikaGlyphColor / 255.0 : diffuse;\n"
          );
        }
      }
      return { vertexShader, fragmentShader };
    }
  });
  textMaterial.transparent = true;
  Object.defineProperties(textMaterial, {
    isTroikaTextMaterial: { value: true },
    // WebGLShadowMap reverses the side of the shadow material by default, which fails
    // for planes, so here we force the `shadowSide` to always match the main side.
    shadowSide: {
      get() {
        return this.side;
      },
      set() {
      }
    }
  });
  return textMaterial;
}
var defaultMaterial = new MeshBasicMaterial({
  color: 16777215,
  side: DoubleSide,
  transparent: true
});
var defaultStrokeColor = 8421504;
var tempMat4 = new Matrix4();
var tempVec3a = new Vector3();
var tempVec3b = new Vector3();
var tempArray = [];
var origin = new Vector3();
var defaultOrient = "+x+y";
function first(o) {
  return Array.isArray(o) ? o[0] : o;
}
var getFlatRaycastMesh = () => {
  const mesh = new Mesh(
    new PlaneGeometry(1, 1),
    defaultMaterial
  );
  getFlatRaycastMesh = () => mesh;
  return mesh;
};
var getCurvedRaycastMesh = () => {
  const mesh = new Mesh(
    new PlaneGeometry(1, 1, 32, 1),
    defaultMaterial
  );
  getCurvedRaycastMesh = () => mesh;
  return mesh;
};
var syncStartEvent = { type: "syncstart" };
var syncCompleteEvent = { type: "synccomplete" };
var SYNCABLE_PROPS = [
  "font",
  "fontSize",
  "letterSpacing",
  "lineHeight",
  "maxWidth",
  "overflowWrap",
  "text",
  "direction",
  "textAlign",
  "textIndent",
  "whiteSpace",
  "anchorX",
  "anchorY",
  "colorRanges",
  "sdfGlyphSize"
];
var COPYABLE_PROPS = SYNCABLE_PROPS.concat(
  "material",
  "color",
  "depthOffset",
  "clipRect",
  "curveRadius",
  "orientation",
  "glyphGeometryDetail"
);
var Text = class extends Mesh {
  constructor() {
    const geometry2 = new GlyphsGeometry();
    super(geometry2, null);
    this.text = "";
    this.anchorX = 0;
    this.anchorY = 0;
    this.curveRadius = 0;
    this.direction = "auto";
    this.font = null;
    this.fontSize = 0.1;
    this.letterSpacing = 0;
    this.lineHeight = "normal";
    this.maxWidth = Infinity;
    this.overflowWrap = "normal";
    this.textAlign = "left";
    this.textIndent = 0;
    this.whiteSpace = "normal";
    this.material = null;
    this.color = null;
    this.colorRanges = null;
    this.outlineWidth = 0;
    this.outlineColor = 0;
    this.outlineOpacity = 1;
    this.outlineBlur = 0;
    this.outlineOffsetX = 0;
    this.outlineOffsetY = 0;
    this.strokeWidth = 0;
    this.strokeColor = defaultStrokeColor;
    this.strokeOpacity = 1;
    this.fillOpacity = 1;
    this.depthOffset = 0;
    this.clipRect = null;
    this.orientation = defaultOrient;
    this.glyphGeometryDetail = 1;
    this.sdfGlyphSize = null;
    this.gpuAccelerateSDF = true;
    this.debugSDF = false;
  }
  /**
   * Updates the text rendering according to the current text-related configuration properties.
   * This is an async process, so you can pass in a callback function to be executed when it
   * finishes.
   * @param {function} [callback]
   */
  sync(callback) {
    if (this._needsSync) {
      this._needsSync = false;
      if (this._isSyncing) {
        (this._queuedSyncs || (this._queuedSyncs = [])).push(callback);
      } else {
        this._isSyncing = true;
        this.dispatchEvent(syncStartEvent);
        getTextRenderInfo({
          text: this.text,
          font: this.font,
          fontSize: this.fontSize || 0.1,
          letterSpacing: this.letterSpacing || 0,
          lineHeight: this.lineHeight || "normal",
          maxWidth: this.maxWidth,
          direction: this.direction || "auto",
          textAlign: this.textAlign,
          textIndent: this.textIndent,
          whiteSpace: this.whiteSpace,
          overflowWrap: this.overflowWrap,
          anchorX: this.anchorX,
          anchorY: this.anchorY,
          colorRanges: this.colorRanges,
          includeCaretPositions: true,
          //TODO parameterize
          sdfGlyphSize: this.sdfGlyphSize,
          gpuAccelerateSDF: this.gpuAccelerateSDF
        }, (textRenderInfo) => {
          this._isSyncing = false;
          this._textRenderInfo = textRenderInfo;
          this.geometry.updateGlyphs(
            textRenderInfo.glyphBounds,
            textRenderInfo.glyphAtlasIndices,
            textRenderInfo.blockBounds,
            textRenderInfo.chunkedBounds,
            textRenderInfo.glyphColors
          );
          const queued = this._queuedSyncs;
          if (queued) {
            this._queuedSyncs = null;
            this._needsSync = true;
            this.sync(() => {
              queued.forEach((fn) => fn && fn());
            });
          }
          this.dispatchEvent(syncCompleteEvent);
          if (callback) {
            callback();
          }
        });
      }
    }
  }
  /**
   * Initiate a sync if needed - note it won't complete until next frame at the
   * earliest so if possible it's a good idea to call sync() manually as soon as
   * all the properties have been set.
   * @override
   */
  onBeforeRender(renderer, scene, camera, geometry2, material2, group) {
    this.sync();
    if (material2.isTroikaTextMaterial) {
      this._prepareForRender(material2);
    }
    material2._hadOwnSide = material2.hasOwnProperty("side");
    this.geometry.setSide(material2._actualSide = material2.side);
    material2.side = FrontSide;
  }
  onAfterRender(renderer, scene, camera, geometry2, material2, group) {
    if (material2._hadOwnSide) {
      material2.side = material2._actualSide;
    } else {
      delete material2.side;
    }
  }
  /**
   * Shortcut to dispose the geometry specific to this instance.
   * Note: we don't also dispose the derived material here because if anything else is
   * sharing the same base material it will result in a pause next frame as the program
   * is recompiled. Instead users can dispose the base material manually, like normal,
   * and we'll also dispose the derived material at that time.
   */
  dispose() {
    this.geometry.dispose();
  }
  /**
   * @property {TroikaTextRenderInfo|null} textRenderInfo
   * @readonly
   * The current processed rendering data for this TextMesh, returned by the TextBuilder after
   * a `sync()` call. This will be `null` initially, and may be stale for a short period until
   * the asynchrous `sync()` process completes.
   */
  get textRenderInfo() {
    return this._textRenderInfo || null;
  }
  // Handler for automatically wrapping the base material with our upgrades. We do the wrapping
  // lazily on _read_ rather than write to avoid unnecessary wrapping on transient values.
  get material() {
    let derivedMaterial = this._derivedMaterial;
    const baseMaterial = this._baseMaterial || this._defaultMaterial || (this._defaultMaterial = defaultMaterial.clone());
    if (!derivedMaterial || derivedMaterial.baseMaterial !== baseMaterial) {
      derivedMaterial = this._derivedMaterial = createTextDerivedMaterial(baseMaterial);
      baseMaterial.addEventListener("dispose", function onDispose() {
        baseMaterial.removeEventListener("dispose", onDispose);
        derivedMaterial.dispose();
      });
    }
    if (this.outlineWidth || this.outlineBlur || this.outlineOffsetX || this.outlineOffsetY) {
      let outlineMaterial = derivedMaterial._outlineMtl;
      if (!outlineMaterial) {
        outlineMaterial = derivedMaterial._outlineMtl = Object.create(derivedMaterial, {
          id: { value: derivedMaterial.id + 0.1 }
        });
        outlineMaterial.isTextOutlineMaterial = true;
        outlineMaterial.depthWrite = false;
        outlineMaterial.map = null;
        derivedMaterial.addEventListener("dispose", function onDispose() {
          derivedMaterial.removeEventListener("dispose", onDispose);
          outlineMaterial.dispose();
        });
      }
      return [
        outlineMaterial,
        derivedMaterial
      ];
    } else {
      return derivedMaterial;
    }
  }
  set material(baseMaterial) {
    if (baseMaterial && baseMaterial.isTroikaTextMaterial) {
      this._derivedMaterial = baseMaterial;
      this._baseMaterial = baseMaterial.baseMaterial;
    } else {
      this._baseMaterial = baseMaterial;
    }
  }
  get glyphGeometryDetail() {
    return this.geometry.detail;
  }
  set glyphGeometryDetail(detail) {
    this.geometry.detail = detail;
  }
  get curveRadius() {
    return this.geometry.curveRadius;
  }
  set curveRadius(r) {
    this.geometry.curveRadius = r;
  }
  // Create and update material for shadows upon request:
  get customDepthMaterial() {
    return first(this.material).getDepthMaterial();
  }
  get customDistanceMaterial() {
    return first(this.material).getDistanceMaterial();
  }
  _prepareForRender(material2) {
    const isOutline = material2.isTextOutlineMaterial;
    const uniforms = material2.uniforms;
    const textInfo = this.textRenderInfo;
    if (textInfo) {
      const { sdfTexture, blockBounds } = textInfo;
      uniforms.uTroikaSDFTexture.value = sdfTexture;
      uniforms.uTroikaSDFTextureSize.value.set(sdfTexture.image.width, sdfTexture.image.height);
      uniforms.uTroikaSDFGlyphSize.value = textInfo.sdfGlyphSize;
      uniforms.uTroikaSDFExponent.value = textInfo.sdfExponent;
      uniforms.uTroikaTotalBounds.value.fromArray(blockBounds);
      uniforms.uTroikaUseGlyphColors.value = !isOutline && !!textInfo.glyphColors;
      let distanceOffset = 0;
      let blurRadius = 0;
      let strokeWidth = 0;
      let fillOpacity;
      let strokeOpacity;
      let strokeColor;
      let offsetX = 0;
      let offsetY = 0;
      if (isOutline) {
        let { outlineWidth, outlineOffsetX, outlineOffsetY, outlineBlur, outlineOpacity } = this;
        distanceOffset = this._parsePercent(outlineWidth) || 0;
        blurRadius = Math.max(0, this._parsePercent(outlineBlur) || 0);
        fillOpacity = outlineOpacity;
        offsetX = this._parsePercent(outlineOffsetX) || 0;
        offsetY = this._parsePercent(outlineOffsetY) || 0;
      } else {
        strokeWidth = Math.max(0, this._parsePercent(this.strokeWidth) || 0);
        if (strokeWidth) {
          strokeColor = this.strokeColor;
          uniforms.uTroikaStrokeColor.value.set(strokeColor == null ? defaultStrokeColor : strokeColor);
          strokeOpacity = this.strokeOpacity;
          if (strokeOpacity == null)
            strokeOpacity = 1;
        }
        fillOpacity = this.fillOpacity;
      }
      uniforms.uTroikaDistanceOffset.value = distanceOffset;
      uniforms.uTroikaPositionOffset.value.set(offsetX, offsetY);
      uniforms.uTroikaBlurRadius.value = blurRadius;
      uniforms.uTroikaStrokeWidth.value = strokeWidth;
      uniforms.uTroikaStrokeOpacity.value = strokeOpacity;
      uniforms.uTroikaFillOpacity.value = fillOpacity == null ? 1 : fillOpacity;
      uniforms.uTroikaCurveRadius.value = this.curveRadius || 0;
      let clipRect = this.clipRect;
      if (clipRect && Array.isArray(clipRect) && clipRect.length === 4) {
        uniforms.uTroikaClipRect.value.fromArray(clipRect);
      } else {
        const pad = (this.fontSize || 0.1) * 100;
        uniforms.uTroikaClipRect.value.set(
          blockBounds[0] - pad,
          blockBounds[1] - pad,
          blockBounds[2] + pad,
          blockBounds[3] + pad
        );
      }
      this.geometry.applyClipRect(uniforms.uTroikaClipRect.value);
    }
    uniforms.uTroikaSDFDebug.value = !!this.debugSDF;
    material2.polygonOffset = !!this.depthOffset;
    material2.polygonOffsetFactor = material2.polygonOffsetUnits = this.depthOffset || 0;
    const color = isOutline ? this.outlineColor || 0 : this.color;
    if (color == null) {
      delete material2.color;
    } else {
      const colorObj = material2.hasOwnProperty("color") ? material2.color : material2.color = new Color();
      if (color !== colorObj._input || typeof color === "object") {
        colorObj.set(colorObj._input = color);
      }
    }
    let orient = this.orientation || defaultOrient;
    if (orient !== material2._orientation) {
      let rotMat = uniforms.uTroikaOrient.value;
      orient = orient.replace(/[^-+xyz]/g, "");
      let match = orient !== defaultOrient && orient.match(/^([-+])([xyz])([-+])([xyz])$/);
      if (match) {
        let [, hSign, hAxis, vSign, vAxis] = match;
        tempVec3a.set(0, 0, 0)[hAxis] = hSign === "-" ? 1 : -1;
        tempVec3b.set(0, 0, 0)[vAxis] = vSign === "-" ? -1 : 1;
        tempMat4.lookAt(origin, tempVec3a.cross(tempVec3b), tempVec3b);
        rotMat.setFromMatrix4(tempMat4);
      } else {
        rotMat.identity();
      }
      material2._orientation = orient;
    }
  }
  _parsePercent(value) {
    if (typeof value === "string") {
      let match = value.match(/^(-?[\d.]+)%$/);
      let pct = match ? parseFloat(match[1]) : NaN;
      value = (isNaN(pct) ? 0 : pct / 100) * this.fontSize;
    }
    return value;
  }
  /**
   * Translate a point in local space to an x/y in the text plane.
   */
  localPositionToTextCoords(position, target = new Vector2()) {
    target.copy(position);
    const r = this.curveRadius;
    if (r) {
      target.x = Math.atan2(position.x, Math.abs(r) - Math.abs(position.z)) * Math.abs(r);
    }
    return target;
  }
  /**
   * Translate a point in world space to an x/y in the text plane.
   */
  worldPositionToTextCoords(position, target = new Vector2()) {
    tempVec3a.copy(position);
    return this.localPositionToTextCoords(this.worldToLocal(tempVec3a), target);
  }
  /**
   * @override Custom raycasting to test against the whole text block's max rectangular bounds
   * TODO is there any reason to make this more granular, like within individual line or glyph rects?
   */
  raycast(raycaster, intersects) {
    const { textRenderInfo, curveRadius } = this;
    if (textRenderInfo) {
      const bounds = textRenderInfo.blockBounds;
      const raycastMesh = curveRadius ? getCurvedRaycastMesh() : getFlatRaycastMesh();
      const geom = raycastMesh.geometry;
      const { position, uv } = geom.attributes;
      for (let i3 = 0; i3 < uv.count; i3++) {
        let x = bounds[0] + uv.getX(i3) * (bounds[2] - bounds[0]);
        const y = bounds[1] + uv.getY(i3) * (bounds[3] - bounds[1]);
        let z = 0;
        if (curveRadius) {
          z = curveRadius - Math.cos(x / curveRadius) * curveRadius;
          x = Math.sin(x / curveRadius) * curveRadius;
        }
        position.setXYZ(i3, x, y, z);
      }
      geom.boundingSphere = this.geometry.boundingSphere;
      geom.boundingBox = this.geometry.boundingBox;
      raycastMesh.matrixWorld = this.matrixWorld;
      raycastMesh.material.side = this.material.side;
      tempArray.length = 0;
      raycastMesh.raycast(raycaster, tempArray);
      for (let i3 = 0; i3 < tempArray.length; i3++) {
        tempArray[i3].object = this;
        intersects.push(tempArray[i3]);
      }
    }
  }
  copy(source) {
    const geom = this.geometry;
    super.copy(source);
    this.geometry = geom;
    COPYABLE_PROPS.forEach((prop) => {
      this[prop] = source[prop];
    });
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
SYNCABLE_PROPS.forEach((prop) => {
  const privateKey = "_private_" + prop;
  Object.defineProperty(Text.prototype, prop, {
    get() {
      return this[privateKey];
    },
    set(value) {
      if (value !== this[privateKey]) {
        this[privateKey] = value;
        this._needsSync = true;
      }
    }
  });
});

// node_modules/kokomi.js/dist/shapes/textMesh.js
var defaultSDFFontUrl = "https://fonts.gstatic.com/s/roboto/v18/KFOmCnqEu92Fr1Mu4mxM.woff";
var preloadSDFFont = (url = defaultSDFFontUrl) => {
  return new Promise((resolve) => {
    preloadFont({
      font: url
    }, () => {
      resolve(true);
    });
  });
};
var TextMesh = class extends Component {
  constructor(base, text = "") {
    super(base);
    __publicField(this, "mesh");
    this.mesh = new Text();
    this.mesh.text = text;
    this.mesh.anchorX = "center";
    this.mesh.anchorY = "middle";
  }
  addExisting() {
    this.container.add(this.mesh);
  }
};

// node_modules/kokomi.js/dist/web/gallery.js
var defaultVertexShader5 = (
  /* glsl */
  `
uniform float iTime;
uniform vec2 iResolution;
uniform vec2 iMouse;

varying vec2 vUv;

void main(){
    vec3 p=position;
    gl_Position=projectionMatrix*modelViewMatrix*vec4(p,1.);
    
    vUv=uv;
}
`
);
var defaultFragmentShader5 = (
  /* glsl */
  `
uniform float iTime;
uniform vec2 iResolution;
uniform vec2 iMouse;

uniform sampler2D uTexture;

varying vec2 vUv;

void main(){
    vec4 tex=texture(uTexture,vUv);
    vec3 color=tex.rgb;
    gl_FragColor=vec4(color,1.);
}
`
);
var Gallery = class extends Component {
  constructor(base, config3 = {}) {
    super(base);
    __publicField(this, "elList");
    __publicField(this, "vertexShader");
    __publicField(this, "fragmentShader");
    __publicField(this, "uniforms");
    __publicField(this, "makuConfig");
    __publicField(this, "isScrollPositionSync");
    __publicField(this, "makuMaterial");
    __publicField(this, "makuGroup");
    __publicField(this, "scroller");
    __publicField(this, "uniformInjector");
    __publicField(this, "materialParams");
    __publicField(this, "useSelfScroller");
    const { elList = [...document.querySelectorAll("img")], vertexShader = defaultVertexShader5, fragmentShader = defaultFragmentShader5, uniforms = {}, makuConfig = {}, isScrollPositionSync = true, scroller = null, materialParams = {} } = config3;
    this.elList = elList;
    this.vertexShader = vertexShader;
    this.fragmentShader = fragmentShader;
    this.uniforms = uniforms;
    this.makuConfig = makuConfig;
    this.isScrollPositionSync = isScrollPositionSync;
    this.makuMaterial = null;
    this.makuGroup = null;
    this.scroller = scroller;
    this.materialParams = materialParams;
    const uniformInjector = new UniformInjector(base);
    this.uniformInjector = uniformInjector;
    this.useSelfScroller = false;
    if (!scroller) {
      this.useSelfScroller = true;
    }
  }
  async addExisting() {
    await preloadImages();
    const { uniformInjector } = this;
    const makuMaterial = new ShaderMaterial({
      vertexShader: this.vertexShader,
      fragmentShader: this.fragmentShader,
      side: DoubleSide,
      uniforms: {
        ...{
          uTexture: {
            value: null
          }
        },
        ...uniformInjector.shadertoyUniforms,
        ...this.uniforms
      },
      ...this.materialParams
    });
    this.makuMaterial = makuMaterial;
    const makuGroup = new MakuGroup();
    this.makuGroup = makuGroup;
    const makus = this.elList.map((el) => new Maku(el, makuMaterial, this.container, this.makuConfig));
    makuGroup.addMultiple(makus);
    makuGroup.setPositions();
    if (this.useSelfScroller) {
      const scroller = new Scroller();
      this.scroller = scroller;
      this.scroller.listenForScroll();
    }
    this.base.resizer.on("resize", () => {
      makuGroup.makus.forEach((maku) => {
        maku.rect = maku.el.getBoundingClientRect();
      });
    });
  }
  update(time) {
    const { scroller, makuGroup } = this;
    scroller == null ? void 0 : scroller.syncScroll();
    makuGroup == null ? void 0 : makuGroup.makus.forEach((maku) => {
      const material2 = maku.mesh.material;
      const uniforms = material2.uniforms;
      this.uniformInjector.injectShadertoyUniforms(uniforms);
      if (this.isScrollPositionSync) {
        if (maku.el.classList.contains("webgl-fixed")) {
          maku.setPosition(0);
        } else {
          maku.setPosition(scroller == null ? void 0 : scroller.scroll.current);
        }
      }
    });
  }
  checkImagesLoaded() {
    return new Promise((resolve) => {
      this.base.update(() => {
        if (this.makuGroup) {
          if (this.makuGroup.makus.map((maku) => {
            var _a4;
            return (_a4 = maku.mesh.material.uniforms.uTexture.value.image) == null ? void 0 : _a4.complete;
          }).every((item) => item)) {
            resolve(true);
          }
        }
      });
    });
  }
};

// node_modules/kokomi.js/dist/web/moji.js
var defaultVertexShader6 = (
  /* glsl */
  `
uniform float iTime;
uniform vec2 iResolution;
uniform vec2 iMouse;

varying vec2 vUv;

void main(){
    vec3 p=position;
    gl_Position=projectionMatrix*modelViewMatrix*vec4(p,1.);
    
    vUv=uv;
}
`
);
var defaultFragmentShader6 = (
  /* glsl */
  `
uniform float iTime;
uniform vec2 iResolution;
uniform vec2 iMouse;

varying vec2 vUv;

void main(){
    vec2 p=vUv;
    vec3 color=vec3(p,0.);
    gl_FragColor=vec4(color,1.);
}
`
);
var Moji = class {
  constructor(el, textMesh) {
    __publicField(this, "el");
    __publicField(this, "textMesh");
    __publicField(this, "rect");
    this.el = el;
    this.textMesh = textMesh;
    const rect = el.getBoundingClientRect();
    this.rect = rect;
  }
  // 同步位置
  setPosition(deltaY = window.scrollY) {
    const { textMesh, rect } = this;
    const { mesh } = textMesh;
    const { x, y, height } = rect;
    const px = x - window.innerWidth / 2;
    const py = -(y + height / 2 - window.innerHeight / 2) + deltaY;
    mesh.position.set(px, py, 0);
  }
};
var MojiGroup = class extends Component {
  constructor(base, config3 = {}) {
    super(base);
    __publicField(this, "elList");
    __publicField(this, "vertexShader");
    __publicField(this, "fragmentShader");
    __publicField(this, "uniforms");
    __publicField(this, "textMeshConfig");
    __publicField(this, "isScrollPositionSync");
    __publicField(this, "textMeshMaterial");
    __publicField(this, "mojis");
    __publicField(this, "scroller");
    __publicField(this, "uniformInjector");
    __publicField(this, "materialParams");
    __publicField(this, "useSelfScroller");
    const { elList = [...document.querySelectorAll(".webgl-text")], vertexShader = defaultVertexShader6, fragmentShader = defaultFragmentShader6, uniforms = {}, textMeshConfig = {}, isScrollPositionSync = true, scroller = null, materialParams = {} } = config3;
    this.elList = elList;
    this.vertexShader = vertexShader;
    this.fragmentShader = fragmentShader;
    this.uniforms = uniforms;
    this.textMeshConfig = textMeshConfig;
    this.isScrollPositionSync = isScrollPositionSync;
    this.textMeshMaterial = null;
    this.mojis = [];
    this.scroller = scroller;
    this.materialParams = materialParams;
    const uniformInjector = new UniformInjector(base);
    this.uniformInjector = uniformInjector;
    this.useSelfScroller = false;
    if (!scroller) {
      this.useSelfScroller = true;
    }
  }
  addExisting() {
    const { uniformInjector } = this;
    const textMeshMaterial = new ShaderMaterial({
      vertexShader: this.vertexShader,
      fragmentShader: this.fragmentShader,
      side: DoubleSide,
      uniforms: {
        ...uniformInjector.shadertoyUniforms,
        ...this.uniforms,
        ...{
          uTextColor: {
            value: new Color("black")
          }
        }
      },
      ...this.materialParams
    });
    this.textMeshMaterial = textMeshMaterial;
    const mojis = this.elList.map((el, i3) => {
      const tm = new TextMesh(this.base, el.innerText.trim());
      tm.mesh.material = textMeshMaterial.clone();
      tm.container = this.container;
      tm.addExisting();
      const styleFontSize = window.getComputedStyle(el, null).getPropertyValue("font-size");
      const fontSize = parseFloat(styleFontSize);
      tm.mesh.fontSize = fontSize;
      const styleTextAlign = window.getComputedStyle(el, null).getPropertyValue("text-align");
      const alignMap = {
        start: "left",
        end: "right",
        center: "center"
      };
      tm.mesh.anchorX = alignMap[styleTextAlign];
      const color = el.dataset["webglTextColor"] || "black";
      tm.mesh.material.uniforms.uTextColor.value = new Color(color);
      const moji = new Moji(el, tm);
      return moji;
    });
    this.mojis = mojis;
    this.mojis.forEach((moji) => {
      moji.setPosition();
    });
    if (this.useSelfScroller) {
      const scroller = new Scroller();
      this.scroller = scroller;
      this.scroller.listenForScroll();
    }
    this.base.resizer.on("resize", () => {
      mojis.forEach((moji) => {
        moji.rect = moji.el.getBoundingClientRect();
      });
    });
  }
  update() {
    const { scroller, mojis } = this;
    scroller == null ? void 0 : scroller.syncScroll();
    mojis.forEach((moji) => {
      const material2 = moji.textMesh.mesh.material;
      const uniforms = material2.uniforms;
      this.uniformInjector.injectShadertoyUniforms(uniforms);
      if (this.isScrollPositionSync) {
        if (moji.el.classList.contains("webgl-fixed")) {
          moji.setPosition(0);
        } else {
          moji.setPosition(scroller == null ? void 0 : scroller.scroll.current);
        }
      }
    });
  }
};

// node_modules/kokomi.js/dist/web/scroller.js
var NormalScroller = Scroller;
var WheelScroller = class {
  constructor() {
    __publicField(this, "scroll");
    this.scroll = {
      current: 0,
      target: 0,
      ease: 0.05,
      last: 0,
      delta: 0,
      direction: ""
    };
  }
  // 监听滚动
  listenForScroll() {
    window.addEventListener("wheel", (e) => {
      const newScrollY = e.deltaY;
      const scrollYDelta = newScrollY;
      this.scroll.target += scrollYDelta;
    });
  }
  // 同步滚动的数据
  syncScroll() {
    this.scroll.current = MathUtils.lerp(this.scroll.current, this.scroll.target, this.scroll.ease);
    this.scroll.delta = this.scroll.current - this.scroll.last;
    this.scroll.direction = this.scroll.delta > 0 ? "down" : "up";
    this.scroll.last = this.scroll.current;
  }
};

// node_modules/kokomi.js/dist/web/utils.js
var handleTextureProp = (el, texture) => {
  const minFilterDefaultValue = el instanceof HTMLVideoElement ? "linear" : "mipmap";
  const magFilterDefaultValue = el instanceof HTMLVideoElement ? "linear" : "mipmap";
  const wrapS = (el == null ? void 0 : el.getAttribute("wrap-s")) || "repeat";
  const wrapT = (el == null ? void 0 : el.getAttribute("wrap-t")) || "repeat";
  const minFilter = (el == null ? void 0 : el.getAttribute("min-filter")) || minFilterDefaultValue;
  const magFilter = (el == null ? void 0 : el.getAttribute("mag-filter")) || magFilterDefaultValue;
  const wrapMap = {
    clamp: ClampToEdgeWrapping,
    repeat: RepeatWrapping
  };
  const filterMap = {
    nearest: NearestFilter,
    linear: LinearFilter,
    mipmap: LinearMipMapLinearFilter
  };
  texture.wrapS = wrapMap[wrapS];
  texture.wrapT = wrapMap[wrapT];
  texture.minFilter = filterMap[minFilter];
  texture.magFilter = filterMap[magFilter];
  if (el instanceof HTMLVideoElement) {
    const start = (el == null ? void 0 : el.getAttribute("autoplay")) || "";
    el == null ? void 0 : el.addEventListener("loadedmetadata", () => {
      if (start) {
        texture.image.play();
      }
    });
  }
};
var loadTextureFromImg = (el) => {
  if (!el) {
    return null;
  }
  const texture = new TextureLoader().load(el.src);
  handleTextureProp(el, texture);
  return texture;
};
var loadCubemapFromImgs = (el, els) => {
  if (!el) {
    return null;
  }
  const texture = new CubeTextureLoader().load(els.map((item) => item.src));
  handleTextureProp(el, texture);
  return texture;
};
var loadTextureFromVideo = (el) => {
  if (!el) {
    return null;
  }
  const texture = new VideoTexture(el);
  handleTextureProp(el, texture);
  return texture;
};
var getUniformFromAsset = (el, name, parent = null) => {
  if (!el) {
    return {};
  }
  let texture = null;
  const type = el.getAttribute("type") || "2d";
  if (el instanceof HTMLImageElement) {
    if (type === "2d") {
      texture = loadTextureFromImg(el);
    } else if (type === "cube") {
      const px = parent == null ? void 0 : parent.querySelector("[cube=px]");
      const nx = parent == null ? void 0 : parent.querySelector("[cube=nx]");
      const py = parent == null ? void 0 : parent.querySelector("[cube=py]");
      const ny = parent == null ? void 0 : parent.querySelector("[cube=ny]");
      const pz = parent == null ? void 0 : parent.querySelector("[cube=pz]");
      const nz = parent == null ? void 0 : parent.querySelector("[cube=nz]");
      texture = loadCubemapFromImgs(el, [px, nx, py, ny, pz, nz]);
    }
  } else if (el instanceof HTMLVideoElement) {
    texture = loadTextureFromVideo(el);
  }
  const uniformName = {
    "2d": name,
    cube: `${name}Cube`
  }[type] || name;
  const uniform = texture ? {
    [uniformName]: {
      value: texture
    }
  } : {};
  return uniform;
};

// node_modules/kokomi.js/dist/web/shadertoy.js
var defaultFragmentShader7 = (
  /* glsl */
  `
void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
    // Normalized pixel coordinates (from 0 to 1)
    vec2 uv = fragCoord/iResolution.xy;

    // Time varying pixel color
    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));

    // Output to screen
    fragColor = vec4(col,1.0);
}
`
);
var Sketch = class extends Base {
  constructor(sel = "#sketch") {
    super(sel);
    this.resizer.disable();
  }
  create(fragmentShader, uniforms = {}) {
    const screenQuad = new ScreenQuad(this, {
      shadertoyMode: true,
      fragmentShader,
      uniforms
    });
    screenQuad.addExisting();
  }
};
var createSketch = (id = "sketch", fragmentShader, uniforms = {}) => {
  const sketch = new Sketch(`#${id}`);
  sketch.create(fragmentShader, uniforms);
  return sketch;
};
var ShaderToyElement = class extends HTMLElement {
  constructor() {
    super();
    __publicField(this, "container");
    __publicField(this, "sketch");
    this.container = null;
    this.sketch = null;
  }
  static register() {
    if (!customElements.get("shader-toy")) {
      customElements.define("shader-toy", ShaderToyElement);
    }
  }
  connectedCallback() {
    this.create();
  }
  get elId() {
    return this.id || "sketch";
  }
  get containerId() {
    return `${this.elId}-container`;
  }
  get fragShader() {
    const fragScript = this.querySelector("[type=frag]");
    return (fragScript == null ? void 0 : fragScript.textContent) || defaultFragmentShader7;
  }
  getTextureUniform(name) {
    const img = this.querySelector(`[name=${name}]`);
    return getUniformFromAsset(img, name, this);
  }
  get uniforms() {
    return {
      ...this.getTextureUniform("iChannel0"),
      ...this.getTextureUniform("iChannel1"),
      ...this.getTextureUniform("iChannel2"),
      ...this.getTextureUniform("iChannel3")
    };
  }
  createContainer() {
    const container = document.createElement("div");
    container.id = this.containerId;
    container.style.width = "100%";
    container.style.height = "100%";
    this.appendChild(container);
    this.container = container;
  }
  create() {
    this.createContainer();
    const fragmentShader = this.fragShader;
    const uniforms = this.uniforms;
    const sketch = createSketch(this.containerId, fragmentShader, uniforms);
    const canvas = sketch.renderer.domElement;
    canvas.style.width = "100%";
    canvas.style.height = "100%";
    this.sketch = sketch;
  }
};
export {
  AnimationManager,
  Animator,
  AssetManager,
  Base,
  BasicPanorama,
  Bender,
  Box4 as Box,
  CameraControls3 as CameraControls,
  Center,
  Clock2 as Clock,
  Component,
  ContactShadows,
  CubemapQuad,
  CustomEffect,
  CustomMesh,
  CustomPoints,
  CustomShaderMaterial,
  DecalGeometry,
  FBO,
  FBXLoader2 as FBXLoader,
  FirstPersonCamera,
  Float,
  GPUComputer,
  Gallery,
  GlassMaterial,
  Html,
  HyperbolicHelicoidGeometry,
  IMouse,
  ImagePanorama,
  Joystick,
  Keyboard,
  MeshPhysicsObject,
  MeshReflectorMaterial,
  MeshReflectorMaterialImpl,
  MeshTransmissionMaterial,
  Moji,
  MojiGroup,
  NormalScroller,
  OrbitControls2 as OrbitControls,
  OrthographicCamera2 as OrthographicCamera,
  PackedMipMapGenerator,
  PanoramaGenerator,
  PersistenceEffect,
  Physics,
  RayMarchingQuad,
  RaycastSelector,
  RectAreaLightHelper,
  Reflector2 as Reflector,
  RenderQuad,
  RenderTexture,
  Resizer,
  ScreenCamera,
  ScreenQuad,
  ShaderToyElement,
  Sparkles,
  SphubeGeometry,
  Stage,
  Stats,
  Text3D,
  TextMesh,
  ThinFilmFresnelMap,
  ThirdPersonCamera,
  UniformInjector,
  Viewer,
  WheelScroller,
  applyViewScissor,
  beautifyRender,
  calcObjectPosition,
  calcPerspectiveScreenSize,
  calcTransformFov,
  computeCurl,
  computeViewWindowScale,
  convertBufferAttributeToVector,
  convertGeometryToShape,
  createPolygonShape,
  detectDeviceType,
  downloadBlob,
  enableRealisticRender,
  enableShadow,
  epsilon,
  expandColor,
  flatModel,
  getBaryCoord,
  getBound,
  getCSSMatrix,
  getCameraCSSMatrix,
  getEnvmapFromHDRTexture,
  getEnvmapFromScene,
  getObjectCSSMatrix,
  getPointsInPath,
  getPositionCentroids,
  getUniformFromAsset,
  getViewport,
  hyperbolicHelicoidFunction,
  isFloat32Array,
  isObjectBehindCamera,
  isObjectVisible,
  isVector,
  iterateBuffer,
  loadCubemapFromImgs,
  loadFBX,
  loadFont,
  loadGLTF,
  loadHDR,
  loadTextureFromImg,
  loadVideoTexture,
  makeBuffer,
  normalizeVector,
  objectScale,
  objectZIndex,
  optimizeModelRender,
  polySort,
  preloadImages,
  preloadSDFFont,
  preventDefaultAndStopBubble,
  printModel,
  range,
  sample,
  sampleParticlesPositionFromMesh,
  saturate,
  sleep,
  smoothNormal,
  sphubeFunction,
  usePropAsIsOrAsAttribute
};
/*! Bundled license information:

imagesloaded/imagesloaded.js:
  (*!
   * imagesLoaded v5.0.0
   * JavaScript is all like "You images are done yet or what?"
   * MIT License
   *)

opentype.js/dist/opentype.module.js:
  (*! https://mths.be/codepointat v0.2.0 by @mathias *)

kokomi.js/dist/lib/three-stdlib/libs/fflate.js:
  (*!
  fflate - fast JavaScript compression/decompression
  <https://101arrowz.github.io/fflate>
  Licensed under MIT. https://github.com/101arrowz/fflate/blob/master/LICENSE
  version 0.6.9
  *)

camera-controls/dist/camera-controls.module.js:
  (*!
   * camera-controls
   * https://github.com/yomotsu/camera-controls
   * (c) 2017 @yomotsu
   * Released under the MIT License.
   *)

gsap/gsap-core.js:
  (*!
   * GSAP 3.12.2
   * https://greensock.com
   *
   * @license Copyright 2008-2023, GreenSock. All rights reserved.
   * Subject to the terms at https://greensock.com/standard-license or for
   * Club GreenSock members, the agreement issued with that membership.
   * @author: Jack Doyle, jack@greensock.com
  *)

gsap/CSSPlugin.js:
  (*!
   * CSSPlugin 3.12.2
   * https://greensock.com
   *
   * Copyright 2008-2023, GreenSock. All rights reserved.
   * Subject to the terms at https://greensock.com/standard-license or for
   * Club GreenSock members, the agreement issued with that membership.
   * @author: Jack Doyle, jack@greensock.com
  *)

troika-three-text/dist/troika-three-text.esm.js:
  (*!
  Custom build of Typr.ts (https://github.com/fredli74/Typr.ts) for use in Troika text rendering.
  Original MIT license applies: https://github.com/fredli74/Typr.ts/blob/master/LICENSE
  *)
  (*!
  Custom bundle of woff2otf (https://github.com/arty-name/woff2otf) with fflate
  (https://github.com/101arrowz/fflate) for use in Troika text rendering. 
  Original licenses apply: 
  - fflate: https://github.com/101arrowz/fflate/blob/master/LICENSE (MIT)
  - woff2otf.js: https://github.com/arty-name/woff2otf/blob/master/woff2otf.js (Apache2)
  *)
*/
//# sourceMappingURL=kokomi__js.js.map
